73IDIIHURWW*6FKPLW]
1XPHULFVLPXODWLRQRIDQLQWHJUDWHG&2 
FRROLQJV\VWHP
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Numeric simulation of an integrated CO2 cooling system
Dipl.-Ing. Torge Pfafferott

Prof. Dr.-Ing. Gerhard Schmitz

Technical University of Hamburg-Harburg
Department of Technical Thermodynamics (6-08)
Denickestr. 17 D-21073 Hamburg
October 13, 2000

Abstract
In a research project of EADS Airbus and the
TUHH a system simulation of a cooling system is to be realized, using the refrigerant carbondioxid (CO2 ). The simulation models of
the cooling cycle are created using Modelica
and the thermohydraulic model library ThermoFlow. Modelica and the model library operate since spring 2000. The project will be finished untill the end of 2002.
For the structure of the CO2 models so far a
FORTRAN program was introduced in Modelica that calculates the state variables of CO 2 using an equation of state. Furthermore the heat
transfer and pressure loss relations were implemented of CO2 for one- and two-phase and the
supercritical status area. Literature reviews of
currently measured results were used to check
the models. Therefore, the modelling of pipes,
evaporators and gascooler/condenser is possible.
First results of an uncomplex CO2 -refrigertion
cycle are presented and a preview of future work
is given.

1 Introduction
In a research project of European Aeronautic
Defence and Space Company (EADS) Airbus
and the Department of Technical Thermodynamics of the Technical University Hamburg–
Harburg (TUHH) a system simulation of a cooling system is to be realized, using the refrigerant carbondioxid (CO2 ). The aim of the project
is to prove the feasibility of an integrated cooling system on board of future airliners. The
idea of an integrated cooling system is to get

more flexibility by the design of the cabin layout. Until now, every galley is cooled by a single airchiller system. In future airliners the galleys and other cooling points will be cooled by
evaporators, which are supplied by the piping
of the integrated cooling system. Such a system
consists of central components like compressor,
gas coller (condenser), receiver and control unit
and the distributed components like evaporators
and expansion valves at the cooling points. The
piping connects the components.
The thermal and hydraulic system properties
has to be modelled in combination with the control of the system. With the verificated models
the operating efficiency of the cooling systems
should be verified for extreme climates at the
ground and at the flight. Also different concepts
of system design und control strategies could be
simulated and compared.
Since the object oriented programming tool
SMILE is used for several years for the simulation of energy systems at the Department of
Technical Thermodynamics, now Modelica is
used for the simulation of CO2 -systems. In
several research projects like, Energy requirements and comfort of gas- and electric-powered
hot-water systems and Modelling and simulation of power plant components the object oriented modelling was used and reasonanble results have been achieved. The models of the
CO2 -system are built-up mainly on base of own
models and the thermohydraulic model library
ThermoFlow [4].

2 Carbondioxid as refrigerant
Expansion
Valve
Cooling
Medium

Internal
Heat Exchanger

Gas Cooler

In the 19th century CO2 (R744) was a widespread refrigerant. The synthetical refrigerants
Evaporator
(HCFCs) displaced CO2 in the 1930s because
Ambient Air
lower system pressures and a simpler technique
Receiver
could be realized. Due to the ozone depleting
Compressor
potential (ODP) of the HCFCs new refrigerants
(HFCs) were introduced. Although the HFCs
M
like R134a have no ODP, the global warming
potential (GWP) is much higher than that of nat- Figure 1: Schematic diagram of a CO 2
ural refrigerants like CO2 or ammonia (NH3).
refrigeration cycle

2.1 The CO2 -refrigeration cycle
Due to the critical point of CO2 (73,77 bar and
30,98 C) the refrigeration cycle has to be operated transcritically when the ambient temperature is near or higher than the critical temperature. In this case the evaporation takes place at
subcritical pressure and temperatur and the heat
rejection at supercritical state.

3 Builtup of numerical models
with Modelica

The basic structure of the modelling of CO 2 cycle-components is given by the decision to
use the thermohydraulic library ThermoFlow.
ThermoFlow is based on a thermodynamic
model which is suited to model systems like
a CO2 -refrigerant cycle. Especially the base
models
of the library and parts of the parAs seen in figure 1, the main components
tial
components
can be used to programm own
of a CO2 -refrigeration cycle are compressor,
gas cooler (instead of a condenser because models.
of the supercritical heat rejection, that occurs
sometimes), internal heat exchanger, expansion 3.1 Base classes for the CO2 -models
valve, evaporator and low-pressure receiver. At
the transcritical cycle the compressor sucks re- For the beginning of modelling components a
frigerant as superheated vapour and compresses FORTRAN programm [1] was introduced in
to high pressure. At the supercritical pressure, Modelica that calculates the state variables of
the CO2 is cooled in the gas cooler by trans- CO2 using an equation of state. Additionferring a heat flux to the ambient climate. The ally other CO2 medium properties were impleCO2 is cooled down near to the ambient temper- mented. After checking the medium models,
ature. In the internal heat exchanger the high- the heat transfer and pressure loss relations were
pressure CO2 is cooled and the low-pressure implemented of CO2 for one- and two-phase reCO2 , as saturated vapour from the receiver, is gion and the supercritical status area.
superheated. Then the refrigerant is throttled to The one-phase region and the supercritical stalow pressure. In the evaporator the CO 2 evapo- tus area are modelled with the same comrates incomplete by constant pressure and tem- mon correlations for heat transfer and pressure
perature and removes a heat flux from the air drop according to [2]. The verification of the
at the cooling point. The low-pressure receiver heat transfer correlation, with experimental data
seperates the two phase; only saturated CO 2 is from the SINTEF [3], shows a good corresponsucked through the internal heat exchanger to dence (see figure 2). The comparsion of the
the compressor. If the ambient temperature is measured pressure drop data with calculation
well below the critical temperature of CO 2 , the models shows good accordance. At the two
refrigeration cycle operates like a typical refrig- phase region the heat transfer relations are diferant compression cycle with heat rejection by ferentiated between evaporation and condensacondensation.
tion. The heat transfer coefficent by evaporation

4

2.25

x 10

2

p101m900q20
p91m900q20
p81m900q20

1.75

2

[W/(m .K)]

1.5

alpha

CO2

1.25

1

0.75

0.5

0.25

0
10

20

30

40
Temperatur [°C]

50

60

70

built up from base models of ThermoFlow and
own models for medium properties, heat transfer and pressure drop. First, the static momentum balance equation is used for the pipe model
instead of the dynamic one, because the simulation of thermal system charateristics is the priority objective. The use of class parameters in
base models of ThermoFlow enable the use of
own models for medium properties and pressure drop. The heat exchangers can be simulated with different models for the wall and the
boundary conditions, depending on the certain
context of investigation.

3.3 Modelling of compressor and expansion valve
The compressor is modelled in a simple way,
basing on the possible separation of control volume and flow model in ThermoFlow. Therefore, the general equation for mass flow of a
reciprocating compressor is implemented and
the enthalpy change is calculated according to
the isentropic efficiency. Future work contains
improved equations of the isentropic and voluFigure 2: Simulation results of supercritical
metric efficiency, which are based on measured
heat transfer (top) and measured data from SINcharateristic diagramms of a CO2 compressor.
TEF (bottom)
The throttling process is treated as isenthalpic
and the pressure drop is calculated with a general mass flow charateristic of expansion valves
is calculated by an equation considering convec- including geometric and hydraulic coefficents,
tive boiling and nucleate boiling. From a critical which are specified by construction of valves.
vapour fraction, the dry-out effect is also considered in the model. For the calculation of heat
transfer coefficent of condensation the relation 4 Simulation of a CO2 -refrigeof turbulent film condensation is implemented
ration cycle
[2]. Checks of the calculation with results the
measured results yields good correspondence.
As seen in figure 3, a simple CO2 -refrigeration
The frictional pressure gradient in two-phase re- cycle consisting of compressor, expansion
gion is calculated with a two-phase multiplier valve, evaporator and gas cooler is simulated
according to the Friedel correlation. In general in Dymola. The heat exchangers are composed
the calculated pressure drop results in values of a discretized pipe, a linear wall model and
that are too low compared with the measured an air flow as boundary condition. The bounddata. However for a first estimation the imple- ary condition of the evaporator is modelled as a
mented correlations can be taken.
volume filled with air (ideal gas) and a constant
heat transfer coefficent. This model represents
conditions like in a refrigerator.
3.2 Pipe and heat exchanger models
The geometric parameters of heat exchangers,
On base of the implemented base classes the compressor and valve are similary set as real
modelling of pipes, evaporators and gas cooler components of a CO2 -cycle. The isentropic and
is realized. The pipe model as base for the pip- volumetric efficiency are set as parameter of the
ing and for of all types of heat exchangers is compressor. The revolution of the compressor

and the mass flow coefficent of the expansion imental CO2 -refrigeration cycle, where meavalve are constant input signals. First simula- surements will be undertaken next year. Right
tion results will be presented at the workshop. now, this experimental system is built up at the
Department of Aircraft Systems Engineering of
the TUHH in context of the research project Integrated CO2 cooling system.

5.1 Acknowledgement
The presented results and efforts would not have
been possible without the help and the work of
some people apart from the authors. Thanks
to Hubertus Tummescheit for providing ThermoFlow before publishing the library. Thanks
to Stefan Wischhusen for the implementation
of various models in his master thesis. Thanks
to Guido Ströhlein for the implementation and
testing of the CO2 -FORTRAN code.

References

Figure 3: Diagram of simulated CO2 -cycle

5 Conclusion

[1] Span, R., Wagner, W.:
Das Software-Grundpaket zur Berechnung
thermodynamischer Daten in Referenzqualität
Institute of Thermodynamic,
RuhrUniversität Bochum, Bochum 1999
[2] N.N.:
VDI-Wärmeatlas - Berechnungsblätter für den Wärmeübergang
VDI-Verlag, 7. Edition, Düsseldorf 1994

So far, basic work for the simulation of CO 2 refrigeration cycles has been done implement- [3] Pettersen, J., Rieberer, R., Munkejord, S.T.:
Heat transfer and pressure drop for flow
ing a CO2 medium model, heat transfer, presof supercritical and subcritical CO 2 in misure drop correlations, modelling of simple
crochannel tubes
components and simulating a simple refrigeraSINTEF Energy Research, Trondheim 2000
tion cycle. Future work in the research project
Numeric simulation of an integrated CO 2 cool- [4] Tummescheit, H., Eborn, J., Wagner,F.:
ing system consists in the implementation of a
ThermoFlow: a Thermo-Hydraulic Library
controller for the compressor and the expansion
in Modelica
valve and of the results of characteristic comManual, Lund 2000
pressor data. Furthermore, the simulation of a
ramified piping with two or more evaporators
and controlled expansion valves has to be done.
The use of the CO2 medium model in the ThermoFlow library and the provided formulation of
balance equations in density (d) and temperature (T), instead of the actual used formulation
in pressure (p) and enthalpy (h), should be realized to speed up the simulations.
The simulation results of the CO2 -cycle will
be verified, using measured data from an exper-

/6DOGDPOL3)ULW]VRQ
2EMHFWRULHQWHG0RGHOLQJZLWK3DUWLDO'LIIHUHQWLDO
(TXDWLRQV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Object-oriented Modeling with Partial Differential Equations
Levon Saldamli and Peter Fritzson
PELAB, Programming Environments Laboratory
Department of Computer and Information Science
Linköping University
SE-581 83, Linköping, Sweden.
levsa@ida.liu.se, petfr@ida.liu.se

Abstract

1.1 Partial Differential Equations (PDEs)

Mathematical models containing partial differential
equations (PDEs) occur in many engineering applications. Modelica is a general, high-level language for
object-oriented modeling with differential-algebraic
equations (DAEs). There is a need for extending Modelica to also support modeling with PDEs. This paper
presents some ideas on such extensions to the Modelica language, that would allow formulation of PDE
problems defined on general domains using objects.

An initial and boundary value problem consists of a
partial differential equation and a set of initial and
boundary conditions. A simple two-dimensional example using the wave equation is

1 Introduction
Modelica [4, 5, 3, 1] is a general, high-level language for object-oriented modeling with differentialalgebraic equations (DAEs). The aim of the Modelica
language is to represent models in a general, domainindependent way. Using object-oriented constructs,
Modelica supports reuse of existing models and model
libraries. By introducing support for PDEs in Modelica, these features will be useful also for modeling and
simulation of PDE-based models.
There are several low-level PDE solving packages
in which the problem is specified as program code
written in a programming language (e.g. Diffpack,
Overture), as well as high-level packages where special purpose languages are used for formulation of the
problem (e.g., gPROMS [10], ELLPACK [12], PDEQSOL [6]), and interactive tools such as FEMLAB.
This section gives a brief introduction to PDEs and
numerical solution methods, and mentions other existing packages with built-in high-level PDE language
support. The MathModelica environment that is used
for implementation is also introduced in this section.
Section 2 contains a discussion of proposed extensions
to Modelica. In Section 3, current status of our work
is given, and in Section 4 future plans are presented.

∂2U
∂x2

∂2U
∂t 2





∂2U
∂y2 

x  y  Ω

where Ω is the domain, with the boundary condition



u x  y t 



0

x  y  ∂Ω

where ∂Ω is the boundary of the domain, and the initial
condition





u x  y 0 

f x  y





x  y  Ω

The first derivative with respect to the variable x is
compactly written as ∂xU, and the second derivative
as ∂xxU, or even shorter as Ux and Uxx .

1.2 Numerical Solution of PDEs
With existing theory, only a small number of PDEs
can be solved analytically, and even smaller number
of these is solvable with useful boundary conditions.
Therefore, many methods have been developed for solution of numerical approximations of PDEs.
1.2.1 Finite Difference Methods
In order to find the unknown function U satisfying the
PDE, the domain is discretized using a grid of points,
searching the value of U at each grid point. In a twodimensional domain with NxN grid points, the value
of U at each point is
ui  j



U xi  y j 



i

0 
	
	
	 N  1  j

0 
	
	
	 N  1

Using Taylor’s theorem, derivatives can be approximated by difference quotients. The first derivative of

U with respect to x is then, using a central-difference
formula,
ui  1  j  ui  1  j
∂xU 
2∆x
Other approximations can be obtained with the
forward-difference formula
ui



∂xU

 

1 j

∆x

ui  j

and the backward-difference formula
∂xU



ui  j



ui 
∆x



1 j

An explicit solver iterates over the points, calculating ui  j at each point using previously calculated values. An implicit solver, when iterating over the points,
needs to solve a system of equations for a set of points
in each iteration, in order to calculate the values of
u. Iterating solvers have different convergence properties, depending on the specific PDE and the selected
difference method.

1.2.3 Method of Lines
Time dependent PDEs can be discretized with respect
to the space variables, generating a set of ODEs, which
can be solved using ODE solvers. This method is
called the method of lines. The advantage of this
method is that there exists advanced algorithms for
fast and accurate solution of ODEs, e.g. with automatic step adjustment to match a requested error tolerance. However, a drawback is that these solvers do
not have control over the error introduced by the initial
discretization that generates the ODEs, which can be
much bigger than the error of the solution of ODEs.

1.3 Related Work
An early effort to define a language for partial differential equations was PDEL [2] in 1970. Since then, a
number of approaches have been investigated to create high-level language based environments to simplify specification and solution of PDE-based problems. In this section, we summarize some of these
environments.

1.2.2 Finite Element Methods
1.3.1 ELLPACK
One way of solving a PDE numerically is to approximate the unknown U with a sum of basis functions, ELLPACK [12] is a package for solving elliptic partial
for example piece-wise polynomial functions, with un- differential equations. It defines a high-level language
for specification of a PDE, a boundary, a grid and a
known factors:
discretization method as well as a solution method. In
N


this
language, there are predefined names for the soluÛ x 
∑ ak φ x
tion variable and its derivatives, such as U, UX (∂xU),
k 0
UYY (∂yyU) and the spatial variables X, Y and Z. These
A system of equations is then set up with the factors are used to specify the PDE:
ak as unknowns. Solving this system gives the approximate solution Û. The family of methods based EQUATION. UXX + UYY + 3.0*UX - 4.0*U = &
EXP(X+Y)*SIN(PI*X)
on this method is called weighted residual methods,
and different choices of weighting functions gives difHere ’&’ is used as a line continuation marker for
ferent methods, such as the collocation method, the
long entries. The boundary conditions can be specified
least-squares method and the Galerkin method.
in
different ways, using lines and parametric curves. A
Instead of finding a global solution, the domain can
be divided into smaller domains, called elements, with circular domain is specified as:
additional conditions on the new boundaries, which
BOUNDARY. U=0.0 ON X= 1.-COS(PI*THETA), &
can be solved separately using the same methods as
Y= 1.-SIN(PI*THETA) &
in the global case. This method is called the finite eleFOR THETA = 0. TO 2.
ment method. Subdivision of the domain can be done
in different ways, e.g. by triangulating the domain.
This boundary specifies the condition that the funcSizes of the elements can also be adjusted according tion is  zero on the circle with the radius 1 and the
to expected variations of U in different parts of the do- center 1  1  . The BOUNDARY statement also defines
main, creating smaller elements where fast variations the domain of the problem. The EQUATION and
are expected. Thus, few polynomials with low order BOUNDARY parts of an ELLPACK program is declarare often sufficient to approximate U over each ele- ative, whereas the rest (GRID, DISCRETIZATION
ment.
etc.), are executed in a sequential order.

Furthermore, the PELLPACK [7] (Parallel ELLPACK) problem solving environment has been developed, also based on ELLPACK, supporting domaindecomposition based parallel solvers and finite element methods. It includes several PDE solving systems, some of those with several specific solving methods. It also covers parabolic problems besides elliptic ones, and some hyperbolic problems. As a problem solving environment (PSE), it also has support
for graphical user interfaces, visualization and analytic
tools.
1.3.2 PDESpec
S. Weerawarana [14] presents a high-level language
PDESpec where the PDE problem is specified using
objects. Different types of objects are equation, domain, boundary and initial conditions, mesh, decomposition, algorithm, solve and solution. For example, an equation object describing the steady-state heat
flow is defined as:
equation (
name = "steady-state heat flow",
domain = "dome",
expressions = [ Dx( k(x,y)*Tx ) +
Dy( k(x,y)*Ty ) = 0 ],
properties = [ [self-adjoint],
[steady-state] ]
);

1.3.3 gPROMS
The gPROMS environment is used for dynamic simulation of chemical processes, and a modeling language
was designed and implemented by M .Oh [10] in the
gPROMS environment. The language supports modeling and simulation of mixed systems of integral, partial and ordinary differential, and algebraic equations
(IPDAEs) over rectangular domains. In gPROMS, a
domain can be declared as:
MODEL TubularReactor
PARAMETER
NbrComp
...
ReactorLen
ReactorRad

AS INTEGER
AS REAL
AS REAL

DISTRIBUTION_DOMAIN
Axial
AS ( 0 : ReactorLen )
Radial
AS ( 0 : ReactorRad )

where Axial and Radial are the independent variables. A dependent variable that is to be solved over
this domain is declared as
VARIABLE
Temp AS DISTRIBUTION (Axial, Radial)
OF Temperature

Here, Temp is the dependent variable of type Temperature (defined elsewhere), and it’s domain is the
three-dimensional area defined by the independent
variables Axial and Radial. This declaration is simiHere T x represents ∂x T and Dx(A)
 is an alias for lar to declaration of arrays in the gPROMS language,
diff(A, x) which represents ∂x A  . Aliases, the
which is done as:
dimension of the problem and names of the independent variables are defined as defaults for equation ob- F AS ARRAY ( NbrComp ) OF Flowrate
jects. The domain ”dome” is defined as a separate object, as well as the boundary conditions and their equaFor-loops are used for specification of a domain for
tions. The domain object is specified as:
a specific expression or equation:
domain (
name = "dome",
type = piecewise_parametric,
boundary = [
orientation = clockwise,
parametric (x=3, y=.7-t, t, 0, .7),
...
]
);

FOR z:= 0 TO ReactorLen DO
-Kr*PARTIAL(Temp(z,ReactorRad),Radial)=
Uh*(Temp(z,ReactorRad)-TWall(z));
END

Here, a boundary condition is defined for the wall
of the tubular reactor, which has an axial distribution but not radial. The partial differentiation can
also be seen here, which is done with the operator
PARTIAL(expr, var), that represents the partial
Besides PDESpec, a problem solving environment derivative of the expression
 expr with respect to the
with an extensible architecture for different solvers variable var (i.e. ∂r Temp z  R  ). The PARTIAL operand an intelligent PDE solver selection based on ex- ator supports differentiation of entire expressions, not
only single variables.
pert system methodology is presented.

1.4

MathModelica

MathModelica [9, 8] is a Mathematica-based tool for
Modelica-based modeling and simulation. The models
are defined interactively in Mathematica notebooks,
using the Modelica language, either using standard
Modelica syntax or using an expression-based syntax
similar to Mathematica. Mathematical symbols and
expressions can be used in these models, making models easier to read. Figure 1 shows the MathModelica input for a pendulum model. Graphical design of
Modelica models based on Modelica library components is also possible in MathModelica.
Model [ Pendulum,
Parameter Real m  1, g  9 	 82, r  12 ;
Real φ [  Start  0  ], vt [  Start  0  ], at , Ft ;
Equation [
Ft   mgSin  φ ;
Ft  mat ;
vt  rφ ;
at  vt ;
];
]

2.1 Spatial Variables
Variables in Modelica are functions of time, if they
are not declared as constants or parameters. In order to introduce spatial variables without changing the
language too much, we can introduce a type modifier
space to be used in declarations of spatial variables.
An example can look like this:
space Real x, y, z;

2.2 Domain Classes
Domain classes are needed to specify the domain
where a function is defined or where an equation holds.
A variable can be assigned a domain when it is declared, which will then also have its spatial dependencies defined. Several approaches can be taken to design domain classes.
2.2.1 Single Domain Classes

Each domain can be defined using a single domain
class. Two new keywords can be introduced, domain
and
subdomain, which are language extensions,
Figure 1: MathModelica input for a pendulum
designating
a new kind of restricted class and a new
model.  is the equality operator and  is the
operator for first derivative of a function of one kind of section within such
 classes. For example, a
x  0  2  y  0  4 can be
rectangular
domain
class
variable in Mathematica.
defined as:
The main advantage of using Mathematica as the
domain Rectangular
implementation platform together with MathModelica
space Real x(min=0, max=2);
is that it is very easy to add extensions to the Mathspace Real y(min=0, max=4);
Modelica language (i.e. Modelica with MathModelica
end Rectangular;
syntax) without modifying the parser which builds the
internal syntax tree. The extensions are preserved durThe attributes min and max belong to the built-in
ing this translation, and additional processing can be
type
Real. Lower dimensional sub-domains can be
made after the MathModelica parser, in order to handefined
in such a domain object by adding a section
dle the extensions appropriately. This is convenient
when experimenting with new language features like subdomain with an equation or a boolean expression
the PDE extensions. The transformational program- that restricts the domain. For example:
ming language that is available in Mathematica is also
domain Rectangular
convenient for handling translation of data structures
space Real x(min=0, max=2);
between different formats.
space Real y(min=0, max=4);

2 Modelica Extensions

subdomain leftright
x=x.min or x=x.max
subdomain updown
y=y.min or y=y.max
end Rectangular;

In order to introduce PDE support in Modelica, several
issues need to be solved, such as handling spatial variComplex domains can also be defined using expresables, domains, and initial and boundary conditions.
This chapter presents some ideas regarding these is- sions as min and max values of the domain variables.
For example:
sues.

In that case, some restrictions on the referred domains might be required, i.e. that a domain must be a
closed curve or a closed polygon in order to be used
with these operators.
The domains can also be built using inheritance and
composite classes. A complete example might appear
as follows:

domain Circular
parameter Real r;
space Real x(min=-r, max=r);
space Real y(min=-sqrt(r-xˆ2),
max=sqrt(r-xˆ2));
subdomain edge
xˆ2+yˆ2 == rˆ2;
end Circular;

This approach is used in the prototype described in
Section 3.

domain Cartesian2D
outer space Real x,y;
end Cartesian2D;

2.2.2 Composite
Classes

record Point2D
Real x,y;
end Point2D;

and

Hierarchical

Domain

For domains with more complex shapes like circle or
polygon, the shape can be defined separately and specified as a boundary for the domain. An example of
such a shape is:
domain Circle
parameter Real radius;
outer space Real x, y;
constraint
xˆ2 + yˆ2 == radiusˆ2;
end Circle;



which declares a circle with the center 0  0  and radius 1. The keyword constraint is a language extension and specifies the expressions that must be true
for the spatial variables to be inside this domain. The
reason the existing equation keyword is not used is
that it should be possible to give boolean expressions
as constraints.
Using the shape Circle above, a circular domain
with a hole can be defined as:
domain Ring
inner space Real x, y;
Circle edge1(radius=1);
Circle edge2(radius=3);
constraint
xˆ2 + yˆ2 <= edge2.radiusˆ2;
xˆ2 + yˆ2 >= edge1.radiusˆ2;
end Ring;

Several constraints separated by ’;’ are equivalent
to the same constraints combined by the and operator. In the future, built-in operators inside() and
outside() might be introduced, in order to specify a relationship between the spatial variables and
other domains. In this example, the constraints could
be specified using these operators together with the
boolean operator and:
inside(edge2) and outside(edge1);

domain Circle2D
extends Cartesian2D;
parameter Point2D center(x=0, y=0);
parameter Real radius=1;
constraint
(x-center.x)ˆ2 +
(y-center.y)ˆ2 == radiusˆ2;
end Circle2D;
domain Ring;
inner space Real x, y;
Circle2D c1(center(x=0,y=0),
radius=1);
Circle2D c2(center(x=0,y=0),
radius=2);
constraint
(x-c2.center.x)ˆ2 +
(y-c2.center.y)ˆ2 <= c2.radiusˆ2;
(x-c1.center.x)ˆ2 +
(y-c1.center.y)ˆ2 >= c1.radiusˆ2;
end Ring;

With the inside() and outside() operators,
the constraints for the Ring domain would be
constraint
inside(c2) and outside(c1);

2.3 Component Declarations
Once domains are defined, variables that depend on
spatial variables, called distributed variables, can be
declared and assigned a domain object. A model with
a variable U defined over the ring-shaped domain (see
Section 2.2) can be specified as:
model PDETest
Ring ringdom;
Real U(domain=ringdom);
...
end Test;

The attribute domain is an addition to the existing type Real in Modelica1 , not to be confused with
the previously introduced use of the keyword domain
as a restricted class. Modification of the domain attribute of the type Real declares the definition domain of U. This modification is also an implicit way
of declaring U to be a spatially dependent variable, besides being time-dependent. Alternatively, declaring a
variable to be spatially dependent can be done explicitly using a new keyword, for example the keyword
field, or the keyword dependent:
depdendent Real U(domain=ringdom);

2.4

Domain Specification for Equations

pder(U,dom.x,2) =
sin(dom.x)+cos(dom.y);

This could also co-exist with the other alternatives.

2.5 Initial and Boundary Conditions
Initial values for variables in Modelica are given using the start attribute of the built-in types. Similarly, initial conditions for a PDE problem can be given
as modification of the start attribute of distributed
variables. The example from Section 2.3 with initial
conditions added looks like:
parameter Real f(domain=ringdom);
Real U(domain=ringdom, start=f);

When specifying an equation, i.e. the PDE or one of
Here, a parameter f is declared, which can be given
the boundary conditions, the domain over which the
equation is valid needs to be specified. One way to as argument to the simulator, or defined in the model
do this is to use for-loops. With a syntax similar to as:
Modelica, this can be done as:
parameter Real f(domain=ringdom) =
equation
for (x,y) in ringdom loop
pder(U,x,2) = sin(x)+cos(y);
end for;

sin(x) + cos(y), (x,y) in ringdom;

The expression in the right-hand side can be given
as a value to the start attribute of U directly, as well.
Boundary conditions can be specified using the
specific sub-domains of a domain in the equations
defining the boundary conditions. A new keyword
boundary is used to separate model equations from
boundary conditions, e.g.:

Here, a new built-in operator pder(U,x,i) is
also introduced, which represents the i:th derivative of
U with respect to x. Instead of using the component
ringdom directly, one could refer to the domain of U
using dot notation, e.g. U.domain.
boundary
The difference between for-loops in Modelica and
for (x,y) in ringdom.c1 loop
the for-loop in the example above is the usage of mulU(x,y) = -5;
tiple variables as loop indexes and a domain object as
end
for;
2
a range . The scope of the variables x and y is local for
the loop, and they are aliases for the spatial variables in
This defines the value of U on the inner circle of the
the domain, with x corresponding to the first declared
ring domain, declared as c1 in Ring.
space variable in the domain and y corresponding to
the second.
An alternative syntax for domain specification is
3 Current Work
pder(U,x,2) =
sin(x) + cos(y), (x,y) in dom;

which is closer to mathematical notation. Both alternatives can be supported as well, with one being
syntactic sugar for the other.
Another, somewhat less convenient alternative is to
use the spatial variables in a domain object directly,
using the member notation:
1 The regular type Real can have a built-in one-dimensional domain  min  max as default, to be consistent with current Modelica.
2 Ranges in Modelica are written as, for example, 1:10 or 1:2:10
which mean 1,2,3,... or 1,3,5,... , respectively.

A prototype translator has been implemented in Mathematica, using the MathModelica environment (see
Section 1.4). This translator supports the kind of
domain classes described in Section 2.2.1, except
that only single equations are recognized in the subdomains and not boolean expressions. An example
defining a circular domain can be seen in Figure 2.
Domain references in equations are done by directly
putting the domain object as an argument to the dependent variable. Thus, all dependent variables have
two arguments, the domain object which implicitly
defines all spatial arguments, and the time variable.

Domain [ Circular,
Parameter Real r  1;
Space Real x[  min   r2  y2 
max   r2  y2  ];
Space Real y[  min   r max  r  ];
Subdomain [ le f tborder,
Equation [ x  x 	 min ];
];
Subdomain [ rightborder,
Equation [ x  x 	 max ];
];
]

3.1 Example
As an example, we can define an initial value problem
with a two-dimensional wave equation using a circular
domain. The equation looks like
∂xx u

∂tt u



∂yy u 



x2

!

y2

1

with the initial and boundary conditions







u 9cone x  y 0 	 4  sin πx  cos πx 
∂t u 0 
u δ
∂x u 0 
∂y u 0 



t
t

x2

x2

x2

0
0
y2
y2
y2

1
1
1

Figure 2: A domain declaration in the prototype

where cone x  y r  is defined as
translator, defining a circular domain



cone x  y r 

#"

1 %$
0



x2 y2
r2



x2 y2 !
otherwise



r

For example:
First, we define a domain object representing a
general circular domain class:
Equation [
∂t U  circdom  time
];



∂xxU  circdom  time



0;

Boundary and initial conditions are put into a
section called Boundary[] as normal equations.
In boundary condition equations, a sub-domain of a
domain is referred with dot notation and used as the
first argument. In initial conditions, the time argument
is set to a constant. For example:
Boundary [
∂t U  circdom 	 le f tborder time  0;
U  circdom 	 le f tborder time  2;

U  circdom  0  Sin  circdom 	 x Cos  circdom 	 y ;
];

Domain [ Circle
Parameter Real xc  0;
Parameter Real yc  0;
Parameter Real r  1;

Space Real x[  min  xc   r2  y  yc  2 


max  xc  r2  y  yc  2  ];

Space Real y[  min  yc  r max  yc r  ];
Subdomain [ le f tborder,
Equation [ x  x 	 min ];
];
Subdomain [ rightborder,
Equation [ x  x 	 max ];
];
];

The default
 values specify a circular domain with
the center 0  0  and the radius 1 when the domain is
The translator uses MathModelica for parsing the instantiated. Then we can specify the main model:
input, and modifies the result for the additions that are
done to the syntax for PDE support. Then, the PDE, PDEModel [ TestModel
boundary and initial conditions, and the geometry of
Parameter Real xc  0;
the model are extracted and converted to an input forParameter Real yc  0;
mat that is used by the solver, a PDE solver [13] imParameter Real r  1;
plemented in Mathematica. This solver uses the finite
Parameter Real delta  0;
difference method to generate special C++ code for the
Circle dom[  xc  xc  yc  yc  r  r  ];
given problem and the selected differentiation methods.
Dependent Real u;

Boundary [
u[dom  0]  uinit[dom 	 x  dom 	 y];
∂t u[dom  0]  0;
u[dom 	 le f tborder time]  delta;
∂x u[dom 	 le f tborder time]  0;
∂y u[dom 	 le f tborder time]  0;
u[dom 	 rightborder time]  delta;
∂x u[dom 	 rightborder time]  0;
∂y u[dom 	 rightborder time]  0;
];

erateSolvePDEInput[], which takes as argument the
name of the model and some parameters needed by the
solver, such as the differentiation methods, start and
end values for the time variable and the spatial variables, and size of the result array. In this example,
we

use the intervals x   1  1  , y   1  1  , t  0  0 	 25  ,
a 100x100 grid and 200 time steps. Figure 4 shows the
result at t 0 	 0625, 0 	 125 and 0 	 1875.

4 Conclusion and Future Work

Equation [
∂tt u[dom  time] 

∂xx u[dom  time] ∂yy u[dom  time];
];
];

The purpose of this paper is to consider some initial
extensions to the Modelica language that are needed in
order to allow modeling with partial differential equations. The focus is the definition of the domain objects
and how they are used together with equations and initial and boundary conditions.

The keyword PDEModel is used by the translator
Future work involves further implementation of the
to recognize PDE models. The start values of the
extensions
discussed in Section 2. Also, an extended
dependent variable u are given as a function uinit[x,y]
syntax
for
domains
will be designed, to allow parametdefined in the Mathematica environment as:
ric specification of boundaries. Another extension that
can
be needed is modification of the function type
uinit[x  y ] 9MyCone[x  y 0 	 4]Sin[πx]Cos[πy];
in Modelica for spatially distributed variables.



MyCone generates a cone with the center 0  0  and
a given radius, and is used to limit the Sin and Cos
functions to a small area of the domain. A plot of the
initial values with radius set to 0 	 4 can be seen in Figure 3).

1
0.5
0
-0.5
-1
-0.4

0.4
0.2
0
-0.2

-0.2

0
0.2

-0.4
0.4

Figure 3: Initial value function uinit with radius
0 	 4 for the PDE used in TestModel.

A powerful feature of Modelica is the connect()
statement, that allows building models using smaller
submodels. Extension of this feature for PDE models
needs to be considered, as well. Possible approaches
are using solvers that support domain-decomposition
techniques, or if different PDE models need to be
connected, techniques like the interface relaxation
method [11].
For solving the PDE problems, specification of
grids, triangulations or triangulation algorithms to be
used with finite element methods and solution method
selection (e.g. selection of finite difference methods
for the solver mentioned in Section 3) needs to be included in Modelica, or defined in a separate support
language.
Furthermore, automatic solver selection can be considered, for example by using pattern matching on
equations and selecting a solver or method from a
database. An architecture with several solvers and the
possibility to add new solvers would make a useful environment.

Another problem is adapting the PDE solvers and
existing DAE solvers that are used for the existing
Then, the input to the PDE solver mentioned in ODE-based models, or finding other ways to support
Section 3 can be generated using the function Gen- solution of existing models together with PDE models.

5 Acknowledgments
This work has been supported by the ECSEL graduate school at Linköping University, supported by the
Swedish Strategic Research Foundation.

References

1
0.5
0
-0.5
-1

70
60
50

30
40

40

50
60

[2] A. F. Cardenas and W. J. Karplus. PDEL — a
language for partial differential equations. Communications of the ACM, 13(3):184–191, March
1970.

30
70

t

[1] Modelica Association 1999. Modelica – A Unified Object-Oriented Language for Physical Systems Modeling - Language Specification Version
1.3, Dec 1999.

0 	 0625

[3] H. Elmqvist, S. E. Mattsson, and M. Otter. A
language for physical system modeling, visualization and interaction. In Proceedings of the
1999 IEEE Symposium on Computer-Aided Control System Design, Hawaii, Aug. 1999.

1
0.5
0
-0.5
-1

70
60
50

30
40

40

50
60

[5] P. Fritzson and V. Engelson.
Modelica—
A unified object-oriented language for system
modeling and simulation. In Eric Jul, editor, ECOOP ’98—Object-Oriented Programming, volume 1445 of Lecture Notes in Computer Science, pages 67–90. Springer, 1998.

30
70

t

[4] H. Elmqvist and S.E. Mattsson. Modelica – the
next generation modeling language – an international design effort. In Proceedings of the First
World Congress on System Simulation, Singapore, Sept. 1–3 1997.

0 	 125

[6] Hitachi, Ltd., Computer Division. PDEQSOL
User’s Manual, 1990.
1
0.5
0
-0.5
-1

70
60
50

30
40

40

50
60

30

[8] M. Jirstrand. MathModelica, a full sytem simulation tool. In Proc. of Modelica Workshop 2000,
2000.

70

t

0 	 1875

Figure 4: Plot of the solution at t
and t 0 	 1875 .

0 	 0625, t

[7] E. N. Houstis, J. R. Rice, S. Weerawarana, A. C.
Catlin, P. Papachiou, K.-Y. Wang, and M. Gaitatzes. PELLPACK: a problem-solving environment for PDE-based applications on multicomputer platforms. ACM Transactions on Mathematical Software, 24(1):30–73, March 1998.

0 	 125

[9] M. Jirstrand, J. Gunnarsson, and P. Fritzson.
MathModelica – a new modeling and simulation
environment for Mathematica. IMS ’99—Third
International Mathematica Symposium, 1999.

[10] M. Oh. Modelling and Simulation of Combined
Lumped and Distributed Processes. PhD thesis,
University of London, 1995.
[11] J. R. Rice. An agent-based architecture for solving partial differential equations. SIAM News,
31(6), 1998.
[12] J. R. Rice and R. F. Boisvert. Solving Elliptic Problems using ELLPACK. Springer-Verlag,
1985.
[13] K. Sheshadri and P. Fritzson. A Mathematicabased PDE-solver generator.
In Scandinavian Simulation Society (SIMS) Conference, Linköping University, Linköping, Sweden,
September 1999.
[14] S. Weerawarana. Problem solving environments
for partial differential equation based applications. PhD thesis, Department of Computer Sciences, Purdue University, August 1994.

06DQGEHUJ%/LVSHU
'LPHQVLRQDO$QDO\VLVIRU0RGHOLFD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

$6FKLHOD+2OVVRQ
0L[HGPRGH,QWHJUDWLRQIRU5HDOWLPH6LPXODWLRQ
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Mixed-mode Integration for Real-time Simulation
Anton Schiela, DLR, Oberpfaffenhofen, Germany
Hans Olsson, Dynasim AB, Lund, Sweden
ABSTRACT
The new possibilities of multi-domain hierarchical modelling often lead to models with both fast and
slow parts. In this paper a new approach to simulate such systems is discussed that is especially useful
in real-time applications. Mixed-mode integration represents a middle course between implicit and
explicit integration. The main idea is to split up the system into a fast and a slow part and to apply
implicit discretization only to the fast part. The partitioning of the system can be performed offline
using a newly developed automatic selection routine, before real-time simulation starts. Mixed-mode
integration was applied to several Modelica models from different fields, e.g. models of a diesel engine
and an industrial robot and tested using Dymola. Speedup factors from about 4-16 were recorded. In
this paper, mixed-mode integration is introduced, the selection routine is described and numerical
results are presented.

highly sophisticated step size- and order control
mechanisms and high-order methods.

Introduction
Real-time simulation is a growing field of applications
for simulation software. One goal is to be able to
simulate more and more complex models in real-time
with fast sampling rates. Many of those models are
multi-domain models, which means, that they contain
components from more than one physical domain.
Mechanic, electric, hydraulic or thermodynamic
components are often coupled together in one model.
This leads to a large span of time-constants in the
model.
In many classical integration methods the fastest timeconstant determines the computational effort for the
simulation, which is too high in many cases. Mixedmode integration is one way to simulate such systems
efficiently.

In real-time simulation the computer typically
communicates with peripheral hardware components
during the simulation. This communication takes
place using a fixed small sampling interval e.g. 1ms.
The simulation must perform the time-step and
provide its results before this interval ends.
Exceeding this “deadline” would be an error. So the
aim of real-time simulation is not to reduce the
average computational cost, but to make sure, that
the calculation time for one step never exceeds this
time limit. This leads to a different choice of
integration methods. To minimise the computational
cost for one time-step usually a very simple
discretization scheme is chosen as for example the
explicit Euler-method.
Stiffness

Problems in real-time simulation
The task of real-time simulation is different from the
classical offline simulation and therefore poses
different problems.
Special requirements
Compared to the classical problem of offline
simulation,
real-time
simulation
demands
fundamentally different properties of the underlying
integration routines, to solve an ordinary differential
equation:
x = f (x)
Offline integrators try to minimise the overall
integration time at a given (high) accuracy, using

Special problems are caused by stiff systems. These
are systems with dynamically very fast and highly
damped components. If an explicit method is used to
integrate such systems, step size is limited due to
stability problems of the integration method. If step
size is too large, then the computed trajectory starts
to oscillate and diverges. The simplest example for
an explicit method is explicit Euler:
x n +1 = x n + hf ( x n )
The standard cure for unstable behaviour is to use
implicit methods. Implicit methods evaluate the
right-hand side at future time points. This leads to a
non-linear equation system that has to be solved at
each step. The simplest example for an implicit
method is implicit Euler:

xn +1 = xn + hf ( xn +1 )
At each time-step this equation has to be solved for
x n +1 .
For real-time integration both methods have their own
severe drawbacks, which limit drastically the size of
stiff systems that can be simulated in real-time.
Explicit methods used for stiff systems usually
demand step sizes that are much lower than the given
real-time step size. As stiffness increases, the step size
tends to zero. The basic problem of implicit methods
is the non-linear equation system to solve at each time
step. In conventional methods, the dimension of this
system is at least the number of states. The solution
process is iterative and requires the costly evaluation
of the Jacobian of the right hand side.
Offline methods can decrease the average
computation time for one implicit step by not
evaluating the Jacobian at each time step and by
allowing slower convergence slowly for the non-linear
solver once in a while [1]. All these considerations are
not possible dealing with real-time simulation, as each
single step must meet the real-time requirements. In
this context the use of implicit methods is very
critical.
Fast and slow components
The situation is especially unsatisfactory when both
fast and slow components are present in the model to
be simulated. Especially multi-domain modelling
often results in such systems. For example in
mechatronical systems a slow mechanical part is often
controlled by fast electric circuits or by a hydraulic
drive. Unfortunately the fastest time-constant governs
the stability of the whole system for explicit methods
and if only one component becomes unstable the
results are worthless. In the classical sense, the whole
model has to be treated as stiff.
To choose between an explicit and an implicit method
means that either the system is integrated at a too
small step size or a non-linear equation system of huge
size has to be solved at each step, although the fast
part is very small. Here, the choice of an implicit
method leads to similarly unsatisfactory results as the
choice of an explicit one.

Principles
The basic idea is simple. We perform a row-wise
partitioning of the right hand side, which results in a
partitioning of the states into fast and slow ones:
x S = f S ( x S , x F )
x F = f F ( x S , x F )
Here the superscript “F” denotes the fast, and the
superscript “S” the slow part of the system.
Then, an implicit discretization formula for step size
h is applied to the fast and an explicit one to the
slow system, for example the Euler-formulas:
xnS+1 = xnS + hf

S

xnF+1 = xnF + hf

F

(x , x )
(x , x )
S
n

S
n +1

F
n

F
n +1

The first of these equations can be evaluated
explicitly and the result is inserted into the second
one. This reduces the size of the non-linear equation
system from the number of states to the number of
fast variables.
Note that the resulting method still has convergence
order 1. For higher order Runge-Kutta methods
certain coupling conditions have to be fulfilled
which is described e.g. in [2, pp. 302-311]. These
conditions trivially hold for the combination of
implicit and explicit Euler.
The linearized model
In the following, the case of a linear differential
equation system is regarded, which makes a closer
analysis possible.
The linear differential equation of dimension d
x = Ax
is partitioned by multiplying A with a diagonal
projection matrix P = diag (δ 1 ,..δ n ); δ i ∈ {0,1} from
the left to select the slow part and with I-P to select
the fast part.
A = PA + (I − P )A
P selects rows of A. PA is the slow part and
( I − P ) A the fast part.
The partitioned differential equation is:
x S = Px = PAx

Mixed-mode integration
As we have seen, both implicit and explicit methods
have performance problems simulating a model with
fast and slow components. This situation motivates the
idea of finding a middle course between implicit and
explicit. One idea is to cut the system into two pieces:
a (hopefully) small fast system that can be treated
easily with implicit methods and a slow system where
cheap explicit methods can be applied on: Mixedmode integration.

x F = (I − P )x = (I − P )Ax
The two equations are discretized as:
xnS+1 = Pxn +1 = Pxn + hPAxn

xnF+1 = (I − P )xn +1 = (I − P )xn + h(I − P )Axn +1
Using explicit Euler for the slow part and implicit
Euler for the fast part.
Adding those two equations yields:
xn +1 = xn + hPAxn + h(I − P )Axn +1

That can be solved for xn +1 :
1
xn +1 = (I − h(I − P )A)− (I + hPA)xn

which is again a linear discrete system with system
matrix:
U h = (I − h(I − P )A)−1 (I + hPA)
xn +1 = U h xn
This discrete linear system has to be numerically
stable for a desired step size h. This means for the
eigenvalues λi of U h that:

λi ≤ 1 + O(h)

∀1 ≤ i ≤ d

So after all, a partitioning is needed, that guarantees
this relation, but treats only a minimal number of
states implicitly.
In the non-linear case the differential equation can be
linearized at several time-points along the trajectory
and each linearization can be analysed. Then the union
of all fast states will be selected as fast and the
corresponding rows of the differential equation will be
selected for implicit integration.
Mixed-mode and inline integration
The concept of mixed-mode integration for itself can
already lead to a considerable reduction of the size of
equation systems to solve. Especially, when there is
only a small number of fast states and a large number
of slow states.
Another common case is that there are several fast
subsystems in a model coupled together by slow ones
like in complex mechatronical systems. Then pure
mixed-mode integration leads to a big implicit part,
which contains all the fast components. This system
has to be solved as a whole.
A big improvement in this situation is to combine
mixed-mode integration with a technique called inline
integration [3], which was designed to reduce the
computational effort when an implicit discretization
formula is used. The discretization formula is inserted
(inlined) into the ODE and the size of the non-linear
equation system can now be reduced by symbolic
manipulations like Block-Lower-Triangular-transformation and tearing before the integration starts. That
technique makes it possible to split large equation
systems into smaller ones. These small systems are
then much faster to solve. However, improvements
achieved by this technique alone are relatively low in
the case discussed here. The dimension of the
remaining non-linear equation system is still too high,
as the slow coupling between the fast components
prevents the symbolic manipulation to split up the
system.
The situation is different when mixed-mode integration and inline integration are used in combination.
Then the slow part is discretized explicitly. It breaks
up the coupling between the implicit components in

the equation system. The decoupled systems can
now be treated more easily by the symbolic
manipulation. This results in several small instead of
one large equation system. Sometimes the small
systems can even be solved symbolically at
translation time. All this leads to a drastic increase
of computational speed. Obviously both methods fit
together very well.
Alternative approaches
One alternative to mixed-mode integration is a
technique called multi-rate integration. The main
idea is to split the system into a slow and a fast part
(like in the mixed-mode case) and to apply an
explicit method to both parts using two different step
sizes: a small one to the fast part and a big step size
to the slow part.
Mixed-mode and multi-rate integration both have
their own advantages and drawbacks. The most
important advantage of multi-rate integration is that
it doesn’t contain any iterative parts during one
(large) step, which means that it might even be
better suited for real-time applications. The price for
this is that one has to choose two step sizes and the
smaller step size depends on the fastest component.
This has several consequences:
•

Very fast components lead to a very small step
size and spoil the performance

•

Integrating non-linear models, the small step
size has to guarantee stability for the whole
simulation, but the time-constants can vary
during integration.

Another important reason for us to prefer mixedmode integration is that it benefits largely from
symbolic manipulation routines and especially from
inlining. Both features are incorporated in Dymola
[4].
There is also a different approach for systems with
fast and slow components. It utilises the structure to
solve the linear equation systems that occur at each
time step quicker, using for example Krylov-space
methods. This approach is described e.g. in [5, pp.
171-176]. However this class of methods is not that
well suited for real-time integration, because they
introduce another iterative loop (for solving the
linear equation system) and the computational cost
can vary considerably between steps.

Partitioning
Once a partitioning is made, the mixed method can
be implemented quite easily in an environment like
Dymola. The task is now to get a good partitioning
that guarantees stability without choosing too many
fast variables. We designed an automatic algorithm
for this purpose which will be described briefly in
this section.

Basic ideas

Stability of the mixed discrete system

For a given linear differential equation system
x = Ax

Obviously, there are many possible partitionings of a
model, e.g. depending on the supplied threshold. All
of them split up the continuous system into two parts
of which the slower part has got eigenvalues below
the threshold. But not all are equally well suited for
a model. This has to do with the coupling between
the two parts. It strongly affects the stability of the
discretization, especially if the eigenvalues of the
two systems are too close to each other.

and a given step size h the partitioning algorithm will
return a projection matrix P as described above such
that the discrete system:
xn +1 = U h xn
U h = (I − h(I − P )A)−1 (I + hPA)
is numerically stable and the implicit part is as small
as possible.
This could be seen as a combinatorial problem, which
could be solved by complete search. However this is
not possible because of complexity reasons. Instead,
heuristic criteria are used to classify variables as fast
or as slow.
The algorithm is divided into two phases:
•

•

Partitioning of the continuous system x = Ax into
a fast and a slow part with the help of a user
supplied threshold for the magnitude of the
eigenvalues.
Stability check of the resulting discrete system
x n +1 = U h x n and - if necessary - stabilisation of
the discrete system.

Partitioning of the differential equation
The main task of this partitioning is to select a “fast”
part so that the magnitudes of the eigenvalues in the
remaining slow part of the system are below a usersupplied threshold.
The first step is quite straightforward: the fast
components of the system are the eigenvectors
corresponding to the fast eigenvalues. The cleanest
solution would be to cut out the subspace spanned by
these eigenvectors. However this is not possible in
general because in the non-linear case it would
involve a coordinate transformation in each step of the
integration routine as the linearization A is time
varying.
Our only freedom is to select states; that means rows
of the matrix. One could select all rows that are
influenced by the fast subspace. This would however
lead to the choice of too many states. In most cases all
states would be selected which means, that we would
receive a fully implicit method again.
The best way to solve this problem is to choose only
states, that are effected strongly by the fast dynamics
and put them into the set of fast states. This means of
course that the fast subspace is not completely
removed from the slow system. Some eigenvalues of
the slow system could still be larger in magnitude than
the threshold. The slow system has to be checked
again and the state selection is repeated, until the
eigenvalues of the slow system are below the
threshold.

We illustrate this in the case of a 2x2-matrix:
 S
A=
C F

CS 

F

Here the components S and F are the eigenvalues of
the uncoupled slow and fast system. S is assumed to
be small and negative, F is large and negative. C F
and C S are the couplings between them. They shall
be assumed as small compared to F and S.
A partitioning is now performed such that the first
row of A is classified as slow, the second as fast. The
projection-matrix is therefore:
1 0 
P=

0 0 
The matrix of the discrete system is then computed
as:
 1 + hS
Uh = 
1 + hS
hC F
1 − hF


hC S
1 + h 2C F CS
1 − hF






If one of the coupling elements is zero, then U h is
triangular and the eigenvalues µ i of the combined
discrete system are not different from those of the
two separate discrete systems:

µ1 = 1 + hS
µ 2 = 1 (1 − hF )
This system therefore inherits the stability properties
of the two separate discrete systems.
If both of the coupling elements are non-zero, the
eigenvalues λi of the discrete system change. The
best insight is given for the linearization around µ i
for small h 2 C F C S :


µ2
λ1 = µ1 1 −
h 2 C F C S 
 µ1 − µ 2



µ2
λ 2 = µ 2 1 +
h 2 C F C S 
µ
−
µ
1
2



(1)
(2)

Some interesting observations can easily be made
regarding those formulas. First, for loose couplings
the explicit part is stabilised, whereas the implicit
part is destabilised. If the coupling between the two
systems becomes tighter, then C F C S gets larger,

and with it the deviation from µ i . The other important
factor is µ 2 ( µ1 − µ 2 ) which also can amplify the
deviation, if µ1 and µ 2 are too close together. On the
other hand, if µ 2 is very small, that means if the fast
system is very stiff, this effect is reduced.
The higher these two factors are, the worse can the
stability properties of the combined system be. In
some cases strong coupling can even result in a severe
destabilization. Then the resulting system only allows
much smaller step sizes than expected. On the other
hand, if the coupling is only moderate, then the
implicit system often stabilizes the combined system.
If coupling between the two parts is too strong, one
can try to reduce it by selecting slow states that
contribute most to it and move them into the set of fast
states. This is performed iteratively in the second part
of the algorithm.
Stability problems are often caused by a bad choice of
the threshold; e.g. when there are two eigenvalues
slightly above and below it. Then sometimes the
partitioning algorithm is forced to tear subsystems in
two pieces that should be kept undivided. This leads
of course to a very strong coupling between the fast
and the slow part. Users can avoid this problem by
carefully choosing the threshold value e.g. after
looking at the eigenvalues of the system.

Computational results
Mixed-mode integration using the explicit and
implicit Euler formulas was implemented in Dymola
[4], where the method and the partitioning algorithm
were tested on several Modelica [6] models. In the
following, three of those test cases are described.
The performance of the new method was measured
and compared with the performance of the fully
implicit and explicit Euler methods. All three
methods were used together with inline integration,
which means that symbolic manipulations could be
applied to the discrete system. The models contained
small algebraic loops.
Partitioning a robot model
The first model to describe is an industrial robot
with six degrees of freedom. For each joint, besides
the mechanical part, the electric circuit of the motor
and a controller are modelled. This leads to an
overall number of 78 states. The fastest eigenvalues
of the linearization of the system at the starting point
are about 7000 in magnitude. See Figure 1. The
8000

4000

The user’s view
In this paragraph we are summing up the most
important issues how to control the process of
partitioning in our algorithm.

0

-4000

The algorithm partitions a linear system of ordinary
differential equations into a fast and a slow part.
Users can supply two parameters:
• A step size, for which the integration process
should remain stable. If the differential equation
is linear, then stability can be guaranteed. If the
system is non-linear, then in many cases stability
is preserved, if the non-linearity doesn’t affect the
structure of the system severely.
•

An optional parameter “threshold”, which is an
upper bound for the magnitude of the fastest
eigenvalue of the explicit part. If the users don’t
supply “threshold”, it will be calculated from the
step size via a simple formula.
In general the threshold should be chosen low enough
to avoid the need for stabilisation at a certain step size.
The threshold is also a good method to give the
algorithm knowledge about the distribution of the
eigenvalues.
The output is a string array with the names of all the
fast states. It can easily be inserted into the Modelica
model at the top-level.

-8000
-4000

-3000

-2000

-1000

0

1000

Figure 1: The eigenvalues of the robot
model was simulated for 1.5 s at a fixed given step
size of 1 ms.
First the explicit Euler method was applied to the
problem. To obtain stable behaviour the step size
had to be reduced for about a factor ten to achieve
stable behaviour. The largest (linear) equation
system that had to be solved during the integration
was of dimension six. This was the mass matrix of
the robot. With a step size of 0.05 ms it took 16.4
sec to perform the simulation.
Implicit Euler performed the simulation run without
stability problems. The execution time was shorter
than the time explicit Euler needed to integrate with
smaller step size but still too long. This was due to a
large non-linear equation system of dimension 39
that couldn’t be split up by the symbolic
manipulation routines. This resulted in an overall
execution time of 13 sec.

partitioning algorithm together with the symbolic
manipulation detected and broke up this weak
coupling. This led to speedup factors of 16
compared to explicit Euler and 13 compared to
implicit Euler.

robot

1

3
mechanics
6
5
4
3
2
1

2

r3Motor

r3Gear
1

ref

f lange

4

To judge the quality of the computed solution a
reference trajectory was created using a high
accuracy method (DASSL; tol =1e-6) and compared
to the mixed-mode solution. As one can expect the
accuracy of the mixed-mode solution wasn’t very
high but fairly good. The errors at the position level
were around 3mm (that is about 2e-3 x the
dimensions of the robot) and on velocity level
around 0.2 m/s (that is about 8e-3 x the maximum
speeds).
For the robot model mixed-mode
integration performed better than DASSL even when
the overall integration time was considered. DASSL
needed 10.5 s to simulate the model using a low
tolerance of 1e-2. This suggests the possibility of
using the mixed-mode approach also for offlineintegration, if a partitioning can be reused for several
simulation runs.

motor

current controller

Partitioning an engine model
Runtime comparisons have also been made
simulating a model of a drive train. It consists of a
diesel engine, its air-supply and a modelled load.

5

16000

12000

Figure 2: Model of the robot
8000

Now the algorithm we described in the last section
was used to partition the robot. The maximum
magnitude of eigenvalues allowed for the slow system
was chosen as 100. The partitioning algorithm chose
45 fast states, which were representing the electric
circuits and the fast parts of the controller of each
joint. Slow variables were mainly in the mechanical
part or pure integrators. Although a relatively large
number of states had to be treated implicitly, the
execution time was much shorter than in the fully
implicit case. This was because the symbolic
manipulation routines could now split up the large
non-linear equation system that had to be solved using
fully implicit discretization. It was split into a couple
of small linear systems - two for each joint drive - that
could be solved symbolically at compile time and one
linear system of dimension six to be solved during
integration. This was the mass matrix again: the same
as in the explicit case. Mixed-mode integration
managed to simulate the model in 1 sec.
Obviously the weak mechanical coupling between the
fast components of the robot was responsible for the
large equation system of implicit Euler. The

4000

0

0

2

4

6

8

10

Figure 3: Magnitudes of eigenvalues changing
during execution time
Together there were 26 states. Most of them were
used to model the air-supply. An eigenvalue analysis
showed that three eigenvalues were much faster than
the others were, namely about factor 20 (see Figure
3). The model was simulated for 10 seconds and a
step size of at least 1 ms should be used.
First explicit Euler was used. The largest non-linear
equation system for it to solve had dimension 1. Due
to the stiffness of the system the integration failed at
a step size of 1ms. Reasonable results were obtained
at a step size of 0.1 ms, which corresponds to the
observation, that the fastest Eigenvalues were 2e5 in
magnitude. In this case the execution time was 23
sec.

Implicit Euler had no problems with stability running
at a step size of 1 ms. The drawback was, that it had to
solve a non-linear equation system of size 17, which
increased the computational cost per step
considerably. The overall execution time was now 21
sec.
Using mixed-mode integration with a threshold of
1000, 4 fast variables were selected. The fastest
Eigenvalues of the slow system therefore had a size of
500 in magnitude and furthermore the discrete system
was stabilised by the implicit part (which is not always
the case). This enabled the simulation to run stable at a
step size of 1 ms and in each step a non-linear
equation system of dimension 3 had to be solved. The
overall execution time could be reduced to 5.4 sec,
which is a speedup factor of 4 compared to implicit
Euler and factor 4.5 compared to explicit Euler.
Robot
No. of states

26

Simulated Time

1.5 s

10 s

Sample Time

1 ms

1 ms

16.4 s

23 s

Stable Step size

0.05 ms

0.1 ms

Size of Eq. Syst.

6x6

1x1

Implicit Euler

Size of Eq. Syst.

This work was in parts supported by the European
Commission under contract IST-199-11979 with
DLR and Dynasim AB under the Information
Societies Technology as the project entitled "Realtime simulation for design of multi-physics
systems".

Anton Schiela would like to thank Martin Otter,
DLR and Hilding Elmqvist, Dynasim for support
and encouragement.

References

Explicit Euler

Overall time

Acknowledgements

The handling of mixed-mode integration was added
to Dymola by Sven Erik Mattsson.

Engine
78

Overall Time

One future extension to this concept could be the
introduction of a third class of states: oscillating
states, which could be treated using the trapezoidal
rule. In many cases mixed-mode integration can also
accelerate off-line simulation especially when large
models with few fast components are considered. In
this case mixed-mode integration should be
performed using partitioned methods of higher
order.

13 s

21 s

39x39

17x17

[1] H. Olsson, G. Söderlind. Stage value predictors
and efficient Newton iterations in implicit
Runge-Kutta methods. SIAM Journal on
Scientific Computing 20(1):185-202, 1999.
[2] E. Hairer, S. P. Nørsett, G. Wanner Solving
Ordinary Differential Equations I. Nonstiff
Problems. Springer Series in Computational
Mathematics, 2nd edition, 1992.

Table 1: Performance of the three methods

[3] H. Elmqvist, F. Cellier, M. Otter Inline
Integration: A new mixed symbolic/numeric
approach for solving differential-algebraic
equation systems. Proceedings: European
Simulation Multiconference June 1995 Prague,
pp: XXIII-XXXIV.

Conclusions and Outlook

[4] Dymola. Dynasim AB, Lund,
Homepage: http://www.dynasim.se.

Mixed-mode Integration
Overall Time
Size of Eq. Syst.

1s

5.4 s

6x6

3x3

Mixed-mode combined with inline integration
provides a good alternative to the classical explicit and
implicit methods. Especially real-time integration of
multi-domain models can benefit considerably. The
main strength of mixed-mode integration lies in its
increased flexibility and in the additional information
the integration routine uses. Stability is preserved, but
the equation systems to be solved are much smaller
compared to an implicit method.
The designed selection routine automatically chooses
states, so that the stability of the linear system for a
given step size is guaranteed. However it is still
important for users to know about the properties of
their model if they want to achieve the best results.

Sweden.

[5] E. Hairer G. Wanner Solving Ordinary
Differential Equations II. Stiff and DifferentialAlgebraic Problems. Springer Series in
Computational Mathematics, 1st edition, 1991.
[6] Modelica. A unified object-oriented language
for physical systems modelling. Modelica
homepage: http://www.Modelica.org, 2000.

&&ODX$6FKQHLGHU7/HLWQHU36FKZDU]
0RGHOOLQJRI(OHFWULFDO&LUFXLWVZLWK0RGHOLFD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Modelling of Electrical Circuits with Modelica
C. Clauß, A. Schneider, T. Leitner, P. Schwarz
Fraunhofer Institute for Integrated Circuits
Design Automation Department
Zeunerstraße 38, D-01069 Dresden, Germany
Email: {clauss, schneider, leitner, schwarz}@eas.iis.fhg.de

Abstract

•

One building block of the Modelica library is the electrical analog part. It contains important but simple
models of electrical and electronic devices including
very simple semiconductor device models. The models
can be composed to any electrical circuit for which the
model simplicity is sufficient enough. The electrical
analog components are capable of interacting with the
components of the other sublibraries of Modelica.

1

time dependent sources (ramp, sine, exponentials,
trapezoid et. al. for voltages and currents)
• basic models (resistor, capacitor, inductor, transformer, linear controled sources et. al.)
• semiconductor devices (diode, bipolar transistors,
metal-oxide semiconductor FETs)
• line models
• ideal elements (switch, diode, opamp, transformer
et. al.)
The symbols of most of the components correspond to
the standard [10]. Some of the symbols can be seen in
fig. 1.

Overview

The electrical analog Modelica [14] library is a collection of electrical components, which are easy to use,
easy to understand, and of a wide interest. It follows the
simple components of the simulator SPICE [11], some
of them are identical. Independent sources are suited to
those of other physical domains. The library is devided
into:

2

Formulation Principles

The underlying modelling concept is n-pole approach
[1]. The components are taken as n-poles which interact with their surrounding network part via their n pins.
At each pin the electrical quantities current and voltage
are defined. After the pins are defined the model equa-

Ground

Resitor

Conductor

Capacitor

Inductor

Transformer

Gyrator

VCV

VCC

CCV

CCC

OLine

ULine

ConstantVoltage

RampVoltage

SineVoltage

ConstantCurrent

RampCurrent

SineCurrent

IdealSwitch

IdealCommutingSwitch

IdealOpAmp

IdealDiode

IdealTransformer

IdealGyrator

Idle

Short

Diode

PMOS

NMOS

PNP

NPN

Figure 1: Components of the Modelica package Modelica.Electrical.Analog.

tions (terminal behaviour [13]) can be formulated using
both the pin quantities and additional variables which
are model internal. This is the behavioural description
method. Another method is filling the n-pole by a subcircuit which is composed using other electrical
components. Both methods can be combined.

v = p.v - n.v

p
p.v

n
n.i

p.i

n.v

Figure 4: TwoPin
n-pole

v = p.v - n.v

p
i0(t)

i1(t)

in-1(t)

v0(t)

v1(t)

vn-1(t)

p.v

i = p.i
0 = p.i + n.i

p.i

n.i

n.v

Figure 5: OnePort
p1

p2

Figure 2: Pins and their quantities at an n-pole

v1

p1.i

p1.v

i1

Because of the n-pole concept interfaces are defined.
The basic interface definition is the pin, which is a connector. At the pin the pin voltage v (between pin and
ground node), and the pin current i are defined. The
current is of the flow- type, because the current sum has
to be zero if pins are connected.

n

v2

p2.i p2.v
i2

n1
n1.v

n2
n1.i v1=p1.v - n1.v
v2=p2.v - n2.v
i1=p1.i i2=p2.i
0=p1.i + n1.i
0=p2.i + n2.i

n2.i n2.v

Figure 6: TwoPort
v

i

Figure 3: Pin
The Modelica pin definition is*:
connector Pin
SIunits.Voltage v
"Potential at the pin";
flow SIunits.Current i
"Current flowing into the pin";
end Pin;

Furthermore, positive and negative pins are defined
which differ in their graphical representation only.
Throughout the library there are some often used pin
patterns, which can be extracted to typical interfaces.
These are the TwoPin, the OnePort, and the TwoPort.

*

In this paper the Modelica source code examples use an abbreviated notation of components taken from the Modelica packages Modelica.SIunits and Modelica.Electrical.Analog. The
complete Modelica source code of all examples can be found at
http://www.eas.iis.fhg.de/sim/publications/papers/2000/028/

The TwoPin interface does not contain the current sum
equation as the OnePort interface does. Therefore, the
TwoPin interface is suitable for being filled with other
library components, which guarantee the current sum
equation. e.g. a subcircuit. The OnePort is suitable for
any mathematical v/i characteristic formulation. Another often used Interface is the TwoPort. The interface
definitions are part of the electrical analog Modelica
library.
Using the predefined interface types most of the library
components have the following structure:
• usage of the interface type, sometimes additional
pin declarations
• declaration of parameters
• declaration of internal variables
• equation part (connections or directly formulated)
• comments, annotations, and graphical information
can be added
The Modelica description of the inductor is an example
for a OnePort component definition which does not use
internal variables:

model Inductor
extends OnePort;
parameter SIunits.Inductance L=1;
equation
L*der(i) = v;
end Inductor;

us = if (D.v > S.v) then D.v else S.v;
uds = ud - us;
ubs = if (B.v < us) then 0 else B.v - us;
ugst = (G.v - us - Vt + K2*ubs)*K5;
id = if (ugst >= 0)
then v*uds*1.e-7
else if (ugst < uds)
then -v*uds*(ugst - uds/2 - 1.e-7)
else -v*(ugst*ugst/2 - uds*1.e-7);
G.i = 0;
D.i = if (D.v > S.v) then -id else id;
S.i = if (D.v > S.v) then id else -id;
B.i = 0;
end PMOS;

The description of an ideal diode is a OnePort which
needs an internal variable within the component:
model IdealDiode
extends OnePort;
parameter SIunits.Resistance Roff
(final min=0) = 1.E-5;
parameter SIunits.Conductance Gon
(final min=0) = 1.E-5;
Boolean off(start=true)
"Switching state of diode";
protected
Real s "Auxiliary variable";
equation
off = s < 0;
v = s*(if off then 1 else Roff);
i = s*(if off then Gon else 1);
end IdealDiode;

Independent sources are OnePorts which use timedependent mathematical functions for defining either the
quantity v (voltage sources) or the quantity i (current
sources).
An example for a TwoPort component is the transformer model. It combines the v1, v2, i1, i2 values
defined in the interface model.
model Transformer
extends Analog.Interfaces.TwoPort;
parameter SIunits.Inductance L1=1;
parameter SIunits.Inductance L2=1;
parameter SIunits.Inductance M=1;
equation
v1 = L1*der(i1) + M*der(i2);
v2 = M*der(i1) + L2*der(i2);
end Transformer;

In this manner most of the components are modeled.
Components with other pin patterns are described using the pin connector directly, e.g. in the PMOS model:
model PMOS
Interfaces.Pin D, G, S, B;
parameter SIunits.Length W=50.0e-6;
parameter SIunits.Length L=8.0e-6;
parameter SIunits.Transconductance
Beta=0.0085;
parameter SIunits.Voltage Vt=-0.15;
parameter Real K2=0.41;
parameter Real K5=0.839;
parameter SIunits.Length dW=-3.8e-6;
parameter SIunits.Length dL=-4.0e-6;
protected
Real v, uds, ubs, ugst, ud,us,id;
equation
v = Beta*(W + dW)/(L + dL);
ud = if (D.v > S.v) then S.v else D.v;

3

Usage

The components of the electrical analog library can be
combined to circuits as they are. This is possible on the
ASCII text level, or in a graphical way.
Due to the strict objectoriented language design of Modelica an extended library usage is possible:
• Components can be connected to create new models. In this way, a hierarchical description of large
circuits is possible.
• The components can be modified by changeing the
mathematical description, adding pins, introducing
parameters, fixing parameters, ... Especially the
possibilities of inheritance [2] allow the creation of
own circuit components in a comfortable way.
• Since the description of the library components is
totally public they can be useful as examples for
components which are to be modelled.
The whole variety of the possibilities of the library usage is not presented. It has to be derived from the
language reference manual. Several aspects of the library usage are demonstrated in the examples.

4

Examples

The examples are part of an extensive validation suite.
They are chosen to indicate the variety of circuits that
can be described using the library. Furthermore, the examples show the complexity which was under test until
now. Further tests e.g. with circuits of hundreds of transistors are necessary.
The examples are simulated using the simulator Dymola [12]. Our experience in simulating the examples is:
• Sometimes the tolerance has to be chosen carefully.
• Some examples require the condition of translation
‘Evaluate true’ (e.g. if capacitors are zero).
• most of the simulation problems arose with the
usage of NPN/PNP semiconductor devices.

4.1

Resistor-Capacitor-Circuit

4.2

The simple resistor-capacitor circuit is usually the beginner model for evaluating electrical analog
simulation systems.
R
R=2
Ce

C=10

V=1.5
Gnd

Diodes

The diode example compares a ideal diode with a real
one. Both of the diodes are components of the library.
The real diode (Diode) is a semiconductor device. Its
current/voltage characteristic is an exponential function which is continuated linearly above a certain
exponent which is the parameter Maxexp. The ideal diode (IdealDiode) uses the declarative description
method [1], [8], [9]. If the parameters Roff, and Gon
are zero the ideal diode is an idle running branch in the
open case, and a chort cut in the clodes case. The following simple circuit uses both of the diodes. The
parameter are chosen such that differences in the diode
behaviour can be seen easily.

Figure 7: Simple RC circuit.

D_ideal

R1
R=1000

The following Modelica text shows the circuit description without graphical instructions. The instantiation of
library components can be seen as well as the usage of
parameters. Once instantiated the circuit elements are
connected in the equation part.

D_real

R2
R=1000

V=220

model SimpleCircuit
ConstantVoltage V(V=1.5);
Resistor R(R=2);
Capacitor C(C=10);
Ground Gnd;
equation
connect(V.p, R.p);
connect(R.n, C.p);
connect(V.n, C.n);
connect(V.n, Gnd.p);
end SimpleCircuit;

Gnd

Figure 9: Comparision of real and ideal diode.

R2.v

R1.v

200

The simulation result is the behaviour of voltage and
current of a capacitor which is charged.

ideal diode
real diode
150

1.6

C.v

C.i

1.4

100

1.2

50

1

0.8

0
0.6
0

10

20

30

40

50

60

70

80

90

100

Figure 10: Simulation results of diode example.

0.4

0.2

0

0

20

40

60

80

100

120

140

160

Figure 8: Simulation results

180

200

4.3

MOS Oscillator

Obviously an odd number of inverters within a chain
tends to oscillate. A single inverter is composed by
MOS transistors. It has its own voltage source for power supply, and a capacitor. The Modelica description of
the inverter is:
model Inverter
Pin inn "input pin";
Pin outt "output pin";
RampVoltage VDD
(V=5, duration=50e-9);
PMOS TP
(W=6.5e-6,L=3.1e-6,Beta=1.05e-5,
Vt=1,K2=0.41,K5=0.8385,dW=-2.5e-6,
dL=-2.1e-6);
NMOS TN
(W=4.5e-6, L=2.5e-6,Beta=4.1e-5,
Vt=0.8,K2=1.144,K5=0.7311,
dW=-2.5e-6,dL=-1.5e-6);
Capacitor Ce(C=0.2e-12);
Ground Gnd;

model Oscillator
Inverter I1, I2, I3, I4, I5, I6, I7, I8;
Resistor R(R=0.01);
Idle E1;
Ground Gnd;
equation
connect(R.n,I1.inn);
connect(I1.outt,I2.inn);
connect(I2.outt,I3.inn);
connect(I3.outt,I4.inn);
connect(I4.outt,I5.inn);
connect(I5.outt,I6.inn);
connect(I6.outt,I7.inn);
connect(I7.outt,I8.inn);
connect(I8.outt,E1.p);
connect(E1.n,Gnd.p);
connect(I7.outt,R.p);
end Oscillator;

When the power voltage rises at once the circuit starts
oscillating.
I5.Ce.v

I8.Ce.v

0

5E-8

I1.outt.v

I2.outt.v

I3.outt.v

I4.outt.v

5

equation
connect(inn,TP.G);
connect(inn,TN.G);
connect(VDD.p,TP.D);
connect(TP.S,TN.D);
connect(TP.S,Ce.p);
connect(TN.S, Gnd.p);
connect(Ce.n,Gnd.p);
connect(VDD.n, Gnd.p);
connect(TN.B, Gnd.p);
connect(TP.B,VDD.p);
connect(outt, TP.S);
end Inverter;

4

3

2

1

0

Once the inverter is defined it can be instantiated manifold and connected to a loop. In the following model
seven inverters form a loop including one resistor, the
eighth inverter is attached out of the loop.
I1

I2

I3

I4

1E-7

1.5E-7

2E-7

2.5E-7

Figure 12: Simulation results of Oscillator.

4.4

Operational Amplifier µA741

A PID device amplifies (proportional), integrates, and
differentiates the input signal. As a weighted sum the
three results form the output signal of the device. If the
following circuit scheme is used the Vin voltage is PIDlike treated

R=0.01
R

I8

I7

I6

E1

Gnd

Figure 11: Oscillator.

I5

7
22
18

24

9

23

3
10

11
6
13

2

20

14

12

25

21

14
Dev
15
1

5

17

19

16

4

uA741
Figure 14: PID circuit with Operational amplifier µA741, and ideal PID device

∫

V out = PV in + I V in dt + D

Unfortunately, this ideal PID behaviour requires an ideal operational amplifier in the circuit. If the uA741 [6]
amplifier is used instead of the ideal one the PID behaviour is limited. E.g. if Vout runs into saturation the PID
behaviour does not longer exist. To demonstrate this a
model is simulated which contains both the PID circuit
using the uA741 and a pure mathematical device which
calculates the ideal PID behaviour (fig. 14). In the plot
the point can be seen where ideal and real behaviour
diverge.

dV in
dt

Cd

R2

Ci

C=1

R=1

C=1

Amplifier

R1
R=1

Vin

Vout

2

IdleDev.v

IdleOp.v

VIN.p.v

0

-2

Gnd1

Gnd2

Gnd3

Figure 13: PID

-4

-6

-8

-10

The coefficients P, I, and D can be simply derived to be
R2 C D
P = ------ + ------R1 C I

-12

-14

-16

0

1
I = -----------C I R1
D = C D R2

0.5

1

1.5

2

2.5

Figure 15: Real, and ideal PID behaviour

Figure 16: Cauer filter

4.5

Cauer’s Filter

The switched capacitor [4] Cauer’s filter model [5] is a
low-pass-filter of the order five. It uses voltages sources, capacitors, and voltage controlled voltage sources
of the electrical analog library. To demonstrate a slightly modification of a library component the commuting
switches are extended. At the positive pin a resistor R
is added. The extended switch is called RealComSwitch. Like the ideal switch it has the same pins
p, n1, n2, and control. The symbol is taken from the
ideal switch. Without any graphical information the
Modelica description of the extended switch is:

connect(control, S.control);
end RealSwitch;

Fig. 16 shows Cauer’s filter in a graphical way. As an
example a pulse response is simulated. The small oscillations are caused by the switching clock signal.

Op1.v2

Op5.v2

Op3.v2

0.12

0.1

0.08

0.06

model RealSwitch
Pin p "positive pin";
Pin n1 "negative pin n1";
Pin n2 "negative pin n2";
Pin control "control pin";
Resistor R(R=0.01) "additional resistor";
ControlledIdealCommutingSwitch
S(level=2.5);
equation
connect(p, R.p);
connect(R.n, S.p);
connect(n1, S.n1);
connect(n2, S.n2);

0.04

0.02

0

-0.02

-0.04

0

2E4

4E4

6E4

8E4

1E5

1.2E5

1.4E5

1.6E5

Figure 17: Pulse response

1.8E5

2E5

4.6

Chua’s circuit
L

Ge

L=0.018

G=530e-6

Nr

equation
i=if(v<-Ve) then Gb*(v+Ve)-Ga*Ve
else if(v>Ve) then Gb*(v-Ve)+Ga * Ve
else Ga*v;
end ChuasDiode;

C=1.e-8

C1

C=1.e-7

C2

Ro

R=12.5

Once defined Chua’s Diode can be used in the circuit.
The Modelica description of the circuit without graphical information is:
model ChuaCircuit
Inductor L(L=0.018);
Resistor Ro(R=12.5);
Conductor Ge(G=565e-6);
Capacitor C1(C=1.e-8, v(start=4.0));
Capacitor C2(C=1.e-7);
ChuasDiode Nr(Ga=-757.576e-6,
Gb=-409.091e-6, Ve=1);
Ground Gnd;

Gnd

Figure 18: Chua ...
If the initial values of the capacitors of Chua’s Circuit
[3] are not zero the node voltages at the conductor show
chaotic behaviour. The only nonlinear component in
the circuit which causes the chaos is Chua’s Diode. It is
a one-port. Its characteristic can be seen in the following picture:

equation
connect(Ro.n,Gnd.p);
connect(Ro.p,L.n);
connect(L.p,Ge.p);
connect(Ge.n,Nr.p);
connect(Nr.n,Gnd.p);
connect(C1.p,Ge.n);
connect(C1.n,Gnd.p);
connect(C2.p,Ge.p);
connect(C2.n,Gnd.p);
end ChuaCircuit;

Slope Gb

The simulation result (until t=0.05) shows the typical
behaviour:
Slope Ga
5

Slope Gb

ChuaCircuit1.C1.v(ChuaCircuit1.C2.v)

4

3

-Ve

Ve
2

Figure 19: i(v)-characteristic of Chua’s Diode

1

0

The characteristic depends on the parameters Ga, Gb,
and Ve. Because of its originality this component,
which is not part of the electrical analog library, is not
derived from a library component. But it uses the definition of a OnePort. Therefore, the branch quantities v
and i are predefined. The following Modelica text describes Chua’s Diode:
model ChuasDiode
extends OnePort;
parameter SIunits.Conductance Ga;
parameter SIunits.Conductance Gb;
parameter SIunits.Voltage Ve;

-1

-2

-3

-4
-1

-0.8

-0.6

-0.4

-0.2

0

0.2

0.4

0.6

0.8

Figure 20: Simulation results of Chua circuit.

5

Conclusion

Once the library exists some improvements become
more and more necessary:
• multidomain components like converters (electric-

•
•

mechanic, electric-magnetic)
a library part of precomposed circuits (e.g. integrators, operational amplifiers, gates (AND, NOR) ...)
the SPICE library, and a compiler which converts
spice netlists into a Modelica description

To come to a SPICE library the most desirable way is
formulating the SPICE components in Modelica. Because of the complexity of most of the SPICE
semiconductor devices this way seems to be very timeconsuming. At the moment we would prefer using the
foreign function call possibility to provide the SPICE
components in the form of C language code.

6

References

[1]

Clauß, C.; Haase, J.; Kurth, G.; Schwarz, P.:
Extended Amittance Description of Nonlinear
n-Poles. Archiv für Elektronik u. Übertragungstechnik 49(1995)2, 91-97
Clauß, Chr.; Leitner, Th.; Schneider, A.;
Schwarz, P.: Object-oriented modeling of physical systems with Modelica using design patterns. Workshop on System Design Automation
SDA 2000, Rathen, March 13-14, 2000, 209216
Kennedy, M.P.: Three Steps to Chaos - Part I:
Evolution. IEEE Transactions on CAS-I
40(1993) 10, 640-656
de Man, H.; Arnout, G.;Vandevalle, J.: Practical Implementation of a General Computer
Aided Design Technique for Switched Capacitor Circuits. IEEE Journal Solid-State Circuits
SC15(1980)2, 190-200
Fehlauer, E.; Krauß, M.: Ein effektiver Algorithmus zur Zeitbereichsanalyse von SCOVSchaltungen. Wiss. Z. Techn. Univers. Dresden
35(1986)H.4, 159-163
Herpy, M.: Analoge integrierte Schaltungen.
Akadémiai Kiadó. Budapest 1976
Leitner, Th.: A new approach for semiconductor models basing on SPICE model equations.
Proc. ECS’97, Bratislava, Slovakia, 4./5. Sept.
1997, 119-123
Otter, M.; Elmqvist, H.; Mattsson, S.E.: Hybrid
modeling in Modelica based on the synchronous data flow principle. CACSD’99, Aug. 22.26. Aug., Hawaii, 1999
Otter, M.; Elmqvist, H.; Mattsson, S.E.: Objektorientierte Modellierung physikalischer Systeme, Teil 8. at Automatisierungstechnik
47(1999)9
Normen über graphische Symbole für die Elektrotechnik, Schaltzeichen. DIN-Taschenbuch
514, Beuth Berlin, Wien, Zürich, 1994

[2]

[3]

[4]

[5]

[6]
[7]

[8]

[9]

[10]

[11]

[12]
[13]

[14]

Johnson, B.; Quarles, T.; Newton, A.R.; Pederson, D.O.; Sangiovanni-Vincentelli, A.:SPICE3
Version 3e, User’s Manual., Univ. of California, Berkeley, Ca., 94720, 1991
Dymola: http:/www.Dynasim.se
Reibiger, A.: On the terminal behaviour of networks. Proc. ECCTD ’85, Prague, Sept. 1985,
224-227
Elmqvist, H. et al.: Modelica - A Unified
Object-Oriented Language for Physical Systems Modeling. Version 1.3, December 1999.
http://www.Modelica.org

66RHMLPD
([DPSOHVRIXVDJHDQGVSUHDGRI'\PROD
ZLWKLQ7R\RWD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Examples of usage and the spread of Dymola within Toyota
Shinichi Soejima
Toyota Motor Corporation
ABSTRACT
This paper describes some usage examples of Dymola within Toyota.
Dymola has been used in many divisions, including Engine, Drivetrain,
and Chassis. In the Drivetrain division, acceleration performance and
noise vibration are being evaluated. In the Engine division, we have
constructed an Engine library for Diesel Engine Control. Using the
model, we have analyzed behavior of mass flow, pressure, and
temperature in all parts of the engine.

In addition evaluation of a

designed control system was done.
Finally, some improvements that we would like to see in Dymola are
stated.

1. Introduction
In the automotive industry, as performance is
improved, the system within the car becomes
more complicated. Because of this, new
development process is required because it
takes too much effort using the conventional
development process. To improve system
performance and reduce development time,
simulation, derived from a physically based
model, is a very important technique.
Therefore, various simulation models and
tools have been used in Toyota.
In controls filed, model based controller
design has been used recently. When we
design a control system, a model which
expresses the physical phenomenon correctly
is required. A useful simulation tool which
includes these models is indispensable.
Dymola has many standard libraries, and
good model reusability. It’s convenient for
modeling. Dymola is one of the various
simulation tools that have been used to
reduce development time at Toyota.

2. Position
of
Dymola
Development Process

in

Dymola has been used in many phases in the
development process.

When we designed

vehicle drivetrain specifications, simulation
analysis results were used.

To construct the

drivetrain models, we have been mainly used
Dymola.

For a simulation package, it is

important that it is easy to construct models.
It is also important that a model once built is
able to be easily re-used.

Therefore,

Dymola is convenient because it has a
drivetrain library, and if the library doesn’t
contain a model which we need, we can make
the necessary model easily.
In the design process of a control system,
model based controller design has attracted
much attention, and is being applied in many
controller designs.

Figure 1 shows the

typical development process when we design

a model based controller. Dymola has been

included in the logic.

used in some of the steps in this process. At

(System Validation) we evaluate the entire

the 1st step (Modeling) we made a model for

ECU system which includes the gain adjusted

controller design from physical equations,

control logic downloaded to it.

and experimental data.

evaluation, we use a Hardware In the Loop

It is required that a

In the final step

In that

model developed to evaluate the performance

Simulation or HILS.

of a controller be simple and accurate to a

model which can be calculated in real time.

certain extent.

In this step, making a model

That model was being constructed in

easily and quickly is required, so Dymola is

Simulink until now, but recently increasingly

used here.

models

constructed

HILS requires a plant

in

Dymola

and

transferred to an S-function are being used.

Modeling

We think that this is a natural change,
because models which are coded in Dymola

Logic Design

are increasing.
In this way, the use of Dymola has been

Coding

becoming increasing recently.
Verification

3. Usage of Dymola
System Calibration
System Validation
Figure 1: Model based process

In the 2nd step (Logic Design) we design a
controller in simulink, and evaluate the
performance of the controller on a PC.

Dymola is used mainly in the drivetrain and
engine divisions.
3.1 Drivetrain Division
In the drivetrain field, Dymola has been used
for analyzing the vehicle acceleration, shock,
and noise vibration performance, and fuel
economy.
Engine

The

control logic is coded in simulink, because
MATLAB/SIMULINK

has

powerful

functions useful in the design of a controller.
In this step, we evaluate the control logic in a
closed loop with the model which is made in
the 1st step.

In the 3rd step (Coding) the

control logic is encoded in C to put in an
ECU.

In the 4th step

(Verification) we

evaluate the C code to make sure it free of
bugs.

In the 5th step (System Calibration)

we adjust parameters and gains which are

Vehicle Body

Tire

Figure 2: Drivetrain model

Figure 2 shows one of the drivetrain models
we have used. This model includes an
engine, clutch, manual transmission, crank
shaft, driveshaft, tire, and vehicle body. The
engine, clutch, and tire models were
constructed by Toyota. The engine model
calculates the cyclic torque. To evaluate

noise vibration, an accurate engine torque is
required. Therefore, the torque is calculated
from the cylinder pressure which was
measured in an actual engine. The tire
model calculates a longitudinal force using
the slip ratio which is calculated from wheel
speed and vehicle speed. The acceleration,
shock and noise vibration performance is
evaluated using this Dymola simulation.
The information obtained from this
evaluation is fedback into the design of
vehicle specification.
Dymola has also been used in a closed loop
fashion. The amount of fuel injected into
the engine is obtained from a simulink model
of the engine control logic. The amount of
fuel is then used to calculate the output
torque of the engine and this is input to the
drivetrain model in Dymola. (See Figure 3.)
In this case, at first we made the drivetrain
model using Dymola, and then translated it to
an S-function to use in Simulink. Then, we
combined that drivetrain model with the
engine control logic which was coded in
simulink. We made the plant model in
Dymola because it was easier to use than
simulink.
Drivetrain model
(S-function Transferred from Dymola)

(simulated on Simulink)
Engine Control Logic
(coded in Simulink)

Figure 3: Engine controller-drivetrain model

3.2 Engine
Dymola has a many standard libraries, but
regrettably, there is no engine library. To
improve the accuracy of engine control, and
to reduce development time, model based

controller design is extensively used. We
have constructed an engine model for the
purpose of analyzing certain engine
phenomena, and for deciding the appropriate
model to use within the engine control logic.
Figure 4 shows a diesel engine model.
atmosphere

Turbin shaft
compressor

VGT
EGR valve

Intake manifold

Exhaust
manifold

cylinder

Figure 4: Diesel Engine Model

The engine model was built by bringing
together smaller models representing each
part of the engine (Intake manifold,
Compressor, Cylinder etc). Each engine
part model is registered in a library. These
models were built using Mean Value Engine
Model[1][2], therefore oscillation of torque or
cylinder pressure is not calculated. The
conservation of energy, mass, and degrees of
freedom are used to derive the model.
Figure 4 shows an engine with a Variable
Geometry Turbo or VGT, and an Exhaust
Gas Recirculation system or EGR.
The EGR system reduces nitrogen oxide
(NOx) by recirculating exhaust gases back to
the intake manifold. The VGT system
increases the exhaust pressure by restricting
the flow of burned gas using vanes installed
at the entrance. To achieve low emission
levels, it is important that we control the
VGT and EGR correctly. But the intake
manifold pressure and fresh air/EGR gas
flow into the engine is influenced by the
VGT and EGR simultaneously.
It is
required that a controller calculates each

3.3 HILS
We are increasingly using S-function models
which have been constructed in Dymola.
One particular area of use is HILS. In this
case, the model is calculated in fixed
calculation step, and the calculation speed is
very important. Up to now, we have built
the model in simulink considering the
calculation speed. We want to be able to put
a model which was made using Dymola into
a HILS system.
In HILS, using a fixed calculation step
creates some problems. When we use the
equation(1) to solve an air mass flow by in a
simulation, when the up stream pressure( p1 )
and down stream( p2 ) are nearly equal, the
ratio p2 / p1 goes to 1, and the slope of
dm& / dp becomes infinite. Because of this, the

mass flow and the up and down stream
pressure calculated by the equation oscillate
(see figure5.). This is a typical problem in a
fixed step solver.
m& = CA 2 p1 ρ1 Φ


2
κ +1 

 κ  p2  κ  p2  κ 




−




 p 
 1
 κ − 1  p1 

Φ=



1

κ
 2  κ − 1
 κ + 1 
κ +1


(1)
κ
 p   2  κ −1
if  2  > 

 p1   κ + 1 

if 



κ

p2
p1

  2  κ −1
 <
  κ + 1 


Pressure [kPa]

To solve problem, we can set the sampling
time short, but in a real time simulator, we
don’t have this freedom to shorten the
sampling time. Therefore, we have coped
with this problem by changing the model.
So, we end up with two models: one for
HILS use and one for evaluation of the
control logic.
p1
p2

Mass flow [kg/s]

effect while the controller controls these
actuators.
This is a very complex
phenomenon, and many papers[3] have
published using a model based approach to
the controller design. We have been using
model to design our control logic.
We want to use this engine library for other
engine types (other than diesel with VGT and
EGR). There are many engine type which
we would like to simulate. With Dymola, it
is very easy to change a model configuration,
we could make an engine model without the
VGT or without the EGR system easily, by
just removing the VGT or the EGR, and
joining the lines.

Time [sec]

Figure 5: Fixed calculation step problem

4. Improvement requests of Toyota
As this paper has described, the usage of
Dymola is increasing within Toyota. We
have asked the Dymola users within Toyota,
“What would you like to see as an
improvement in Dymola?”. From this, we
think that the most important request
concerns the calculation time in simulink
when we use a model which was coded in
Dymola and then transferred to an S-function.
This problem is as follows. When we
perform a simulation with a model in Dymola,
the calculation speed is very fast. But,
when we transfer the model to an S-function,
and perform the same simulation in simulink,
it takes much longer. We have heard that
this is caused by the solver performance of
simulink, and it is difficult to shorten the
calculation time. In simulink, when the
simulation calculation time is long or the
simulation gives up, it is fairly easy to change
the way the simulation is written to get
around this problem. Unfortunately, when a

model is written using the standard Dymola
libraries, it is not so easy to change how the
model is written. Therefore, in Dymola
when the simulation calculation time is long,
we have no recourse action. Because of this,
we feel it is very important to ensure that the
simulation time is as short as possible in
Dymola.
Other improvements we would like to see are
in the user interface. We would like to
make below things more user friendly.
(1) Plot window (Graph).
(2) Edit Window (Editor).

5. Modelica within Toyota
In Toyota, almost all Dymola users use the
Dymola language, and they admit that
Dymola is an excellent simulation tool.
Regrettably,

we

don’t

understand

the

advantage of the Modelica language at
present.

We want to watch what happens

with Modelica, and then ascertain when to
change to Modelica language.

6. Conclusion
In this paper, examples of usage of Dymola
were presented.
Within Toyota in the
drivetrain and engine division, Dymola has
been used in many phases: design of vehicle
specification, design of control logic, HILS

in the step of system validation. In these
divisions, Dymola is thought in the
development phase of a necessary and
indispensable tool.
Finally, some desired improvements were
stated. We are hoping that Dymola will be
come a more convenient and useful
simulation tool to fit our user needs, and that
development time can be further reduced by
using Dymola.

References
[1] Hendricks, E., and Sorenson, S. C.,
“Mean Value Modelling of Spark Ignition
Engines”,SAE Technical Paper No.960616
[2] Hendricks, E., Chevalier, A., Jensen, M.,
and Sorenson, S. C., “Modelling of the Intake
Manifold Filling Dynamics”,SAE Technical
Paper No.960037
[3] M. J. van Nieuwstadt, I.V. Kolmanovsky
and P. E. Moraal, “Coordinated EGT-VGT
Control for Diesel Engines: an Experimental
Comparison”, SAE Technical Paper 2000-010266

:'6WHLQPDQQ37UHIILQJHU
6LPXODWLRQRI)XHO&HOO3RZHUHG'ULYH7UDLQV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Simulation of Fuel Cell Powered Drive Trains
Modelica Workshop 2000, 23-24 October 2000, Lund

W.D. Steinmann, P. Treffinger
German Aerospace Center (DLR)
Institute of Technical Thermodynamics
Pfaffenwaldring 38-40, D-70569 Stuttgart
wolf.steinmann@dlr.de

Abstract
DLR is working on fuel cells and their application,
whereby the interest in the mobile application of
fuel cells is constantly increasing. The design of
fuel cell systems is a multi-disciplinary task. It
requires knowledge in electrochemistry, thermoand fluid dynamics, electrical science and control.
In the design of fuel cells systems for the energy
supply of car engines, additional aspects have to be
considered. Tools to optimise fuel cell systems
should, therefore, be capable to link knowledge
from several disciplines.
Consequently, DLR is currently developing a
suitable design tool for fuel cell systems with
respect to various applications. The presentation
explains our approach of a physical model of a fuel
cell and its implementation by Modelica. Some
exemplary results highlight the application of the
model.

fuel cells. DLR is working on the high temperature
Solid Oxide Fuel Cell (SOFC) and on the low
temperature
Polymer Electrolyte Fuel Cell
(PEFC). The operating temperatures are around
800 C and around 80 C. Generally the PEFC is
considered as the most promising type of fuel cell
for power trains. Actually hydrogen is used as a
fuel for the PEFC. The following paper deals with
the PEFC.

Introduction
Recently German Aerospace Center (DLR) has
initiated a new business division transport. The aim
is to focus, strengthen and extent a number of
already existing research activities within this
sector. Among them are the research on transport
systems e.g. analysis of the structure of transport
systems, whereby DLR uses models developed for
the analysis of air traffic. Other fields are the
application of adaptronics and telematic in vehicle
technology or use of advanced light weight
materials for vehicle construction. It is well known
that the transport sector contributes increasingly to
the CO2 – emissions. Therefore hybrid and fuel
cell vehicles are discussed in order to reduce these
emissions. A number of car manufacturers are
currently developing fuel cell powered vehicle.
DLR has performed research in fuel cells for space
and stationary application for a number of years. A
part of these capacities has been put into the
transport division. There exist different types of

Fig.1: Membrane Fuel Cell Test Facility PEMA at
DLR Institute of Technical Thermodynamics

The design of fuel cell systems is a multidisciplinary task. The fuel cell itself is an
electrochemical energy converter. The detailed
modeling of an fuel cell requires knowledge e.g. in
electrochemistry, heat and mass transfer,
multiphase thermodynamics, fluid dynamics. A
fuel cell system consists of several sub systems:
- fuel cell
- air supply system
- fuel supply system = hydrogen supply system
- cooling system (heat and water management)
- control system
The air supply system has to deliver the oxidant
usually oxygen to the fuel cell. It consists of
blowers, fans valves and pipes. The fuel supply
system could be a tank where the hydrogen is

brake
Drive
cycle

Vehicle
control
unit

Driver

Fuel cell
energy
supply

„gas“

Drive
train

Aux.
FC

Aux.

Car

mech. connection
electr. connection
signal connection

Fig. 2: Basic structure of the highest level of the
fuel cell system model.

Fig.3: Model for the fuel cell energy supply

system

As shown in Fig. 2 a driver compares the actual
velocity of a car with the velocity of a certain drive
cycle. The comparison results into an acceleration
request to the vehicle control unit. The vehicle
control unit contains strategies to fulfil the
acceleration request with respect to the state of the
energy supply system. This results into control
signals for the mechanical brake and the drive
train. Concerning the fuel cell activities, the main
interest of DLR is the fuel cell energy supply
system [Fig.3]. The modeling of the fuel cell
system, mainly the fuel cell itself, is subject of this
paper.
Some exemplary results are shown. Fig. 4 shows
the results for the single fuel cell voltage (which is
proportional to the thermal efficiency) in
dependance of the current density for different air
ratios. A higher air mass flow at the cathode of the
0,80

λO2 = 2,5

0,75

λO2 = 2,0

0,70

λO2 = 1,5

0,65

λO2 = 1,2

0,60

U / Volt

stored and some pressure reducing and control
valves reducing the pressure respectively metering
the hydrogenl to the fuel cell. Actually there exists
no satisfying solution for the storage of hydrogen.
Pressure tanks are bulky and heavy, which yield to
limited ranges. The production of liquified
hydrogen requires a significant amount of energy,
furthermore the highly insulated storage tanks are
very costly. An alternative is the on-board
production of hydrogen by a reformers splitting a
hydrogen rich hydrocarbon like methanol. Such
reformer are chemical reactors which are followed
by apparatus to purify the reformer gas in order To
achieve sufficiently high reformer efficiencies
often internal heat recovery is a must. To date the
reformer is still a crucial sub system with respect
to the dynamic operation of the fuel cell system.
Having said this it is understandable why tools
from chemical engineering like Aspen Speedup or
other are used for the design and development of
fuel cell systems. Having in mind that the current
R&D in fuel cells yields to a steadily increasing
knowledge base and also that the fuel cell system
should be analysed with respect to the application
in part load and transient operation, which
especially the case for fuel cell powered drive
trains, DLR has chosen MODELICA as a
simulation tool for fuel cell systems.

0,55
0,50
0,45
0,40
0,35
0,30
0

2000

4000

6000

8000

10000

12000

14000

2

I / (A / m )

Fig. 4: Modelling effect of air ratio on single
cell performance

16000

fuel cells leads to a higher efficiency of the single
fuel cell.
The necessity of simulating the complete system
becomes obvious in Fig. 5: here, the efficiency of
the complete system is calculated. In contrast to
Fig.4, due to the parasitics of the compressor, the
efficiency of the complete system is not best with
the highest air mass flow.

can be attributed to different mechanisms: at low
current densities, the cell voltage is mainly reduced
by the cathodic reaction. Mass transport limitations
become dominant at high current densities. The
voltage losses are increased by the resistance of the
membrane. This resistance is not constant but
dependent on the water content of the membrane.
This demands an appropriate water managment of
the fuel cell. The aim of the numerical simulation
is not only the calculation of the electrical power
produced by the fuel cell, but also the computation
of the water and heat balance.

0,60
0,55

ηΒΖ

0,50

λO 2 =2,5

ηBZ , ηSystem

0,45

λO 2 =1,5
λO 2 =1,2

0,40

ηSystem

0,35

λO 2 =1,5

0,30

λO 2 =2,5
0,25

λO 2 =1,2

0,20
0

2000

4000

6000

8000

10000

12000

14000

16000

2

I / (A / m )

Fig. 5: Effect of air ratio on system performance and
single cell efficiency.

Basic Fuel Cell Model
A fuel cell is an electrochemical device that
converts the chemical energy of a fuel to electrical
energy without the Carnot cycle limitation of heat
engines. The fuel and the oxidant are supplied
continously to the fuel cell. A fuel cell is composed
of an anode, where the fuel is oxidized and a
cathode, where the oxidant is reduced. The two
electrodes are seperated by the electrolyte, an ionic
conductor. Solid polymer fuel cells(PEFC) use a
solid polymer membrane as ionic conductor. The
membrane is sandwiched between two porous
electrodes. This makes the PEFC a robust fuel cell
with simple design. With hydrogen as fuel and air
as oxidant, a single PEFC reaches a voltage of
about 0,7V. In order to provide higher voltages,
singles cells are connected in series to form a fuel
cell stack. The performance of a PEFC is
characterized by the polarization curve showing
the relationship between cell voltage and current
density. The cell voltage is proportional to the
thermal efficiency. Voltage losses (overvoltages)

Physical Model
Both electrodes of the fuel cell are seperated into
three different sections. The reactant gases flow in
gas channels along the backside of the electrodes.
A certain amount of the gases enters the porous
electrode and diffuses to the catalyst layer adjacent
to the membrane. At the catalyst-membrane-gas
interface the electrochemical reaction takes place.
The ions produced at the anode migrate through
the membrane to the cathode .
The structure of the system always remains the
same, the reason for using a modular modeling
strategy is the ability to exchange submodels in an
efficient way. This is necessary since the
knowledge about the physical processes taking
place in the fuel cell is in an early stage. As a
result, different kinds of fuel cell models with a
large variation in complexity are described in
literature [e.g. 1-4]. The main aim of the modular
modelling of the fuel cell is the development of an
efficient engineering model by identifying the key
mechanisms in the fuel cell.
Modelica Implementation
The basic structure of the fuel cell consists of the
membrane-module that is connected to the anode on one
side and to the cathode on the other side. Three models
representing the reaction layer, the diffusion layer and
the gas channel are connected in series to simulate the
electrodes [Fig. 6]. In this paper we present the most
basic fuel cell model.

Layers of the fuel cell model
Except for the reaction-layers, each of the seven
layers of the model contains an ohmic resistor
elresistplusq and an element heatconduct
representing the thermal conduction in the layer.
Due to the Joule heating the ohmic resistor
represents a heat source that is connected to
thermal conduction element [Fig.7].

Fig.6: Schematic of the basic fuel cell model.

Connectors
In addition to the connectors used for heat transfer and
electrical current, connectors for the different reactants
are needed. Since the reactants are humified before
entering the fuel cell, connectors for multicomponent
mass flow are used. For humified hydrogen fed to the
gas-channel of the anode the connector contains the
molar flow mdot, the total pressure p, the specific
enthalpy h and the molar concentration x[1] of hydrogen
and x[2] of water. The corresponding connector for
humified air at the cathode includes the mdot, p, h and
the molar concentration of nitrogen x[1], oxygen x[2]
and water x[3]. Between the different layers of the fuel
cell, the components must be treated seperately, so there
are also connectors for dry oxygen, dry hydrogen, dry
nitrogen and water. All these connectors contain the
variables mdot, p, h but are defined as seperate models
to prevent connections between different species.

Physical properties of reactants
A library properties contains packages with the
state equations of the different substances.
Hydrogen, oxygen and nitrogen are treated as ideal
gases. A partial model idealgaslaw with the
functional relation between temperature, pressure
and density serves as parent class for these gases.
Water can occur both in liquid and gaseous state
and plays an important role in heat and mass
transfer. The package water contains functions
with the saturation values of pressure, enthalpy and
density. The algorithms used for the description of
the relation between the state variables usually
contain polynoms. The integration of these
polynoms in acausal models proved to be difficult:
although the isolated models worked, more
complex system didn’t converge. Instead of the
models, functions are used to describe the relations
between the state variables.

Fig. 7: Basic layer model.

Gas channels
The model for the gaschannel is anodchannel on
the anode side and cathchannel on the cathode
side. The model cathchannel is shown in Fig. 8.
The connector for the inflowing humified air is
connected to the model cathjunction where the air
is seperated into its components. The seperation of

Fig. 8: Model cathchannel for the gas
channel of the cathode

the air is necessary since the cathodic reaction
consumes oxygen while water can flow in both
directions at the interface between gas-channel and
diffusion layer depending on the current density.
Nitrogen is an inert component at the cathode. At
the exit of gas-channel the different components
are combined to leave the fuel cell in an wet air
connector.
Diffusion layers
The reactants flow through the diffusion layer to or
from the reaction zone of the electrode. An example for
the range of complexity of physical models describing
the processes in the fuel cell can be shown with the
diffusion layer of the cathode. The most simple
assumption is, that there is no loss in pressure of the
oxygen. In this case, the model is reduced to the base
model of a layer, the inlet connectors for the different
gases are connected to the outlet connectors. The more
complex model (Dusty-gas-model [5]) considers
different kinds of transport mechanisms in the porous
diffusion layer: the mass flow is regarded as
combination of molecular diffusion, Knudsen diffusion
and convective flow due to a pressure gradient. The
Dusty-gas-model can be regarded as combination of
different transport resistances [Fig.9].

Fig. 9: Dusty-gas model for diffusion in porous
media

In Modelica, for each of these three transport
mechanism a partial model was created. These
partial models were then completed by the
transport-properties of the different gases. Finally,
the models are connected according to the Dustygas-model. Calculations show, that the difference
between the results of a fuel-cell model with the
most simple model and the results of a fuel cell
model with the Dusty-gas-model grow with the
current-density. High current densities usually
occur at low cell-voltages indicating low thermal
efficencies. For automotive applications, the
current range where transport limitations become
significant should be avoided since the efficiency
of the fuel cell is not sufficient. For most

Fig. 10: Diffusion layer model with Dusty-gas
model dgmcathode1

Fig.11: Dusty-gas model of the cathodic
diffusion layer dgmcathode1.

automotive applications, simulation models with
simple transport models provide results that don’t
differ much from results calculated with more
sophisticated models.

Reaction layers
The electrochemical reaction takes place in the
interfaces between the membrane and the elctrodes

Fig. 12: Reaction layer of the cathode

The model h2reaction calculates the consumption
of hydrogen and the heat produced by the splitting
of the hydrogen molecules into ions. At the
cathode, the model o2reaction determines the
consumption of oxygen and the heat produced by
the reaction. In contrast to the anode, significant
voltage losses result from the reaction. These
losses are dependant on current density, oxygen
pressure and temperature.

memresistor for calculating the ohmic resistance in
dependance of a parameter defining the wetness of
the membrane. Due to electroosmose water flows
from the anode to the cathode. This drag is
calculated in the model waterdrag. There is also
diffusion of water through the membrane due to
the concentration gradient of water betweeen the
both sides of the membrane. This flow is
calculated with the model memdiff.
Conclusion
Modelica is applied to simulate transport systems
using fuel cells. The modularity of Modelica
supports the identification of the most efficient
configuration of the basic components needed for a
fuel cell system. The basic Modelica fuel cell model
presented here is the starting point for the
comparison of different physical models describing
the processes in a fuel cell. The extension of the fuel
cell library will continue with the aim of creating a
efficient tool for the design of fuel-cell system.

Literature
[1]

BERNARDI, D.M.; VERBRUGGE, M.W.
A Mathematical Model of the SolidPolymer-Electrolyte Fuel Cell
J. Electrochem. Soc. 139(1992)9, p.24772491

[2]

AMPHLETT, J.C. ET AL.
Performance Modeling of the Ballard Mark
IV Solid Polymer Electrolyte Fuel Cell
J. Electrochem. Soc. 142(1995)1, p. 1-8

[3]

FULLER, T,F; NEUMAN, J.
Water and Thermal Management in SolidPolymer-Electrolyte Fuel Cells
J. Electrochem. Soc. 140(1993)5, p. 12181225

[4]

SPRINGER, T.E.; WILSON, M.S.;
GOTTESFELD, S.
Polymer Electrolyte Fuel Cell Model
J. Electrochem. Soc. 138(1991)8, p. 23342342

[5]

KEIL, F.
Diffusion und chemische Reaktionen in der
Gas/Feststoff-Katalyse
Springer-Verlag
Berlin Heidelberg 1999

Membrane model

Fig. 13: Model of the polymer membrane

The ohmic resistance of the membrane is the most
significant one in the fuel cell. The conductivity of
the membrane depends on the wetness of the
polymer. The model membrane contains the model

07LOOHU3%RZOHV
'HWDLOHG9HKLFOH3RZHUWUDLQ0RGHOLQJLQ0RGHOLFD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Detailed Vehicle Powertrain Modeling in Modelica
Michael Tiller and Paul Bowles
Ford Motor Company, USA
Hilding Elmqvist, Dag Brück, Sven Erik Mattson, Andreas Möller and Hans Olsson
Dynasim AB, Sweden
Martin Otter
German Aerospace Research Establishment (DLR), Germany

Abstract
This paper describes of a detailed vehicle model in
Modelica, consisting of the 3D vehicle chassis, engine, automatic gearbox and hydraulics to control the
gearbox. Furthermore, simulations of these models
were done using Dymola. Emphasis is given to the
engine modeling, because it required many new Modelica components to be developed. This feasibility
study shows that it is possible to use Modelica for large
models assembled from complex structured subsystem
models.

1

Introduction

The work presented in this paper was done to evaluate the capability of the Modelica [2, 8] modeling language and Dymola [7] for modeling and simulation
of complex automotive systems. There were three aspects to this evaluation. The first aspect was whether
existing models, with very complex behavioral descriptions, could be expressed using the Modelica language. The second aspect was how reusable these
models could be made. Finally, the last aspect of the
evaluation was to determine if the Modelica approach
would scale well for very large problems.
Initially, the model development started with the
development of mechanical models for the engine and
soon included gas properties and combustion models.
Several tests were conducted to validate the behavior
of both motoring (no combustion) and firing engines.
The next stage in the project was to develop a
mechanical transmission model. The development of
this model was greatly facilitated by the existence of
the Modelica standard library’s 1D rotational package.
Once a mechanical model of the transmission had been

constructed, the hydraulic subsystem was realized.
In order to study the powertrain system it was necessary to create a model of the vehicle chassis. The
Modelica multi-body systems library [3] contains a
collection of 3-dimensional mechanical components
from which a complete vehicle chassis model can be
created. However, creation of a complex vehicle chassis model by hand would be a tedious and error prone
task. A model of the vehicle chassis was already available in ADAMS [1]. For this reason, an ADAMS
translator was developed which automatically translates ADAMS models into Modelica representations
which use the Modelica MBS library.
Finally, the reusability and scalability of the Modelica language and the Dymola environment [7] were
tested by integrating various combinations of the engine, transmission, transmission hydraulics and chassis.
This work benefited greatly from the domainneutral nature of the Modelica language as well as the
extensive set of available components in the Modelica
Standard Library. The significance of both of these
factors will be very important in the success of the
Modelica modeling language in industrial engineering
applications.
The emphasis in this paper is on the development
of the engine models because most of those models
needed were not already available and had to be developed. More details about the results and validation of
the transmission and chassis work can be found in [6].
Additional background information is available for the
rotational library [4], hydraulics library [5] and multibody components [3].

2 Engine Models

across such a connector. Representing momentum is
important when modeling other engine processes (e.g.,
2.1 Background
manifold dynamics).
When formulating the connector definitions, it
The first system modeled was a multi-cylinder internal
is
sometimes
necessary to consider implications to
combustion engine. The focus of such a model is to
the underlying medium models (see Section 2.3.3 for
capture the behavior of the thermodynamic effects inmore details).
side the cylinder. The models presented in this section
are referred to as cycle simulation models [9]. This
means that they are capable of representing the tran- 2.3 Thermodynamic Components
sient response of the engine. In contrast, ”cycle aver- 2.3.1 Thermodynamic State
aged” models predict the nominal, steady-state torque
At the heart of the thermodynamic models is the applioutput of an engine.
In order to model the engine, the connector defini- cation of the first law of thermodynamics. Typically,
tions and the underlying behavioral models had to be the first law for a control volume is represented by an
developed from scratch. Initially, there were not many equation of the form:
models available which could be used in building a
dV
dU
model of an engine. However, once the fundamen= ∑ ṁi hi + Q , P
(1)
dt
dt
i
tal models were developed a wide variety of systems
could be built by reusing fundamental ones.
where U is the total energy within the control volume,

2.2

ṁi is the mass flow rate into the control volume via the
ith path, hi is the specific enthalpy of the fluid into the
control volume via the ith path, Q is the net heat into
the control volume, P is the pressure of the control
volume and V is the volume of the control volume.
The other conservation law that is used is conservation of mass which can be written as:

Connector

The first step in building up thermodynamic models
for the engine was to decide on the connector definition. One of the very useful features of the Modelica
language is the fact that a connector can have multiple
through and across variables. For thermodynamic systems, the state of the working fluid is represented by
dmt
= ∑ ṁi
(2)
pressure and temperature. In addition, the composition
dt
i
(i.e., chemical mixture) of the working fluid is represented by a vector containing the mass fractions of the where mt is the total mass within the control volume.
various species. In addition, each connection repre- This conservation law can in turn be applied to each of
sents a path for energy and mass (both total mass and the chemical species present which yields:
mass of a particular chemical species) to move through
dmc
c
the system. Taking all of these issues into account, the
= ∑ ṁi
(3)
dt
i
following connector definition was formulated:
which can be applied for each chemical species (represented by the superscript c).
In addition to the first law, there are several constitutive relationships used in the thermodynamic models. For example, the ideal gas law is used to express
the relationship between the temperature in a control
volume and the pressure of the control volume (for a
given mass and volume). Other important phenomena
(e.g., flow through the valves) have their own constitutive relations. All of these are straightforward to implement in Modelica because these are represented by
straighforward equations.
There are several modeling issues that appear in the
thermodynamic domain that are uncommon in other

connector Thermo "Therm. connection"
package SI=Modelica.SIunits;
parameter Integer nspecies=4;
SI.Pressure
P;
SI.Temperature T;
SI.MassFraction X[nspecies];
flow SI.Power
q;
flow SI.MassFlowRate m_dot;
flow SI.MassFlowRate xm_dot[nspecies];
end Thermo;

While this connector definition has proved very
useful, it still has several shortcomings. First, there
is redundancy in this connector definition because the
quantity m dot should always be equal to the sum
of the components of the xm dot vector. In addition, there is no capacity to handle momentum flowing
2

domains. The first is the implicit nature of the prob- 2.3.2 Numerical Issues
lem. Rewriting Equation (1) to include explicit referAnother problem that can occur in thermodynamic
ences to the temperature of the control volume gives:
systems is that the mass within a given control volume
might vanish. This can happen for a number of readV
dU
= ∑ ṁi hi + Q , P
(4) sons. For example, the control volume may contain
dt
dt
U = mt u(T )
(5) liquid fuel which completely evaporates. The difficulty in handling this case is that no equation exists for
where u(T ) is the specific internal energy of the con- the temperature as the mass vanishes and the problem
trol volume and mt is the mass within the control vol- becomes under constrained. In some cases, it should
ume. Note that it is essential to compute the temper- be possible to solve for the limit of the temperature
ature since it is used in evaluating mixture properties solution as the singular case is approached.
and it appears in many constitutive equations.
The vanishing of mass within the control volume
There are several ways to deal with this equation. is also a problem because thermodynamic problems
The first is to choose U as the state variable. In this contain numerous intensive variables (i.e., quantities
case, the differential equation for U is integrated and which are normalized with respect to mass). For examthe solution of U is available directly. The tempera- ple, the specific internal energy, u(T ), shown in Equature, T , is then computed by applying a non-linear so- tion (5).
lution algorithm (typically Newton-Raphson) to EquaFinally, when dealing with thermodynamic modtion (5). Note, that within a differential-algebraic els it is often necessary to use an iterative algorithm
equation solver, these two steps are combined. The re- like Newton-Raphson. Such algorithms require initial
quirement of invoking a non-linear solver could neg- guesses for quantities like temperatures and pressures.
atively affect the performance of the integrator. The It is important to make sure that a reasonable value
other approach is, to add an equation which computes (from an engineering perspective) is provided for the
the derivative of the temperature, so that temperature start attribute of any variables that represent thercan be used as a state during the simulation:
modynamic states. In the worst case, the definitions
from the Modelica.SIunits package would be
dT (t )
(6) used where the value of the start attribute is zero
dT =
dt
by default (a very non-physical value for engineering
This equation introduces a new (dummy) variable dT problems).
which is computed by the derivative of T . Since we
would like to transform the equations (at least locally) 2.3.3 Medium Models
into state space form, i.e., dTdt(t ) = f (T ), the derivaAs pointed out in the previous section, the enthalpy
tive of T has to appear in the equations, which is perand energy of the working fluid must be represented
formed by introducing (6). Equations (4, 5, 6) are
in the fundamental thermodynamic equations. Tied to
now three equations to compute the three unknowns
the definitions of enthalpy and energy are other propU ; T ; dT . Due to (5), there is a constraint equation beerties such as density, molecular weight and specific
tween the potential states T and U and therefore only
heat capacities. A consistent set of these properties is
one of them can be the “actual” state.
known as a medium model.
Modelica has been constructed such that these sitWhen modeling thermodynamic systems, it is posuations can be solved automatically by using the alsible for a wide variety of medium models to be availgorithm of Pantelides [11] together with the dummy
able and/or required. Different medium models may
derivative method [10]. The result is, that T is selected
represent different working fluids or different levels
as a state, that U is computed from (5), dU
dt is com- of compositional detail for a given working fluid. For
puted from (4) and dT
dt is computed by the differenti- this reason, it is very useful to build component modated equation of (5). Therefore, with this approach,
els in such a way that they can be used with a variety
no nonlinear equation has to be solved. From a modof medium models. Idioms for representing medium
ellers perspective, only equation (6) has to be added,
models in Modelica are still being developed and evaland the rest is performed automatically with an approuated [12]. Medium models are important in many
priate Modelica tool, such as Dymola [7].
engineering domains (e.g., hydraulics, heat-transfer,
fluid flow).
3

Modelica supports the ability to have external functions compiled in other languages (e.g., C or FORTRAN). This is very useful to allow the incorporation of existing source code for implementing medium
models.

tions. The first is that at all other times during the
combustion process only one zone is present in the
combustion chamber. Because Modelica does not allow the number of equations to change during the simulation, equations must be present for both zones even
when only one really exists. This leads to the problem of having zero mass in the control volume (as dis2.3.4 Summary
cussed in Section 2.3.2).
Overall, the representation of thermodynamic systems
Finally, because the combustion process is cycliis relatively straightforward as this Modelica control cal it is necessary to be able to reinitialize the state of
volume model shows:
the system at the start of each cycle. For example, in
partial model ControlVolumeBase
the multiple zone case one zone is typically called the
package SI = Modelica.SIunits;
“burned zone” and the other is the “unburned zone”.
parameter Integer nsp=4 "# of species";
At the start of a cycle, all mass is in the unburned
public
zone1 . As combustion proceeds, all the mass is transFord.Interfaces.Thermo n(nspecies=nsp);
protected
fered to the burned zone (along with a compositional
SI.Mass
total_mass;
change). When the next cycle starts the burned mass
SI.Mass
mx[nsp];
from the previous cycle becomes the initial unburned
SI.Volume
vol "Volume";
Ford.Engine.Properties.PreferredPropBlock mass for the next cycle. For this reason it is necesprops(T=n.T, P=n.P, X=n.X) "Media";
sary to reinitialize the states of the burned and unReal dT;
burned zone (i.e., the mass and energy must be instanequation
taneously relocated).
// Conservation of mass
der(total_mass) = n.m_dot;
der(mx) = n.xm_dot;

// First law of thermodynamics
der(props.u) = n.q - n.P*der(vol);
dT = der(T);
// Ideal gas law (equivalent to P*V=m*R*T)
n.P*vol = total_mass*(props.h - props.u);
// Compute mass fractions
n.X = mx/total_mass;
end ControlVolumeBase;

Note the similarities between the equations in this
model and Equations (1, 2, 3).

2.4

Modeling Combustion

2.5 Mechanical Components
The one area where some component models already
existed and could be reused was in the mechanical aspect of the engine. For example, the piston model is a
translational force component and it uses the translational connector definition from the translational motion library2 . Because it uses the same connector definition as the existing components in the translational
library, translational components like masses, springs,
dampers and friction elements can be connected to the
piston to model a variety of important effects inside
the engine.
Obviously, rotational components also play a large
part in the modeling of an engine. The rotational
motion library3 provides models to represent inertias,
damping, friction, gear effects, etc.
Finally, an important thing to represent among the
mechanical components is ”experimental instrumentation”. In other words, it is important to be able to represent macroscopic information about the performance
of the engine. Using some of the hybrid modeling capabilities of the Modelica language, many important
cycle averaged results can be computed. For example,

A single zone model of combustion only requires that
mass of one species in the mixture be converted into
another. Such a conversion results in a tremendous increase in the temperature of the mixture. The temperature increases because the mixture composition lowers
the specific internal energy of the gas but the total energy changes very little during the combustion process
(e.g., due to heat transfer or work). The result is that
the gas must have a higher temperature in order to con1 The name “unburned zone” is a misnomer in this case because
tain a nearly constant total energy.
Multiple zone models are more complicated be- the unburned zone invariably contains some combustion products
left over from the previous cycle.
cause mass is exchanged between two different zones.
2 Modelica.Mechanics.Translational
3 Modelica.Mechanics.Rotational
The multiple zone case brings up several complica4

by integrating the instantaneous torque over two complete revolutions of the crankshaft (i.e., one engine cycle), commonly used metrics like cycle-average torque
and mean effective pressure can be computed.

2.6

Complex Assemblies

Figure 2: An individual cylinder

Figure 1: Single cylinder engine

So far, the basic building blocks of the engine models have been described. Once these building blocks
are in place, complex assemblies can be created. Figure 1 shows a model of a single cylinder engine. This
basic model includes piston, crank mechanism, timing
belt, cams, valves and an ideal dynamometer.
Of course, building an entire six cylinder engine the
way the single cylinder engine is constructed in Figure
1 would be very tedious. For this reason, an individual cylinder can be create which includes only the percylinder components. A model of such a cylinder is
shown in Figure 2.
Using the individual cylinder model shown in Figure 2 a six cylinder engine model like the one shown
in Figure 3 can be constructed.

2.7

Figure 3: Six cylinder engine

Future Directions

Predictive combustion models would also benefit from
the ability to simulate “impulses”. In this context, an
impulse is an instantaneous flow of conserved quantities from one location to another. An example of an
impulse is an elastic ball bouncing on a hard surface. It
is often convenient to model the collision as an instanteous event. The same sort of functionality is useful in
5

initiating the combustion process (i.e., the spark).
Another effect that is useful to capture that has
not been modeled is the thermal warmup of the engine. Since a thermal component library is currently
in development, the hope is that such a warmup model
could easily be developed from the components that
will be available in that library.
The models presented here have been designed to
allow for multiple medium models. Unfortunately,
only one medium model has been tested. In the fu-

ture, more detailed medium models will become available and the robustness and reusability of the medium
model approach will be tested more thoroughly.
These models have only demonstrated the uncontrolled operation of the engine. A more detailed model
would be equipped with a wide range of sensors and
actuators. The sensors and actuators would be connected to a control system and the closed-loop performance of the engine could be tested. The ability to test
the effectiveness of sensors, the response of actuators
and the overall performance of the control system is
extremely valuable in current engineering processes.
Comparisons were done between existing Ford inhouse engine modeling tools and the models developed in Modelica. There was good agreement between
both tools. However, the Ford in-house tools are still
farther advanced than the Modelica models in their
Figure 5: Hydraulic Subsystem
ability to predict combustion characteristics. Future
development work may focus on bringing the Modelica models up to the level of existing Ford in-house
Once again, the comparison between the numerical recycle simulation models.
sults showed “line on line” agreement between the trajectories.

3

3.1

Transmission Models

3.3 Combined System

Mechanical System

The real test of the mechanical and hydraulic subsystem models was to see if they could be connected together and function as a complete subsystem. Building the integrated transmission model was surprisingly
straightforward. There was no significant difference
between connecting two simple components and connecting two complex subsystems. As with the previous
models, comparisons were made with existing Ford inhouse tools and there was excellent agreement.

A transmission model was developed for the work described in this paper. A schematic of the mechanical
subsystem is shown in Figure 4. The existence of a rotational library of components made the development
of this model significantly easier. Many of the components needed were already available and the ones that
were not available were easily built from the connectors and partial base classes available.
The mechanical system by itself was validated
against a set of Ford in-house tools. There was “line
on line” agreement between the results from Dymola
and the results from the Ford in-house tools.

3.2

3.4 Summary
Just as with the engine, the ability to model impulses
would be very useful in development of the transmission models. In the mechanical system there are numerous sources of backlash and many of these models
would be easier to express using impulses. Within the
hydraulic system, it is common for the spools inside
the spool valves to collide both with the surrounding
walls as well as with each other. Once again, the modeling of these collisions would be easier with the ability to express impulses.

Hydraulic System

Because of the complexity in the hydraulic subsystem
of the transmission, only a subset of the hydraulics
were modeled. Specifically, only the valves required
for a shift from first to second gear were included. The
development of these libraries was facilitated by the
existence of a commercial library of hydraulic components [5]. The subsystem model that was developed is
shown in Figure 5.
Just as with the mechanical subsystem, the hydraulic subsystem was validated by comparing simulation results between Dymola and our in-house tools.

6

Figure 4: Mechanical Transmission Subsystem

4

Vehicle Chassis

4.2 ADAMS to Modelica translator

For this study we chose to use a detailed model of a
minivan chassis which had already been created using
ADAMS, a program for three-dimensional mechanical simulation from Mechanical Dynamics Inc. [1].
In order to integrate the chassis, engine and transmission into one Modelica model, the ADAMS chassis
model was converted to Modelica by a newly developed translator which is described to some detail in
the rest of this section.

4.1

Multibody Systems

To simplify the translation of the ADAMS model, a
new library of ADAMS compatible models was developed based on this MBS library, see Figure 7.
It contains realizations of ADAMS elements such as
Ground, Part, Revolute, Sforce, Coupler, Bushing and
Field.
7UDQVODWLRQDO'&

+RRNH'

8QLY HUV

8QLY HUV'

&RQY HO'&

Prior to this work, a library for modeling of multi-body
systems in Modelica had already been developed.
Figure 6 shows the sublibrary for joints. Other
sublibraries contain parts, forces and sensors. The

,QSODQH

&\ OLQGHU''
,QSODQH'

&
,QOLQH'&

&

6SKHULFDO'&

8QLY HUV'&

&RQY HO'

&RQY HO

,QOLQH

,QOLQH'

+RRNH

&

&\ OLQGHU'&

&\OLQGHU
$WSRLQW'&

6SKHULFDO'

6

7UDQVODWLRQDO'
+RRNH'&

6SKHULFDO

&\OLQGHU'
,QSODQH'&

,QSODQH&

&

&

,QOLQH&

&

76SULQJ'DPS
)ORDWLQJ)RUFH

*)25&(

9)25&(

972548(

7

Figure 7: Subset of ADAMS compatible library
5HYROXWH

3ULVPDWLF

6FUHZ

&\OLQGULFDO

An example is shown in Figure 8, where the
ADAMS JPRIM-INLINE joint is realized. This joint
)UHH0RWLRQ
8QLYHUVDO 3ODQDU
6SKHULFDO
has 4 degrees-of-freedom such that the right connector
moves along the z-axis of the left connector. This new
Figure 6: MBS sublibrary for joints
joint class is simply built-up by connecting an available translational and spherical joint with each other.
Additionally, a translator from the ADM file fornewest version of this library is available from
mat of ADAMS to Modelica was realized. This transhttp:\www.Modelica.org\library\library.html
lator reads an ADM file, stores all information of the
as ModelicaAdditions.MultiBody.
ADM file in an internal data structure, analyzes the
data and generates appropriate Modelica code. Most
7

VSKHULFDO

FXWD

6
SULVP Q]

val with the numerical solver DASSL and a tolerance
of 10,4 took 17 min (in ADAMS it took 15 min).

FXWE

6

Figure 8: ADAMS JPRIM/INLINE joint (left) and the
individual joints used to construct it (right)

statements have corresponding models in the Modelica package Adams, resulting in a one-to-one translation of the ADM file. Many properties which are
represented as references to MARKER statements are
converted to parameters of part and joint components.
For example, the center of mass of a part is represented
by a marker,

Figure 9: Modelica model of chassis.

PART/2, MASS = 4.116014532, CM = 5
MARKER/5, PART = 2, QP = -200, 450, 0

5 Integration Results

but in the Modelica model, it is given directly as a pa- In the previous sections favorable comparisons were
shown between Modelica models and the existing Ford
rameter:
in-house analysis tools. The primary goal was that
Part P2(MASS = 4.116014532,
CM_QP={-200, 450, 0}, ...);
the independently developed and validated subcomponents, such as the transmission and the chassis should
Finally, the model topology is represented in Modbe assembled together to arrive at an overall vehicle
elica by connections between Part, Joint and Force
model. The ability to do this integration is important
objects. This information is extracted by visiting
for several reasons: First, it makes collaboration beeach joint and force element in the data structure and
tween different modeling efforts within the same orgalooking up the corresponding marker and part elenization easier. The other reason is to leverage work
ments. For example, the following ADAMS statedone by third parties (e.g. suppliers, tool vendors, uniments (slightly abbreviated):
versities) regardless of the specific toolset used.
PART/1, GROUND
MARKER/1, PART = 1, QP = -200, 450, 0
PART/2, MASS = 4.116014532, CM = 4
MARKER/5, PART = 2, QP = -200, 450, 0
JOINT/1, REVOLUTE, I = 5, J = 1

5.1 Engine and Transmission
In order to test the integration features in Modelica,
the engine and transmission models presented in the
previous sections were combined. By using a more detailed engine model, the transmission receives a more
widely varying torque compared to a cycle average engine model . The results of the analysis using the detailed engine and transmission models can be seen in
Figure 10.
The ability to combine the engine and transmission
models together allows analyses of complex interactions that may occur between the engine and transmission. Some examples where the combination of detailed engine and transmission models would be useful
include neutral rollover noise, gear chatter and body
boom among others.

yield the following Modelica code:
Ground P1(...);
Part
P2(...);
Revolute J1(...);
...
equation
connect (P1.b, J1.a);
connect (J1.b, P2.a);

Using the ADAMS-to-Modelica translator, an
available ADAMS model of a minivan was translated
to Modelica. This chassis model consists of 73 parts,
32 revolute joints, 13 translational joints, 14 other
joints, 22 bushings, 10 fields, 67 other force elements,
and 205 graphical elements. The resulting 3D composition after translating this model from an ADAMS
ADM-file to its Modelica representation is shown in
Figure 9. Simulation in Dymola for a 10 second inter8

models that have yet to be explored. The potential to
do an even more comprehensive model of the powertrain system still exists and the development of less detailed, control system oriented models seems straightforward. In fact, several of the models that were developed were successfully exported to Simulink4 as Sfunctions which enables plant models to be developed
using the acausal approach available in Modelica.
A few issues were raised in this study about the
suitability of Modelica for such a wide variety of systems. Overall, Modelica was very capable of expressing the behavior of all the models mentioned. While
there is room for improving the Modelica language
(e.g., representing impulses) such improvements are
Figure 10: Detailed Engine and Transmission Analy- not required in order to describe the behavior of all
sis
of the systems discussed here.

5.2

Engine, Transmission and Chassis

7 Acknowledgments

The chassis and transmission including hydraulics
model, as well as a simplified engine model were integrated to finally arrive at a detailed overall vehicle model. This model contains about 3500 parameters, 25000 nontrivial scalar equations, and 320 state
variables. The equations are analyzed for systems
of simultaneous equations (algebraic loops). Nonlinear systems of equations corresponding to the position
equations of kinematic loops are found. Linear systems of equations correspond to inversions of the mass
matrix and to velocity equations of kinematic loops.
The symbolic manipulation takes just a couple of minutes to perform on a PC with a Pentium 500 MHz and
256 Mbytes of main memory. In this case, no comparisons of simulation results could be made, since
such an integrated model did not exist in any other
tool. The simulation time increased considerably due
to the complex dynamics of the hydraulics. Simulating
a start from zero velocity and a gearshift from first to
second gear was performed over a 10 sec interval and
took 125 min.

6

The authors would like to thank George Davis and
Nizar Trigui who initiated and guided this feasibility
study and who provided the necessary resources.
We would also like to thank the following people for the technical support of this study: Bill Tobler, Greg Pietron, Yuji Fujji and James McCallum assisted in the development of the transmission component models (both mechanical and hydraulic). In addition, they provided sample component data and helped
us to create benchmark cases to compare Dymola results with the existing Ford in-house tools.
Cleon Davis helped develop the initia l engine component models used in this study. Charles Newman
and Hubertus Tummescheit assisted in the development of the engine subsystem models by helping to
identify and explore the common difficulties that arise
when developing engine and thermodynamic models.
In addition, they assisted in collecting data and running validation cases.
Kevin Martus helped in understanding the ADAMS
chassis model and some of the peculiar ADAMS component models.

Conclusion

The connector object in Modelica is quite powerful. For the engine and chassis modeling, the ability to
carry numerous signals on a single connector is essential. For the transmission and hydraulics work, the use
of common connector definitions allowed several
different libraries developed independently to be used
together with no significant reworking.
While the model development described was very
successful, there are many other applications for these

References
[1] ADAMS. Mechanical Dynamics Inc., Homepage:
http://www.adams.com/.
[2] Modelica Association. Modelica Language
Specification (Version 1.3),
http://www.Modelica.org, 1999.
4 Simulink

9

is a registered trademark of The MathWorks, Inc.

[3] Modelica Association.
ModelicaAdditions.MultiBody,
http://www.Modelica.org/library/library.html, 2000.
[4] Modelica Association.
Modelica.Mechanics.Translational,
http://www.Modelica.org/library/library.html, 2000.
[5] P. Beater. Modeling and Simulation of Hydraulic
Systems in Design and Engineering Education using
Modelica and HyLib. In Proceedings of the Modelica
2000 Workshop, Lund, Sweden, October 2000.
Modelica Association.
[6] P. Bowles, M. Tiller, H. Elmqvist, D. Brück, S.E.
Mattsson, A. Möller, H. Olsson, and M. Otter.
Feasibility of detailed vehicle modeling. In
Proceedings of the SAE 2001 World Congress. The
Society of Automotive Engineers, Inc., 2001.
[7] Dymola. Dynasim AB, Lund, Sweden, Homepage:
http://www.dynasim.se/.
[8] H. Elmqvist, S.E. Mattsson, and M. Otter. Modelica
— A Language for Physical System Modeling,
Visualization and Interaction. In Proceedings of the
1999 IEEE Symposium on Computer-Aided Control
System Design, CACSD’99, Hawaii, August 1999.
IEEE Control Systems Society.
[9] John B. Heywood. Internal Combustion Engine
Fundamentals. McGraw-Hill, 1988.
[10] S.E. Mattsson and G. Söderlind. Index Reduction in
Differential-Algebraic Equations Using Dummy
Derivatives. SIAM Journal of Scientific and
Statistical Computing, 14(3):677–692, May 1993.
[11] C.C. Pantelides. The Consistent Initialization of
Differential-Algebraic Systems. SIAM Journal of
Scientific and Statistical Computing, 9:213–231,
1988.
[12] H. Tummescheit, J. Eborn, and F. Wagner.
Development of a Modelica Base library for
Modeling of Thermo-Hydraulic Systems. In
Proceedings of the Modelica 2000 Workshop, Lund,
Sweden, October 2000. Modelica Association.

10

07LOOHU
0RGHOLFD7KHUPDO/LEUDU\
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Modelica Thermal Library
Michael Tiller
Modelica Association
October 13, 2000

Abstract
This paper presents a new library of thermal components to be incorporated into the Modelica Standard Library. The goal for this package is to provide a reasonably simple set of basic
models and connectors that can be used as the basis for further development in the thermal
domain.

1 Introduction
The Modelica Standard Library is an excellent example of how a common set of connector
definitions, interfaces and basic models can be used not just as building blocks for complex
models but also as a mechanism for collaboration between model developers and users. The
key to the Modelica Standard Library’s success is the fact common connector definitions are,
for the most part, sufficient to allow models developed by different people or organizations to
be used together. A great deal has been accomplished using the connector definitions in the
current version1 of the Modelica Standard Library.
However, the current version of the Modelica Standard Library does not provide the basic set of objects needed to allow collaboration in some common engineering domains. In
particular, connector definitions for both thermal and hydraulic systems have not yet been
incorporated into the Modelica Standard Library. This is not to say these domains have
been overlooked. An extensive library of Modelica models is being developed for complex
thermo-hydraulic systems[7] and a commercial Modelica library already exists for hydraulic
components[3]. Nevertheless, the basic connector definitions required for simple thermal and
hydraulic systems are not yet part of the Modelica Standard Library.
The focus of the library is a connector definition for thermal systems. Such a connector
needs to include temperature as an across variable and power as a through variable. Several
names were considered for this library. A similar library, called the HeatFlow library, was
developed as part of the ModelicaAdditions library[2]. The name HeatFlow did not
convey the scope of this new library very well. Another consideration was HeatTransfer
which seemed very appropriate. However, the name HeatTransfer implies the scope of
the library is limited to the three modes of heat transfer: conduction, convection and radiation.
This seemed too constraining. The name Thermal was decided upon because it captured the
essence of the library and left room for many models beyond the scope of simple heat transfer
(see Section 6).

2 Interfaces
2.1 Connector definition
The connector definition is the foundation of any library in Modelica. Care needs to be taken
when designing a library to make sure that the appropriate level of detail is present in a connector. To little detail will limit the applicability of the connector while too much detail might
make the library overly complex for many purposes.
1 The

current version of the Modelica Standard Library is version 1.3.1

For the most part, the connector definition for the Thermal library was straightforward
to arrive at. As previously mentioned, the across variable at the connector (i.e., the non-flow
quantity) is temperature. The only real issue was what to make the through (or flow) quantity.
The choice was between a scalar representation for heat flow or a vector representation of
heat flow. The latter was decided upon because it does not increase the complexity much
(the Modelica.Blocks library is a precedent for such an approach) and it leaves open the
possibility to develop two and three dimensional components.
The one remaining issue was what to call the connector. The convention for the Modelica
Standard Library has been to name connectors after their physical counterparts. For example,
in the case of the rotational mechanics library the connector is called a flange. Unfortunately,
naming a thermal connector is difficult because there is no clear physical counterpart to name
it after. Instead, conventions in other computational disciplines were considered. For heat
transfer equations in multiple dimensions, the term node is often used[5, 6, 4]. Because of
this precedent, the name Node was settled on. After all this consideration, the following
connector definition was adopted:
connector Node "Temperature nexus"
package SIunits=Modelica.SIunits;
parameter Integer ndim=1 "Spatial dimensions";
SIunits.Temperature T(start=300);
flow SIunits.HeatFlowRate q[ndim];
end Node;
Note the fact that a start value is provided for the temperature. This is important since
the units are Kelvin and the default value is normally zero. The start attribute was changed
because very few practical applications in the thermal domain have temperatures near absolute
zero.
The Node definition does not include any graphical annotations. However, graphical
annotations are useful in diagrams for distinguishing different connectors. For this reason,
three additional connectors, with different graphical representations, are derived from Node.

2.2 Simple One-Dimensional Models
Because one-dimensional heat transfer is likely to be quite common, the following partial
model was developed:
partial model Element1D
Node_a a(final ndim=1);
Node_b b(final ndim=1);
protected
Modelica.SIunits.HeatFlowRate q "Flow from a->b";
Modelica.SIunits.Temperature dT "a.T-b.T";
equation
dT = a.T - b.T;
a.q[1] = q;
b.q[1] = -q;
end Element1D;
where dT is the temperature difference across the component and q is a scalar representing
heat flow through the component. By using this model, the fact that a.q and b.q are arrays
does not complicate the writing simple models.

3 Linear Components
A set of basic one-dimensional, linear models was developed to describe energy storage and
each of the three modes of heat transfer.

3.1 Capacitance
The constitutive equation for the thermal capacitance model is:
V cpρ

dT
dt

q

(1)

where V is the volume, c p is the specific heat, ρ is the density, T is the uniform temperature
of the mass and q is the heat flow. This relationship can be expressed in Modelica as:
model Capacitance
parameter Modelica.SIunits.SpecificHeatCapacity cp(start=1.0);
parameter Modelica.SIunits.Density rho(start=1.0);
parameter Modelica.SIunits.Volume V(start=1.0);
Modelica.Thermal.Interfaces.Node_c n(final ndim=1);
equation
V*cp*rho*der(n.T) = n.q[1];
end Capacitance;

3.2 Conduction
The constitutive equation for conduction is:
q

Ak

dT
dx

(2)

where A is the area and k is the thermal conductivity. Since we do not have a convenient way
of expressing spatial derivatives in Modelica, the spatial derivative must be approximated as:
dT
dx

∆T
L

(3)

where ∆T is the temperature across the conducting element and L is the length of the conducting element. The Modelica code for this model can be written as follows:
model Conduction
extends Modelica.Thermal.Interfaces.Element1D;
parameter Modelica.SIunits.ThermalConductivity k(start=1.0);
parameter Modelica.SIunits.Length L(start=1.0);
parameter Modelica.SIunits.Area A(start=1.0);
equation
q = A*k*dT/L;
end Conduction;

3.3 Convection
The constitutive equation for convection is:
q

Ah∆T

where h is the coefficient of heat transfer. This model is then expressed in Modelica as:
model Convection
extends Modelica.Thermal.Interfaces.Element1D;
package SI=Modelica.SIunits;
parameter SI.CoefficientOfHeatTransfer h(start=1.0);
parameter SI.Area A(start=1.0);
equation
q = A*h*dT;
end Convection;

(4)

3.4 Radiation
Finally, the model for black body radiation is based on the equation:
q



FσA Ta4  Tb4 

(5)

where F is the view factor and σ is the Stefan-Boltzmann constant. From this equation, we
construct the following model:
model BlackBodyRadiation
extends Modelica.Thermal.Interfaces.Element1D;
parameter Real F "View factor";
parameter Modelica.SIunits.Area A(start=1.0);
equation
q = F*Modelica.Constants.sigma*A*(a.Tˆ4 - b.Tˆ4);
end BlackBodyRadiation;

4 Boundary Conditions
Once we have the basic mechanisms for describing the flow of energy through a thermal
system, we require models to specific boundary conditions. The models in this package are
general enough to function for any number of spatial dimensions.

4.1 Prescribed Temperature
There are two types of prescribed temperature boundary conditions. One assumes the prescribed temperature is a constant and is represented as:
model FixedTemperature
parameter Modelica.SIunits.Temperature T;
Interfaces.Node_c n;
equation
n.T = T;
end FixedTemperature;
The other type assumes that a temperature will be provided by a block from the Modelica.Blocks package. For this latter case the boundary condition is represented as:
model VariableTemperature
Modelica.Blocks.Interfaces.InPort T(final n=1);
Interfaces.Node_c n;
equation
n.T = T.signal[1];
end VariableTemperature;

4.2 Prescribed Heat Flux
The other simple boundary condition provided is a prescribed heat flux which can be represented by the following code:
model PrescribedHeatFlux
parameter Integer ndim=1;
Modelica.Blocks.Interfaces.InPort q(final n=ndim);
Modelica.SIunits.Area A(start=1.0);
Interfaces.Node_c n(final ndim=ndim);
equation
n.q = A*q.signal;
end PrescribedHeatFlux;

5 Sensors
5.1 Temperature
There are really two temperature sensors available in the Modelica.Thermal package.
The first is an ideal temperature sensor (i.e., it senses temperature changes instantly without
any heat transfer). This model can be expressed simply as:
model TemperatureSensor
Modelica.Blocks.Interfaces.OutPort T;
Modelica.Thermal.Interfaces.Node_c n;
equation
T.signal[1] = n.T;
end TemperatureSensor;
Another temperature sensor that is available is the Thermocouple model. Strictly
speaking, this model should probably have been discussed in Section 6 because it actually
mixes two physical domains (i.e., thermal and electrical). However, since the Thermocouple model is primarily a sensor the model is included here.
One way used by instrumentation manufacturers[1] to describe the behavior of a thermocouple is to use the following general equation:
n

E

∑ CjT j

(6)

j 0

where E is the potential across the thermocouple (in the absence of any current flowing), C
is the vector of calibration coefficients for the thermocouple and T is the temperature of the
thermocouple. This behavior can be represented in Modelica using the following code:
model Thermocouple
extends Modelica.Electrical.Analog.Interfaces.OnePort;
parameter Real C[:] "Calibration coefficients";
Modelica.Thermal.Interfaces.Node_c node_c;
equation
v = polyval(C, node_c.T);
node_c.q = zeros(node_c.ndim);
end Thermocouple;

5.2 Heat Flow
The last basic sensor model included is the HeatFlow sensor which is written as follows:
model HeatFlow
extends Modelica.Icons.RotationalSensor;
Modelica.Thermal.Interfaces.Node_a a;
Modelica.Thermal.Interfaces.Node_b b;
Modelica.Blocks.Interfaces.OutPort heat(n=size(1, a.q))
"Heat flowing from a->b";
equation
a.q + b.q = 0;
heat.signal = a.q;
a.T = b.T;
end HeatFlow;

6 Mixed Domain
As mentioned in Section 1, one of the reasons the name Modelica.Thermal was chosen
was that the scope of the library goes beyond simple heat transfer. In particular, many models
span more than one physical domain.

One example of a mixed domain model is the HeaterElement model which extends the
Resistor model provided in Modelica.Electrical package. The HeaterElement model functions as a resistor but also contributes the energy dissipated by the resistor
to a thermal node as shown in the following model:
model HeaterElement
extends Modelica.Electrical.Analog.Basic.Resistor;
parameter Real efficiency(start=.90);
Modelica.Thermal.Interfaces.Node_c thermal;
equation
thermal.q[1] = -iˆ2*R*efficiency;
end HeaterElement;
Another example of a mixed domain model is a rotational spring that changes shape in
response to temperature changes:
model RotationalSpring
extends Modelica.Mechanics.Rotational.Interfaces.Compliant;
parameter Real c(final unit="N.m/rad", final min=0,
start=1.0) "Spring stiffness";
parameter Modelica.SIunits.Temperature T_nom(start=273.15)
"Nominal temperature";
parameter Real dudT(final unit="rad/L", start=1.0)
"Angular expansion coefficient";
parameter Modelica.SIunits.Angle unstretched_nom
"Nominal unstretched length (at T_nom)";
Modelica.SIunits.Angle phi_rel0(start=0)
"Unstretched spring angle";
Modelica.SIunits.Angle dphi "Delta phi";
Modelica.Thermal.Interfaces.Node_c node_c;
protected
Modelica.SIunits.Energy P;
equation
dphi = (phi_rel - phi_rel0);
P = c*dphiˆ2;
der(P) = node_c.q[1];
phi_rel0 = unstretched_nom + dudT*(node_c.T - T_nom);
tau = c*dphi;
end RotationalSpring;
There are numerous other examples of mixed domain models (e.g., temperature sensitive
resistors) that could be included as well.

7 Examples
A complex example which exercises many of these components is to consider a control system
regulating the temperature inside of a single story house. Figure 1 shows a sample problem
consisting of two houses, two furnaces and two thermostats. The houses and the furnaces are
identical but the thermostats are different.
One thermostat, shown on the left in Figure 2, is a mechanical thermostat. The furnace is
controlled my a mercury switch mounted on mechanism which moves as a result of thermal
expansion. The other thermostat, shown on the right in Figure 2, is an electronic thermostat.
The integrated circuit shown in Figure 2 represents the logic of the controller. The circuit uses
the voltage drop across two of its pins to compute the temperature in the house (by inverting
the temperature relationship in Equation 6). Based on this temperature and the logic of the
controller the two pins leading to the furnace are shorted to turn on the furnace.
Figure 3 shows the diagram of the single story house. The model includes conduction of
heat into the ground, convection of heat through the walls to the ambient air and heat transfer
due to radiation from the roof.

295K

amb_temp

period={24*60*60}

Figure 1: An example to exercise the Modelica.Thermal library

  
  
  
  

  
  
  
  

 

 

 


Tn

Tp

Fp

p

p

Fn

g

mechanism
damper

J=1e-5

ground

d=100

rotation=setting

n

n

Figure 2: Mechanical thermostat (left) and digital thermostat (right)

T

sun_position

period={day}

Solar Heating
Heat Loss
Through Walls

T

Thermal Inertia of the House

Tamb

Conduction to Ground

Figure 3: Diagram of heat transfer within the house

8 Conclusion
This paper serves several purposes. First, the paper shows how the thermal library connector was defined and also shows how numerous simple models were built from common
constitutive relations. Another useful function of this paper is to demonstrate how model
libraries are created. Note that the structure of the paper mimics the structure of the Modelica.Thermal package. Last, but not least, the paper discusses the current status of the
thermal library. This is just a first draft of the library and should be considered a request for
comments on how the library may be improved or expanded.

9 References
References
[1] Omega’s Temperature Handbook, chapter Z, pages Z–201. Omega Engineering, Inc.,
”http://www.omega.com”, 2000.
[2] Modelica Association. ModelicaAdditions.HeatFlow,
http://www.modelica.org/library/library.html, 2000.
[3] P. Beater. Modeling and simulation of hydraulic systems in design and engineering
education using Modelica and HyLib. In Proceedings of the Modelica 2000 Workshop,
Lund, Sweden, October 2000. Modelica Association.
[4] Robert D. Cook, David S. Malkus, and Michael E. Plesha. Concepts and Applications of
Finite Element Analysis. John Wiley and Sons, third edition, 1989.
[5] Claes Johnson. Numerical Solution of Partial Differential Equations by the Finite
Element Method. Cambridge University Press, 1992.
[6] J. N. Reddy. An Introduction to the Finite Element Method. McGraw-Hill, 1984.
[7] H. Tummescheit, J. Eborn, and F. Wagner. Development of a Modelica base library for
modeling of thermo-hydraulic systems. In Proceedings of the Modelica 2000 Workshop,
Lund, Sweden, October 2000. Modelica Association.

+7XPPHVFKHLW-(ERUQ)-:DJQHU
'HYHORSPHQWRID0RGHOLFD%DVH/LEUDU\IRU
0RGHOLQJRI7KHUPR+\GUDXOLF6\VWHPV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Development of a Modelica Base Library
for Modeling of Thermo-Hydraulic Systems
Hubertus Tummescheit†, Jonas Eborn† and Falko Jens Wagner‡
†

Department of Automatic Control
Lund University, Sweden
{hubertus,jonas}@control.lth.se

Abstract
This paper presents current results of an ongoing project to develop a Modelica base library
for thermo-hydraulic systems.
There are many different aspects to the development of such a library, from the basic physics
of fluids and heat to the structuring of model
classes in the library and the actual implementation in the Modelica language. The structuring should define interfaces and partial classes
that facilitate reuse to make the library general and easy to use. Different choices of media, use of different state variables as well as
different levels of complexity in modeling is anticipated in the library structure.
The basic entity in the library is the model of
a control volume. It is formed by multiple inheritance from three parts; the partial thermal model, the partial hydraulic model and
the medium model. Flexibility is obtained by
parameterizing this control volume. It can be
either lumped or discretized in n sections. The
three parts are also parameterized with class
parameters. This means for example that you
can easily exchange medium in a control volume.
The aim of the project is to develop a model
library that contains all basic components
needed for thermo-hydraulic systems. Besides
control volumes and medium models this also

‡

Department of Energy Engineering
Technical University of Denmark
falko@et.dtu.dk

means models for simple machinery, e. g.,
pumps, valves and heat exchangers. Code examples are given in the paper.

1. Introduction
With the modeling language ModelicaTM , (3, 5),
it is possible to create model libraries for different application areas. In the current Modelica base library distribution there are libraries
for multi-body systems, electrical systems and
block diagrams. To further expand the range
of applications for Modelica a base library for
modeling and simulation of thermo-hydraulic
systems is also needed. A thermo-hydraulic
base library should cover the basic physics of
flows of fluids and heat. It also needs to cover
models for properties of fluids like water and
refrigerants. The library would then be useful
in several application areas, e. g., power generation plants, district heating and refrigeration
systems.
The general goal of the library is to provide a
framework and basic building blocks for modeling thermo-hydraulic systems in Modelica.
For obvious reasons it is impossible to provide
components for every application, so one of the
main goals is extensibility. For the same reason, much more emphasis will be put on the
basic parts of the library, such as medium mod-

els and essential control volumes, than on an
exhaustive application library. The focus of the
library is on models of homogeneous one- and
two-phase flows, non-homogeneous and multiphase flows are not taken into account yet. It
is necessary to support bidirectional flow, because flow directions can change during simulation or are not known initially in networks.
To make the library general and extensible,
the structuring must accommodate for example different choices of media, single/multicomponent flow and one- or two-phase flows.
For numerical efficiency reasons it may also
be interesting to use different pairs of state
variables, e. g., { p, h}, { p, T } or {ρ , T }. This is
anticipated in the library structure. The basic entity in the library, the control volume,
is built up by multiple inheritance from three
parts. The partial thermal model contain dynamic state equations derived from conservation laws of mass and energy. The partial hydraulic model contain the mass flow equation
that is formed from either a static or a dynamic
momentum balance. The third part in the control volume is the medium model that calls the
appropriate medium property functions.
The models in the library are designed for system level simulation, not for detailed simulation of flows, which are usually done in CFD
packages. The models are thus discretized in
one dimension or even lumped parameter approximations.
It has to be emphasized that especially in the
area of fluid flow different assumptions about
the importance of terms in the general equations can lead to models which are very different mathematically. The library offers only
a choice of assumptions, which nonetheless
should cover a broad range of applications.
Some of the ideas for the thermo-hydraulic
base library have previously been presented
in (2, 8, 9, 10) as well as object-oriented
component based modeling has been presented
in (11, 12).

2. Basic ideas
The basic design principles of the library are:

• one unified library both for lumped and
distributed parameter models,
• both bi- and unidirectional flows are supported,
• separation of the medium submodels,
which can be selected through class parameters,
• assumptions (e. g., gravity influence yes
or no) can be selected by the user from
the user interface.
The first guideline puts a constraint on the discretization method used in the distributed parameter models: only the “staggered grid” or
finite volume method (see Figure 1), where all
fluxes are calculated on the border of a control volume and the intensive quantities are
calculated in the center of a control volume,
reduces to a useful model in the lumped parameter case. The finite volume method (6)
is common for systems modeling with onedimensional discretizations, but has the drawback that spatial derivatives are only first order accurate.
The ability to handle reversing flows requires
extra information in the connectors between
models. Transported properties, e. g., enthalpy
and composition, would need to be included
twice, upstream and downstream. This has
instead been solved by including convective
heat flow and component mass flows in the
connectors. Thus the information needed for
the balance equations (see Section 3.1) is
contained in variables depending on the flow
direction, i. e., mass flow and convective heat
mass and energy

hi-1
pi-1

inlet

.
mi
.
q c,i

hi
pi

.
m i+1
.
q c,i+1

h i+1
pi+1

momentum

Fig. 1

Discretized Flow Grid

outlet

flow. In contrast the transported properties
in the connector are always taken from the
closest control volume.
The connector for single medium flow without
dynamic momentum balance then contains the
variables:

{ p, h, ṁ, q̇c, ρ , T , s, κ }
where ṁ is mass flow, q̇c is convective heat flow
and κ is the ratio of specific heats.

3. Control volume equations
The basic thermo-dynamic equations governing a fluid system are partial differential equations. In our discretized setting these are integrated over a fixed control volume to obtain
ordinary differential equations.
For a complete model description of a control
volume, three parts are needed:

• Balance equations (mass, energy and momentum)
• Constitutive equations (pressure drop,
heat flow)
• Medium property routines

3.1 Balance equations
With the staggered grid approximation described in Section 2 the balance equations are
split up. The control volume model holds the
equations for total mass and internal energy.
If there are n flow connections to other control
volumes and l heat transfer areas these are
written as (positive flow into the CV):
d
dt

M
U

!
=

!
Pn
i ṁi
Pn
Pl
i q̇conv,i +
j q̇trans f er, j
(3.1)

Between the control volumes there must be
a flow model, which holds the momentum
balance. Currently two types of flow models are
implemented in the library:

• Stationary pressure drop model
• Dynamic momentum balance for pipes
with constant cross-sectional area.
Static flow models are much used in system
simulation where the thermal behavior is the
main concern. The dynamic momentum balance is useful for pressure wave propagation
studies in a system which is mainly modeled
with distributed parameter models. Keep in
mind that it is possible to add other types of
flow models to the existing structure, e. g., a
momentum balance for variable cross-sectional
area along the flow channel.
The dynamic momentum balance is used to
calculate the mass flow rate,
dI
dṁ
∆z
=
= İ1 − İ2 + ( p1 − p2 ) A − Fwall
dt
dt
where I = ṁ ∆ z is the momentum and the frictional force, Fwall, is given by some constitutive
equation.
This alternating structure of one control volume and one flow model, see Figure 2, guarantees that the simulation problem is well specified and that there are no unnecessary algebraic loops. The models can be used in either
lumped, compound models or distributed, vectorized models, giving the user a possibility to
change the complexity of the system model.

3.2 Constitutive equations
The constitutive equations are empirical relations for heat flow, pressure drop and characteristics of machinery. They are typically formulated as characteristic equations for individual components, often algebraic equations
but they could also be formulated as differential equations. For example in a pump,
there exist many different relationships between mass flow rate, pressure increase, angular speed and consumed power. The fluid
flow literature also holds many different expressions for the relationship between flow and
pressure drop.

Atomic model types

ControlVolume

FlowModel

Compound or Discretized Models

Fig. 2

Atomic, Compound and Discretized Models

These constitutive equations should be replaceable, in order to have a general model for
a component that can be used in different situations by exchanging the model for the characteristics, see Section 4.1 for an example.

3.3 Medium property routines
For simulation of thermo-hydraulic systems,
it is necessary to have accurate models for
the thermodynamic properties of the fluid that
is flowing in the system. For the purpose
of dynamic system simulation, the following
criteria have to be met:

• Accuracy
• Speed
• Robustness
In some areas there exist recommended formulations (IAPWS/IF97 for water (13)) or defacto standards (NIST-REFPROP routines for

refrigerants, (4)) that have to be taken into account. External function call interfaces in Modelica make it possible to use these standards
directly. Available routines and most medium
property models in the literature (see, e. g.,
(7)) are designed with stationary calculations
in mind, therefore they have to be extended to
include some needed extra derivatives for dynamic calculations.
In dynamic simulations the speed of the
medium property functions is very important
for the performance of the simulations. Whenever possible the medium properties should be
non-iterative, which is the case when they are
explicit in the dynamic states. This is easy to
achieve for the steam tables, where the industrial standard formulation, IAPWS-IF97, has
explicit routines for a variety of input variables (pressure and temperature, enthalpy or
entropy). The complete industrial steam tables
are implemented in the library.
For other properties, e.g. R134a, such inverse
formulations are not available. However, it is
still possible to save a huge amount of computation time by precomputing the phase boundaries off-line and use an auxiliary equation for
it. These vapor-liquid equilibrium calculations
(VLE) for cubic and other medium models have
to be performed iteratively and numerically,
either by using Maxwell’s criterium or calculating that Gibbs’ free enthalpy is equal for
both phases. The numerical calculations are
too inefficient to be performed at each time
step during dynamic simulation. In order to
calculate medium properties inside the twophase region, it is sufficient to know the properties on the phase boundaries and interpolate
with the vapor mass fraction x. An efficient
implementation of medium properties for pure
components requires that VLE are calculated
before the simulation and that VLE data is
approximated either with a suitable function
or with smooth spline interpolation. For the
above listed media, high accuracy approximations are either available in the standard formulation (e. g., partially for water and CO2 ) or
provided in the base library.

The phase boundaries require special attention: the derivatives of most properties are
discontinuous across the phase transition and
therefore this has to be implemented as a discrete change which restarts the integration
routine if a control volume changes its phase.
This is a robustness requirement for most normal cases, but it can lead to unexpected “sliding mode” behavior, if e. g., heat transfer coefficients also change discontinuously at the
phase boundary.
Currently we have implemented high-accuracy
medium models for the whole fluid region
for water, carbon dioxide and R134a. More
refrigerant properties will be available soon.
It is relatively easy to add your own medium
model to the existing ones and it is even
simpler to exchange the medium model in
existing models against another one.
Summarizing this means that the medium
properties that are provided with this library:

• are adapted for use with dynamic simulations.
• use non-iterative, auxiliary equations for
the calculation of VLE.
• are highly accurate for water, CO2 and
R134a.
• include ideal gas properties for a wide
variety of gases.

3.4 State variable transformations
There is an interdependence between the
choice of the medium model and the selection
of state variables. Many details of the medium
model depend on the choice of the state equations. Most medium models are available for
all of the choices of state variables in the library, but the numerical efficiency can be very
different. The common choice { p, h} is very efficient for water in the two-phase region where
the medium model is explicit in these states,
while it is slower at super-critical pressures,
since the medium model is explicit in {ρ , T }
and thus iterations are needed.

The balance equations for mass and internal
energy (3.1) can be rewritten into differential
equations for ρ and u. A differentiation of
M = ρ V and U = uM for a constant volume
yields:

dρ
dM


=
 V
dt
dt
(3.2)

dU
dM
du

 M
=
−u
dt
dt
dt
These primary equations are then transformed
into secondary forms to give differential equations in the states suitable with the medium
model. For example, if pressure and enthalpy
are chosen as states,

 

V ρ 
V ρ 
!
!
 V p
V h p 
ρ
p
d
d
h



 
=
dt
 V u 
V u   dt
h
u
V p h V h  p
|
{z
}
Jacobian, J

(3.3)
To obtain differential equations for pressure
and enthalpy eq. (3.3) must be solved for the
derivative of ( p, h)
!
!
p
ρ
d
−1 d
=J
(3.4)
dt
dt
h
u
The partial derivatives of ρ are calculated in
the medium model, while the partial derivatives of u can be reduced to those of ρ . From
u = h − p/ρ we obtain




V u 
p V ρ 
V u 
1
p V ρ 
= 1+ 2
=− + 2
Vh
ρ Vh
V p
ρ ρ V p
p

p

h

h

This gives the inverse Jacobian as


J−1 =

a2 


ρ 


p V ρ 
ρ+
−ρ
ρ V h p

p V ρ 
1−
ρ
ρ V p
h


V ρ 
V h p

V ρ 
V p







h

where a is the velocity of sound. By combining
(3.4) and (3.2), multiplying with M = ρ V and

Fig. 3

Basic Package Structure of the ThermoFlow Library

noting that h = u + p/ρ we obtain


 !


ρ dp
V ρ 
dM
V ρ  dU


−
 V a2 dt = ρ + h V h 
dt
V h  p dt
p





ρ dh
V ρ 
dM
V ρ  dU


 V 2
= 1−h
+
a dt
V p h dt
V p h dt
which are the differential equations for p, h
used in ThermoFlow. Similar expressions has
also been derived for other pairs of state
variables, for example { p, T }, { p, s} or {ρ , T }.

3.5 Library structure

4. Object-oriented modeling
Modelica is an object-oriented modeling language, designed for modeling physical systems.
Many of the object-oriented features defined by
(1) are found in the Modelica language:

• (Multiple) Inheritance
• Class parameterization
• Generalization
The concept of inheritance lets one object inherit methods and properties (i. e., the behavior) from other objects. This allows code sharing and calls for applying generalization.

The main idea of the ThermoFlow library
is to provide an extensible basis for a robust thermo-hydraulic component library. The
structure of the library is divided into three
parts, see Figure 3.

Class parameterization gives the possibility to
implement generic classes that can be used
for specialization later. With this, a parameter
can be passed to a class during instantiation,
giving the class the desired behavior, see Section 4.1.

Base classes are the central part of models,
the basic physical equations for a control volume and the connector types for
flowing media; either single or multicomponent, with a static or dynamic flow
description.

In a way, the concept of object-orientation,
in relation to component based modeling, inspires the user to generalize the system he/she
is about to model. This can lead to a better
understanding of the system being modeled.
Through generalization, the user is forced to
decompose the system into subproblems. Each
subproblem can then be modeled and implemented in meaningful classes. These classes
tend to represent the essential parts (i. e.,
subproblems) of the system, and aggregation
(through multiple inheritance) collects these
parts again to form a complete model of the
system.

Partial components contain common expressions for component models, this
allows code sharing and simplifies maintenance.
Components are the user part of the library,
models that can be used to build a system
for simulation.

4.1 Object-oriented constructs in Modelica
In the following subsections we will give examples of how the object-oriented features described above are handled in Modelica.
Aggregation through multiple inheritance is
used to build up basic models. A control volume
formulation of a pipe can be decomposed in the
following individual subproblems:

• Balance equations
• Flow model
• An empty shell with connectors
These subproblems are modeled individually
in the following classes:
partial model Balances
... some equations;
end Balances;
partial model FlowModel
... some equations;
end FlowModel;
partial model TwoPort
FlowConnector a,b;
end TwoPort;

and aggregation of these base classes leads to
a general description of a control volume, e. g.,
a pipe
model Pipe
extends TwoPort;
extends Balances;
extends FlowModel;
end Pipe;

By the Modelica keyword extends the new
model Pipe inherits all attributes of the base
classes. Common parts of the base classes are
only inherited once.
Class parameterization
is used to add replaceable objects to a class. This object can
then be replaced by passing a specific class as
a parameter during instantiation.
As an example we take the FlowModel from
above. Any flow model needs some sort of
pressure loss model. In order to make the class

FlowModel as general as possible, we only
specify a generic flow model during base class
implementation.
partial model FlowModel
replaceable class
Ploss = GenericPressureLossModel;
extends Ploss;
end FlowModel;

The GenericPressureLossModel does not have
to contain anything, but for practical reasons
(and as a base class for inheritance in specialized pressure loss models) it contains the most
necessary variables.
During specialization in later classes, this
generic pressure loss model is then replaced
by a more meaningful model, containing not
only the variables, but also some equations for
calculating the actual pressure loss.
model SpecialPipe
extends TwoPort;
extends Balances;
extends FlowModel(redeclare
Ploss = SpecialPressureLossModel);
end SpecialPipe;

Generalization is the key element in objectorientation. It is closely related to the notion
of classes. A class describes some general behavior of objects that have some properties in
common. Exactly these common properties call
for a general description - a class. The purpose
is obviously code sharing, but an often quite
appreciated side effect of this is a better understanding of the problem being modeled.
Generalization is in this library used to specify
behavior of components, which for some reason
is common to all components of that particular
type. For flow equipment a general feature is
the convective heat transport, which can be
expressed as
partial model FlowModelBase
extends FlowVariables;
extends TwoPort;
equation

a.q_conv = if a_upstr
then mdot*a.h
else mdot*b.h;
end FlowModelBase;

where the specification of the flow direction,
a_upstr, and the mass flow, mdot, is postponed
until later.
Since the calculation of the mass flow depends
on the type of flow equipment used, this additional information has to be provided in a
specialized class. For example a valve with a
linear expression for pressure losses
model LinearValve
extends FlowModelBase;
equation
a_upstr = a.p > b.p;
mdot = mdot0/dp0*(a.p-b.p);
end LinearValve;

where the mass flow depends on the parameters mdot0, dp0 and the pressure difference
over the valve.

the volume flow rate, the pressure increase and
the speed of the pump. This is called the pump
characteristic or pump profile. One example of
an expression for this relationship is

∆ pn = R1 nn + 2R2 nn Vn − R3 e Vne Vn

(5.1)

here, pn , nn and Vn are the normalized pressure p, speed of the pump n and volume flow
rate V . The design point is ( pn , nn, Vn) =
(1, 1, 1) and represents the pump in normal operation.
In terms of the ThermoFlow library structure,
the pump can be modeled by using a lumped
control volume and a lumped flow model according to Figure 2. The lumped flow model
then represents the pump characteristic (5.1),
whereas the lumped control volume in front
of the pump is used according to the library
structure. This control volume represents the
volume of the pump, which should not be neglected.

5.2 Heat exchangers
4.2 Summary
Some examples have shown how important
object-oriented constructs are implemented in
the Modelica language. These constructs are
used throughout the library structure (see
Section 3.5) to facilitate wide spread use of
generalization and code sharing and make the
library more flexible.

5. Component models
As mentioned earlier, the aim of this project
was not extensive component modeling, but to
create a base structure for future development
of component models. For demonstration purposes a few component models have been implemented. This section presents some of them.

A heat exchanger is modeled using base components from the library. Basically, it consists
of two pipes connected by a heat conducting
wall. Figure 4 shows the principle of modeling
a heat exchanger and a sample system.
Heat exchangers can either be lumped or
distributed. In the distributed case the heat
transfer model uses a simple temperature difference between the individual elements of the
distributed pipes. The lumped case is either
based on this simple model or uses the logarithmic mean temperature. Furthermore, tube
and shell heat exchangers are implemented using a circular wall geometry with an inner and
an outer pipe.

5.3 Turbines
5.1 Pumps
For modeling a pump, e. g., feed water pump,
it is necessary to have a relationship between

Analogous to pumps, a turbine is modeled
as a lumped control volume with a following
lumped flow model. The flow model introduces
the turbine characteristic or turbine profile.

sources and sinks are required. These are
used to add "boundary" conditions to other
components or systems of components. Typical sources are temperature, pressure or heat
sources. They can either be fixed or depend on
some input signal. The sample system in Figure 4 contains 2 controlled sources and 2 sinks.
For flow sources, the model consists of a control volume, giving thermodynamic properties
to the supplied flow, and a flow model at the
outlet of the source. The control volume is
a so called "infinite reservoir", i. e., the thermodynamic conditions do not vary over time
as mass leaves the control volume. The flow
model is used to make the sources more realistic (and numerically less stiff), e. g., by modeling a pressure drop over the outlet.
Heat sources can either be fixed in temperature or fixed in heat flux, i. e., they can also be
controlled by an external signal. A sink is usually just a fixed pressure control volume, and
the assumption about the "infinite reservoir"
holds as well.

6. Examples

Fig. 4 Example system using a heat exchanger
consisting of two pipes, a wall and 4 connectors

Currently two models are implemented in the
base library. One model is according to Stodola,
the other after Linnecken. The Stodola model
is an idealized turbine with an infinite number
of stages. The Linnecken model considers the
maximum mass flow rate through the turbine
stage and can be parameterized according to
the type of the turbine and the number of
stages.

A system with a parallel flow plate heat exchanger (see Figure 4) is simulated with a
temperature increase on the hot side, followed
by a pressure increase on the cold side with
according mass flow rate increase. The result
is shown in Figure 5.

5.4 Reservoirs

What can be seen from the results is that an increase in the temperature on the hot side also
increases the temperature on the cold side.
Since this is a parallel flow heat exchanger, the
temperature difference between the hot and
the cold side also increases. The following flow
increase on the cold side causes the temperature difference between the hot and the cold
side to increase, and the temperature on the
hot side drops accordingly due to the increase
in the heat flow to the cold side.

Some thermo-hydraulic systems are closed
systems, e. g., power plants or refrigeration
systems. But for general modeling purposes,

Using the components implemented in the
library, it is possible to build also more complex
systems, e. g., power plants, see Figure 6.

of what one model contains, the advantages
with a more maintainable structure are bigger.
Some further conclusions:

Fig. 5

Resulting temperatures from simulating the
system in Figure 4

Fig. 6

Example system

7. Conclusion
In the design of the base library, the concepts
of object-oriented modeling have been used
to make the library flexible and easy to use.
The generalization splits a complex problem
into subproblems, which are modeled individually (e. g., balance equations, momentum equations, heat transfer) and aggregated to build
component models. This separation simplifies
library maintenance and makes building many
model variants easier.
The Modelica language offers standard objectoriented features, such as composition and inheritance as well as more advanced features
like class parameterization. Using these, basic constraints from thermo-hydraulic modeling are inherent in the library models, but
they can still be made flexible and extensible
through specialization and class parameterization. Although the decomposition of models
sometimes makes it difficult to get an overview

• Ease of use: Taking the user perspective
early in the library design process is
important for the final result.
• Nomenclature of research field: Use
of known symbols and nomenclature is
very important for the usefulness of the
library.
• No overkill: There is a risk of overstructuring using object-oriented methods.
We have also seen, that it is possible to model
complex systems with the components implemented in the library. The modeling and simulation tool DymolaTM has been used in the design of the library. Dymola has a graphical user
interface that allows drag and drop model editing, making the modeling process easier.
Please note, because of the structure of the
library only verification of the base models is
possible. Real model validation is only possible
in a system context, which has been done for
a few examples. Also, the library is meant
as a basis for further development, the basic
control volume and flow models are complete,
but there is a need for many more components
for different application areas.

7.1 Further information
For the interested reader, further information
about the ThermoFlow project can be obtained
at www.control.lth.se/˜ hubertus/ThermoFlow
or by contacting the authors.

8. References

[1] M. Abadi and L. Cardelli. A Theory of
Objects. Springer, New York, Berlin, 1996.
[2] J. Eborn, H. Tummescheit, and K. J.
Åström. “Physical system modeling with

Modelica.” In 14th World Congress of
IFAC, vol. N. IFAC, July 1999.

toolbox for modeling and simulation of dynamical systems.” SIAM Workshop, 1998.

[3] H. Elmqvist, S. E. Mattsson, and M. Otter.
“Modelica - a Language for Physical System Modeling, Visualization and Interaction.” In Proceedings of Symposium on
Computer-Aided Control System Design,
CACSD’99, Hawaii, August 1999. IEEE.
Plenary paper.

[13] W. Wagner and A. Kruse. Properties of
water and steam. Springer, Berlin, 1998.

[4] M. O. McLinden, S. A. Klein, E. W.
Lemmon, and A. P. Peskin. NIST Thermodynamic and Transport Properties of
Refrigerants and Refrigerant Mixtures—
REFPROP. U. S. Department of Commerce, version 6.0 edition, January 1998.
[5] Modelica Design Group. “The Modelica Language Specification.” Version 1.3,
http://www.modelica.org/, 1999.
[6] S. V. Patankar. Numerical Heat Transfer
and Fluid Flow. Hemisphere Publishing
Corporation, 1980.
[7] R. C. Reid, J. M. Prausnitz, and B. E. Poling. The Properties of Gases and Liquids.
Mc Graw Hill, Boston, Massachusetts,
1987.
[8] H. Tummescheit. “Object-oriented modeling of physical systems, part 11.” Automatisierungstechnik, 48:2, 2000. In german.
[9] H. Tummescheit. “Object-oriented modeling of physical systems, part 12.” Automatisierungstechnik, 48:4, 2000. In german.
[10] H. Tummescheit and J. Eborn. “Design
of a thermo-hydraulic model library in
Modelica.” In Zobel and Moeller, Eds.,
Proc. of the 12th European Simulation
Multiconference, ESM’98, pp. 132–136,
Manchester, UK, June 1998. SCS.
[11] F. J. Wagner and M. Z. Poulsen. “C++
toolbox for object oriented modeling and
dynamic simulation of physical systems.”
SIMS Conference, Linkoeping, 1999.
[12] F. J. Wagner, M. Z. Poulsen, P. G. Thomsen, and N. Houbaok. “Object oriented

-$QGUHDVVRQ$0|OOHU02WWHU
0RGHOLQJRID5DFLQJ&DUZLWK0RGHOLFD
V
0XOWL%RG\/LEUDU\
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Modeling of a Racing Car with Modelica’s Multi-Body Library
Johan Andreasson, DLR, Germany (T96 ANO@t.kth.se)
Andreas Möller, Dynasim AB, Sweden (mra@ffa.se)
Martin Otter, DLR, Germany (Martin.Otter@dlr.de)

Abstract

the following properties of the different parts of the
vehicle:

The modular modeling of the 3-dimensional mechanics of a racing car with Modelica is discussed. For ex- Mechanics: The driver sits in a low position and the
fuel tank is placed around the centre of mass to
ample, one base model class of the wheel suspension
not effect the weight distribution during a race.
is defined and used to model 4 occurences in the front
The engine and the integrated gearbox are placed
and rear suspension. This model of the car is based on
between the rear axle and the driver, and work as
a new Modelica library to model 3-dimensional mea structural part of the chassis.
chanical systems. This library is explained in some
detail.
Solid mechanics: The chassis is built up like a carbon
fibre shell, a so called monocoque and all connections are stiff, especially the suspension is built up
1 Introduction
with stiff rods connected by ball joints.
In this article the modular modeling of the 3dimensional mechanics of a racing car is discussed, Vehicle dynamics: The geometry and angles are chosen in a way that conserves the wheel geometry
see figure 1 for a typical representative. The model is
during load, like cornering or braking, and comdescribed with a new Modelica library for modeling of
pensates for deformation that occurs in wheels
multi-body systems. This approach has the advantage
rims, hubs and suspension links - all for the sake
that it is straightforward to built up the system in a hito maximise the use of the tires full potential in
erarchical way from basic building blocks, such as a
every situation.
suspension or a wheel, which are in turn defined with
elements of the multi-body library. The overall model Aerodynamics: The vehicle body is slimmed to just
itself is a component which has 1D-connectors to drive
house the driver and the engine. Extensions from
the wheels and to steer the car. Using the standard
the vehicle body, such as air intake and housings
1D-mechanics libraries of Modelica it is then easy to
for the radiators, have as small projection area as
add the powertrain of the car. This racing car model is
possible. As a result, body mass is kept quite
mainly utilized to get experience with the handling of
close to the cars longitudinal axis, i.e., around this
complex vehicle models in Modelica and Dymola [2]
axis the inertia is low.
(component structuring, combining different libraries,
symbolic transformation, efficiency of simulation).

3 Libraries used for the modelling
2

Formula car characteristics

A formula car is a one seated race car with a minimal
carossery. The car model used in this article is taken
from [3] and represents a typical formula car very well
[7]. Maximum performance on smooth tarmac race
tracks is the dominating design criterion and results in

The Modelica libraries used as a basis for the modeling of the racing car are shortly discussed. These
libraries can be downloaded from the Modelica Webside (http://www.Modelica.org). They are part
of the standard distribution of a Modelica environment, such as Dymola.

Figure 1: A formula car in action, in this case, a Dallara 398 at Zandvort, NL.

3.1

Modeling of 1D mechanical components

automatic gearboxes can be modeled conveniently.
For the racing car, currently only a very simple model
The steering system and the wheel driving/braking
of the driving system is used. However, it is planned
system of the racing car are modeled with the
to add more details.
1-dimensional mechanical Modelica libraries Modelica.Mechanics.Rotational and Modelica.Mechanics.Translational. In figure 2 the 3.2 Modeling of 3D mechanical components
Rotational library is displayed. This library contains The modeling of the vehicle chassis is performed
basic elements, such as a rotational inertia, ideal with the new Modelica library ModelicaAddigearboxes, shaft elasticity, bearing friction, clutches, tions.MultiBody which is used to describe 3brakes, and sensors. Additional components dedicated dimensional mechanical systems, see figure 4. The
more specifically to power trains of vehicles, are components of the MultiBody library can be combined
available in the PowerTrain library, see [4] for details. with the 1D-mechanical libraries mentioned in the preThese two libraries allow to build up quite detailed vious subsection.
models of the mechanical part of the driving system
A simple example of the usage of this library can
of a vehicle, e.g., the detailed shifting behaviour of be seen in figure 3, where a simple pendulum with
damping in the joint is modeled. Component inertial in figure 3 defines the inertial system of the model
,GHDO3ODQHWDU\
([DPSOHV
,QWHUIDFHV
,QHUWLD
as well as the gravity acceleration. Component revolute describes a revolute joint which is connected to
/LEUDU\
/LEUDU\
,GHDO*HDU
the inertial system. The axis of rotation is defined
UDWLR
6SULQJ'DPSHU
(ODVWR%DFNODVK
to be the vector f0; 0; 1g, i.e., a vector in z-direction
,GHDO*HDU57 6SULQJ
'DPSHU
resolved in the frame at the left side of the revolute
F
G
joint. Since this frame is rigidly attached to the inerE
UDWLR
G
%HDULQJ)ULFWLRQ
tial frame, these two frames are identical. As a conse*HDU(IILFLHQF\

*HDU

&OXWFK

2QH:D\&OXWFK

3RVLWLRQ

$FFHOHUDWH

SKL
F

D

%UDNH

GDP SHU

HWD

7RUTXH

)L[HG

G

WDX

6HQVRUV

6

G

/LEUDU\

5HODWLY H6WDWHV

Figure 2: Library Modelica.Mechanics.Rotational.

LQHUWLDO
\

ER[ %RG\

[

UHY ROXW H

^`

U

^/  `

Figure 3: Example: Pendulum with damping in joint.

quence, the revolute joint rotates around the z-axis of
the inertial system.
Component boxBody defines a box. The box is
defined by lenght, width and height and some material properties, such as the density. The mass, center of mass and inertia tensor are calculated from this
data. Additionally, the shape of the box is used for animation. Finally component damper is a 1D-element
from the Rotational library and describes the velocity
dependent damping in the joint axis. It is connected
between the driving and the bearing flange of the joint.
Both of these flanges are 1D mechanical connections.
The 3D-components are connected together at
connectors Frame a or Frame b. Both connectors
define a coordinate system (a frame) at a specific location of the component, which is fixed in the component, see figure 5. The frame, i.e., the corresponding
connector, defines all the kinematic properties, such as
the absolute rotation matrix from the frame to the inertial system 0 Ta and the absolute position vector from
the inertial system to the frame origin 0 r0a , resolved
in the inertial frame. Additionally, the connector contains the resultant cut-force a fa and cut-torque a a at
the origin of the frame, both resolved in Frame a.
The Modelica MultiBody library has sublibraries
for joints, cut-joints, parts, force elements, sensors and
example systems, see upper part of figure 4. Ideally,
all elements of the library can be connected together
in any meaningful way. Unfortunately, this is not possible with the present version of this library1 . The reason is that the orientation of a coordinate system is
described with a redundant set of coordinates and this
leads to an overdetermined, but consistent, set of equations if closed kinematic loops are present. Such sys1 The next release of this library is currently under development
and has no longer the mentioned restrictions. Especially, the user
does not have to define cut-joints and can connect the joints, parts
and other elements in any meaningful combination.

connector Frame_a

f

a a

0

τ

a a

plane of cut

Ta

r

0 0a

inertial system

Figure 5: 3-dimensional mechanical connector.

tems cannot be handeled with the standard algorithms
of object-oriented modelling techniques.
Therefore, users have to remove joints, until the
resulting connection of joints and parts forms a tree.
Then the removed joints have to be added from the
special sublibrary CutJoints (and not from sublibrary Joints) to arrive at the desired mechanical
system. Cut-joints are primarily used to remove the
redundant description of the orientation.
The one-degree-of-freedom joints (Revolute, Prismatic, Screw) may have a variable structure. That
is, the joint can be locked and unlocked during the
movement of a multibody system. This feature can
be used to model brakes, clutches, stops or sticking
friction. Locking is modelled with elements of the
Rotational library, such as model classes Clutch or
BearingFriction, which can be attached to the
flange of such a joint.

4 The racing car model
The model of the racing car consists of the chassis,
the driving and steering system and the road. In the
following subsections, these components are discussed
in more detail and it is explained how subcomponents,
such as the suspension, are provided as parameterized
model classes. The most important parts of the model
are displayed in figure 6.
As already discussed in section 2, a formula car
differs in several aspects from a conventional vehicle.
For the modeling process, the most important differences are:
 In formula cars mostly ball joints are used to connect parts instead of bushings. This results in
very stiff part connections. Therefore, more parts
are kinematically constrained as it is usually the
case, leading to bigger numbers of closed kinematic loops.
 The dominating suspension linkage in a formula
car is a double wishbone linkage. This suspension type has 5 closely coupled kinematic loops.
On the other hand, a McPherson suspension often used in conventional vehicles has only 2 kinematic loops.

Since every kinematic loop introduces nonlinear equations on position variables, both the simulation and the
initialization is more difficult.

&XW-RLQWV

([DPSOHV

)RUFHV

,QWHUIDFHV

/LEUDU\

/LEUDU\

/LEUDU\

/LEUDU\

-RLQWV

3DUWV

6HQVRUV

/LEUDU\

/LEUDU\

/LEUDU\

,QHUWLDO6\VWHP

)UDPH7UDQVODWLRQ

5HYROXWH

3ULVPDWLF

6FUHZ

U

%RG\
&\ OLQGULFDO

8QLYHUV DO

3ODQDU

)UDPH$QJOHV

&\ OLQGHU%RG\

6SKHULFDO

)UDPH5RWDWLRQ

)UDPH$[HV

%RG\

%R[%RG\

U

6KDSH%RG\

U

6KDSH

)UHH0RWLRQ
U

Figure 4: Library ModelicaAdditions.MultiBody.

4.1

Driving and steering system

In subfigure 1 of figure 6 the topmost level of the vehicle can be seen. It consists of the chassis model which
has five rotational flanges (= 1D connectors visualized
by filled squares at the border of the chassis model) to
drive the four wheels and to steer the steering wheel of
the driver. Elements of the 1D-rotational library can
be used to built up quite detailled models of the power
train to drive the wheels and of the steering system. In
the figure, very simple models are used:
Via a differential gearbox, a driving torque is split
and applied to the rear wheels. The driving torque is
determined from a signal source. The front wheels
are not driven and therefore the wheel flanges have no
connection. Additionally, on all wheels a brake from
the Rotational library could be attached. The steering
angle is kinematically constrained by component Position and forced to follow the output of a signal
source. Alternatively, a torque could be used together
with a driver model which produces this torque.

4.2 Chassis model
Subfigures 2–5 of figure 6 display the various levels of
the chassis model.
Subfigure 2 is the chassis, built up from the main
car body (= rigid body + animation shape), a front and
a rear suspension. The two suspension systems are
rigidly attached to the car body. Via joint FreeMotion, the car body is connected to the inertial system,
i.e., the 6 absolute translational and rotational coordinates, as well as the 6 absolute velocity and angular
velocity coordinates of the car body are used to describe the movement of the car relatively to the inertial
system.
The generic suspension systems have a steering
connector. Since only the front wheels are steered, the
steering angle of the rear wheels are set to a fixed angle
of zero degrees via component FixedSteering.
In subfigure 3, the realization of the rear suspension can be seen. It consists of components for steering, dampers, drive train, suspension linkages, wheel
body and tyre models. These elements can be combined to build up different kinds of suspension systems. The wheels at the upper and lower part of this

7URTXH
WDX
N

^W RUTXH`

V LQH



3RVLWLRQ
SKL

/

I UHT+ ] ^ `


5

6WHHULQJ

5
)UHH0RWLRQ

[
,

/

\

/
)L[HG6WHHULQJ 

7R
5L
JK
W6
XV
SH
QV
LR
Q

55LJKW'DPSHU
D

E

[
ER

G G5LJKW'DPSHU

55LJKW&UDQN



ER[


)URP&KDVVLV

5

)URP&KDVVLV

/

56XVSHQVLRQ&HQWUH
5

5
/

5/HIW&UDQN

5

ER
[

5/HIW'DPSHU
D

/

ER
[

E

ER[

QR
LV
QH
SV
X
W6
IH
/R
7

G G/HI W'DPSHU

/

6WHHULQJ:KHHO



7R
5
LJ
KW
6X
VS
HQ
VL
RQ
[
RE

[R
E

&
U SLQLRQ3RV

)URP&KDVVLV

)UDPH7UDQVODWLRQ

&

3
&

UDWLR UDWLR:KHHO7R5DFN

:KHHO7R5DFN
ER
[

Q
R
VL
Q
H
S
V
X
W6
IH
/
R
7



IODQJHBD

&

Figure 6: Composition diagrams of the different levels of the racing car model.

subfigure consist of a wheel body and a tyre model according to [5], chapter 2.6. There are three rotational
flanges (= 1D-rotational connectors) on each suspension to regulate wheel rotation and steering wheel angle, as well as one Frame (= 3D connector) to attach
the suspension system rigidly at a specific position
and orientation on another part. The different suspension model classes have the same interfaces and are
therefore completely interchangeable. However, the
parameterization maybe different, e.g., a monodamper
suspension has only parameters to define one damper
while a twindamper has parameters for a left and a
right damper.
In subfigure 4, the implementation of a twindamper suspension is shown and in subfigure 5 the
steering system.
Finally, in subfigure 6 the model of the suspension
linkages is displayed. This part contains 5 kinematic
loops and therefore 5 cut-joints are utilized at appropriate places. The four joints at the lower left part
of this subfigure are universal joints, i.e., they have
2 degrees of freedom. In reality, spherical joints are
present at these places. The universal joints are used
in order to remove the non-interesting self rotations of
the rods of the suspension around the rod axes (since
the inertia is small around these axes, the rotation can
be neglected).
The 4 hierarchical levels of this model have been
found appropriate. Of course, one could easily remove
one level by implementing the car directly with steerings, dampers etc. and skip the level with front and
rear suspensions. Since these units are fairly separated
in a vehicle, e.g., they do not have any common closed
loops, there are no advantages of using a flatter model.
Note, that with the subcomponents used to model
the racing car, it is quite easy to describe completely
different vehicles if they have a similiar structure. To
illustrate this, a model OffRoadTruck is built up,
see figure 7.

Parameter default values
In the car component library, the parameterisation is
usually selected in such a way that the parameters
do not influence each other, i.e., if one parameter is
changed, there is usually no need to modify another
parameter as well.
For all parameters, realistic default values are
used. For example, a link arm is by default modelled as a bar with equally distributed mass, depending on the length of the rod: rCM = 2r , m = ρjrj,
I11 = m3 (r22 + r23 ) and the density ρ of, say, steel is
taken. Therefore, whenever the length of the rod is
changed, the position of the center of mass, the mass
and the inertia tensor are changed appropriately. It is
of course possible to overwrite at any time the default
values by, e.g., supplying explicit numeric values for
the mass and the inertia tensor. This approach has the
advantage that by providing only a few parameters, a
first rough model of a vehicle can be built and simulated. In further steps, the parameters can be better
adapted to the actual vehicle data by overwriting the
default values.
Parameterisation of closed kinematic loops

Usually, in every subcomponent the coordinate system of one of the 3D connectors is used as a reference
frame for this component, and all other frames are selected to be parallel to this frame. As a consequence,
all local vectors are expressed in the reference frame.
If a subcomponent is parameterized which does
not have kinematic loops, such as the damper system
in subfigure 4 of figure 6, it is most convenient to just
directly use the parameterization necessary to describe
the base components used. This means, e.g., that position vectors are defined as relative quantities between
local frames.
On the other hand, if a subcomponent has kinematic loops (see, e.g., subfigure 6 of figure 6) such a
parameterization leads to difficulties, since the gener4.3 Parameterisation of subcomponents
alized coordinates of the joints in the loops have to be
determined at initial time by the solution of nonlinear
In order that the subcomponents displayed in figure 6
algebraic equations where the start values may not be
are reusable, an appropriate parameterisation has to be
good. It is more robust to select as independent pautilized. Some aspects shall be discussed:
rameters the position vectors from the reference frame
to the ”essential“ points, e.g., the connection points, at
the initial configuration and compute the needed relative position vectors by simple vector addition rules.

R

L

R

R

R

L

L

L

Fixed=0

R
L

Figure 7: The FormulaCar compared to the OffRoadTruck model. Already defined components can be
reused to built-up easily quite different cars.
As a consequence, at the initial position the kinematic is present, and function road is called when needed in
loops are always consistent.
the tyre model. Whenever this function is called, the
actual function body is searched all the levels up in the
model hierarchy, until a corresponding inner declara4.4 Road
tion of the following form is found:
The wheel and tyre models need the altitude and the
inner function road = roadProfile1;
friction coefficient at the point of contact of a tyre with
the road. Changing the road description should not re- In this case, the actual function called in the tyre model
quire to modify the car model itself. Since the road and instances is function roadProfile1. As a consequence,
the tyre exchange data, the standard way in Modelica the road properties can be defined at the top-level of
would be to have a road component which is connected the model and can also be easily changed. Usually,
to all four wheels of a car. This would result in a close a function is supplied which reads a table from a file
coupling of car and road model.
defining the road profile. To summarize, inner/outer
A better alternative is to see the road as a physical functions in Modelica can be seen as pointers to funcfield and use the inner/outer Modelica language tions where the actual function body is defined at
constructs designed for the description of such fields. higher hierarchical levels.
In this case, the prototype of a function for the road
properties is defined as:
partial function roadInterface
input Real x
"x-position";
input Real y
"y-position";
input Real v
"velocity";
output Real z
"z-position";
output Real mue "friction coeff.";
end road;

that is, given the x- and y-coordinates of a contact
point, as well as the absolute value of the velocity
vector at the contact point parallel to the road, the zcoordinate of the road and the coefficient of friction at
this point are computed. Within the wheel/tyre model,
a declaration of the form
outer function road = roadInterface;

5 Simulations results
The overall model of the racing car consists of 73
bodies with shape information for animation, 92 revolute joints, 24 spherical joints and 24 closed kinematic
loops. Dymola needs a few minutes on a PC to transform this system to state space form with 30 states and
about 6500 algebraic variables (reduced from a set of
about 60000 unknown algebraic variables).
In figure 8 the animation view of the racing car is
shown. It consists of a CAD-picture of the main body
and of graphical objects, such as cylinders and boxes,
to display other parts, such as the suspension systems.
In figure 9 a typical simulation result of a driving manoeuvre is shown, where the racing car drives
through a curve and starts to skid.

7 Acknowledgments

Figure 8: Animation view of racing car model.

The development of the ModelicaAdditions.MultiBody library was in parts supported by the European
Commission under contract IST-199-11979 with DLR
under the Information Societies Technology as the
project entitled ”Real-time simulation for design of
multi-physics systems”.
The authors would like to thank Hilding Elmqvist,
Matthijs Langelaar, Sven Erik Mattsson, Hans Olsson
and Andrea Burzoni for their support.

References
[1] ADAMS. Mechanical Dynamics Inc., Homepage:
http://www.adams.com/
[2] Dymola. Homepage: http://www.dynasim.se/
[3] Möller A: Studies of Race Car Vehicle Dynamics.
Master thesis, Lund Institute of Technology, Division
of Mechanics, 1999.

Figure 9: Driving through a curve with skidding.

6

Conclusions

The racing car model described in this article demonstrates that it is possible and suitable to model large
3-dimensional mechanical systems with Modelicas
multi-body library. Since it is very easy to combine
this library with other Modelica libraries, such as 1dim. Rotational-, PowerTrain-, Hydraulics-, Blockslibrary, it is straighforward to add detailled models of
other components of the car, such as the power train.
In [6] the results of a feasibility study are presented, where a detailed model of a conventional vehicle has been realized, including the 3-dim. model of
the chassis, engine, automatic gearbox and hydraulics
to control the gearbox, as well as simulations performed in Dymola. For the 3D-mechanics part, an existing ADAMS [1] model of the vehicle chassis was
used and transformed to Modelica with a newly developed translator.
The racing car model shows clearly that it is
advantageous to model the vehicle mechanics directely in Modelica, because the hierarchical structering makes it possible to browse and understand all the
details of the model and to re-use subcomponents for
other vehicles.

[4] Otter M., M. Dempsey and C. Schlegel: Package
PowerTrain: A Modelica library for modeling and
simulation of vehicle power trains. In Proceedings of
Modelica’2000, Lund, Oct. 2000.
[5] Rill G.: Simulation von Kraftfahrzeugen. Vieweg,
1994.
[6] Tiller M., Bowles P., Elmqvist H., Brück D.,
Mattsson S.-E., Möller A., Olsson H. and Otter M.:
Detailed Vehicle Powertrain Modeling in Modelica.
In Proceedings of Modelica’2000, Lund, Oct. 2000.
[7] William F. and Milliken D.L.: Race Car Vehicle
Dynamics, 1995.

%%DFKPDQQ+:LHVPDQQ
$GYDQFHG0RGHOLQJRI(OHFWURPDJQHWLF7UDQVLHQWV
LQ3RZHU6\VWHPV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Advanced Modeling of Electromagnetic
Transients in Power Systems
Bernhard Bachmann
University of Applied Sciences
Bielefeld, Germany

Hansjürg Wiesmann
ABB Corporate Research
Baden, Switzerland

September 20, 2000

Abstract
Simulation of fast and slow dynamic behavior
of electrical power systems is needed for many
industrial applications. The results influence the
development of electrical and mechanical components and the design of control elements in
power systems. Examples are






Mechanical stresses on network elements
Control systems of turbines and generators
Settings of protective relays
Transient stability of power systems

Important phenomena to be simulated are i.e.
synchronous stability, machine dynamics, subsynchronous resonance, influence of load variations, switching and lightning overvoltages, and
saturation effects.
The conventional and functional grouping of
simulation tools into power flow-, short circuitand dynamic calculations was necessary in the
past for computation reasons. Traditional simulation tools are especially designed for each application, seperated by the different time constant of interest.
Power flow calculations are needed for stability
investigations in electrical power systems. Simulation tools like PSS/E and Simpow, [10, 11]
are able to compute the long term dynamics.
In order to calculate fast transients caused by
switching and lightning, etc. detailled models
of the network components are needed (realized
i.e. in EMTP, EMTDC, Netomac, etc. [7, 8, 9])
The numerical schemes implemented are based
on [4] and discussed in detail in [5]. Drawbacks have been identified and compared to a
pure state space representation.

The effizient object-oriented hierarchical modelling language Modelica enables the graphical definition of complex networks. The used
components are defined by their differential algebraic equations (DAE). Simulation tools [1]
transform the overall differential algebraic system to a state space representation. The individual components are depending on the application (time constraints) and can be variied
in compexity. The component interfaces are
kept equal, which enables an easy exchange of
simple to complex components. This concept
enables the simulation of electrical, mechanical and control application and combines power
flow-, short circuit- and dynamic calculations
within one simulation environment.

1 Introduction
Important for object-oriented modelling of a
physical domain is the determination of the
component interfaces. For electrical power systems, this is done by the following considerations.
The simulation of the dynamical behavior of a
synchronous machine is usually formulated using the two-axis theory of Park [2, 6]. This
theory is based on the mathematical description
(Park-Transformation P) of a 3-phase rotating
system (voltages Uabc and currents Iabc ) by the
diagonal components of the rotor (Udq0 , Idq0 ).
For θ = ωt + φ, with ω angular velocity, t simulation time and φ initial angle, the following
mathematical relations hold:

q2 0
P= 3@

cos(θ)
sinp
(θ)
1= 2

cos(θ
sin(θ

2π
3 )
2π
3 )

p

1= 2

cos(θ
sin(θ

1
p A
1= 2
4π
3 )
4π
3 )

P  PT

= Id

00
1
T
@1
ω  P  der(P) =
0

1
1 0
0 0 A =: y
0 0

Uabc = PT  Udq0 ; Iabc = PT  Idq0
P  der(Iabc ) = der(Idq0 ) + ω  y  Idq0

The identification and determination of the
model parameters of a component within electrical power systems is very difficult and timeconsuming. The model parameters are often determined based on measurement data. The calculations are in general well-known, and in example for the generator described in [3]. These
pre-calculations should not be mixed with the
dynamical simulation and be done in advance.
This can be realized in Modelica by using corresponding functions, so that the user has only
to input the given measurement data for a simulation run. For the following model component
equations these pre-calculations are considered
as given.

The quantaties Udq0 and Idq0 are constant in case
of a non-disturbed steady state, e.g. fixed rotating frequency of the rotor. (see figure 3, 4).
These consideartions can be generalized to all
model components of electrical power systems
that are described in this paper. Therefore, the
definition of the interfaces is dependend on Udq0
as potential variable and Idq0 as flow variable.
The following example of an inductive element
describes the changes in the differential equations (in the dq0-system), which are due to the 3PhaseStar
Park-transformation.

basic components

f0 0
;

;

p
3  ung = udq0
p
3  i0 = in

der(L  Iabc ) = Uabc
LP  der(Idq0 ) + ω  y  LP  Idq0 = Udq0
The matrix LP = P  L  PT is for all model components (generator, transformer, load, etc.) constant (e.g. independent of time). This finally
leads to a system of DAEs, that can be solved
very efficiently.
When modelling electrical power systems, it is
common to formulate the equations of different
components dependend on a base voltage Ubase
and a base power Pbase . The so-called per unit
modelling allows, therefore, a description of the
model component independent of the surrounding system. This results in the following recalculations:
Idq0 = Ibase  idq0
Udq0 = Ubase  udq0
The differential equation for the inductive element can be rewritten in per-unit quantaties as
follows:

3PhaseResistor

3PhaseInductor

3PhaseCapacitor

r  idq0 = udq0

x  der(idq0 )+

ωyx  idq0 = udq0

c  der(udq0 )+

ωyc  udq0 = idq0

Table 1: Basic component models

2 Basic Components

The most simple 3-phase basic model components necessary for building an electrical power
x  der(idq0 ) + ω  yx  idq0 = udq0
system are shown in table 1. The component
equations on the right column of the table are
Due to the Park-transformation, x and y are the given in per unit (p.u.). The star-connector gives
resulting normalized reactance-matrix and ro- the possibility to couple also 1-phase electrical
model components, necessary i.e. for grounding
tating matrix, respectively.

Figure 1: Object-diagram of a linear ∆/Y-Transformer.
elements of transformers and generators. Using 4 Mechanical Components and
hierarchical connections of these basic compoControl System
nents, other linear models can be easily generated (i.e. inductive-capacitive load, pi-element The turbine model components can be described
of a transmission-line, etc.).
in different complexity by using the Modelica
library Rotational1D. For applications, where
stress effects of turbine and generator, or the
3 Transformer and Generator
movement of masses of generator, exciter and
When modelling transformers in Modelica, a turbine group can be neglected, all masses can
special treatment can be done in order to seper- be combined to one mass or it can be assumed
ate the topology information (∆- / Y- Connec- that an infinite mass is given. This corresponds
tors) from the magnetic coupling of the individ- to simulation with constant velocity. The control system can be defined by using the model
ual phases (see figure 1).
As a result, the magnetic coupling can be de- components of the Modelica Block library.
scribed with different complexity based on the
phenomena of interest, i.e. losses, saturation
and internal faults can be include if important
for the corresponding simulation application.
The differential algebraic equations of a linear
3Phasetransformer model are given as follows:



hybrid elements
0 = if (Opena ) then
der(ia ) else ua
0 = if (Openb ) then
der(ib ) else ub

Switch

0 = if (Openc ) then

Delta-Connector

der(ic ) else uc

vdq = fuq ; ud g, idq = f jq ;jd g,
v0 = 0, i0 = 0

f0 0 0g = if Fault then
fua ub
;

;

;



Y-Connector
vdq0 =udq0

f0 0
p

un =rn in , in =



;

;

p

3i0

ABCFault

3un g, idq0 =jdq0 ,

ub

uc ;

sum(der(iabc ))g
else der(iabc )

Table 2: Switch and 3-phase fault
Trafo-Coupling
x1  der(j1dq0 )+
(ωyx + r)1 j1dq0 = (v1dq0 v0dq0 )
x2  der(j2dq0 )+
(ωyx + r)2 j2dq0 = (v2dq0 v0dq0 )
xcpl  der(jmdq0 )+
ωyxcpl jmdq0 =v0dq0
jmdq0 =j1dq0 +j2dq0

5 Ideal Switches and Faults

When simulating switches and faults, the 3
phases of a model component have to be
considered seperately and be written in abcrepresentation. Table 2 shows the corresponding equations for the switch and the 3-phase
Modelling of generators leads to equations with fault. Having switches or faults in a differential
algebraic equation system results in general in
analog structur as described in [2, 6].

Figure 2: Object-diagram of the simulation
so-called higher index problems and variing index of the DAE during switching and fault scenario. Therefore, the equations have to be formulated differentiated. The boolean variables
Opena ; Openb ; Openc and Fault have to be determined, so that the switch can only be operated, when the current crosses the zero line.
This is true for simulating a fault or switch in
series to an inductive element. If a capacitive
element is parallel to a switch or fault analog
considerations result in differentiating the voltages uabc . In this case, operating the switch or
fault can only be done when the corresponding
voltage crosses zero. Other 3-phase fault types
are given by:



ABCG-Fault:

f0 0 0g = if Fault then uabc
;

;

else der(iabc )



AB-Fault:

f0 0g = if Fault then fua

ub ;
sum(der(iab ))g
else der(iab )

;

0 = der(ic )



ABG-Fault:

f0 0g = if Fault then uab else der(iab )
;

0 = der(ic )



AG-Fault
0 = if Fault then ua else der(ia )
f0; 0g = der(ibc )

Cyclic permutations of the variables ia ; ib ; ic and
ua ; ub ; uc result in further fault-types.

6 Initialization
Due to the representation of the overall system in dq0-coordinates, the initialization can be
done with the same differential algebraic system
that is later used for the dynamic simulation. In
existing simulation tools (EMTP, EMTDC, Netomac, etc.) a seperate equation system for the
initialization process has to be generated. This
is only necessary, when representing the equations in the abc-system. In this case, the currents
and voltages are not constant for the stationary
state (see figure 3).
The initialization of the switch and fault model
components is simple, since in example the
switch is either open (Iabc = f0; 0; 0g) or closed
(Uabc = f0; 0; 0g), before the simulation starts.
Similarly, the fault is not present when initializing the system (Iabc = f0; 0; 0g).

7 Simulation
For the application example defined in figure 2
the following fault szenario has been simulated.
First, the stationay state has been initialized and
kept for 0.03 seconds (see figure 3,4).
During the stationary state a constant power is
flowing across both transmission lines into the
infinite bus. Then a 3-phase fault is initiated in
the middle of the transmission line RX f. At
0.05 seconds the two switches Switch1, Switch2
receive a signal to take off the faulted transmission line. The abc-currents have been cut off
when crossing the zero line (see figure 5). This

0.2

0.5

0.15

0

0.1

−0.5

0

i

i

dq0

abc

−1

(p.u.)

(p.u.)

0.05

−1.5
−0.05

−2
−0.1

−2.5

−0.15

−0.2

0

0.02

0.04

0.06

0.08
time (sec)

0.1

0.12

0.14

−3

0.16

Figure 3: Stationary state (abc-phase-system)

0

0.02

0.04

0.06

0.08
time (sec)

0.1

0.12

0.14

0.16

Figure 6: Fault szenario (dq0-phase-system)

0.2

tor Circuits. IEEE Transactions on Energy
Conversion, Vol. 8, No. 2, pp. 280-296,
June 1993.

0.15

0.1

(p.u.)

0.05

i

dq0

0

−0.05

[3]

Canay, I.M.: Determination of the Model
Parameters of Machine from the Reactance Operators xd ( p); xq ( p). IEEE Transactions on Energy Conversion, Vol. 8, No.
2, pp. 272-279, June 1993.

[4]

Dommel, H.W.: Digital Computer Solution of Electromagnetic Transients in
Single- and Multiphase Networks, IEEE
Transactions on Power Apparatus and
Systems, Vol. 88, No. 4, pp 388-399, April
1969.

−0.1

−0.15

−0.2

0

0.02

0.04

0.06

0.08
time (sec)

0.1

0.12

0.14

0.16

Figure 4: Stationary state (dq0-phase-system)

corresponds to an ideal description of a switch.
The signals are in general given by a protection
relay. Later in the simulation the transmission
line is again inserted in the system by re-closing
the switch. After a certain time the stationary [5]
case is again reached. This can be seen most
clearly in the dq0-system (see figure 6).
2.5

2

Linnert, U. und Hosemann, G.: Neue
Methoden zur Netzsimulation im Zustandsraum verglichen mit dem Differenzenleitwertverfahren, Arch f. Elektrotech. 77,
pp. 415-423, 1994.

1.5

1

[6]

Anderson, P.M. und Fouad, A.A.: Power
System Control and Stability, IEEE Press
Power Systems Engineering Series, 1994.

[7]

EMTP: Homepage:
http://www.emtp96.com/

[8]

EMTDC: Homepage:
http://www.hvdc.ca/

[9]

Netomac: Homepage:
http://www.ev.siemens.de/

0

i

abc

(p.u.)

0.5

−0.5

−1

−1.5

−2

−2.5

0

0.02

0.04

0.06

0.08
time (sec)

0.1

0.12

0.14

0.16

Figure 5: Fault szenario (abc-phase-system)

References
[1]
[2]

Dymola: Homepage:
http://www.dynasim.se/
Canay, I.M.: Modeling of AlternatingCurrent Machines having Multiple Ro-

[10] PSS/E: Homepage:
http://www.pti-us.com/
[11] Simpow: Homepage:
http://www.abb.com/powersystems

3%HDWHU
0RGHOLQJDQG'LJLWDO6LPXODWLRQRI+\GUDXOLF
6\VWHPVLQ'HVLJQDQG(QJLQHHULQJ
(GXFDWLRQXVLQJ0RGHOLFDDQG+\/LE
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

0%HXVFKHO
$8QLIRUP$SSURDFKIRU0RGHOLQJ(OHFWULFDO
0DFKLQHV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

A Uniform Approach for Modeling
Electrical Machines
Michael Beuschel

Abstract
In this paper, an approach is presented that enables
uniform modeling of different types of electrical machines using a novel Modelica library of magnetic
components. Results of simulations with Dymola are
presented. This approach is also applicable to education.

magnetic potential difference ∆θx , ∆θy are used in
2-dimensional space vector representation including
real and imaginary part (x- and y-axis respectively).
This is reflected by the definition of magnetic connectors MagP and MagN, which only have different icons
to identify more easily the pins of a component (see
Fig. 1).

2.2 Basic Magnetic Components

1

Introduction

Modelica provides a very general approach of modeling physical systems. Libraries for electrical and electronic as well as for mechanical components are already distributed on an open source code basis.
Based on this, a new library1 for modeling rotational
magnetic fields has been developed also including interfaces to electrical and mechanical components.
In this paper, rotary electro-magnetic motors are
considered. Basically, different types of electrical machines employ the same physical principle: A magnetic field is produced that always tends towards a state
of minimal energy. This is achieved by a change of the
rotor position, which is the desired effect of a motor.

2

A Modelica Library of Magnetic
Components

Calculation of magnetic circuits is often done using a
notation similar to that of electrical circuits. Therefore, the magnetic flux ψ and the magnetic potential
difference ∆θ can be treated like current i and voltage v
respectively. These are used in the following to model
magnetic components.

2.1

Magnetic Connectors

As the focus of this paper is on modeling rotating
electrical machines, both magnetic flux ψx , ψy and
1 For

details on the Modelica implementation, please see the
appendix.

Some basic magnetic components have been implemented (see Fig. 1).







As in electrical circuits, a magnetic ground
(MagGround) is mandatory in every magnetic
circuit model to define the “magnetic potential”
for simulation.2
θx

=

0

θy

=

0

(1)

A permanent magnet is a magnetic source (MagSource), that generates a magnetic potential
difference ∆θ with angular orientation β.
∆θx

=

∆θ cos(β)

∆θy

=

∆θ sin(β)

(2)

A linear magnetic resistance (MagResistance) connects the magnetic potential difference with the magnetic flux by

with

ψx Rm

=

∆θx

ψy Rm

=

∆θy

=

2

Rm

(3)

N =M

The magnetic resistance Rm is determined by the
number N of turns and the corresponding (electrical) inductance M. For 2-dimensional simulation,
the above operation is calculated for the real and
imaginary part of the magnetic field separately.

Figure 1: Basic magnetic components

system. This is why the negative mechanical angle
Zϕ is used here instead of β. Z scales the mechanical angle to obtain the magnetic one, where Z
is half the number of poles. The mechanical connector flange b can be connected to components of the
Modelica.Mechanics.Rotational library.

2.5 Stator and Rotor
Employing basic magnetic components, interfaces
to electrical and mechanical components are discussed To model the interaction between the stationary and
rotational part of electrical machines, a stator rotor
in the next section (see Fig. 2).
block (StatorRotor) is employed. It provides
transformation between stator and rotor coordinates
and calculates the mechanical torque τ from magnetic
flux ψx , ψy and potential difference ∆θx , ∆θy .

Figure 2: Magnetic interface components

2.3

0

=

ψ1x

+

ψ2x cos(Z ϕ)

0

=

ψ1y

+

ψ2x sin(Z ϕ) + ψ2y cos(Z ϕ) (6)

∆θ1x

=

∆θ2x cos(Z ϕ)

∆θ1y

=

∆θ2x sin(Z ϕ) + ∆θ2y cos(Z ϕ)

τ

=

Z ψ2x ∆θ2y

+

ψ2y sin(Z ϕ)

∆θ2y sin(Z ϕ)
Z ψ2y ∆θ2x

(7)
(8)

Magnetic Coupling

A linear magnetic coupling (MagCoupling) is based
on the electrical OnePort class. It relates electrical
voltage v and current i to magnetic potential difference 3 Modeling Electrical Machines Usand flux due to the induction law. An additional scaling the Magnetics Library
ing factor k adjusts magnetic to electrical values due to
simplified modeling and field geometry.
The components of the magnetics library have been


tested implementing common electrical machines in
dψy
N
dψx
v =
cos(β)
+ sin(β)
(4) the Dymola simulation environment. In Figure 3 the
k
dt
dt
corresponding icons of a DC machine, a permanent
∆θx = k N i cos(β)
magnet DC machine, an induction AC machine and a
∆θy = k N i sin(β)
(5) permanent magnet synchronous AC machine are displayed.
N is the number of turns; β gives the orientation of
the winding. Combining a magnetic coupling with a
magnetic resistance (3), the well known equation v =
M di=dt of an inductance is obtained.

2.4

Commutator

Figure 3: Electrical machine models (icons)
A commutator block (Commutator) is based on the
block magnetic coupling with additional rotation of
the magnetic field orientation due to the function of
a commutator in DC machines.
As the winding of a rotor moves forward the mag- 3.1 DC machine
netic field rotates backwards in the rotor coordinate Figure 4 shows the implementation of the DC ma2 In physics no magnetic monopole is known. Thus, the “mag- chine. The stator winding provides the flux due to
netic potential” θ ist only used in the magnetic ground and the the stator current IS through PositivePin1 and Negamagnetic connector classes to distinguish from the magnetic po- tivePin1. The related magnetic field is applied to the
tential difference ∆θ that always needs two reference points.

DC machine

Speed and Torque

150
Speed [rpm]
Torque [Nm]
100
50
0
−50

0

0.02

0.04

0.06

0.08

0.1
Time [s]

0.12

0.14

0.16

0.18

0.2

0.06

0.08

0.1
Time [s]

0.12

0.14

0.16

0.18

0.2

30
Stator Current [A]
Rotor Current [A]
Current

20
10
0
−10

0

0.02

0.04

Figure 5: DC machine simulation results

2=π for the flux has to be introduced in the magnetic
coupling block in order to model (9) and (10) correctly.
Hence, the magnetic potential difference ∆θy and, applying the magnetic ressistance Rm , the magnetic flux
ψy are:

Figure 4: DC machine implementation

stator rotor block at an angle of 90Æ using a magnetic
coupling block.
The magnetic resistance Rm is determined by the inductance LR and the number NR of turns of the rotor
winding, which also has to match the corresponding
commutator block.
The induced voltage (back emf) is calculated employing (4). Whereas the orientation of the flux is constant in stator coordinates, from the view point of the
rotor coordinate system it rotates. This is achieved by
introducing a commutator block. The number of poles
(2Z) has to be identical for the stator rotor block as
well as for the commutator, of course.
Employing the flux ψS = ∆θS =Rm = LS IS =NS of the
stator winding and the magnetic potential difference
∆θR = IR NR caused by the rotor current IR through PositivePin2 and NegativePin2, the torque τ the and induced voltage vi of the DC machine can be calculated
employing the machine constant km = 2ZNR =π.
τ

=

2
 Z ψSNRIR
π
2
 Z ψSNR ω
π

=

∆θR
km ψS 
NR

2
∆θS
π
2
ψy = ψS
π

∆θy

=

An acceleration procedure of this machine using another current controller for the rotor current IR as well
as a speed controller and applying a load torque of
20 Nm has been simulated, see Fig. 5.
The data of the implemented DC machine are as
follows:
Inductance Stator
Inductance Rotor
Turns Stator Winding
Turns Rotor Winding
Resistance Stator
Resistance Rotor
Number of Poles / 2
Mass Inertia

LS
LR
NS
NR
RS
RR
Z
J

=
=
=
=
=
=
=
=

6.4
4.0
2400
60
1.0
0.25
4
0.43

H
mH

Ω
Ω
kg m2

(9)

(10) 3.2 Permanent Magnet DC Machine
The DC machine has then been modified using a perAssuming an ideal DC machine, the flux ψS is almost manent magnet to provide the flux at an angle of 90Æ
equally spread over 180Æ =Z of the airgap. In the same (see Fig. 6). The magnetic potential difference ∆θy of
way, also the rotor current IR is the same for alle turns the magnetic source is set to get the same flux ψy as
(depending on the type of the rotor winding).
above. The scaling factor k is included, too.
However, as the magnetics library employs a space
2
vector representation of the flux, a scaling factor k =
∆θy =  IS NS
(11)
π
vi

=

= km ψS ω

The same acceleration procedure as in Fig. 5 has been
simulated, see Fig. 7.

Figure 8: Induction AC machine implementation

Commonly, the mutual inductance M is referred to a
single phase and is defined using the amplitude of the
Figure 6: Permanent magnet DC machine implemen- flux vector j~ψj and the peak phase current IbS .
tation
j~ψj
M = NS
(12)
IbS
Permanent Magnet DC machine

Speed and Torque

150
Speed [rpm]
Torque [Nm]

100
50
0
−50

0

0.02

0.04

0.06

0.08

0.1
Time [s]

0.12

0.14

0.16

0.18

0.2

Figure 7: Permanent magnet DC machine simulation
results

3.3

Simulation of an Induction AC Machine

Employing components of the magnetics library, also
an induction AC machine has been implemented (see
Fig. 8). The three stator windings are modeled separately, including resistance RS and leakage inductance
LSσ each. They are coupled to the magnetic circuit using magnetic coupling blocks at angular orientation of
0Æ , 120Æ and 240Æ .
The magnetic resistance Rm may either be applied
to the stator or to the rotor side of the magnetic circuit (the first one is chosen here). The magnetic resistance is determined by the mutual inductance M and
the number NS of turns in each stator winding, which
has to match the number of turns in the corresponding
magnetic coupling blocks.

Figure 9: Space vector representation of stator current
IS
The amplitude of the magnetic potential difference
vector j∆~θj is (see also Fig. 9)


 ~
∆θ

=




Æ

NS ISa (t ) + ISb (t ) e j 120



+ ISc (t ) e

j 240Æ 


3
N IbS
(13)
2
which determines the actual magnetic resistance Rm
using j~ψj and j∆~θj as
=



 ~
∆θ

Rm

=

jψj
~

=

3
NS IbS
2
Mb
IS
NS

=

3 NS2

2 M

(14)

The same calculation is applied to the leakage inductances LSσ and LRσ .3
The rotor has to employ at least two windings at
equally spaced angle. In the example in Fig. 8, a 3phase rotor winding is modeled.
A start-up of this machine connected to symmetric
3-phase mains (ve f f = 230V , f = 50 Hz) and applying
a load torque of 20 Nm has been simulated, see
Fig. 10. The data of the implemented induction AC
machine are as follows (all numbers of turns equal 1):

Leakage Inductance Stator
Leakage Inductance Rotor
Mutual Inductance
Resistance Stator
Resistance Rotor
Number of Poles / 2
Mass Inertia

LSσ
LRσ
M
RS
RR
Z
J

=
=
=
=
=
=
=

2.1
1.9
32.2
324
203
3
0.8

mH
mH
mH
mΩ
mΩ
kg m2

Induction AC machine
Speed [rpm]
Torque [Nm]

Speed and Torque

1000
800
600
400
200
0
−200
0

0.1

0.2

0.3
Time [s]

0.4

0.5

Figure 11: Synchronous AC machine implementation

Figure 12 shows simulation results of the synchronous AC machine. The stator windings have
been connected to a frequency and amplitude sweep 3phase supply. The magnetic source applies a magnetic
potential difference ∆θ = NS IS = 5 A that corresponds
to a flux of ψ = ∆θ=Rm = 1:71Vs. The data of the
damping windings of the implemented machine are as
follows:

0.6

Leakage Inductance Rotor
Resistance Rotor

400
Stator Current [A]
Rotor Current [A]
Current

200

LRσ
RR

=
=

1.0
40

mH
mΩ

0

Synchronous AC machine

−200

Speed [rpm]
Torque [Nm]

−400

0

0.1

0.2

0.3
Time [s]

0.4

0.5

0.6

Figure 10: Induction AC machine simulation results

Speed and Torque

1000
800
600
400
200
0
−200
0

0.1

0.2

0.3

0.4

0.5
Time [s]

0.6

0.7

0.8

0.9

1

3.4

Permanent Magnet Synchronous AC Machine

Voltage and Current

400
200

Stator Voltage [V]
Stator Current [A]

0
−200

Based on the above induction machine, a synchronous
−400
0
0.1
0.2
0.3
0.4
0.5
0.6
0.7
0.8
0.9
1
Time [s]
AC machine has been simulated, where the rotor flux
is provided by a permanent magnet (see Fig. 11). The
stator is identical to the induction machine. At the ro- Figure 12: Synchronous AC machine simulation retor, a 2-pole damping winding has been introduced to sults
obtain a smooth torque output without vector control.
3 For an improved version of the magnetics library, 3 magnetic
resistances related to the 3 windings should be employed rather
than a single inductance. However, this would require angle sensitive magnetic resistances that are not yet implemented. Alternatively, the leakage inductances can also be implemented in the
electrical circuits.

4 Conclusion
A new Modelica library of magnetic components has
been implemented and tested simulating DC and AC

machines. Simulation results have been validated using conventional motor models.
The presented approach enables a uniform and intuitive modeling of different types of electrical machines. It also shows that different types of electrical
machines employ the same basic principles. Therefore, this approach might be attractive especially for
education purposes.
However, due to redundant model variables compared to conventional models, the presented approach
is not optimized in terms of simulation efficiency. It
also appears to be numerically more sensitive. Therefore, the quality of simulation results significantly depends on the integration algorithm and its tolerance
setting.

5

Outlook

TU München, 1993.
[4] Schröder, D.:
Elektrische Antriebe 2 – Regelung von Antrieben.
Springer–Verlag, Berlin, 1995.

Michael Beuschel studied at the Technical University of Munich, Germany, and
at the University of Sussex, England. He
received his Dipl.-Ing. degree in electrical
engineering in 1996.
Since 1996 he has been with the Power
Electronics and Electrical Drives Department of the Technical University of Munich as a research assistant. His research
interests include signal analysis as well as nonlinear control applications of electrical drives.

Further investigations should be done regarding the
magnetics library itself as well as its application.
A variable magnetic resistance, a nonlinear mag- Appendix:
netic resistance Rm (∆θ) and a magnetic resistance
Modelica Package ”Magnetics”
Rm (β) with angular orientation should be introduced
to enable modeling of e.g. saturation, variable air gap This package will become available on the Modelica
and reluctance effects (e.g. switched reluctance mo- homepage http://www.Modelica.org/library/library.html.
tors). Furthermore, the existing components can be
improved employing a vector implementation. This package Magnetics
would extend the library to 3-dimensional modeling
connector MagP "Positive magnetic pin"
SIunits.MagneticPotentialDifference theta_x;
(e.g. of magnetic bearings).
SIunits.MagneticPotentialDifference theta_y;
flow SIunits.MagneticFlux psi_x;
The presented models of electrical machines can
flow SIunits.MagneticFlux psi_y;
end MagP;
then be refined and extended, e.g. by modeling leakage effects by individual magnetic components. In
connector MagN "Negative magnetic pin"
SIunits.MagneticPotentialDifference theta_x;
addition, also other magnetic devices such as 1-phase
SIunits.MagneticPotentialDifference theta_y;
flow SIunits.MagneticFlux psi_x;
and 3-phase transformers can be modeled employing
flow SIunits.MagneticFlux psi_y;
end MagN;
the magnetics library.

References

class MagGround "Magnetic ground"
Modelica.Electrical.Analog.Magnetics.MagP mag_p;
equation
mag_p.theta_x = 0;
mag_p.theta_y = 0;
end MagGround;

[2] Fischer, R.:
Elektrische Maschinen.
Hanser–Verlag, München, Wien, 1979.

class MagSource "Magnetic potential difference source"
parameter SIunits.Angle beta=1e-8;
parameter SIunits.MagneticPotentialDifference theta=1;
SIunits.MagneticPotentialDifference theta_x;
SIunits.MagneticPotentialDifference theta_y;
Modelica.Electrical.Analog.Magnetics.MagP mag_p;
Modelica.Electrical.Analog.Magnetics.MagN mag_n;
equation
theta_x = mag_p.theta_x - mag_n.theta_x;
theta_y = mag_p.theta_y - mag_n.theta_y;
0 = mag_p.psi_x + mag_n.psi_x;
0 = mag_p.psi_y + mag_n.psi_y;
theta_x = theta*cos(beta);
theta_y = theta*sin(beta);
end MagSource;

[3] Lorenzen, H.-W.:
Grundlagen der elektromechanischen Energiewandlung – Skript zur Lehrveranstaltung.

class MagResistance "Magnetic resistance"
parameter Real N(final min=0) = 1;
parameter SIunits.Inductance M = 1;
SIunits.MagneticPotentialDifference theta_x;
SIunits.MagneticPotentialDifference theta_y;
SIunits.MagneticFlux psi_x;
SIunits.MagneticFlux psi_y;

[1] Elmquist, H., D. Brück, and M. Otter:
Dymola – User’s Manual.
Dynasim AB, Lund, Sweden, 1996.

Modelica.Electrical.Analog.Magnetics.MagP mag_p;
Modelica.Electrical.Analog.Magnetics.MagN mag_n;
equation
theta_x = mag_p.theta_x - mag_n.theta_x;
theta_y = mag_p.theta_y - mag_n.theta_y;
0 = mag_p.psi_x + mag_n.psi_x;
0 = mag_p.psi_y + mag_n.psi_y;
psi_x = mag_p.psi_x;
psi_y = mag_p.psi_y;
N*N*psi_x = M*theta_x;
N*N*psi_y = M*theta_y;
end MagResistance;
class MagCoupling "Linear magnetic coupling"
extends Modelica.Electrical.Analog.Interfaces.OnePort;
parameter SIunits.Angle beta = 1e-8 "Mag. Field Orient.";
parameter Real N(final min=0) = 1 "Number of Turns";
parameter Real k(final min=0) = 1 "Scaling Factor";
SIunits.MagneticPotentialDifference theta_x;
SIunits.MagneticPotentialDifference theta_y;
SIunits.MagneticFlux psi_x;
SIunits.MagneticFlux psi_y;
Modelica.Electrical.Analog.Magnetics.MagP mag_p;
Modelica.Electrical.Analog.Magnetics.MagN mag_n;
equation
theta_x = mag_p.theta_x - mag_n.theta_x;
theta_y = mag_p.theta_y - mag_n.theta_y;
0 = mag_p.psi_x + mag_n.psi_x;
0 = mag_p.psi_y + mag_n.psi_y;
psi_x = mag_p.psi_x;
psi_y = mag_p.psi_y;
v = -N/k*cos(beta)*der(psi_x) - N/k*sin(beta)*der(psi_y);
theta_x = N*k*i*cos(beta);
theta_y = N*k*i*sin(beta);
end MagCoupling;
class Commutator "Commutator with magnetic coupling"
extends Modelica.Electrical.Analog.Interfaces.OnePort;
parameter Real Z(final min=0) = 1 "Number of Poles / 2";
parameter Real N(final min=0) = 1 "Number of Turns";
parameter Real k(final min=0) = 1 "Scaling Factor";
SIunits.Angle phi "Rotational Magnetic Angle";
SIunits.MagneticPotentialDifference theta_x;
SIunits.MagneticPotentialDifference theta_y;
SIunits.MagneticFlux psi_x;
SIunits.MagneticFlux psi_y;
Modelica.Electrical.Analog.Magnetics.MagP mag_p;
Modelica.Electrical.Analog.Magnetics.MagN mag_n;
Modelica.Mechanics.Rotational.Interfaces.Flange_b flange_b;
equation
theta_x = mag_p.theta_x - mag_n.theta_x;
theta_y = mag_p.theta_y - mag_n.theta_y;
0 = mag_p.psi_x + mag_n.psi_x;
0 = mag_p.psi_y + mag_n.psi_y;
psi_x = mag_p.psi_x;
psi_y = mag_p.psi_y;
0 = flange_b.tau;
phi = -flange_b.phi*Z;
v = -N/k*cos(phi)*der(psi_x) - N/k*sin(phi)*der(psi_y);
theta_x = N*k*i*cos(phi);
theta_y = N*k*i*sin(phi);
end Commutator;
class StatorRotor "Stator and rotor of electric machines"
parameter Real Z(final min=0) = 1 "Number of Poles / 2";
SIunits.Angle phi(final start=1e-8) "Rotational Angle";
SIunits.MagneticPotentialDifference theta_1x "port 1";
SIunits.MagneticPotentialDifference theta_1y "port 1";
SIunits.MagneticPotentialDifference theta_2x "port 2";
SIunits.MagneticPotentialDifference theta_2y "port 2";
SIunits.MagneticFlux psi_1x "port 1";
SIunits.MagneticFlux psi_1y "port 1";
SIunits.MagneticFlux psi_2x "port 2";
SIunits.MagneticFlux psi_2y "port 2";
equation
theta_1x = mag_1p.theta_x - mag_1n.theta_x;
theta_1y = mag_1p.theta_y - mag_1n.theta_y;
theta_2x = mag_2p.theta_x - mag_2n.theta_x;
theta_2y = mag_2p.theta_y - mag_2n.theta_y;
0 = mag_1p.psi_x + mag_1n.psi_x;
0 = mag_1p.psi_y + mag_1n.psi_y;
0 = mag_2p.psi_x + mag_2n.psi_x;
0 = mag_2p.psi_y + mag_2n.psi_y;
psi_1x = mag_1p.psi_x;
psi_1y = mag_1p.psi_y;
psi_2x = mag_2p.psi_x;
psi_2y = mag_2p.psi_y;
flange_b.tau = Z*psi_2x*theta_2y - Z*psi_2y*theta_2x;
phi = flange_b.phi*Z;
0 = psi_1x + psi_2x*cos(phi) - psi_2y*sin(phi);
0 = psi_1y + psi_2x*sin(phi) + psi_2y*cos(phi);
theta_1x = theta_2x*cos(phi) - theta_2y*sin(phi);
theta_1y = theta_2x*sin(phi) + theta_2y*cos(phi);
end StatorRotor;
class DC_machine "DC machine using magnetic elements"
parameter Real Z(final min=0) = 4 "Number of Poles / 2";

parameter
parameter
parameter
parameter
parameter

Real
Real
Real
Real
Real

L_rotor(final min=0) = 0.004;
N_stator(final min=0) = 2400;
N_rotor(final min=0) = 60;
R_stator(final min=0) = 1;
R_rotor(final min=0) = 0.25;

Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin1;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin1;
Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin2;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin2;
Modelica.Electrical.Analog.Basic.Resistor
Resistor_Stator(R=R_stator);
Modelica.Electrical.Analog.Basic.Resistor
Resistor_Rotor(R=R_rotor);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling(beta=3.14159/2, N=N_stator, k=2/3.14159);
Modelica.Electrical.Analog.Magnetics.Commutator
Commutator(Z=Z, N=N_rotor);
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Stator;
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Rotor;
Modelica.Electrical.Analog.Magnetics.StatorRotor
StatorRotor(Z=Z);
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance(N=N_rotor, M=L_rotor);
Modelica.Mechanics.Rotational.Interfaces.Flange_b
Flange_b;
equation
connect(PositivePin1, Resistor_Stator.p);
connect(PositivePin2, Resistor_Rotor.p);
connect(NegativePin2, Commutator.n);
connect(NegativePin1, MagCoupling.n);
connect(Resistor_Stator.n, MagCoupling.p);
connect(Resistor_Rotor.n, Commutator.p);
connect(MagCoupling.mag_p, StatorRotor.mag_1p);
connect(MagCoupling.mag_n, StatorRotor.mag_1n);
connect(MagGround_Stator.mag_p, MagCoupling.mag_n);
connect(MagGround_Rotor.mag_p, Commutator.mag_n);
connect(StatorRotor.mag_2p, MagResistance.mag_p);
connect(MagResistance.mag_n, Commutator.mag_n);
connect(Commutator.mag_p, StatorRotor.mag_2n);
connect(StatorRotor.flange_b, Flange_b);
connect(Commutator.flange_b, Flange_b);
end DC_machine;
class DC_PM_machine "Permanent magnet DC machine"
parameter Real Z(final min=0) = 4 "Number of Poles / 2";
parameter Real Theta_stator(final min=0) = 36000*2/3.14159
"Stator mag. Pot. Diff.";
parameter Real L_rotor(final min=0) = 0.004;
parameter Real R_rotor(final min=0) = 0.25;
parameter Real N_rotor(final min=0) = 60;
Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin1;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin1;
Modelica.Electrical.Analog.Basic.Resistor
Resistor_Rotor(R=R_rotor);
Modelica.Electrical.Analog.Magnetics.MagSource
MagSource(beta=3.14159/2, theta=Theta_stator);
Modelica.Electrical.Analog.Magnetics.StatorRotor
StatorRotor(Z=Z);
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Stator;
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Rotor;
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance(N=N_rotor, M=L_rotor);
Modelica.Electrical.Analog.Magnetics.Commutator
Commutator(Z=Z, N=N_rotor,
psi_y(start=-Theta_stator*L_rotor/N_rotorˆ2));
Modelica.Mechanics.Rotational.Interfaces.Flange_b
Flange_b;
equation
connect(StatorRotor.mag_2p, MagResistance.mag_p);
connect(Resistor_Rotor.n, Commutator.p);
connect(PositivePin1, Resistor_Rotor.p);
connect(Commutator.n, NegativePin1);
connect(MagResistance.mag_n, Commutator.mag_n);
connect(MagGround_Stator.mag_p, StatorRotor.mag_1n);
connect(MagGround_Rotor.mag_p, Commutator.mag_n);
connect(Commutator.mag_p, StatorRotor.mag_2n);
connect(StatorRotor.flange_b, Flange_b);
connect(Commutator.flange_b, Flange_b);
connect(MagSource.mag_p, StatorRotor.mag_1p);
connect(MagSource.mag_n, MagGround_Stator.mag_p);
end DC_PM_machine;
class AC_machine
parameter Real
parameter Real
parameter Real

ÄC induction machine"
Z(final min=0) = 3 "Number of Poles / 2";
M_mutual(final min=0) = 0.0322;
L_stator_leakage(final min=0) = 0.0021;

parameter
parameter
parameter
parameter
parameter

Real
Real
Real
Real
Real

L_rotor_leakage(final min=0) = 0.0019;
N_stator(final min=0) = 1 "Stator turns";
N_rotor(final min=0) = 1 "Rotor turns";
R_stator(final min=0) = 0.324;
R_rotor(final min=0) = 0.203;

Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin1;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin1;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin2;
Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin2;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin3;
Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin3;
Modelica.Electrical.Analog.Basic.Resistor
Resistor1(R=R_stator);
Modelica.Electrical.Analog.Basic.Resistor
Resistor2(R=R_stator);
Modelica.Electrical.Analog.Basic.Resistor
Resistor3(R=R_stator);
Modelica.Electrical.Analog.Basic.Resistor
Resistor4(R=R_rotor);
Modelica.Electrical.Analog.Basic.Resistor
Resistor5(R=R_rotor);
Modelica.Electrical.Analog.Basic.Resistor
Resistor6(R=R_rotor);
Modelica.Electrical.Analog.Basic.Ground Ground4;
Modelica.Electrical.Analog.Basic.Ground Ground5;
Modelica.Electrical.Analog.Basic.Ground Ground6;
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling1(beta=0, N=N_stator);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling2(beta=2*3.14159265/3, N=N_stator);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling3(beta=4*3.14159265/3, N=N_stator);
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Stator;
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling4(beta=0, N=N_rotor);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling5(beta=2*3.14159265/3, N=N_rotor);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling6(beta=4*3.14159265/3, N=N_rotor);
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Rotor;
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance(N=N_stator, M=M_mutual*2/3);
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance1(N=N_stator, M=L_stator_leakage*2/3);
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance2(N=N_rotor, M=L_rotor_leakage*2/3);
Modelica.Electrical.Analog.Magnetics.StatorRotor
StatorRotor(Z=Z);
Modelica.Mechanics.Rotational.Interfaces.Flange_b
Flange_b1;
equation
connect(PositivePin1, Resistor1.p);
connect(NegativePin1, MagCoupling1.n);
connect(PositivePin2, Resistor2.p);
connect(NegativePin2, MagCoupling2.n);
connect(PositivePin3, Resistor3.p);
connect(NegativePin3, MagCoupling3.n);
connect(MagCoupling2.mag_n, MagCoupling3.mag_p);
connect(MagCoupling3.mag_n, MagGround_Stator.mag_p);
connect(MagCoupling4.n, Resistor4.n);
connect(MagCoupling6.n, Resistor6.n);
connect(MagCoupling5.n, Resistor5.n);
connect(MagCoupling4.mag_n, MagCoupling5.mag_p);
connect(MagCoupling5.mag_n, MagCoupling6.mag_p);
connect(MagCoupling6.n, Ground6.p);
connect(MagCoupling5.n, Ground5.p);
connect(MagCoupling4.n, Ground4.p);
connect(MagGround_Rotor.mag_p, MagCoupling6.mag_n);
connect(MagCoupling1.mag_p, MagResistance.mag_p);
connect(MagGround_Stator.mag_p, StatorRotor.mag_1n);
connect(StatorRotor.mag_2p, MagCoupling4.mag_p);
connect(MagGround_Rotor.mag_p, StatorRotor.mag_2n);
connect(MagCoupling1.mag_n, MagCoupling2.mag_p);
connect(MagResistance.mag_n, StatorRotor.mag_1p);
connect(MagCoupling4.p, Resistor4.p);
connect(MagCoupling5.p, Resistor5.p);
connect(MagCoupling6.p, Resistor6.p);
connect(StatorRotor.flange_b, Flange_b1);
connect(MagResistance1.mag_p, MagResistance.mag_p);
connect(MagResistance1.mag_n, MagGround_Stator.mag_p);
connect(Resistor3.n, MagCoupling3.p);
connect(Resistor2.n, MagCoupling2.p);
connect(Resistor1.n, MagCoupling1.p);
connect(MagResistance2.mag_p, StatorRotor.mag_2p);
connect(MagResistance2.mag_n, MagGround_Rotor.mag_p);
end AC_machine;
class AC_PM_machine ÄC PM machine using magnetic elements"
parameter Real Z(final min=0) = 3 "Number of Poles / 2";
parameter Real Theta_rotor(final min=0) = 0.172*2/3.14159;

parameter
parameter
parameter
parameter
parameter
parameter
parameter

Real
Real
Real
Real
Real
Real
Real

M_mutual(final min=0) = 0.0322;
L_stator_leakage(final min=0) = 0.0021;
L_rotor_leakage(final min=0) = 0.001;
N_stator(final min=0) = 1 "Stator turns";
N_rotor(final min=0) = 1 "Rotor turns";
R_stator(final min=0) = 0.324;
R_rotor(final min=0) = 0.04;

Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin1;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin1;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin2;
Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin2;
Modelica.Electrical.Analog.Interfaces.NegativePin
NegativePin3;
Modelica.Electrical.Analog.Interfaces.PositivePin
PositivePin3;
Modelica.Electrical.Analog.Basic.Resistor
Resistor1(R=R_stator);
Modelica.Electrical.Analog.Basic.Resistor
Resistor2(R=R_stator);
Modelica.Electrical.Analog.Basic.Resistor
Resistor3(R=R_stator);
Modelica.Electrical.Analog.Basic.Resistor
Resistor4(R=R_rotor);
Modelica.Electrical.Analog.Basic.Resistor
Resistor5(R=R_rotor);
Modelica.Electrical.Analog.Basic.Ground Ground4;
Modelica.Electrical.Analog.Basic.Ground Ground6;
Modelica.Electrical.Analog.Magnetics.MagSource
MagSource(beta=0, theta=Theta_rotor);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling1(beta=0, N=N_stator);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling2(beta=2*3.14159265/3, N=N_stator);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling3(beta=4*3.14159265/3, N=N_stator);
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling4(beta=0, N=N_rotor,
psi_x(start=Theta_rotor*M_mutual/N_rotorˆ2*2/3));
Modelica.Electrical.Analog.Magnetics.MagCoupling
MagCoupling5(beta=3.14159265/2, N=N_rotor);
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Stator;
Modelica.Electrical.Analog.Magnetics.MagGround
MagGround_Rotor;
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance(N=N_stator, M=M_mutual*2/3);
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance1(N=N_stator, M=L_stator_leakage*2/3);
Modelica.Electrical.Analog.Magnetics.MagResistance
MagResistance2(N=N_rotor, M=L_rotor_leakage);
Modelica.Electrical.Analog.Magnetics.StatorRotor
StatorRotor(Z=Z);
Modelica.Mechanics.Rotational.Interfaces.Flange_b
Flange_b1;
equation
connect(PositivePin1, Resistor1.p);
connect(NegativePin1, MagCoupling1.n);
connect(PositivePin2, Resistor2.p);
connect(NegativePin2, MagCoupling2.n);
connect(PositivePin3, Resistor3.p);
connect(NegativePin3, MagCoupling3.n);
connect(MagCoupling2.mag_n, MagCoupling3.mag_p);
connect(MagCoupling3.mag_n, MagGround_Stator.mag_p);
connect(MagCoupling4.n, Resistor4.n);
connect(MagCoupling5.n, Resistor5.n);
connect(MagCoupling5.n, Ground6.p);
connect(MagCoupling4.n, Ground4.p);
connect(MagGround_Rotor.mag_p, MagCoupling5.mag_n);
connect(MagCoupling1.mag_p, MagResistance.mag_p);
connect(MagGround_Stator.mag_p, StatorRotor.mag_1n);
connect(StatorRotor.mag_2p, MagCoupling4.mag_p);
connect(MagGround_Rotor.mag_p, StatorRotor.mag_2n);
connect(MagCoupling1.mag_n, MagCoupling2.mag_p);
connect(MagResistance.mag_n, StatorRotor.mag_1p);
connect(MagCoupling4.p, Resistor4.p);
connect(MagCoupling5.p, Resistor5.p);
connect(StatorRotor.flange_b, Flange_b1);
connect(MagResistance1.mag_p, MagResistance.mag_p);
connect(MagResistance1.mag_n, MagGround_Stator.mag_p);
connect(Resistor3.n, MagCoupling3.p);
connect(Resistor2.n, MagCoupling2.p);
connect(Resistor1.n, MagCoupling1.p);
connect(MagResistance2.mag_p, StatorRotor.mag_2p);
connect(MagResistance2.mag_n, MagGround_Rotor.mag_p);
connect(MagCoupling4.mag_n, MagSource.mag_p);
connect(MagSource.mag_n, MagCoupling5.mag_p);
end AC_PM_machine;
end Magnetics;

3%XQXV9(QJHOVRQ3)ULW]VRQ
0HFKDQLFDO0RGHOV7UDQVODWLRQ6LPXODWLRQDQG
9LVXDOL]DWLRQLQ0RGHOLFD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Mechanical Models Translation, Simulation and
Visualization in Modelica
Peter Bunus, Vadim Engelson, Peter Fritzson
PELAB, Programming Environment Laboratory
Department of Computer and Information Science,
Linköping University, SE-581 83, Linköping, Sweden
{petbu,vaden,petfr}@ida.liu.se
ABSTRACT
Modeling and simulation have become central to all disciplines of engineering and science. In a
comprehensive modeling and simulation environment, it is desirable to integrate models specified in
different modeling formalisms and to extend modeling language constructs to support multi-domain
and multi-formalism modeling integrated with powerful visualization capabilities. This paper is
concerned with the design of a complete integrated environment that combines the powerful
mechanical model design of various CAD packages with the structuring mechanisms of object oriented
modeling languages including a mathematical and logical behavior representation. We present an
integrated environment for simulation of multi-domain models which has been implemented using
Modelica as a standard model representation. The user can work with mechanical models designed
with AutoDesk’s Mechanical Desktop, extend the corresponding Modelica model in various ways, and
analyze the simulation results in a high performance interactive visualization environment.

Introduction
Modelica is a new language for hierarchical objectoriented physical modeling, which is developed
through an international effort. The language unifies
and generalizes previous object-oriented modeling
languages. Modelica is intended to become a de facto
standard. The language has been designed to allow
existing and future compilers to generate efficient
simulation code automatically with the main objective
to facilitate exchange of models, model libraries, and
simulation specifications. It allows defining
simulation models modularly and hierarchically by
combining various formalisms expressible in the more
general Modelica formalism. The multi-domain
capability of Modelica gives the user the possibility to
combine
electrical,
mechanical,
hydraulic,
thermodynamic, etc. model components within the
same application model. Interaction between system
components, which are often complex and difficult to
analyze, can be easily studied.
In order to automate the design of mechanical
models, CAD tools can be utilized. We have focused
on adding the ability to easily interface the Modelica
simulation environment with a wider variety of CAD
systems. At the first stage we have focused on
achieving full integration with widely accepted
mechanical CAD solutions like SolidWorks and
Mechanical Desktop. In this paper we present a
translator
implementation
from
AutoDesk’s
Mechanical Desktop to Modelica, which extracts
geometric and parametric information from an
existing designed mechanical model and produces a

corresponding set of Modelica class instances with
connections between them.
AutoDesk’s Mechanical Desktop 4 is an
integrated package of advanced 3D modeling tools
and 2D drafting and drawing capabilities, that help
the modeler to conceptualize, design, and document
a mechanical product. Our comprehensive integrated
environment consists of a CAD tool, a simulation
environment, like Dymola or MathModelica, and a
visualizer that provides online dynamic display of
the assembly (during simulation) or offline (based
on saved state information for each time step).
The developed integrated environment allows
designers and engineers to build very quickly a
virtual prototype which enables them to identify
design flaws that would previously only have been
found after building costly and time consuming
physical prototypes. The combined mechanical
design environment enhanced with simulation
capabilities given by the Modelica simulation
environment emphasizes the concept of functional
design. In Modelica it is possible to specify arbitrary
control algorithms for mechanical and mechatronic
models. In that way it is possible to model and
simulate both control an mechanical aspects of the
desired mechanical application. Through simulation
of the complete mechatronic system, the designer
can predict how his mechanical subsystem will
interact with the other subsystems. The dynamics of
mechanical and/or control systems is also
documented by plots of system variables completing
in that way the realistic animation of the visualizer.
Given an initial mechanical design, the user can
modify this design (based on the simulated results)

in order to improve the functional performance of the
mechanical assembly.
Figure 1 represents a general view of our
integrated environment for design, simulation and
visualisation of mechanical models. In order to create
such an environment we have combined a typical
CAD environment with an equation based simulation
environment with enhanced visualization capabilities.
First the user will define the mechanical model in
his/her favourite CAD package using, maybe standard,
predefined component library models. The result of
this operation usually is a static wire-frame model
without any dynamic capabilities. A plug-in to the
CAD package extracts from the drawing the geometry,
mass, inertia and constraints information, translating
them to a simulation language source code. This code
is combined with other code fragments (e.g. control
systems), simulated, and the output can be visualised
as a data plot of the system variables and/or as a 3D or
2D dynamic model animation. The 3D visualisations
are scenes that display the geometry of the parts in
motions prescribed by the simulation results. The
graphical user interface of the CAD model and the
output visualisation capabilities of the simulation
environment make it easy to describe and modify
model geometry as well as examine analysis results at
the same time. More implementation details of the
integrated environment will be given in the remainder
of the paper.
CAD
Environment

Simulation
Environment

Standard
Component
Library

Standard
Component
Library

Mechanical
Model Design

Simulation
Environment

Visualization
Static Model
Visualization

Dynamic Model
Visualization
(Animation)

Data
Plot

Figure 1. Functional structure of the integrated
environment
In this paper, we first give a brief introduction to the
overall design of the developed simulation
environment. At the same time, we examine the
implementation details of the developed translator. A
brief overview of the Modelica language is also given
with an emphasis on the modular and hierarchical
facilities of the language. The Modelica Multi Body
System Library (MBS) is briefly presented together
with a simple modeling and simulation example. We
will also present some principles of the developed
translator implementation. The use of the translator is
demonstrated on several examples. We conclude with
an overview concerning further development based on
the integrated design and simulation environment.

The Modelica Modeling Language
Modelica is a new language for hierarchical objectoriented physical modeling which is developed
through an international effort [Fritzson and
Engelson 1998; Elmqvist et al. 1999].
Compared to other modeling languages available
today, Modelica offers four important advantages
from the simulation practitioner point of view:
• Acausal modeling based on ordinary differential
equations (ODE) and differential algebraic
equations (DAE). There is also, ongoing
research to include partial differential equations
(PDE) in the language syntax and semantics
[Saldamli and Fritzson 2000].
• Multi-domain modeling capability, which
provides the user with the possibility to
combine electrical, mechanical, thermodynamic,
hydraulic etc., model components within the
same application model.
• A general type system that unifies objectorientation, multiple inheritance, and templates
within a single class construct. This facilitates
reuse of components and evolution of models.
• A strong software component model, with
constructs for creating and connecting
components. Thus the language is ideally suited
as an architectural description language for
complex physical systems, and to some extent
for software systems.
The reader of the paper is referred to [Modelica
Association 1999a] and [Modelica Association
1999b] for a complete description of the language
and its functionality from the perspective of the
motivations and design goals of the researchers who
developed it. Those interested in shorter overviews
of the language may wish to consult [Fritzson and
Engelson 1998] or [Elmqvist et al. 1999].
Two environments employing the declarative
equation based programming paradigm and
Modelica language will be extensively discussed in
this paper: MathModelica [Jirstrand et al. 1999] and
Dymola with Modelica support.
The dynamic simulation capabilities of the
language has been demonstrated many times in the
literature by modeling and simulating heat
exchangers [Mattsson 1997], automatic gear boxes
[Otter et al 1997] or hydraulic systems [Ferreira et al
199], [Tummescheit and Eborn 1998]. The
advantage of such a modeling language is that the
user can concentrate on the logic of the problem
rather than on a detailed algorithmic implementation
of the simulation model. In order for declarative
equation based modeling languages to achieve
widespread acceptance, associated programming
environments and development tools must become
more accessible to the user.

Related Work
In this part of the paper, we briefly survey some of the
commercial virtual prototyping packages available
which are most closely related to our developed
environment.
VisualNastran 4D from MSC Working Knowledge
provides an integrated environment for motion and
FEA (Finite Element Analysis) simulation and
complete suite of tools for the development and
communication of physics-based virtual prototypes.
Constraints and drivers can be defined by numeric or
equation input in the formula editor, or with tabular
data.
ADAMS, standing for Automatic Dynamic
Analysis of Mechanical Systems developed by
Mechanical Dynamics Inc., provides a fully integrated
virtual prototyping environment. In addition to the
powerful modeling and visualization capabilities
includes an analysis engine called ADAMS/Solver
which converts an ADAMS model to equations of
motion, and then solves the equations, typically in the
time domain. ADAMS/Solver can resolve redundant
constraints, handle unlimited degrees of freedom, and
perform static equilibrium, kinematic, and dynamic
analyses.
Dynamic Designer/Motion and Simply Motion,
two other products from Mechanical Dynamics Inc.,
provides a full integration with Mechanical Desktop.
Simply Motion written also in AutoDesk’s ARX
development language extends the design automation
capabilities of Mechanical Desktop to include realistic
3D dynamic motion simulation. Simply Motion
anticipates the mechanical designer needs and
automatically updates the motion data. Through a
browser called IntelliMotion Browser, the user can
add joints, springs and input motion to the mechanical
model.
DADS, standing for Dynamic Analysis and Design
System available from LMS International Inc.
(CADSI), performs assembly, kinematic, dynamic,
inverse dynamic and preload analysis. It incorporates
advanced numerical methods to solve Differential
Algebraic Equations (DAE) using both implicit and
explicit solvers.
The primary limitation of these environments is
the difficulty of integrating multi-domain simulation
in the same environment. Usually an interface to other
popular simulation tools, like MATLAB and Simulink,
is provided, but this solution does not offer too much
flexibility. We have identified two major needs for a
virtual prototyping system:
• The need to integrate multi-domain simulation
in the same environment.
• The generation of quality documentation
coupled to the design and code.
In the following pages, we detail our proposed
procedure for avoiding the current limitations of the
software in this area.

MBS (Multi Body System) Library in
Modelica
The equation-based foundation of the Modelica
language enables simulation in an extremely broad
range of scientific and engineering areas. Some of
the model libraries include application areas such as
mechanics, electronics, hydraulics and pneumatics.
The MBS (Multi Body System) library has been
developed in [Otter 1995], and an overview can be
found in [Otter et al. 1996]. We briefly present the
multi-body system library together with a simple
modeling examples.
A distinguishing feature of mechanical multibody systems is the presence of joints, which impose
different type of kinematic constrains between the
various bodies of the system. Kinematic constraints
are enforced between the kinematic variables of two
bodies. These constraints express the conditions for
relative translation or rotation of the two bodies
along or around a body fixed axis, and imply the
relative sliding of the two bodies which remain in
constant contact with each other. However, in
Mechanical Desktop it is possible to define a relative
distance when specifying the mates between two
bodies.
In order to correctly simulate a mechanism, it is
necessary to have a closed kinematic chain with one
link fixed. When we say that one link is fixed, we
mean that it is chosen as a frame of reference for all
other links, i.e., that the motion of all other points on
the linkage will be measured with respect to this
link, thought of as being fixed. The CAD
environment has the possibility of specifying which
part of the kinematic chain will be fixed. Later, in
the translation phase, this fixed part will be
connected with an instance of the InertialSystem
class.
An instance of the Inertial class defines the
global coordinate system and gravitational forces
(the inertial frame). All parameter vectors and
tensors are given in the home position of the multibody system with respect to the inertial frame. One
instance of class Inertial must always be present
for every multi-body model. All other objects are in
some way connected to the inertia system, either
directly or through other objects.
Every basic mechanical component from the
MBS library has at least one or two interfaces to
connect the element rigidly to another mechanical
elements.
An example of the MBS library usage is shown
by the following modeling examples.
Our first modeling example consists of a mass
hanging on a spring in a gravity field. When the
spring-mounted body is disturbed from its
equilibrium position, its ensuing motion in the
absence of any imposed external forces is termed
free vibration. However, in the real world, every
mechanical system posses some inherent degree of

friction which will act as a consumer of mechanical
energy. Therefore, we should add to our system a
viscous damper for the purpose of limiting or
retarding the vibration.
A schematic diagram of our system under
consideration is shown in Figure2.
inertial
y
x

S
prismS = [0, -1, 0]

kinematic constrains between the various bodies of
the kinematic chain. The motions between links of
the mechanism must to be constrained to produce
the proper relative motion, those chosen by the
designer for the particular task to be performed.
A Prismatic joint has been introduced in order to
produce the relative motion in the Y-direction. The
relative motion direction is specified by the
parameter vector n=[0,-1,0] which is the axis of
translation resolved in frame a.

body1 = [0, -0.2, 0]

Mechanical Desktop
spring3D

dumper3D

Figure 2. Schematic diagram of the damped free
vibration mass system
The Modelica code for the model considered above is
shown below:
import "library/mbs/mbscom.mo";
import "library/mbs/mbs1.mo";
import "library/drive/drivep1.mo";
model DFVmass
parameter Real c = 300;
Inertial inertial;
PrismaticS prismS1 (n=[0,-1,0]);
BoxBody body1(r=[0,-0.2,0],Width=0.2,
Height=0.2);
Spring spring3D (c=c);
Damper damper3D(d=2);
equation
connect(inertial.b,
connect(prismS1.b,
connect(prismS1.a,
connect(spring3D.a,
connect(spring3D.b,
connect(body1.a,

prismS1.a);
body1.a);
spring3D.a);
damper3D.a);
damper3D.b);
spring3D.b);

end DFVmass;

As we have seen from the previous example, a
simulation model that uses the MBS library consists of
an inertial system (an instance of Inertial class)
and different mechanical components connected
together with the connect statement. The statement
connect(v1,v2) expresses coupling between
variables. These variables are called connectors and
belong to the connected objects. Each connection
specifies interaction between components. A
connector should contain all quantities needed to
describe the interaction. This gives a flexible way of
specifying topology of physical systems described in
an object-oriented way using Modelica.
A distinguishing feature of multi-body systems is
the presence of joints, which impose different types of

In the above we have explored how a simple
simulation is expressed with the help of the
Modelica language and the Multi-Body library. Now
we can take a look how typical design of a multibody system is done in our target CAD environment
and what facilities are offered by this environment.
AutoDesk’s Mechanical Desktop, like other
typical CAD/CAM systems supports modeling the
geometry of parts and static assemblies of parts. The
assemblies can be built combining two or more
parts, or parts grouped in subassemblies. Like part
features, parts and subassemblies act like building
blocks. Each solid component (a rigid body) is
modeled as a separate part which can be saved in a
separate document and later externally referenced to
the assembly. In an assembly model, these parts are
put together in order to form a complete model.
Mechanical Desktop builds individual parts and
subassemblies into an assembly. Using externally
referenced parts into an assembly creates a truly
parametric assembly design. Changes to an external
reference can be made from within the assembly or
in the original file.
Mechanical Desktop has the possibility to
automate the design and revision process by using
parametric geometry, which controls relationships
among design elements and automatically adjusts
models and drawings as they are refined.
The assembly document defines the mobility
between the parts of an assembly. After parts or
subassemblies have been created, constraints are
applied to position them relative to one another.
Each time when a constraint is applied to a part,
some degrees of freedom are eliminated. After the
parts have been assembled and constraints have been
applied an interference checking can be performed
and mass calculations can be performed on parts to
insure that they are structurally sound.
The Mechanical Desktop offers the following
mate types:
• AMMATE - Mate constraint. Causes a plane or
axis on one part to be coincident with a plane,
point, or axis on another part in a specified
direction. Removes a translational or rotational
degree of freedom.

• AMFLUSH - Flush constraint. Make two planes
coplanar with their faces aligned in the same
direction.
• AMINSERT - Insert constraint. Aligns center
points and planes of two circles in a specified
direction. Removes translational degrees of
freedom. Used to constrain a bolt in a hole, for
example.
• AMMANGLE – Angular Constraint. Specifies an
angle between two planes, two vectors, or a
combination of a plane and a vector.
The links of the designed mechanism have been
connected together in some manner in order to
transmit motion from the driver (input link) to the
follower (output link). The joints between the links are
also called (kinematic) pairs, because each joint
consist of a pair of mating surfaces, two elements, one
matting surface or element being part of each of the
joined links as it is shown in Figure 3.
mate2

P1

mate1
pl1

Z
Y

pl2

pl1'

pl2'

• An axis planar with a plane.
• Two axes that share the same direction and
slope (collinear).
• A point that lies on an axis.
• Two coincident points.
• A sphere, cylinder, or cone tangent to a plane or
to other spheres, cylinders, and cones.
The translator will gather the information about the
mate constraints applied to the two parts and will be
translated to a corresponding joint object from the
MBS library. In our example the translated joint will
correspond to a prismatic joint which only permits a
relative sliding motion and therefore is often called a
sliding joint. This type of joint only has a single
degree of freedom.
Any invalid combinations of mates are
automatically rejected by the Mechanical Desktop so
the possibility of translating to an incorrect joint is
eliminated already during the design phase. Each
valid combination of mates will be translated to a
combination of joints, which resides in the multibody library. Table 1 lists the names of the lower
joints, together with the number of translational and
rotational degrees of freedom [Shigley 1995], and
their correspondents from the MBS library. All other
joint types are called higher pairs. They are
combinations of the basic joints and are not listed in
Table 1.

X
S

P2

prismS = [0, -1, 0]

Figure 3. Two links connected together by two
coincident plane/plane mates and the corresponding
joint from the MBS library
Each time when we apply a constraint to a part, some
degrees of freedom are eliminated. The number of
degrees of freedom determines the movement of a part
in various directions; the more constraints applied, the
less the part can move. At the beginning, we have
applied a mate constraint mate1 which cause plane
pl1 from part P1 to be coincident with plane pl2
from part P2. The mate constraint mate1 has
eliminated a translational degree of freedom on axis X
and two rotational degrees of freedom: one around
axis Y and the other one around axis Z. Applying the
second constraint mate2 by constraining plane pl2’
to be coincided with plane pl1’ we have eliminated
a translational degree of freedom of axis Y and the
rotational degree of freedom around axis X. The
rotational degree of freedom around axis Z have been
already eliminated by the first applied mate constraint.
In conclusion, our assembly will have only one degree
of freedom, namely a translational degree of freedom
on axis Z.
The Mate constraint has the following available
options:
• Two planes coplanar with their normals aligned in
opposite directions (facing each other).

Pair

Tr. and
Rot. DOF
Revolute 1rot
Prismatic 1tr
Cylindric 1rot; 1tr
Sphere
3rot
Flat
3tr

Nr. of
DOF
1
1
2
3
3

Relative
motion
Circular
Linear
Cylindric
Spheric
Planar

MBS name
RevoluteS
PrismaticS
CylindicalS
SphereCardanS
PlanarS

Table 1. Lower joints

Translator Implementation
The translator was implemented as a plug-in to
AutoDesk’s Mechanical Desktop by using a
provided application development tool, AutoDesk
Mechanical Application Programming Interface
(MCAD API) [AutoDesk 1999b]. The MCAD API
provide a direct and unified access mechanism for
AutoCAD and Mechanical Desktop geometry
making possible in that way to translate the
geometrical, mass, inertia and constraint information
to source code in Modelica. From the AutoCAD
point of view, our translator is an ObjectARX
application. An ObjectARX application is a dynamic
link library (DLL) that shares the address space of
AutoCAD and makes direct function calls to
AutoCAD. It is possible to add new classes to the
ObjectARX. The ObjectARX entities created are
virtually indistinguishable from the built-in
AutoCAD entities. The ObjectARX protocol can be
extended by adding functions at runtime to existing
AutoCAD classes [AutoDesk 1999a].

.
Mechanical Desktop
DWG

Mechanical Desktop and
the attached translator
Assemblies

Mates related
information

Translator ARX

TRANSLATION
Parts

Mass &
Inertia

C External
Functions

Modelica
Component
Libraries

Mechanical
MODELICA
Model
model.mo

MODELICA
EXECUTION

Dymola or
MathModelica
Simulation
Environment

Geometry

STL Format

MVIS
3D
Visualization
and Animation

2D Graph
Viewer

Figure 4. The path from a Mechanical Desktop static model to a dynamic system visualization
The overall architecture of our virtual prototyping
environment and how the developed translator is
integrated in this environment is shown in Figure 4.
A mechanical model designed and fully
constrained in the Mechanical Desktop Environment
serves as a starting point in the virtual prototyping.
The models are saved in the DWG format, which
contains all the information related to the geometrical
properties of the parts and information related to the
mechanical assembly like mates and constraints.
The geometry of each part is exported to the STL
file format [3Dsystems, 2000]. At the same time, mass
and inertia of the parts are extracted together with
mates information from the mechanical assembly. The
translator will use this information to generate a
corresponding set of Modelica class instances with
connections between them. This automatically
generated Modelica file is processed by a simulation
environment like Dymola or MathModelica. In
contrast to other virtual prototyping environments
presented in the related work chapter, our environment
creates readable Modelica code so the programmer
can combine it with other code fragments and modify
it if necessary. For instance, the simulation code can
be enhanced by adding other components from other
Modelica libraries or by adding externally defined C
code. In that phase electrical, control or hydraulics
components can be added to the generated mechanical

model, providing in that way a multi-domain
simulation.
By default, only the gravity force is applied to
the translated model. The translated CAD model
models a set of dynamic equations of motion.
Therefore, the simulation can predict the mechanism
response to a given set of initial conditions or force
(or torque) load, which might be function of time.
External functions can be specified by adding an
instance of ExtForce class from the MBS library.
The results of the simulation can be visualized as
2D plotting of the simulation variables or as a 3D
dynamic animation of the mechanical assembly with
the MVIS (Modelica VISualizer) and OpenGL based
interactive visualization tool [Engelson 2000].
Compared to the similar translator developed for
SolidWorks [Larson 1999], the main improvement
of the Mechanical Desktop to Modelica translator is
the possibility of visualizing the simulation result
inside the CAD editor (marked in Figure. 5 as the
arrow which connects the Modelica execution with
the Mechanical Desktop assembly drawing). This is
usually combined with visualization of variables in
the 2D Graph viewer incorporated in the simulation
environment.
The overall system will produce a dynamic
multi-body system simulation in time domain for the
evaluation of the dynamic interaction between

several parts of the mechanical system or between the
mechanical assembly and the attached controller. This
is very useful in optimizing the mechanical
components geometry, and leads to a good deal of
confidence when it comes the time to go from
drawings to fabricating the equipment. Simulating a
couple of scenarios with mechanical rigid body
models and inspecting animations and numerical
results has validated our approach.
More details will be given next about the MVIS –
Modelica Interactive Visualization Tool and about the
geometric data translation between the CAD system
and the simulation environment together with a brief
description of the STL geometry export format.

MVIS
Modelica Interactive Visualization Tool
The integrated environment includes a 3D viewer that
provides online dynamic display of the assembly
(during simulation) or offline (based on the saved state
information for each step).
This tool loads the corresponding STL file for each
part and optimizes is for rendering. After that,
rendering is performed by OpenGL library functions.
During optimization, the vertices positioned very close
are merged together. Optimized STL code is stored in
a binary file for future use.
The user can alternatively use the pop-up menu
system, keyboard shortcuts, or a command string in
order to control various options. We found that the
following options (that can be turned on and off)
should be available, and we have implemented them:
• Rotating the camera in 2 degrees of freedom
(DOF), moving the camera in three DOF,
zooming in and out.
• Using perspective and orthographic projections.
• Parts are displayed as a wire-frame, lighted or
hidden, with or without a shadow.
• Vectors (forces, velocities, etc.).
• Application specific environment (road for car
simulation, or an airport for flight simulation).
• Planned and actual trajectory (mission) of some
parts.
• Synchronization of animation with machine
clock.
• Starting, stopping, continuing animation,
steeping forward and backward.
• Targeting camera center of view on a particular
part, so that camera follows the part all the time
• Rotating camera together with the target part

Geometric Data Translation. The STL
File Format.
Geometry information is saved in a separate STL file
for each mechanical part using the export
capabilities of the Mechanical Desktop environment.
STL files are used for representation of 3D surfaces.
The surface is tessellated or broken down logically
into a series of small triangles (facets). Each facet is
described by its normal vector and three points
representing the vertices (corners) of the
triangle.[3DSystems 2000]. The resolution of the
mesh created by these triangles can be controlled by
the AutoCAD system variable FACETRES. Our
translator uses the STL ASCII format for translating
the geometry information. The syntax for an ASCII
STL file is as follows:
solid
...
facet normal 0.00 0.00 1.00
outer loop
vertex 2.00 2.00 0.00
vertex -1.00 1.00 0.00
vertex 0.00 -1.00 0.00
endloop
endfacet
...
endsolid

In future, the environment will be able to support
other geometry formats, for instance VRML.

A Double Pendulum Model Translation
and Simulation
The next part of the paper reports direct modeling
experience with the implemented translator by
showing a simple modeling and simulation example.
In the following, we analyze the simulation of a
simple mechanical double pendulum with the purpose
of validating our environment and showing its basic
capabilities. The model of the pendulum (Figure 5)
was designed and fully constrained in Mechanical
Desktop.

pendulum to rotate relative to each other about a
common axis. It will remove all three translational
degrees of freedom and two rotational degrees of
freedom from the part is attached to.
Then coordinate translation components (class
Bar) are added between the connection points. The
kinematic diagram of the pendulum under
consideration is shown in Figure 6.
Inertial I

Bar BASE_bar

BodyME BASE

RevoluteS rev1
BASE

RevoluteS rev1

Bar ARM1_bar

BodyME ARM1

ARM1
RevoluteS rev2

RevoluteS rev2

Bar ARM2_bar

BodyME ARM2

ARM2

Figure 6. Kinematic diagram of the pendulum
under consideration
Figure 5. Double Pendulum model, designed and
constrained in Mechanical Desktop
At the start, the first link of the pendulum has an angle
q (w.r.t the vertical axis) and the initial velocity is 0.
First, based on the extracted mass and inertia
related information, three instances of the BodyME
class will be created: BASE, ARM1, ARM2. In
addition to the normal Body class, this class includes
information how to position the object for the purpose
of visualization with the MVIS tool. A complete
description of the BodyME class can be found in
[Larsson 1999]. Then, based on the assembly
constraint information the type of joints will be
identified.
The translator will automatically create a revolute
joint when two components share a line/line and a
plane/plane assembly constraint and the line/line is
oriented along the normal of the plane/plane. In the
design of the presented pendulum we have used the
AMINSERT command in order to create the assembly
constraint between the two circular faces of the
connecting part of the pendulum. AMINSERT will
constrain the parts by making the selected edges or
faces share the same axis, while forcing their faces to
be coplanar. The same type of mate was used to
constrain the first part of the pendulum with the
support cylinder. The automatically translated revolute
joint will allow the corresponding two parts of the

The translator will automatically generate the
connections between the class instances. The
following connections will be generated as a result
of the assembly mechanical design structure:
connect(I.b, BASE.a)
connect(I.b, BASE_bar.a);
connect(BASE_bar.a, rev1.a);
connect(rev1.b, ARM1.a);
connect(rev1.b, ARM1_base.a);
connect(ARM1_base.s, rev2.a);
connect(rev2.b, ARM2.a);
connect(rev2.b, ARM2_bar.a);

Up to this point, we have automatically generated
the Modelica simulation code for the given
mechanical design. After the translation phase the
user can easily add the first revolute joint a rotary
motion generator attached to its available rotational
degree of freedom by editing the generated code. At
this phase, multi-domain simulation can be
integrated with the mechanical model by connecting
it with other domain simulation models. The
simulation environment allows the user to couple
various physical domains in one simulation.
The added visualization capabilities are very
important both for engineering interpretation and for
design reviews. Data variable plots and animation of
the mechanical system make it even easier to spot
trends and region of interest.

Integration with the
MathModelica Simulation Environment
Mechanical Desktop
DWG

Mechanical Desktop and
the attached translator

Translator

Mechanical
MODELICA
Model
model.mo
Geometry

Mathematica
Notebook
Generator

MathModelica
Notebook

Other model
related
information

Figure.7 CAD integration with the MathModelica environment
Our environment will, in the future, be fully integrated
with the MathModelica environment. MathModelica
is an integrated problem-solving environment (PSE)
for full system modeling and simulation [Jirstrand et
al. 1999; Jirstrand 2000]. The environment integrates
Modelica-based modeling and simulation with graphic
design, advanced scripting facilities, integration of
code and documentation, and symbolic formula
manipulation provided via Mathematica. Import and
export of Modelica code between internal structured
and external textual representation is supported by
MathModelica. The environment use extensively the
principles of literate programming [Knuth 1984] and
integrates most activities needed in simulation design:
modeling, symbolic processing, transformation and
formula manipulation, storage of simulation models,
version control, input and output data visualization,
storage
and
generation
of
documentation.
Mathematica [Wolfram 1996] is an interpreted
language and integrates several features into a unified
integrated environment: numerical and symbolic
calculations, functional, procedural, rule-based and
graphical programming. Also the language
incorporates many features of traditional mathematical
notation and the goal of the language is to provide a
precise and consistent way to specify computations.
Mathematica is divided into two distinct parts: the
computer algebra engine (“kernel”) that receives and
evaluates all expressions sent to it and the user
interface (“front-end”). The front-end provides the
program interface to the user and is concerned with
such issues as how input is entered and how
computation results are displayed to the user.
Mathematica’s front-end documents are called
notebooks [Wolfram 1996]. They combine text,
executable commands, numerical results, graphics,
and sound in a single document. A notebook provides
the users with a medium in which they can document
their solution along side the computation itself.
A functional structure diagram of the CAD
integration with the MathModelica environment is
given in Figure 7. A translator will extract all the

necessary information from the CAD system
generating a mechanical Modelica model, geometry
related information and other related information of
the mechanical model. This information will be
processed by a Mathematica notebook generator
which outputs a MathModelica notebook. The
generated notebook is processed by the
MathModelica simulation environment using the
incorporated simulation engine, 2D plotting of the
system variables are generated together with a
realistic animation of the mechanical system under
consideration.
The advantages of such a development chain for
virtual prototyping are:
• Early detection of mechanical design flaws.
• High quality generated code.
• High quality documentation generation which is
coupled to the design and code.
• Reduced time for design validation and
implicitly reduced development time.
• Multi-domain modeling is made possible.
• The possibility to handle information about a
product’s entire life cycle, from the design
phase to the manufacturing phase.

SUMMARY AND FUTURE WORK.
The objective of the work presented herein was to
demonstrate that the integration of a typical
CAD/CAM system and an equation based
simulation environment can produce a feasible
virtual prototyping environment with an enhanced
flexibility
compared
to
other
traditional
commercially available environments. The main
advantage of our environment is that the multidomain simulation is made possible in the same
environment.
The improved CAD integration provides the
users with a more intuitive and sound way of
constructing and verifying large, moving assemblies.
In that way designers can take into account the
dynamic nature of the problem and simulate the
entire mechanical assembly, rather than visualize a

static part or a small subassembly, resulting in more
accurate modeling and design solutions
Commercially available MBS simulation packages
like ADAMS or Working Model 3D cannot be directly
used for modeling the motion of mechanical systems
with attached controllers. To solve this problem we
propose a methodology based on the utilization of
possibilities available from both Mechanical Desktop
and Modelica. The efficiency of the proposed
methodology has been illustrated by the modeling and
simulation of the motion of a simple pendulum. The
integration of Mechanical Desktop and Modelica
enabled us to prove that our design concept of a
mechanical system can fulfill the functional
specification. The control algorithms can be tested in
parallel with the mechanical design of the systems.
The combination of two environments, the CAD
modeling
environment
and
the
simulation
environment, in effect, collapse the phase of coding.
In the future, we shall concentrate on the following
tasks:
• A complete integration of the CAD
translators to the MathModelica environment
• Better collision detection handling and
visualization of forces and effects of collisions.
• Automatic output of the force data to finite
element analysis (FEA) packages for structural
analysis and other applications.

ACKNOWLEDGMENTS
The work has been supported by the European
Commission Research and Development Program as
part of the RealSim project and by the ECSEL
Graduate School supported by the Swedish Strategic
Research Foundation.

REFERENCES
3Dsystems Inc, 2000. “Stereo Lithography Interface
Specification.”
AutoDesk Inc. 1999a. “AutoCAD 2000 ObjectARX
Developer’s Guide.
AutoDesk
Inc.
1999b.
“Mechanical
Application
Programming Interface [API] – Developers Guide.
Elmqvist, H.; S. E. Mattsson and M. Otter. 1999. “Modelica
- A Language for Physical System Modeling, Visualization
and Interaction.” In Proceedings of the 1999 IEEE
Symposium on Computer-Aided Control System Design
(Hawaii, Aug. 22-27).

Conference on Information Visualization (London, July
14-16), 188-193.
Fritzson P. and V Engelson. 1998. “Modelica - A Unified
Object-Oriented Language for System Modeling and
Simulation.” In Proceedings of the 12th European
Conference on Object-Oriented Programming (ECOOP'98
, Brussels, Belgium, Jul. 20-24).
Ferreira, J.A.; J.E de Oliveira; V.A. Costa; 1999.
“Modeling of Hydraulic Systems for Harware-in-the-loop
Simulation: a Methodology Proposal.” In Proceedings of
The International Mechanical Engineering Congress and
Exposition. (Nashville, USA, November 14-19).
Jirstrand, M.; 2000. “MathModelica – A Full System
Simulation Tool”. In Proceedings of Modelica Workshop
2000 (Lund, Sweden, Oct. 23-24 )
Jirstrand, M.; J. Gunnarsson; and P. Fritzson. 1999.
“MathModelica – a new modeling and simulation
environment for Modelica. ” In Proceedings of the Third
International Mathematica Symposium (IMS’99, Linz,
Austria, Aug).
Knuth, D.E. 1984. “Literate Programming” The Computer
Journal, NO27(2) ( May): 97-111.
Larson, H.,1999. Translation of 3D CAD models to
Modelica. Master thesis. IDA, Linköping University,
Sweden, April.
Mattsson, S. E. 1997. “On Modeling of Heat Exchangers
in Modelica. “ In Proceedings of European Simulation
Symposium (Passau, Germany, October 19-22)
Modelica Association 1999. Modelica – A Unified ObjectOriented Language for Physical Systems Modeling Tutorial and Design Rationale Version 1.2(Dec).
Modelica Association 1999. Modelica – A Unified ObjectOriented Language for Physical Systems Modeling –
Language Specification Version 1.3. (Dec).
Otter, M.; C. Schlegel; H. Elmqvist. 1997 “Modeling and
Realtime Simulation of Automatic Gearbox using
Modelica.” In Proceedings of European Simulation
Symposium (Passau, Germany, October 19-22).
Otter, M. ; Elmqvist H.; F. E. Cellier. 1996. “Modeling of
Multibody Systems with the Object-oriented Modeling
Language Dymola, Nonlinear Dynamics, 9:91-112,
Kluwer Academic Publishers.
Otter, M. 1995 Objektorientierte Modellierung
mechatronischer Systeme am Beispiel geregelter Roboter,
Dissertation, Fortshrittberichte VDI, Reihe 20, Nr 147.
Saldamli, L.; Fritzson, P.;2000 “Object-oriented Modeling
With Partial Differential Equations”. In Proceedings of
Modelica Workshop 2000 (Lund, Sweden, Oct. 23-24 )

Elmqvist, H.; D. Bruck; M. Otter. 1996. Dymola – User’s
Manual. Dynasim AB, Research Park Ideon, Lund

Shigley, J. E. 1995. Theory of Machines and Mechanisms.
McGraw-Hill, New York series in mechanical engineering.

Engelson, V. 2000. “Tools for Design, Interactive
Simulation, and Visualization of Object-Oriented Models in
Scientific Computing”. Ph.D. Thesis, IDA, Linköping
University, Sweden.

Tummescheit H.; J.Eborn. 1998. “Design of ThermoHydraulic Library in Modelica.” In Proceedings of The
12th European Simulation Multiconference (Machester,
UK, June 16-19 )

Engelson, V.; H. Larsson; P. Fritzson. 1999. “A Design,
Simulation and Visualization Environment for ObjectOriented Mechanical and Multi-Domain Models in
Modelica. “ In Proceedings of 1999 IEEE International

Wolfram S.. 1996. The Mathematica Book. Wolfram
Media Inc. (February).

6'URJLHV0%DXHU
0RGHOLQJ5RDG9HKLFOH'\QDPLFVZLWK0RGHOLFD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Modeling Road Vehicle Dynamics with Modelica
Stefan Drogies, Michael Bauer
Institute of Automatic Control
Darmstadt University of Technology
Landgraf-Georg-Straße 4
D-64283 Darmstadt
Germany
E-mail: Sdrogies@iat.tu-darmstadt.de

ABSTRACT
This paper presents a complex vehicle dynamics model which is implemented using the object oriented
modeling language ModelicaTM. The main focus is on the multi body system (MBS) implementation of
the dynamics of the chassis and wheels. The chassis contains models of an independent front
suspension with anti-roll bar, as well as of a twist-beam rear axle. Furthermore, a model of the
complete powertrain with automatic transmission is included. The resulting model is described in detail
and validated against measured data from test drives with a notchback sedan.

Introduction
The development process of modern-time
vehicles and its intelligent high-tech components
is characterized by the need to minimize the time
and the costs from the vision of a new automobile
until its series production. Under these conditions
car manufacturers and suppliers make more and
more use of simulation tools to keep or even
improve the current standards of vehicle safety,
comfort and quality.
Modern cars can be seen as heterogeneous
systems, which are composed of elements from
different physical domains. For this reason a
general model of a road vehicle may include
components from the hydraulic, electronic,
control or even thermodynamic domain. Above
all, simulating vehicle dynamics requires dealing
with 3D mechanics.
The development of multibody codes has made it
possible for complicated models of all types of
mechanical models to be produced. Tools such as
ADAMS [ADA98] or SIMPACK [Kor98] are
highly specialized on the simulation of multibody
systems, however they lack the multi-domain
capabilities: the integration of non-mechanical
systems is not straightforward.
On the other hand, purpose-built codes like
CARSIM [Say95] or MatlabTM- and Fortranbased models usually cover most of the important
aspects of a vehicle model. Unfortunately,
changes of the model structure, especially of the
mechanic parts, are often difficult to achieve.

For this reason we consider the use of
ModelicaTM [Fri98], a general object-oriented
language for modeling and simulation of
physical systems.
The language unifies and generalizes previous
object-oriented modeling languages. Compared
to other commonly used simulation languages
ModelicaTM offers three important advances: It
is built on non-causal modeling with true
ordinary differential and algebraic equation.
Furthermore, it offers a general type system that
unifies object-orientation, multiple inheritance
and templates within a single class construct.
Besides that, ModelicaTM is designed to model
and to simulate systems consisting of
components from different domains such as
electrical circuits, drive trains, multibody
systems, thermodynamical and hydraulical
systems.
As requirements for the proposed vehicle
dynamics model the following guidelines were
defined. The model should be easy to modify
and extend, intuitive to use, it should have a
modular structure and contain varying levels of
detail according to different simulation tasks.
Furthermore, the model is intended to have
sufficient complexity to replicate the braking
and handling responses of automotive vehicles
through the full range of non-crash conditions.
Figure 1 shows the structure of the vehicle
model with its main components powertrain
including the combustion engine, car body,

front and rear axle, steering, brake system,
wheels and ground. Model inputs are the throttle
angle, the brake pressure and the steering angle.

measured data from test drives with a
notchback sedan. The technical data of the
vehicle is outlined in Table 1.

Powertrain (Powertrain)
Steering Angle

The class Powertrain contains instances of
classes
representing
the
ModelicaTM
components of the drivetrain: combustion
engine, torque converter, automatic gearbox,
differential, appropriate inertias and the
automatic transmission control unit (ATCU)
which generates the gearshift signals. Figure 2
shows the according ModelicaTM component.
Mechanical flanges are characterized by small
square boxes, whereas signal connectors are
indicated by small triangles.

Brake Pressure
Throttle Angle

Figure 1: Top level structure of the vehicle
dynamics model

With regard to the mechanical part of the vehicle
it is useful to distinguish between the kinematics
of the chassis, the body and the steering and the
dynamics of the powertrain.
With its specialised MBS and rotational (former
drivetrain) library, ModelicaTM favours this
classifying. The wheels as an interface between
the rotation of the powertrain and movement of
the body are attached to both systems.
Mass

1555 kg

Wheelbase

2,6 m

Wheel track

1,4 m

Max. power

125 kW

Max. torque

227 Nm

Transmission

automatic 4-speed planetary
gear with Trilok converter

Front wheel
suspension

McPherson struts with A-arms
and stabilizer

Rear wheel
suspension

twist-beam axle

Steering

rack and pinion steering

Brake

conventional hydraulic brake
with disks all around

Table 1: Technical data of the test vehicle

In the following sections the model structure is
explained in detail, some annotations with regard
to its realization in ModelicaTM are made and the
resulting simulation model is validated against

In the following sections all components which
are not part of the ModelicaTM standard library
are described in more detail.
Combustion Engine (EngineTorque)
The characteristics of the combustion engine
are described by a static neural network, which
approximates the engine torque in dependency
of the actual throttle angle and the engine
speed. A three layer multi-layer perception
network was trained using the engine data
measured by an engine dynamometer test cell.
In order to take the effect of ageing and wear
into account, the resulting engine torque is
multiplied by a throttle dependent factor.
The inertia of the engine and of the torque
converter pump are taken into account in the
shaft element InertiaEnginePump.
Torque Converter (TorqueConverter)
The trilok torque converter is a fluid coupling
device used in automatic transmissions for its
damping
characteristics
and
torque
multiplication characteristics. Torque is
transferred to the turbine as a result of oil flow
induced by the pump which is connected to the
engine shaft. The torque converter is assumed
to be always operating at its capacity and
therefore can be adequately modeled by its
steady state characteristics [För90]. Given the
turbine speed ωT and the pump speed ωP,
Euler’s turbine equation yields

TT = k P (ω P ,ω T ) ⋅ DP5 ⋅ ω P2

(1)

Figure 2: The class Powertrain

where kP is a characteristic parameter of the
converter that depends on the ratio between pump
and turbine speed, and DP denotes the
characteristic diameter of the converter. From the
resulting pump torque TP, the turbine torque TT is
determined using

TT = − µ (ω P ,ω T ) ⋅ TP

(2)

where µ is the torque ratio of the converter
provided by the manufacturer. The inertia of the
turbine and the converter oil are taken into
account in the shaft element InertiaTurbineOil.
The torque converter clutch (TCC) can bypass
the torque converter in the fluid coupling mode
of operation to provide a direct mechanical link
between the engine and the drivetrain. Thus,
power losses are reduced. The TCC is controlled
by the ATCU and is modeled using the
ModelicaTM library class FrictionBase.
Automatic Gearbox (Gearbox)
The transmission consists of a Ravigneaux design
compound planetary gear train, which provides
four forward ratios. The used model assumes an
ideal gearbox with fixed gear ratios. As gear
shifting occurs within a finite time duration, not
instantly, speed transitions are presented by lowpass filtering the gear ratio commanded by the
ATCU. Furthermore, an additional delay time is
applied to the gear shift as well as to the TCC
signal from the ATCU, in order to better fit the
dynamic
behaviour
of
the
automatic
transmission. The inertia of the gearbox is taken
into account in the shaft element InertiaGearbox.

Automatic Transmission
(GearControlUnit)

Control

Unit

The ATCU determines the gear shifting
operation based on the knowledge of the current
gear, the throttle input, the vehicle’s velocity
and the status of the torque converter clutch.
These inputs are applied to a shift logic map
which calculates the gear ratio and the TCC
signal for the automatic gearbox.
Differential (Differential)
An ideal conventional differential without
inertia was considered according to

2 ⋅ ω Gear = nDiff ⋅ (ω L + ω R )
TL = TR

(3)

TGear ⋅ nDiff = −(TL + TR )
where nDiff is the gear ratio of the differential, TL
and TR are the torque acting on the left and right
wheel shaft and ωL and ωR are the associated
shaft speeds.

Brake System (BrakeSystem)
Due to the shift in dynamic forces from rear to
front that accompanies vehicle braking, the
braking torque applied to the front must be
greater than that of the rear. Thus, a brakepressure limiter for the rear brakes is often
used. In the class BrakeSystem this fact is taken
into account by setting the brake power
distribution ratio to 70% / 30% (front / rear).
Moreover, the dynamics of the hydraulic
pressure build up and pressure reduction is
assumed to be of first order low pass with
different time constants for pressure build up an

pressure drop. The brake itself is modeled in the
class Wheel.

Multibody System
The classes Body, FrontAxle, RearAxle, Steering,
Ground and parts of the class Wheel are modeled
with the ModelicaTM MBS library, because its use
of the recursive Euler algorithm allows fast and
efficient modeling with a high grade of failure
immunity [Wol00]. In the following section some
general remarks are made with regard to the
realization of the classes in ModelicaTM,
thereafter a more detailed description of each
class follows.

term "unsprung" is not exactly correct because
those parts are sprung by the tires yet. All
sprung masses may be represented by one mass
component, whereas the unsprung masses
should be considered more carefully. According
to the available vehicle data all masses of the
vehicle are modeled using elements of the
ModelicaTM MBS library (e.g. boxBodies,
cylinderBodies and Masses).

Steering

Front
Axle

Rear
Axle

Aspects of the Implementation
Many MBS vehicle simulations use only one
connection from the inertial system to the car,
e.g. Adamski in [Ada99]. This requires that the
centers of roll and pitch are known. However,
when testing constructive changes of the wheel
suspension for example, this is a great
inconvenience.
In this case, the vehicle’s degrees of freedom
(DOF) might be unintentionally decreased. In
order to prevent this possibility, in our approach
each wheel is connected to the ground. Without
wheel suspension, this would lead to three
kinematic loops.
Complex axles increase the number of loops. For
example, the twist beam of the rear axle leads to
an additional loop, and so does the stabilizer.
Including the steering, the number of kinematic
loops of the MBS is 13.
A rigid car body is assumed, and therefore any
elasticities of its connections to the axle support
are neglected.

Ground

Joint

Chassis

Cut

Body

Figure 3: Overview over the MBS model

The braking of the kinematic loops is done by a
six-dimensional cut spring, which allows to
assign certain stiffness and damping to each of
the DOF, thus permitting an exact modeling of
the elasto-kinematic suspension bearings.
Moreover, the stiffness of the twist-beam and
the stabilizer is realized by using these cutsprings.
The non-cut bearings are modeled with
Prismatic and Revolute Joints of the
ModelicaTM MBS library.

Figure 3 gives an overview of the MBS, its
kinematic loops and the cut elements which are
used to break the kinematic loops.
The cut-components which help breaking the
kinematic loops are distributed symmetrically in
the chassis elements, except for the steering.
Thus, the replacement of any wheel’s suspension
is easy to realize and a user of the model does not
need to bother with kinematic loops.
All masses of an vehicle can be separated in
sprung and unsprung masses. [Say95] The body
and parts of the axles belong to the sprung mass.
The unsprung masses are the wheels and the
steered parts of the suspension. Note, that the

massless
Bar

7
8
2

6

3

1

4
5

Figure 4: MBS of the test vehicle

Front Suspension (FrontAxle)
As shown in Figure 4 the wheels are suspended
by McPherson struts (6) and A-arms (5). The Aarms of both sides are connected through an antiroll bar (4) which is also supported by the body.
A McPherson strut differs from a common
suspension strut by its ability to compensate
transversal forces. This behavior is represented
by a Cylindrical Joint with a parallel connected
Damper, whose characteristic line is given by a
CombiTable1D.

The A-arms were modeled as solid body. All
bearings of the axle are realized as cut springs
or classes with sprung and damped Prismatic
and Revolute Joints for all six DOF . The
stabilizer also got a central cut spring to
reproduce the behavior of a flexible bar.
Rear Suspension (RearAxle)
The suspension of the rear wheels is realized as
twist-beam (7) axle with longitudinal rods (8).
The twist beam of the axle is composed of two
boxBodies which are connected by a cut spring.
The stiffness around its twist-axis is set to low
values, while to the other five DOF high values
are assigned. For making a reciprocal deflection
possible the bearings of the longitudinal links
are elastic around each axis. Again springs and
shock absorbers are taken from the ModelicaTM
MBS library.
Steering (Steering)

Body
Steering
Wheel
Body

Figure 5: Model of the McPherson strut

Because the spring is inclined against the damper,
it is attached in our model to the end of two bars
as shown in Figure 5. Additionally, the
integration of this strut into the front axle is
shown there.

The front wheels are controlled by a rack and
pinion steering. Turning of the steering wheel is
resulting in displacement of the steering rack
(1) which moves the steering link (2) and the
steering knuckle arm (3). The effect of the
power steering of the test cars is neglected,
because the main focus is on the vehicle
dynamics itself and not on the driving comfort.
For this reason we consider only the measured
steering angle and not the required torque at the
steering wheel.
The modeling of the steering is carried out
according to the same technique already applied
to the suspension elements.
A major difference is the use of an
IdealGearR2T class from the ModelicaTM
rotational sublibrary as steering gear. The DOF
of the gear rack is given by a Prismatic Joint
that can be sprung and damped for fitting
stiffness and friction of the steering to measured
values.
Wheel (Wheel)
Since the wheels transmit the drive-, brake- and
side forces of the car, its description is most
important for each simulation model [Kie00].

Figure 6: 3D sight of the McPherson strut

The wheel has two main tasks. First, it connects
the vehicle to the ground and therefore it needs
four DOF: Two Revolute Joints at its base,
which allow that the wheel can camber and turn
around its vertical axis. Furthermore, a

Prismatic Joint which enables the compression of
the tire spring and the lifting of the wheel and
finally a third Revolute Joint at the wheel center
which describes its bearing.

calculated according to Burkhardt [Bur93].
From this values the tractive forces are
computed.
Ground (Ground)
This class serves as an interface between the
inertial system and the wheels. Three Prismatic
Joints are assigned to each wheel. Two joints
allow its plain movement, whereas the third
joint simulates vertical road irregularities.
These road irregularities can be given by
measured tables, as any analytical function or
by shaping filters.

Figure 7: The class Wheel

The brake functionality is modeled by the Clutch
element from the ModelicaTM rotational library
which is connected to the bearing and the axis
flange of the Revolute Joint. Thus, a support of
the braking torque at the wheel suspension can be
realized. Input to the brake is the pressure of the
brake fluid.
The wheel resistance force is applied as torque to
the wheel using the axis flange of the Revolute
Joint. Optionally, the drivetrain torque can act on
the same flange. Note, that no distinction
between driven or undriven wheel has to be
made.
The angular velocity of the wheel is measured
and compared with the translational speed of the
wheel center. From this results slip and slip angle
are computed. Using the force acting vertically at
the ground contact point, the wheel friction is

Figure 8: 3D sight of the MBS model

Examplary Results of Experimental
Verification
The model was verified using the test vehicle
described by table 1. Two experiments are
presented. A lane changing maneuver at a
vehicle speed of 14 m/s (experiment A) and a
braking and accelerating maneuver (experiment
B). The results given below (Figures 9-12)
show the precision of the model with regard to
the longitudinal dynamic of the car (experiment
B).

Steering Angle [rad]

The second task is to compute the angular
velocity of the wheel. For this reason it has a
Revolute Joint which is connected to the chassis,
a Mass with inertia and a FrameTranslation
pointing at the center of tire contact, where the
tractive and side forces are acting on. In order to
force this point to rest at its ground position, two
FrameRotations compensate camber and rotation.

Time [s]

Figure 9: Input of experiment A

Velocity [m/s]

Roll Velocity [rad/s]

0.4
0.2
0

Simulation

-0.2

Measurement
-0.4

0

1

2

3

4

5

6

7

8

9

35
30
25
20
15
10
5
0
-5

10

Simulation
Measurement

0

5

10

15

25

30

35

40

35

40

35

40

4

0.6

Acceleration [m/s2]

Yaw Velocity [rad/s]

20

Time [s]

Time [s]

0.4
0.2
0
-0.2

Simulation

-0.4

Measurement
0

1

2

3

4

5

6

7

8

9

10

2
0
-2
Simulation

-4

Measurement

-6
-8

0

5

10

15

20

25

30

Time [s]

Engine Speed [rad/s]

Lateral Acceleration [m/s2]

Time [s]

10
5
0

Simulation

-5

Measurement
-10

0

1

2

3

4

5

6

7

8

9

Simulation

100
0

Measurement

0

5

10

15

20

25

30

Figure 12: Results of experiment B

Conclusions and Outlook

However, the lateral dynamics of the test vehicle
(experiment A) are not as good reproduced as the
longitudinal dynamics. A reason for this may rely
on the fact that the parameter provided by the
manufacturer of the rear axle were not complete
and therefore some assumptions had to be made.

A model of a road vehicle was presented which
was modeled in ModelicaTM. The intention was
to simulate a complete car using only a single
software tool. The model should be easy to
modify and extend, intuitive to use and should
have a modular structure. The model showed to
have sufficient complexity to replicate the
braking and handling responses of a test car.
Nevertheless, some parameters still need to be
fitted for a better model match.

40

Throttle Angle [deg]

200

10

Figure 10: Results of experiment A

30
20
10

0

5

10

15

20

25

30

35

40

Time [s]

Brake Pressure [105 Pa]

300

Time [s]

Time [s]

0

400

60

40

20

0

0

5

10

15

20

25

30

Time [s]

Figure 11: Inputs of experiment B

35

40

Unfortunately the computational demand of the
model is rather high, so e.g an application to.
hardware-in-the-loop simulation is yet not
possible. Simplifications especially of the MBS
will be tested to improve this, e.g. by reducing
the number of kinematic loops. This is
facilitated by the ability to change any class
without the need to restructure the whole
model.
Due to the complexity of the model a very high
number of parameters is used for its
description. For this reason the organization of
the parameter records should be improved,
which would also provide an elegant possibility
to manage a greater number of different car
types.

REFERENCES
ADAMS: Mechanical Dynamics Engineering
Software, Product Overview 1998. Mechanical
Dynamics Inc., Ann Arbor, USA.
Adamski, D., Bardini, R., Bertram, T., Hörsken,
C., Lange, O., Roll, U., Torlo, M., and Ward., D.
1999. "Vehicle Modeling and Simulation in the
Duisburg Mechatronics Laboratory." In A.
Kecskeméthy, M. Schneider, and C. Woernle,
editors, Advances in Multibody Systems and
Mechatronics, pages 65-88, Institut für Mechanik
und Getriebelehre, Graz, Austria.
Burkhardt, M. 1993. “Radschlupf-Regelsysteme.” (in German) Vogel Verlag, Köln,
Germany.
Förster, H.-J., 1990, “Automatische Fahrzeuggetriebe” (in German), Springer Verlag, Berlin,
Germany.
Fritzson, P. and V. Engelson. 1998. “Modelica –
A Unified Object-Oriented Language for System
Modeling and Simulation.” In Proceedings of the
12th European Conference on Object-Oriented
Programming, ECOOP'98, Brussels, Belgium.
Kiencke, U. and Nielsen, L. 2000. "Automotive
Control Systems " Springer Verlag, Berlin,
Germany.
Kortüm, W., W. Rulka, M. Spieck, 1998.
“Simulation of Mechatronic Vehicles with MBScode SIMPACK.” Multibody Dynamics: New
Techniques and Applications, London, UK.
Sayers, M. and D. Han, 1995. “A Generic
Multibody Vehicle Model for Simulating
Handling and Braking”. Proc. 1995 IAVSD
Symposium, Ann Arbor, USA.
Wolf, A. and Kayser, A. 2000."Component
Orientated Modelling of Electrical and
Mechanical Systems as Required by Component
Simulation Software." In 1st IFAC-Conference
on Mechatronic Systems Preprints Volume II,
Darmstadt, Germany.

-(ERUQ.-cVWU|P
0RGHOLQJRID%RLOHU3LSHZLWK
7ZR3KDVH)ORZ,QVWDELOLWLHV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Modeling of a Boiler Pipe with Two-Phase
Flow Instabilities
Jonas Eborn and Karl Johan Åström
Department of Automatic Control
Lund Institute of Technology, Lund, Sweden
October 13, 2000

Abstract:
Tubes with boiling are common elements of many processes.
They appear in steam generators and refrigerators and many other systems.
The behavior of such systems is complicated and many physical phenomena
are involved. It has for example been observed that different types of
instabilities can occur. In this paper we will discuss modeling of tubes with
boiling. As an application we will discuss an instability phenomenon due to
pressure oscillations that has been observed experimentally in many different
situations. We will first derive a simple analytical model which is able to
capture the oscillations qualitatively. The simple model also gives insight into
the mechanisms that generate the oscillations. A more complicated model
is then built using a recently developed model base library in Modelica. A
comparison between the simple and the complicated model is also given.

1. Introduction
Evaporation of fluids flowing through a tube is common in many processes. It is a key element
in steam generators, refrigerators and many other systems. The physical phenomena during
evaporation is quite complicated. Both the dynamics and fluid property relations are highly
non-linear and key quantities like the dry-out point or the amount of superheat are difficult
to measure. Many factors contribute to making these processes hard to control. It has for example
been observed that different types of flow instabilities /oscillations can occur, see (1, 4, 8).
In this paper we will discuss modeling of tubes with boiling. As an application we will discuss
an instability phenomenon due to pressure oscillations that has been observed experimentally in
different situations, e. g., in (5). Modeling of such systems is usually done by "brute-force", using
CFD code with high discretization. In this paper we take a different approach.
Within the framework of a European collaboration a new modeling language, called Modelica, has
been developed. Modelica is based upon the experiences of the members of the Modelica Design
Group and is aiming at becoming a standard for equation-based continuous-time and hybrid
modeling. As a part of the effort some Modelica base libraries for applications within different
domains have been developed, among these a thermo-hydraulic base library, see (7). This library
is used here to build a discretized model of a boiling tube.
First a simple, low-order analytical model is derived from first principles. The simple model is
able to capture the oscillations that have been observed experimentally. It can also give insight
into the mechanisms that generate the oscillations. Then a more complex model is built using the
thermo-hydraulic base library in Modelica. Simulations of the complex model shows that it gives

steam
quality
1

0
0

Q1
Fig. 1

Q1 + Q2

position

Distribution of vapor along a heated tube.

results comparable to the simplified model and also close to experimental data. But the complex
model also has a richer behavior. Comparisons between the two models are given.

2. Simple Physical Analysis
When liquid streams through a heated tube it is first heated to the boiling temperature, when
boiling occurs there is a mixture of liquid and gas and finally there is only gas which is heated.
This is illustrated schematically in Figure 1. The heating zone is from 0 to Q1 , the boiling zone
from Q1 up to Q1 + Q2 and after this point there is no liquid left in the tube. If the flow is sufficiently
fast the liquid does not spend enough time in the tube for all liquid to evaporate and then there
are only two zones. If the flow rate is even higher boiling may not even start.
Two phase flows are quite complicated. Here we will first start with a simplified, homogeneous
model. Let P be the power per unit length supplied to the tube, let m be the mass flow rate, let
hin be the enthalpy of the liquid at the entrance of the tube, hl the liquid enthalpy at boiling
temperature and hc = hv − hl the difference between the enthalpy of the vapor and the liquid.
Moreover let L be the length of the tube and Q1 and Q2 be the length of the heating and boiling
zones. If we assume stationary conditions, a global energy balance gives
m(hl − hin) = PQ1
mhc = PQ2

(1)

The condition for having complete boiling is that Q1 + Q2 < L. Neglecting the enthalpy increase of
the vapor we get
PL
m < mc =
(2)
hv − hin
where mc is the critical mass flow rate.
The pressure drop is

∆p =

k 2
k m2
ρv =
2
2A2 ρ

(3)

To determine the pressure drop we thus have to calculate the average 1/ ρ . To calculate the average
we will consider three separate cases.
Complete Boiling: In this case all phases are present. In (2) it was shown that in steady state
the mass ratio of the vapor in a heated tube is piecewise linear. If we assume that this profile is
a good approximation also in the transient stage we can assume that the volumity, ν = 1/ ρ , is an
affine function in the boiling zone, i.e.

ν=

ξ
Q2 − ξ
νv +
νl
Q2
Q2

where 0 ≤ ξ ≤ Q2 and the origin is at the start of boiling. Hence
Z
Z Q2

1
1  Q1
ν −νl 
=ν =
ν l dξ +
νl + ξ v
dξ + ( L − Q1 − Q2 )ν v
ρ
L 0
Q2
0


Q1 1
1
L − Q1 − Q2 1
Q2 1
=
+
+
+
L ρl
2L ρ v
ρl
L
ρv

(4)

It follows from Equation (1) and Equation (2) that

Q1
hl − hin m
=
L
hv − hin mc
Introducing x = m/mc into (4) we find that

Q2
hv − hl m
=
L
hv − hin mc

h − hin
ρl
ρ
x hv − hl ρ l + ρ v
= (1 − x) l + x l
+
ρ
ρv
hv − hin 2 hv − hin ρ v

Partial Boiling: In this case there is only a heating zone and a boiling zone. The flow at the
exit of the tube consists of a mixture of both vapor and liquid. We have Q1 < L = Q1 + Q2 and we
get
Z
Z Q2
1
1  Q1
νv − νl  
=ν =
ν l dξ +
ν l + ar ξ
dξ
ρ
L 0
Q2
0

Q1 1
ρ
Q2 
=
(5)
+
2 + ar l − 1
L ρl
2L ρ l
ρv
where ar is the mass fraction of vapor at the tube outlet. Neglecting the energy increase in the
pure vapor phase a global energy balance gives
mar (hv − hl ) = PQ2 = P( L − Q1 ) = mc (hv − hin) − m(hl − hin)
Combining this with Equation (2) we find
mc (hv − hin) − m(hl − hin)
m(hv − hl )
Q2
m hv − hl
m hl − hin
=
ar = 1 −
L
mc hv − hin
mc hv − hin

ar =

Inserting this into (5) we get

ρl
1
hv − hin − x(hl − hin) ρ l − ρ v 
hl − hin
hl − hin 
=x
+
1−x
2+
ρ
hv − hin 2
hv − hin
x(hv − hl )
ρv

No Boiling:

In the case where there is no boiling we have

ρl
ρl
=
=1
ρ
ρl
Summarizing the different cases we find that the pressure drop is given by
km2
km2c  m 
∆p =
=
f
2A2 ρ
2A2 ρ l
mc
where the function f = x2 ρ l / ρ is given by


a2

x2 a3 + x3 a1 +
(a3 + 1) − a3


2



 

1 − a1 x
1 − a1 x
2
2+
(a3 − 1)
f ( x) = x xa1 +
2
a2 x






 x2

(6)

for 0 ≤ x < 1
for 1 ≤ x <
for x ≥

1
a1

1
a1

(7)

700

600

500

f(x)

400

300

200
400
200
128
50

100

0
0

Fig. 2

5

10
x

15

20

The function f (normalized pressure drop) for different ρ l / ρ v .

where the coefficients ai are given by
h − hin
a1 = l
hv − hin

a2 =

hv − hl
hv − hin

a3 =

ρl
ρv

(8)

Figure 2 shows that the curve has a negative slope for certain values of the ratio ρ l / ρ v. When
this occurs the function f will also have non-trivial extrema.

2.1 Conditions for local extrema
As can be seen in Figure 2 the pressure drop function (7) can have negative slope for certain
values of ρ l / ρ v. The local maximum and minimum will, for reasonable values of ai , always occur
in the partial boiling region, 1 ≤ x < 1/a1 . By differentiating the expression for f in this region
and setting it equal to zero we obtain
 a2 (a − 1) 

a1 (a3 − 1)  a3 − 1
3
f P ( x) = 3x2 1
+ 2x 1 −
+
=0
2a2
a2
2a2


a2
< 3( xa1 )2 + 4( xa1 )
−1 +1= 0
a1 (a3 − 1)
Solving this equation we find that the local extrema occur at
s

2 1
2 
a2
1 4
a2
1−
1−
−
±
x1,2 =
3a1
a1 (a3 − 1)
a1 9
a1 (a3 − 1)
3

(9)

Examining the second derivative shows that it is negative for small x and becomes positive above
x  2/(3a1 ), indicating a maximum for the smaller x in (9) followed by a minimum. The condition
for having two separate extrema is
2
4
a2
1≤
1−
3
a1 (a3 − 1)
√
a2
a3 ≥ a3c = 1 +
(4 + 2 3)
(10)
a1
The solution to this inequality shows that over a certain density ratio, ρ l / ρ v, the conditions for
local extrema are fulfilled and pressure-drop oscillations can occur. The critical density ratio (10)
depends on a1 , a2 and thus on the amount of sub-cooling. Analyzing the case when there is no
sub-cooling (a1 = 0) shows that the pressure drop is strictly increasing and thus there are no
local extrema. For the conditions in Figure 2 the critical density ratio is ρ l / ρ v = 127.89.

Summarizing we find that if a3 = ρ l / ρ v fulfills condition (10) then the function f has extrema in
(9) and the slope of f between the extrema is negative. The extrema will coincide if ρ l / ρ v = a3c .
The difference x2 − x1 increases with increasing ratio ρ l / ρ v.

3. Analysis of Oscillations
Having obtained a model for the pressure drop we will now
investigate some interesting dynamical phenomena. Figure 3
shows a schematic diagram of a boiling channel with a surge
tank. This corresponds to the experimental configuration
used in several experiments, see (5).
Let m0 and m denote the mass flow rate in and out of
the surge tank respectively. Let p be the pressure in the
surge tank and p0 the external pressure. The system can be
described by mass and momentum balances. The variables
p and m are chosen as states variables. The equations for
these states are derived from a momentum balance for the
heater tube and a mass balance for the surge tank:
dm
A
A
km2c
m 
= ( p − p0 − ∆ p) =
p − p0 −
f(
)
2
dt
L
L
2A ρ l mc
dV
ρl
= m0 − m
dt
where A is the cross-section of the tube and L is the length
of the tube.
The pressure in the tank is given by the ideal gas law. By
differentiating this equation we get an equation for dp/dt

Exit Restriction

Heater Tube

Surge Tank

p
m0

m

d
dt

dp
dV
( Vt − V ) = p
dt
dt
Solving for dp/dt and eliminating Vt − V we get
p( Vt − V ) = p0 V0

p0

−→

Fig. 3

Schematic of a boiling channel.

p dV
p2
dp
=
=
(m0 − m)
dt
Vt − V dt
ρ l p0 V0
The system is thus described by the second order differential equation system
dm
A
km2c
m 
=
p − p0 −
f
(
)
dt
L
2A2 ρ l mc
dp
p2
=
(m0 − m)
dt
ρ l p0 V0

(11)

The equilibrium of the equation system (11) is given by
m = m0 ,

p = p0 +

km2c
m0
f(
)
2A2 ρ l mc

3.1 Normalization
Introduce the time constants
Tma =

ρ l V0
m0

and

Tmo =

m0 L
Ap0

which are associated with the mass balance of the surge tank and the momentum balance of the
heating tube respectively. Notice that ρ l V0 is the mass of the liquid in the volume V0 and m0 is
the mass flow rate. Similarly, note that m0 L is the momentum of the fluid in the tube and Ap0 is
the force acting on the fluid.

Fig. 4

Simulated limit cycle of pressure drop oscillations.

By then introducing the scaled time τ defined by
s
r
1
Ap0
τ =
t=
t
Tma Tmo
ρ l V0 L
the equation system becomes
dx
= α ( y − 1 − β f (γ x))
dτ
dy
1
= (1 − x) y2
dτ
α
where

s

α =

ρ l V0 Ap0
Lm20

s
=

Tma
,
Tmo

β=

km2c
∆ pc
=
,
2A2 ρ l p0
p0

(12)

γ =

m0
mc

and ∆ pc is the stationary pressure drop when m = m0 = mc .
If the simplified model (12) is used the system is thus characterized by four parameters only; the
ratios of densities, ρ v/ ρ l , time constants, Tma /Tmo , pressures, ∆ pc / p0 , and mass flows, m0 /mc .

3.2 Linearization
The equilibrium values of the normalized variables are
x=1
y = y0 = 1 + β f (γ )
If we choose u = ∆ m0 /m0 as an input the linearized system of equations at the equilibrium is
  
  

x   −α βγ f P (γ ) α   x   0 
d 
 


=


 
+
 2 
u
dt y
y
y0 /α
− y02 /α
0
Since the coefficients α , β and γ are positive it follows that the equilibrium is stable if f P (γ ) is
positive and that it is unstable if f P (γ ) is negative.

3.3 Simulation
The simple model (11) can easily be coded in Modelica to examine the behavior of the model. The
pressure drop function, f , is given as a Modelica function with four arguments, as seen in the

Sink

Tube
Heat
Source

Surge Tank
Fig. 5

Model diagram of the system.

code example below:
model evap "Evaporating tube with density-varying pressure drop"
parameter SIunits.Power P(start=800);
.
.
.
SIunits.Pressure dp;
SIunits.Pressure p(start=3e5);
SIunits.MassFlow m(start=0.024);
equation
dp = k*mc*mc/(2*A*A*rl)*f(x=m/mc, a3=rl/rv, a1=a1, a2=a2);
der(p) = p*p*(m0 - m)/p0/V0/rl;
der(m) = A/L*(p - pe - dp);
end evap;

With parameters taken from (5) you obtain a similar limit cycle in pressure and mass flow as
observed from their measurements. A phase plot of the limit cycle is shown in Figure 4. The
pressure drop characteristic is drawn with a full line and the pressure in the surge tank is
dashed. The period of the oscillation depends a lot on the volume of the surge tank, V0, which is
not stated in the reference.

4. More Complex Modelica Models
To verify the simplified model we can build a more complex, discretized model and compare the
results. This is done using the Modelica base library for thermo-hydraulic models, ThermoFlow, see
(7, 6). The basic components in this library are lumped and discretized control volumes containing
the balance equations for mass, energy and momentum. Using these standard components, a
system model as in Figure 5 is created with a surge tank and a discretized pipe. The pipe can
be discretized to any degree, in the presented results n = 10 was used, which gave reasonable
results. This complex model can exhibit a much more complicated behavior than the simplified
one.

4.1 One flow, multi-temperature model
To obtain a model similar to the simplified model we use a lumped mass (pressure) balance and a
discretized thermal (enthalpy) balance. In this way there is only one flow through the pipe instead

of n flows between the discretized volumes. Thus we can only obtain the type of pressure-drop
oscillations seen with the simplified model. This mixed model is not available as a component in
the library, but can be obtained by changing some of the basic components. Below are the central
parts of the pipe model; BalanceTwoPort, ThermalModel and FlowModel. Only the essential code
and changes to the classes are given.
For the mixed model to be correct, it is important to keep track of the mean thermal state, used in
the ThermalModel below. It is also important to distribute the flow difference between inlet and
outlet over the discretized energy balances, which can be seen in the BalanceTwoPort. Otherwise
flow changes are concentrated in one section of the pipe, influencing the thermal state in that
section too much.
partial model BalanceTwoPortSingleSpecial
...
SIunits.MassFlowRate dm[1];
equation
...
dm[1] = (mdot[1] - mdot[2])/n;
edot[1] = a.q_conv;
for i in 2:n loop
// Interpolated mass flow used for edot
edot[i] = if mdot[1]-dm[1]*(i-1) > 0
then (mdot[1]-dm[1]*(i-1))*h[i-1]
else (mdot[1]-dm[1]*(i-1))*h[i];
end for;
edot[n+1] = if mdot[2]>0 then mdot[2]*h[n] else mdot[2]*b.h;
for i in 1:n loop
der(M[i]) = dm[1];
der(U[i]) = edot[i] - edot[i+1] - p[1]*der(V[i]) + Q_s[i];
end for;
end BalanceTwoPortSingleSpecial;
partial model ThermalModelSpecial
replaceable model Medium = StateVariablesSpecial;
extends Medium;
equation
...
for i in 1:n loop
// thermal state equations
km[i]*der(h[i]) = kh[1, i]*der(M[i]) + kh[2, i]*der(U[i]);
end for;
km[n + 1]*der(p[1]) = kp[1]*sum(der(M)) + kp[2]*sum(der(U));
// Mean value of enthalpies in last component, gives mean thermal state
h[n + 1] = h[1:n]*d[1:n]/sum(d[1:n]);
end ThermalModelSpecial;
model FlowModelTwoPortSingleSpecialDyn
...
equation
G_norm[2] = if mdot[2] > 0
then mdot[2]*mdot[2]/d[n+1]/A
else -mdot[2]*mdot[2]/ddown/A;
dG = G_norm[1]-G_norm[2] + dGdown;
// This is the momentum balance equation
L*der(mdot[2]) = dG + (p[1] - pdown)*A - sum(Ploss)/n*L*Dhyd*Pi;
end FlowModelTwoPortSingleSpecialDyn;

Simulating the mixed model gives similar results as the simplified model, see Figure 6. This
verifies that the derivation of the pressure loss in the simplified model is correct. The simulation
results are also qualitatively very close to the experimental results in (5).

p [105 Pa]

1.9

1.8

1.7

1.6
0

Fig. 6

10

20

t [s ]

30

40

50

Pressure drop oscillations with simplified (—) and complex model (– –).

4.2 Fully discretized model
The standard model of a discretized pipe with n mass
balances (and flows) can also be used to study the problem with pressure oscillations. The results are however slightly different due to discretization effects. Each
time one section of the pipe goes from liquid to twophase it generates a small pressure shock wave in the
system. When there are pressure oscillations the phase
of the sections is constantly changing and thus highfrequency shock waves are generated, superimposed on
the slower pressure oscillations, see Figure 7. These
waves could be mistaken for high-frequency densitywave oscillations, (8), but are really discretization artefacts. One way around this problem would be to use a
so-called moving boundary model, (3), but this has not
been done here.

Fig. 7

High-frequency oscillations with fully
discretized model.

5. Comparisons
The pressure drop oscillations observed using the simple model from Section 2 are similar in
period and amplitude to the oscillations obtained with the one-flow discretized model. Note that
the shape of the pressure drop curve, and thus the properties of the oscillations, depend very much
on the average media properties used, ρ l , ρ v, hl , hv and hin. In the complex model the properties
change with the pressure and mass flow into the system, which causes differences in limit cycle
period and amplitude. In Figure 8 the pressure drop characteristic is plotted together with limit
cycles obtained with the one-flow model. The amplitude and damping of the oscillations vary with
the mean flow. This is caused by the energy dynamics which produce a lag in the density changes,
unlike the immediate response of the pressure drop function in the simplified model. The simple
model uses constant, average properties and thus gives the same limit cycle amplitude for all
mass flows within the unstable region.

6. Conclusions
A simplified model of a boiler tube has been derived, assuming equilibrium conditions and a
linear quality profile also during transients. The model gives a closed expression for the pressure

p [105 Pa]

1.9

1.8

1.7

1.6
0

Fig. 8

0.1

ṁ [kg/s]

0.2

0.3

Simulation results of the complex model, characteristic obtained from the simplified model. Two limit cycles
for different mean flows, ṁ = 0.15 kg/s (– –) and 0.2 kg/s (- - -).

drop which depends on mass flow through the tube and the ratio of vapor and liquid density.
The simplified model gives insight into how a known instability phenomenon, pressure-drop
oscillations, arises. The simplified model also gives results close to measurements in (5).
The simplified model has also been compared to two different discretized models developed in
Modelica. A one-flow model with lumped mass balance and discretized energy balance and a
fully discretized model. The one-flow model is shown to give more realistic oscillations than the
simplified model. The fully discretized model, however, gives high frequency oscillations due to
discretization effects and is not reliable for studies of pressure-drop oscillations.
The two discretized models was built using a thermo-hydraulic base library in Modelica,
ThermoFlow. The example shows how models for studying a complicated phenomenon can be
built from model library units, and how the library units can be adapted.

References

[1] C. J. Aldridge and A. C. Fowler. “Stability and instability in evaporating two-phase flows.”
Surveys on Mathematics for Industry, 6, pp. 75–107, 1996.
[2] R. D. Bell and K. J. Åström. “Drum-boiler dynamics.” Automatica, 36:3, pp. 363–378, 2000.
[3] P. A. Heusser. Modelling and Simulation of Boiling Channels with a General Front Tracking
Approach. SCS, 1996.
[4] S. Kakaç and H. T. Liu. “Two-phase flow dynamic instabilities in boiling systems.” In Chen
et al., Eds., Proc. 2nd Int. Symp. on Multi-Phase Flow and Heat Transfer, vol. 1, pp. 403–444,
1991.
[5] H. T. Liu, H. Koçak, and S. Kakaç. “Dynamical analysis of pressure-drop type oscillations with
a planar model.” Int.J. Multiphase Flow, 21:5, pp. 851–859, 1995.
[6] H. Tummescheit. “Object-oriented modeling of physical systems, part 11.” Automatisierungstechnik, 48:2, 2000. In german.
[7] H. Tummescheit, J. Eborn, and F. Wagner. “Development of a Modelica base library for
modeling of thermo-hydraulic systems.” In Modelica 2000 Workshop Proceedings, Lund,
October 2000. Modelica Association.
[8] G. Yadigaroglu. “Two-phase flow instabilities and propagation phenomena.” In Delhaye
et al., Eds., Thermal-hydraulics of Two-phase Systems for Industrial Design and Nuclear
Engineering, chapter 17. Hemisphere McGraw-Hill, New York, 1981.

:)UHLHLVHQ5.HEHU:0HGHW]'6WHO]POOHU
7HVWLQJ3/&SURJUDPVZLWK0RGHOLFD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Testing PLC programs with Modelica
Wolfgang Freiseisen, Robert Keber, Wilhelm Medetz, Dietmar Stelzmüller
SCCH – Software Competence Center Hagenberg, Austria
www.scch.at

Abstract
This paper describes the current status of the VirtMould project. The goal of the proj ect is to develop an
injection moulding machine simulator, that allows an offline simulation and testing of IEC 1131 based plc
programs.

Introduction
ENGEL is a leading manufacturer of injection moulding machines, producing more than 1000 machines per
year. Only 30% of these are standard machines, all others are configured individually according customer
requirements. This also requires individual plc software development (based on IEC-1131) for each of these
machines.
The final machine is usually only two weeks available for testing (including software test). Thisplaces a very
high time constraint on software development, as the software test (and fixing potential software bugs) must
be finished within this time. As software functionality and comple xity continuously increases, also this
bottleneck is continuously increased.
In order to improve this situation, each plc programmer should have a “virtual injection mo ulding machine”
on his deskto p. It must be integrated with the
IEC -1131 programming environment and should allow
interactive testing and debugging of plc
programs. A prerequisite therefore is, that also the IEC-1131
programming environment supports execution (simulation) of plc program s on the desktop ( usually plc
programs can only be executed on a real plc). It must also provide an interface for c oupling the plc
simulation with the machine simulation.
The main goals of the VirtMould project are:
•
•
•

Increase plc software quality
Decrease plc software development time
Increase customer support and satisfaction

In order to achieve a high user acceptance it is essential that the plc programmer has no extra work to define
the simulation models. The simul ation models are generated automatically based on existing hydraulic and
electronic CAD models of the machine.
The testing environment will also provide the possibility to
test program changes for already deliver ed
machines. To reduce errors due to side effects of program changes a regression test environment will perform
an automatic test run.
The project will be realized in several p hases. In t he first phase, only very approximate simulation models
will be used to simulate the behavior of th e injection moulding machines. The main goal of these models is
not quantitative but qualitative co rrect simulation. Depending on the achiev ed results the models will be
refined later.

Modelica
Several commercially available simulation systems were analyzed for usability within this project. The main
requirements were:
•
•
•
•
•

Integration with plc simulator through a COM interface. The
simulation model exec ution must be
triggered from the plc simulator.
Generation of simulation models from CAD models.
Possibility to add a custom graphical editor. The graphical edit ing should be similar to the CAD system
already in use.
Possibility to add a custom visualization that supports special debugging and testing functionally like
assertions and breakpoints
A standard hydraulic library should be available.

Due to these requirements the final decision was to implement a Modelica subset compiler for this project .
This provides an easy integration with the other components and later will also provide the possibility to use
a third-party Modelica compiler or hydraulic library.

Architecture
A parser implemented with ANTLR converts standard Modelica files to an intermediate parse tree
representation based on XML (figure 1) . These ModelicaXML files contain all the information of the
Modelica language, but provide easier access to the simulation models. The graphical editor is based on these
XML files and provides simple interactive editing of the simulation models. The automatic model generator,
that converts CAD models to M
odelica m odels, imports XML based C AD models and outputs
ModelicaXML models. In a next step the code generator uses these ModelicaXML files
to generate
executable C++ simulation code.
Modelica Standard
Libray

VirtMould Base
Library

Modelica
Parser

CAD Models

ModelicaXML

Graphical
Editor

C++ Code
Generator

Figure 1: Architecture

Modelica Compiler
The implemented Modelica compiler currently only supports a subset of the Modelica language, mainly
input output blocks. The main focus of the compiler is on an efficient integration of discrete simulation with
continuous simulation. Therefore an event based discrete sche duler has been implemented. It uses the
information of the connected input out put blocks as a d irected graph and provide an efficient change
propagation, thus minimizing the need to recomputed the whole simulation model at each simulation step.

Modeling
In the first phase simple simulation model s of the complete machine (hydraulic, mechanic, electronic,
pneumatic, logic) are create d. These are built upon input output blocks using discrete simulation logic and
simple ODE´s. The main goal of these models is not quantitative but qualitative co
rrect simulation. The
overall simulation model can be viewed as a large input output block, where the input are the ou ports of the
plc, and the output are the inports of the plc (figure 2).

L1-L3
Hauptschalter

L1..L3

L1-L3

230VAC
24VAC
+24VE
+24VC
+24VK1S
+24VKS
+24VK1
+24VK
+24VKN

Steuerspannung

NOTAUS
NOTAUS

SG

230VAC Steuerspg.

Watchdog

Watchdog
DO12
Filtermotor

Schutzgitter-Schließseite

Spg.

24VAC
+24VE

DI17
DI11
DI9

Schutzgitter-Spritzseite

DI3
DI11

+24VK
Einspritzen

+24VK1S
+24VK1
+24VKS
+24VK

DO321

SPS-Output

DO18

DO12
DO5
DO9
DO10
DO38
DO6
DO7
DO32
DO33
DO0
DO25
DO27
DO31
DO4
DO8
DO15
DO2
DO3
DO13
DO14

P1
P2
P1+2

Auswerfer
AI4

Kerne

P2
DO32
DO33
DO0
DO25
DO27
DO31
AO2
+24VK1S

AO2

AO3
AO4
AO5
AO6

SG
P2
DO4
DO8
DO15

AO0

TT081-out

Kü0..Kü7

DI29
DI30

DO6
DO7

AR281-out

H0..H7

Pumpen

+24VK1
+24VK
DO9
DO10
DO38
AO3/4
AO5/6

P2

L1..L3
230VAC
+24VE
Watchdog
DO18
H0..H7
Kü0..Kü7

Heizungen
DI15
Öl, T1..T7

SG
P1
+24VK
+24VE
DO2
DO3
DO13
DO14
AO0

DI22
DI19

Form
Ö/S

Anpresseinheit

+24VK
+24VE

SimDIGIN

DI4
DI5

DI0
DI12
DI13
DI14
DI20
DI23
DI24

DI17
DI1
DI9
DI3
DI11
DI22
DI19
DI29
DI30
DI0
DI12
DI13
DI14
DI20
DI23
DI24
DI4
DI5
DI2
D10
DI15

DI 325

AR281-in

DI2
DI10
AI4
Si0

Si1

Si0
Si1
AI3
ADI1

TT081-in

Einspritzen
Dosieren
AI3
ADI1

SPS-Input

L1-L3
Motor
+24VE
NOTAUS
DO5

Watchdog

Öl
T1..T7

Figure 2: Overall moulding machine model

Model Execution
The interface between the plc simulator and the machine simulator is realized by a COM interface. It
supports both synchronous (offline) and asynchronous (real -time) simulation. For the synchronous
simulation the simulation steps are triggered by the plc program simulator. This provides an ideal debugging
environment as the simulation s can be stopped, analyzed , and then continued at any
time step . The
asynchronous simulation provides som e kind of soft real -time simulation where both simulations are
executed in real-time. It is also planned to use some Windows NT real -time extension to provide a hardware
in the loop environment, where the machine simulator is coupled with a real plc. Figure 3 shows first results
of simulating a complete injection cycle.

Figure 3: Injection cycle results

Graphical Editor
The graphical editor is based on Ob jective Views, an MFC based C++
graphical editor framework. It
provides standard graphical editing features l ike add, delete, move, connect and editing of sub models . To
provide an easy navigation it will also support a
tree view of the simulation model and of available
simulation libraries.

Visualization
For the visualization OPC (OLE for process cont rol) is used as a standard interface. Th
is allows the
integration of available process visualization tools. All Modelica variables are mapped to OPC tags. OPC
provides an easy me chanism to browse available tags and to query the current value. It also provides an
event based notification mechanism for tag value changes.

Results and outlook
The current implementation provides a first working injection moulding machine simulator and looks very
promising. In addition to the main application area of program testing it might also be used for computer based training.

%-DFREVRQ-)UHGULNVVRQ-+HOOJUHQ-.DUOVVRQ
-6FDUSDWL37HPSOLQ+9DOOHMR
0RGHOLFD8VDJHLQ$XWRPRWLYH3UREOHPVDW
&KDOPHUV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

0-LUVWUDQG
0DWK0RGHOLFD$)XOO6\VWHP6LPXODWLRQ7RRO
0RGHOLFD:RUNVKRS3URFHHGLQJV

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

MathModelica - A Full System Simulation Tool
Mats Jirstrand
MathCore AB
Teknikringen 1F
SE-583 30 Linköping
Sweden
Abstract
The objective of this paper is to demonstrate the new software MathModelica and also
give a brief overview of some industrial and academic pilot projects where it has been
used. MathModelica is a modeling, analysis, and simulation environment for engineers at
companies which design complex products or systems of physical character. The tool is
built to support the iterative design and modeling process of complex systems where
analysis, technical computations, partial models, simulations, documentation, and control
system design are non-separable issues. Today this process is carried using a broad range
of tools. In MathModelica the modeling and simulation capabilities are tightly integrated
with an environment for technical computations which supports the engineering design
process from initial assumptions and tests to a final complex multi-domain model.
MathModelica is useful in a variety of areas such as the automotive and aircraft
industries, robotics, and complex machinery. The tool provides a technology that makes
it possible to ‘lift’ modeling and simulation one or several levels closer to the real
product than what is possible with most of today's software tools. Virtual prototyping is a
common term for parts of this process but does usually only include the mechanical
modeling part of the whole system. Full system simulation is a more accurate description
of what MathModelica provides.
The software provides both graphical and textual facilities for designing, programming,
documenting, simulating, analyzing, and publishing multi-domain models. Due to its
power and ease of use, it permits creation of ‘virtual prototypes’, computer simulations
that behave like a real physical object or system, e.g., an electrical network, a turbo
engine, an aircraft, or an industrial robot. The software consists of several modules for
different purposes and are used in different phases of the modeling process. The basic
modules are the Model Editor and Notebooks. MathModelica integrates and extends a
number of softwares such as the technical computing system Mathematica from Wolfram
Research, a diagram and visualization tool, and simulation algorithms from Dynasim.
This means that the MathModelica environment consists of well developed and reliable
software integrated in an environment for technical computations.
Recently, MathCore have started a number of pilot projects for multi-domain modeling
and simulation together with a few industrial and academic partners. The paper will also
include an overview of one or more of these projects and their results.

%-RKDQVVRQ3.UXV
0RGHOLFDLQD'LVWULEXWHG(QYLURQPHQW8VLQJ
7UDQVPLVVLRQ/LQH0RGHOOLQJ
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Mo d e lic a in a D is tr ib u te d E n v ir o n m e n t U s in g
T r a n s m is s io n L in e Mo d e llin g
B jö r n J o h a n s s o n a n d P e tte r K r u s
De p a rtm e n t o f M e c h a n ic a l E n g in e e r in g
L in k ö p in g U n iv e rs ity , S E -5 8 1 8 3 L in k ö p in g , S w e d e n
{ b jo jo , p e tk r } @ ik p .liu .s e

A b s tr a c t
P ro d u c ts a re b e c o m in g in c r e a s in g ly c o m p le x w ith
fu n c tio n a lity a n d c o m p o n e n ts fro m d iff e r e n t e n g in e e r in g d o m a in s . T h e o b je c t- o rie n te d m o d e llin g
la n g u a g e M o d e lic a fa c ilita te s th e m o d e llin g o f s u c h
s y s te m s . H o w e v e r, b y m a k in g it p o s s ib le to c r e a te
c o m p le x m o d e ls , th e re w ill b e a n in c re a s e d fo c u s o n
th e a c tu a l s im u la tio n .
T h e d is trib u te d m o d e llin g c o n c e p t is a w a y to
d e a l w ith s y s te m c o m p le x ity a ls o d u rin g th e s im u la tio n . T h e c o n c e p t im p lie s th a t th e s y s te m c a n b e
p a rtitio n e d in to s u b -s y s te m s a n d e x e c u te d in p a ra lle l. E a c h c o m p o n e n t is e q u ip p e d w ith a s o lv e r fo r
th e c o m p o n e n t s p e c if ic e q u a tio n s . T o a c h ie v e th e
fu ll s y s te m b e h a v io u r, th e c o m p o n e n ts e x c h a n g e
d a ta a t s p e c ific tim e in s ta n ts . T o in c r e a s e th e m o d e l
r o b u s tn e s s , th e c o m p o n e n ts c a n b e n u m e r ic a lly is o la te d fr o m e a c h o th e r u s in g th e tra n s m is s io n lin e
m o d e llin g te c h n iq u e . T h e d e la y w h e n s ig n a ls a r e
p ro p a g a tin g th r o u g h a s y s te m is th e n u s e d to n u m e r ic a lly s e p a ra te th e c o m p o n e n ts .
In th is p a p e r, th e fe a s ib ility o f c o m b in in g M o d e lic a w ith tra n s m is s io n lin e s f o r d is tr ib u te d s im u la tio n is d e m o n s tra te d . A ls o d is c u s s e d a r e th e a d v a n ta g e s c o m p a re d to th e tr a d itio n a l te c h n iq u e s o f
s im u la tio n .

In tr o d u c tio n
A s s im u la tio n is u s e d a s a to o l fo r d e s ig n in g a n d
a n a ly s in g c o m p le x s y s te m s , a n u m b e r o f a s p e c ts
m u s t b e c o n s id e r e d r e g a rd in g m o d e l c o m p le x ity . A n
o b je c t-o rie n te d a n d n o n - c a u s a l m o d e llin g la n g u a g e
lik e M o d e lic a p ro v id e s a b a s e fo r d e s ig n in g w e lls tru c tu r e d s im u la tio n m o d e ls [2 ,1 0 ]. H o w e v e r, th e
p o s s ib ilitie s o f c re a tin g la rg e a n d c o m p le x m o d e ls
s e ts th e fo c u s o n o th e r a s p e c ts th a t n e e d s to b e c o n s id e r e d .
T h e s im u la tio n m o d e l a n d its e x e c u ta b le in te rp re ta tio n m u s t b e n u m e r ic a lly s ta b le , e ffic ie n t a n d
fle x ib le . M u lti-d o m a in m o d e ls c o n s is t o f s u b s y s te m s w ith d iff e r e n t n u m e r ic a l p r o p e r tie s a n d tim e
c o n s ta n ts . T h e p o s s ib ility to c o n n e c t s u b s y s te m s

w ith d iffe r e n t s o lv e r s a n d tim e s te p s is a n a d v a n ta g e w h e n it c o m e s to s im u la tio n o f c o m p le x
m u lti-d o m a in s y s te m s .

D is tr ib u te d m o d e llin g
T h e d is trib u te d m o d e llin g c o n c e p t c a n b e v ie w e d
a s a n o p p o s ite s o lu tio n to th e c e n tra lis e d te c h n iq u e
re g a r d in g th e e x e c u tio n o f th e s im u la tio n m o d e l. A
b rie f d e s c rip tio n o f th e c e n tra lis e d a p p ro a c h is th a t
a ll e q u a tio n s d e s c rib in g th e s y s te m a r e c o lle c te d to
o n e la rg e s e t o f e q u a tio n s . A n in te g r a tio n a lg o rith m is th e n a p p lie d a n d a ll s ta te v a r ia b le s a re
s o lv e d fo r in e a c h tim e s te p d u r in g th e e x e c u tio n .
T h e c e n tr a lis e d c o n c e p t is v e r y c o m m o n a n d u s e d
in s e v e ra l s im u la tio n p a c k a g e s . A d v a n c e d s y m b o lic m a n ip u la tio n o f th e e q u a tio n s is p o s s ib le to
in c r e a s e th e n u m e r ic a l e ffic ie n c y . T h e d r a w b a c k o f
th e c e n tr a lis e d s im u la tio n te c h n iq u e is th o u g h th a t
th e w h o le s y s te m m u s t b e s ta te d in a u n ifo r m w a y .
S in c e th e s o lv e r o fte n u s e v a r ia b le tim e s te p , fa s t
d y n a m ic s in o n e p a rt o f th e s y s te m a ffe c t th e s te p s iz e a n d s im u la tio n tim e o f th e w h o le s y s te m .
U s in g th e d is tr ib u te d m o d e llin g te c h n iq u e , th e
c o m p o n e n ts b u ild in g th e s y s te m m o d e l a re c o n s id e r e d a s o b je c ts , n o t o n ly in th e m o d e llin g p h a s e b u t
a ls o d u rin g th e e x e c u tio n . A lo c a l s o lv e r is a tta c h e d to e v e r y c o m p o n e n t. T h e c o m p o n e n ts a re
th e n e x e c u te d in p a ra lle l e x c h a n g in g th e s a m e in fo r m a tio n a s th e p h y s ic a l c o m p o n e n ts . T h e d is trib u te d e n v iro n m e n t h a s a n u m b e r o f a d v a n ta g e s .
M o s t im p o rta n t is th a t a d is trib u te d e n v iro n m e n t
c a n b e v e ry f le x ib le . A s th e c o m p o n e n ts a r e in d e p e n d e n t o b je c ts , it is ra th e r s tr a ig h tfo rw a rd to c o n n e c t e x te rn a l c o m p o n e n ts to th e s im u la tio n m o d e l.
E x a m p le s o f s u c h e x te rn a l c o m p o n e n ts c a n b e a
p ie c e o f h a rd w a r e (H a r d W a re I n th e L o o p [6 ]) o r a
c o n n e c tio n to a n e x te rn a l s im u la tio n p a c k a g e .
T h e s e c o n n e c tio n s c a n b e e ith e r lo c a lly o n o n e
c o m p u te r o r o v e r a n e tw o r k (L A N , In te rn e t e tc .)
[4 ]. A n o th e r a d v a n ta g e is th a t th e d is tr ib u te d c o n c e p t o ffe rs lin e a r s c a lin g p r o p e rtie s . W h e n th e s iz e
o f th e s y s te m s , i.e . th e n u m b e r o f c o m p o n e n ts is
in c r e a s e d , th e s im u la tio n tim e is in c r e a s e d w ith th e
s a m e m a g n itu d e . A lth o u g h it is p o s s ib le to u s e a

lo t o f in fo r m a tio n fro m th e s y s te m s tru c tu re to in c r e a s e th e c o m p u ta tio n s p e e d u s in g a c e n tra lis e d
m e th o d , lin e a r s c a lin g is v e r y h a r d to a c h ie v e . T h e
s c a lin g p ro p e r tie s fo r c e n tr a lis e d s o lv e r s a r e v e r y
m u c h d e p e n d in g o n th e s y s te m p ro p e r tie s .
In F ig u r e 1 , a p o s s ib le s im u la tio n e n v ir o n m e n t
u s in g a d is trib u te d s tru c tu r e is s h o w n .

th e m e d iu m p a s s in g th ro u g h th e tra n s m is s io n lin e
is d iffe r e n t, b u t th e m a th e m a tic a l v a ria b le s a re
flo w a n d e ff o r t v a r ia b le s , th e s a m e w a y a s in th e
B o n d -g ra p h m o d e llin g te c h n iq u e .
E ffo rt e 1

E ffo rt e 2

F lo w f 1

F lo w f 2

F ig u re 2 : U n it T ra n s m is s io n L in e

T h e e q u a tio n s d e s c rib in g th e tr a n s m is s io n lin e a re

H a rd w a re

E Ex xteternrna al ls simim u ulalatiotion n
p pa ac ck ka ag ge e

e 1 (t + T ) = c 1 ( t ) + Z c f1 ( t + T )

(1 )

e 2 (t + T ) = c 2 (t) + Z c f 2 (t + T )

(2 )

w h e re Z
Da ta e x c h a n g e
S o lv e r
C om ponent
m odel

S o lv e r
C om ponent
m odel

F ig u re 1 : D is trib u te d s im u la tio n e n v ir o n m e n t

A d is tr ib u te d e n v ir o n m e n t w ith o r w ith o u t c o n n e c tio n s to h a rd w a re a n d e x te r n a l s im u la tio n p a c k a g e s
r e q u ir e s c o n tro l b y a to p -le v e l p ro c e s s . T h e m a in
ta s k fo r th is p r o c e s s is to c o n tro l th e s im u la tio n
s p e e d fo r th e s y s te m . A g lo b a l s te p s iz e c a n b e s e t
fo r th e s y s te m w h ile c o m p o n e n ts w ith fa s t d y n a m ic s
c a n b e lo o p e d fa s te r a n d e x e c u te d w ith a s h o rte r
tim e s te p .
T o a c h ie v e n u m e ric a l r o b u s tn e s s fo r a d is trib u te d
a p p ro a c h , it is p o s s ib le to n u m e r ic a lly is o la te th e
c o m p o n e n ts fro m e a c h o th e r. T h is s e p a r a tio n c a n b e
a c h ie v e d u s in g th e tra n s m is s io n lin e m o d e llin g c o n c e p t, T L M [7 ,1 ]. T h e m a in id e a is to in c lu d e th e
p ro p a g a tio n o f in f o r m a tio n th r o u g h th e s y s te m in th e
m o d e l. I n m o s t p h y s ic a l s y s te m s , th e r e is a d e la y in
tim e w h e n a s ig n a l p r o p a g a te s fro m o n e c o m p o n e n t
to a n o th e r. F o r e x a m p le a p r e s s u re p u ls e th a t is
c a u s e d in a h y d ra u lic v a lv e d o e s n o t im m e d ia te ly
a ffe c t th e w h o le s y s te m . T h e d e la y is n o r m a lly d e p e n d in g o f th e s p e e d o f s o u n d in th e tra n s m is s io n
m e d ia . T h is d e la y w h e n in f o r m a tio n p r o p a g a te s is a
v a lu a b le p ie c e o f e x tra in fo r m a tio n th a t c a n b e u s e d
to s e p a ra te th e c o m p o n e n ts n u m e r ic a lly .

Dis tr ib u te d
s io n lin e s

m o d e llin g

u s in g

tra n s m is -

T h e c o r e c o m p o n e n t in T ra n s m is s io n L in e M o d e llin g , is th e U n it T ra n s m is s io n L in e . T h is c o m p o n e n t
c a n b e v ie w e d a s a c a rrie r o f e n e rg y w ith a tim e d e la y . De p e n d in g o f th e s y s te m th a t is to b e m o d e lle d ,

c

is th e c h a ra c te r is tic im p e d a n c e , c 1 a n d

c 2 a re th e c h a ra c te r is tic s d e s c r ib in g th e w a v e fr o m
th e c o n n e c te d c o m p o n e n t. T h e c h a ra c te r is tic s a re
o f th e s a m e m a g n itu d e a s e ffo r t a n d a re d e f in e d a s
c 2 ( t ) = e 1 ( t ) + Z c f1 ( t )

(3 )

c 1 (t) = e 2 (t) + Z c f2 (t)

(4 )

A t e a c h c o m p o n e n t b e tw e e n th e lin e s , th e e q u a tio n s th a t n e e d s to b e s o lv e d a re th e fo llo w in g s e t
o f e q u a tio n s

f = f(e )

(5 )

e = c +Z cf

(6 )

w h e r e f is a v e c to r c o n ta in in g a ll th e flo w v a r ia b le s , e is th e c o rre s p o n d in g e ffo r t v a r ia b le s , c is
th e c h a ra c te r is tic s a n d Z c is a d ia g o n a l m a tr ix w ith
th e c h a ra c te ris tic im p e d a n c e s in th e d ia g o n a l.

T ra n s m is s io n
s y s te m

lin e

c o m p o n e n ts

in

a

In a s y s te m , th e c o m p o n e n ts m o d e lle d a s T L M c o m p o n e n ts a re d iv id e d in to tw o g ro u p s o f c o m p o n e n ts .
• Q -c o m p o n e n ts , c a lc u la tin g flo w
• C -c o m p o n e n ts , c a lc u la tin g c h a ra c te ris tic im p e d a n c e a n d th e c h a ra c te r is tic (th e w a v e , e ff o r t
v a ria b le )
Du rin g th e s im u la tio n , th e d iff e r e n t ty p e s o f c o m p o n e n ts a r e e x e c u te d a lte rn a te ly . F irs t, th e C c o m p o n e n ts a re c a lle d , u p d a tin g th e c h a r a c te ris tic s
a n d c h a ra c te ris tic im p e d a n c e s . T h e n th e Q c o m p o n e n ts a r e c a lle d c a lc u la tin g th e s ta te v a ria b le s a s flo w a n d e ffo rt. E x a m p le s o f Q c o m p o n e n ts a re re s is tiv e c o m p o n e n ts a s e le c tr ic a l
re s is to r s a n d h y d ra u lic o rific e s . E x a m p le s o f C ty p e c o m p o n e n ts a re c a p a c itiv e c o m p o n e n ts a s
v o lu m e s , s p rin g s a n d e le c tric a l c a p a c ito rs . It is n o t
a lw a y s p o s s ib le to s e p a r a te c o m p o n e n ts fro m a

c o m p o n e n t lib ra ry . O n illu s tra tiv e e x a m p le is a re c tifie r b rid g e , w h e r e th e tra n s m is s io n lin e te c h n iq u e
w o u ld re q u ir e s e p a r a tin g th e d io d e s w ith tr a n s m is s io n lin e e le m e n ts . T h is s e p a r a tio n w o u ld th e n a ffe c t
th e b e h a v io u r o f th e s y s te m u n le s s th e tim e s te p is
v e r y s h o rt, c a u s in g lo n g s im u la tio n tim e . T o a v o id
th is , th e re c tif ie r b rid g e c a n b e tre a te d a s o n e c o m p o n e n t a n d s o lv e d a s a n o r d in a ry c e n tr a lis e d m o d e l.

U s in g Mo d e lic a in a tr a n s m is s io n
lin e e n v ir o n m e n t
M o d e lic a is a p o w e rfu l la n g u a g e fo r d e s ig n in g
s im u la tio n m o d e ls w ith a s tru c tu re s im ila r to th e
p h y s ic a l s tru c tu r e . T h e T L M -c o n c e p t k e e p th e o b je c ts s e p a ra te d th r o u g h th e s im u la tio n w ith b e n e fits
a s n u m e r ic a l e ffic ie n c y , lin e a r s c a lin g , p a ra lle l c o m p u ta tio n e tc . A s o lu tio n w h e r e M o d e lic a c o m p o n e n ts
a re im p le m e n te d in a T L M -e n v ir o n m e n t w o u ld h a v e
th e p o te n tia l o f b e in g a p o w e r fu l a lte rn a tiv e to th e
tra d itio n a l im p le m e n ta tio n u s in g th e c e n tra lis e d
te c h n iq u e .
In th is w o r k , a to o l f o r a u to m a tic tra n s la tio n o f
s in g le M o d e lic a c o m p o n e n ts h a s b e e n c r e a te d u s in g
th e M a th e m a tic a p a c k a g e [1 1 ]. M a th e m a tic a is a
s y m b o lic m a th p a c k a g e , e n a b lin g h ig h -le v e l p ro g r a m m in g . B e s id e s th e m a th e m a tic a l p ro c e s s in g ,
a d v a n c e d te x t o p e r a tio n s c a n b e p e rfo r m e d a s w e ll.
T h e to o l tr a n s la te s a M o d e lic a c o m p o n e n t to a c o m p o n e n t w r itte n in F o rtra n th a t c a n b e in s e r te d in a
H O P S A N [5 ] s im u la tio n m o d e l.
H O P S A N is a s im u la tio n p a c k a g e u s in g th e
tra n s m is s io n lin e m o d e llin g te c h n iq u e . T h e m o d e ls
th a t a re s im u la te d in H O P S A N a r e n o r m a lly w ritte n
in th e F o r tra n la n g u a g e , a n d c o m p o n e n ts a re s to r e d
in a lib r a ry . S y s te m m o d e ls a r e c re a te d u s in g a
g r a p h ic a l m o d e llin g to o l [9 ]. T h e fo llo w in g s e c tio n s
w ill d e m o n s tra te h o w a M o d e lic a c o m p o n e n t is
a d a p te d to fit in a T L M e n v iro n m e n t.

T r a n s la tin g M o d e lic a c o m p o n e n ts
Dis trib u te d m o d e llin g u s in g th e T L M -m e th o d re q u ire s m o d e ls d e s c rib e d in a s p e c ific w a y . T h e c o m p o n e n ts s h o u ld h a v e e x tr a v a ria b le s fo r th e w a v e
p ro p a g a tio n a n d a s o lv e r fo r in d e p e n d e n t s o lv in g o f
th e e q u a tio n s in th e c o m p o n e n t. T h e M o d e lic a c o m p o n e n t c o u ld b e s ta te d d ir e c tly in th a t w a y , s till fo llo w in g th e M o d e lic a s y n ta x . It is d e s ire d h o w e v e r
th a t th e m o d e l d e s ig n e r s h o u ld n o t h a v e to c a r e
a b o u t is s u e s th a t a r e s p e c ific to th e im p le m e n ta tio n .
T h e m a in a d v a n ta g e w ith M o d e lic a is th a t th e m o d e l
c o d e s h o u ld b e s e p a ra te d fro m th e im p le m e n ta tio n .
T h is m e a n s th a t th e M o d e lic a c o m p o n e n t m u s t b e
m a n ip u la te d to fit in to th e T L M -e n v ir o n m e n t.

E x te n d in g a p r e v io u s ly c re a te d to o l in th e
M a th e m a tic a p a c k a g e , c a lle d C o m p g e n [8 ], th e
c o m p o n e n t file w ritte n in M o d e lic a c a n b e p ro c e s s e d a c c o r d in g to th e f o llo w in g s e q u e n c e :
S te p 1 : R e a d th e M o d e lic a c o m p o n e n t file
S te p 2 : F in d c o n n e c to r s , v a r ia b le s a n d p a ra m e te r s
S te p 3 : F in d th e e q u a tio n s d e s c r ib in g th e c o m p o n ent
S te p 4 : T r a n s fo rm th e e q u a tio n s to M a th e m a tic a
n o tific a tio n
S te p 5 : A d d th e b o u n d a ry e q u a tio n s a c c o r d in g to
th e ty p e o f c o m p o n e n t
S te p 6 : C a lc u la te p a rtia l d e r iv a tiv e s o f th e e q u a tio n s
S te p 7 : De fin e th e J a c o b ia n fr o m th e p a rtia l d e r iv a tiv e s
S te p 8 : A d d a N e w to n -R a p h s o n s o lv e r fo r th e
e q u a tio n s a n d w rite th e c o m p o n e n t a s
F o r tra n c o d e to a file
T h ro u g h s te p 1 -3 , th e te x t file c o n ta in in g th e c o m p o n e n t is s c a n n e d b y th e M a th e m a tic a p r o g r a m .
U s in g th e M o d e lic a s y n ta x d e fin itio n , th e in f o r m a tio n is th e n s o rte d a n d g r o u p e d . T h e m a th e m a tic a l
n o tific a tio n in M o d e lic a a n d M a th e m a tic a is n o t
th e s a m e , w h ic h is w h y a tra n s la tio n m u s t b e p e r fo r m e d to b e a b le to a n a ly tic a lly m a n ip u la te th e
e q u a tio n s in M a th e m a tic a . A s s e v e ra l c o m p o n e n ts
c a n b e d e s ig n e d a s e ith e r Q o r C -c o m p o n e n ts , it is
fo r th e u s e r to s e le c t a c c o r d in g ly . De p e n d in g o n
th e ty p e , d iffe r e n t v a ria b le s a r e u p d a te d d u rin g th e
e x e c u tio n .
T h e to o l is o n ly a b le to tr a n s la te a s u b s e t o f th e
M o d e lic a la n g u a g e . T h e e ffo rt h a s b e e n f o c u s e d o n
c re a tin g a to o l th a t w o rk s fo r s in g le c o m p o n e n ts
a n d th e m a in p u rp o s e is to fa c ilita te e x c h a n g e o f
c o m p o n e n ts b e tw e e n to o ls a n d p e o p le . T h e m a jo r
lim ita tio n is th a t in h e r ita n c e is n o t h a n d le d , w h ic h
m e a n s th a t a M o d e lic a c o m p o n e n t m u s t b e fu lly
d e s c rib e d w ith th e c o m p le te s e t o f e q u a tio n s .

T h e to p o lo g y d e s c rip tio n
T h e to p o lo g y o f a s y s te m o f c o m p o n e n ts c a n in
M o d e lic a b e d e s c rib e d u s in g th e  s ta te m e n t. T h is is n o t y e t im p le m e n te d in th e to o l p r e s e n te d h e r e . It is th o u g h in te r e s tin g to n o tic e th a t
th e s y s te m d e s c rip tio n fo r th e p r o g ra m g e n e r a to r
DY N M O C , d e v e lo p e d fo r th e H O P S A N e n v ir o n m e n t b y A r n e J a n s s o n in 1 9 9 7 , h a s a v e r y s im ila r
s y n ta x c o m p a r e d to M o d e lic a . In F ig u r e 3 a n d
F ig u r e 4 , th e to p o lo g y o f th e s a m e s y s te m is d e s c rib e d u s in g M o d e lic a a n d H O P S A N s y n ta x . T h e
m in o r s y n ta c tic a l d iffe r e n c e s im p ly th a t it w o u ld

b e s tra ig h tf o r w a rd to c re a te a tra n s la to r a ls o fo r th e
to p o lo g ic a l d e s c rip tio n , m a k in g it p o s s ib le to s im u la te c o m p le te M o d e lic a s y s te m s in H O P S A N .

	
!"
#$#%'&
()!)*(%'&
(+,-).-%/&
0 ,1 0 %'2 03 &
4567
98 0 %/:;,%'2<# 3 :;,%'=&
98>#%/:;, 3 2?(%/:;,%'=&
98;(%/:;, 3 2 03 :;,%'=
98;(%/:;,@/2?-%/:;,%'=
	AB!"C&
F ig u r e 3 : T o p o lo g ic a l d e s c rip tio n in Mo d e lic a

DEB#$#%
DEB()!)F(%
D.(+,-).-%
D 0 ,1 0 %
 0 %G,%G$# 3 ,%
#%G, 3 (H%G,%
.(%G, 3  03 ,%
.(%G,@F-H%G,%

p o rt a m o d e l d e s ig n e d b y e n g in e e rs s p e c ia lis e d in
a n o th e r d o m a in .
va

E x a m p le
C o n s id e r a s im p le s y s te m d e s c r ib in g a h y d ra u lic
tra n s m is s io n . T h e s y s te m is m o d e lle d in th e
H O P S A N p a c k a g e u s in g c o m p o n e n ts fro m th e c o m p o n e n t lib r a ry . U s in g th e m o d e l tra n s la to r p re s e n te d
in th is p a p e r, a m o d e l o f a n e le c tr ic m o to r w ritte n in
th e M o d e lic a la n g u a g e c a n b e a u to m a tic a lly tra n s la te d a n d c o n n e c te d to th e h y d ra u lic tr a n s m is s io n .
T h is e x a m p le c a n a ls o illu s tra te a p o s s ib le in d u s tria l s c e n a rio w h e r e e n g in e e r s th a t a r e s p e c ia lis e d in
o n e s p e c if ic e n g in e e r in g d o m a in w o u ld n e e d to im -

H p

H m

vb
M o d e lic a c o m p o n e n t

F ig u re 5 : H y d r a u lic tra n s m is s io n in th e
H O P S A N e n v iro n m e n t

T h e h y d ra u lic s y s te m c o n s is ts o f a p u m p a n d a
m o to r w ith a n in te r m e d ia te v o lu m e . A m e c h a n ic a l
lo a d is a tta c h e d to th e h y d ra u lic m o to r. T o th e h y d r a u lic p u m p , a p r im e m o v e r c a n b e c o n n e c te d
th ro u g h a m e c h a n ic a l s h a ft, m o d e lle d a s a s tiff
s p rin g . T h is is w h e r e th e M o d e lic a m o d e l o f a n
e le c tric DC -m o to r is to b e a tta c h e d , s e e F ig u r e 5 .
S y s te m o f e q u a tio n s
T h e s im p le s t m o d e l o f a n e le c tr ic DC - m o to r c a n b e
v ie w e d a s a n in d u c ta n c e , a r e s is ta n c e a n d a c o n v e r te r d e s c rib in g re la tio n s b e tw e e n e le c tric a l a n d
m e c h a n ic a l q u a n titie s , s e e F ig u r e 6 . T h e f o llo w in g
e q u a tio n s d e s c rib e th e c o m p o n e n t:

d ia
( v − v b ) − R a ⋅ i a − ω x ⋅ψ m
= a
dt
La

F ig u re 4 : T o p o lo g ic a l d e s c r ip tio n in H O P S A N

O n e p ro b le m is th a t in M o d e lic a , th e s y s te m d e s c rip tio n is n e c e s s a r ily n o t s e p a ra te d fro m th e d e s c rip tio n s o f th e c o m p o n e n ts . C o n n e c tio n s a r e tra n s fo r m e d to n o r m a l e q u a tio n s w h e n th e m o d e l is tra n s fo r m e d to lo w - le v e l c o d e . H O P S A N u s e s a s e p a ra te
file to d e s c rib e th e c o n n e c tio n s o n s y s te m le v e l w ith
th e s y n ta x s h o w n in F ig u r e 4 . T h is m e a n s th a t to b e
a b le to tra n s fo r m a M o d e lic a s y s te m to a d is trib u te d
e n v iro n m e n t lik e H O P S A N , th e c o d e m u s t b e re s tric te d . It m u s t b e s ta te d w h a t d e fin e s th e to p o lo g y
o f th e s y s te m , e x p re s s e d in a s e p a ra te file , o r s e p a r a te d b e tw e e n id e n tifie rs .

Em

u d if f

J ⋅

d ωx
= i a ⋅ψ m − b ⋅ ω x − M
dt

(8 )
x

i a = −i b

va

(9 )

ia
L

a

R

a

ψm
vb

(7 )

Em f

M x , ωx

ib
F ig u re 6 : D C -m o to r c irc u it

If th e e le c tric m o to r is v ie w e d a s o n e c o m p o n e n t,
th e r e a r e th r e e c o n n e c tio n s to s u rr o u n d in g c o m p o n e n ts : tw o e le c tric a l n o d e s a n d o n e m e c h a n ic a l.
F o r th is c o m p o n e n t to fit in a T L M -e n v ir o n m e n t it
is d e s ig n e d a s a Q -c o m p o n e n t. T o m o d e l th e e x c h a n g e o f e n e rg y a n d th e w a v e p ro p a g a tio n , fo u r
v a ria b le s in e a c h c o n n e c to r m u s t b e p re s e n t. T h e s e
v a ria b le s a r e flo w , e ffo rt, th e c h a ra c te r is tic a n d th e
c h a ra c te r is tic im p e d a n c e . In th e c o m p o n e n t, th is is
h a n d le d b y a d d in g o n e e x tra e q u a tio n f o r e a c h

n o d e d e s c rib in g th e b o u n d a r y c o n d itio n s . T h e th r e e
b o u n d a r y e q u a tio n s a r e :

M

v a = c a + Z c ⋅ ia

(1 0 )

v b = c b + Z c ⋅ ib

(1 1 )

x

=cx +Z

cx

⋅ωx

H O P S A N e n v ir o n m e n t a n d s im u la te d . T h e s y s te m
in s e rte d in th e g ra p h ic a l m o d e llin g to o l G D y n m o c
[9 ] c a n b e v ie w e d in F ig u r e 7 .

M o d e lic a
co m p o n en t

(1 2 )

w h e r e c a , c b , a n d c c a re th e w a v e s th a t a re c a lc u la te d fr o m th e c o n n e c te d n o d e s . Z c a n d Z c x a re th e
c h a ra c te r is tic im p e d a n c e a ls o d e liv e re d fro m th e
c o n n e c te d c o m p o n e n ts .

is c a lle d F b . T h e to ta l s e t o f e q u a tio n s c a n th e n b e
e x p re ss e d a s:
F ( F a , F b ,t ) = F ( y ,

2

n

dy d y
d y
, 2 , I , n ,t) = 0
dt dt
dt

(1 3 )

T h e f o llo w in g s te p s a re :
• F ( F a , F b , t ) is tra n s fo r m e d in to tim e d is c r e te
r e p re s e n ta tio n u s in g b ilin e a r tra n s fo r m . T h e r e s u lt is c a lle d G .
• T h e J a c o b ia n J is e v a lu a te d fro m p a rtia l d e riv a tiv e s o f G .
• T h e e q u a tio n s a r e s o lv e d n u m e r ic a lly u s in g th e
N e w to n -R a p h s o n ite r a tio n .

y k +1 ( t ) = y k ( t ) − J k ( t ) −1 G ( y k ( t ))

(1 4 )

A fte r p e r fo r m in g th e s e ite ra tio n s , th e c o m p o n e n t c a n
b e w r itte n to a F o r tra n file w ith th e c o r re c t n o d e in te r fa c e a n d th e s o lv e r. T h e p ro c e d u r e tra n s la tin g th e
DC -m o to r w ritte n in th e M o d e lic a la n g u a g e h a s n o w
r e s u lte d in a c o m p o n e n t th a t c a n b e in s e rte d in to th e

T h e s im u la te d s y s te m

S im u la tio n r e s u lts
F ro m th e c o m p le te s y s te m m o d e l in th e H O P S A N
e n v iro n m e n t, s o m e s im u la tio n r e s u lts c a n b e o b ta in e d .
150.0
Electric motor
100.0

100.0

50.0

50.0
Hydraulic motor

0.0

0.0
Torque on hydraulic motor axis

Power on
-50.0
0.00

0.50

1.00

1.50

2.00

2.50

Torque on hydraulic motor axis [Nm]

150.0

Rotational speed [rad/s]

S o lv in g th e s y s te m
T h e m o d e l m u s t b e e q u ip p e d w ith a n u m e ric a l
s o lv e r to b e c o m e a n in d e p e n d e n t c o m p o n e n t in th e
T L M s y s te m . T h is c a n b e d o n e u s in g a n y s u ita b le
s o lv e r. In th is w o rk , th e N e w to n -R a p h s o n ite ra tio n
a lg o rith m is u s e d b a s e d o n th a t it h a s s h o w n g o o d
r o b u s tn e s s fo r s tiff s y s te m s a n d w o r k s w e ll in c o m b in a tio n w ith th e T L M -m e th o d . A s h o rt d e s c rip tio n
o f th e s te p s p e r fo r m e d in s e rtin g th e s o lv e r to th e
c o m p o n e n t w ill b e g iv e n b e lo w . F o r a d e ta ile d d e s c rip tio n o f th e p ro c e s s , s e e [8 ].
T h e e q u a tio n s (7 )- (9 ) d e s c r ib e th e in te r n a l re la tio n s in th e c o m p o n e n t a n d a re th o s e th a t w e fo u n d
in th e M o d e lic a b a s e c o m p o n e n t. C a ll th is s e t o f
e q u a tio n s F a a n d th e b o u n d a ry e q u a tio n s (1 0 )-(1 2 )

F ig u re

-50.0
3.00

Time [s]

F ig u re

:

e s u lts fr o m th e s im u la tio n

T h e s im u la tio n s h o w s th e s p e e d o f th e h y d ra u lic
m o to r a n d th e e le c tr ic m o to r, s e e F ig u re 8 . W h e n
th e p o w e r to th e e le c tric a l m o to r is tu rn e d o n , th e
s p e e d o f th e e le c tr ic m o to r in c r e a s e s fo llo w e d b y a
s im ila r b e h a v io u r o f th e h y d r a u lic m o to r. T h e d e la y is d u e to th e v o lu m e in th e h y d r a u lic s y s te m ,
w h ic h a ls o a ffe c t th e b e h a v io u r w h e n a s te p in lo a d
is a p p lie d . T h e s p e e d o f th e h y d ra u lic m o to r d e c re a s e s fa s te r a n d m o r e th a n th e e le c tr ic m o to r.
T h e s a m e m o d e l e x e c u te d in H O P S A N h a s a ls o
b e e n s im u la te d in th e Dy m o la e n v ir o n m e n t [3 ].
T h e Dy m o la s im u la tio n p a c k a g e u s e s c e n tra lis e d
s o lv in g a n d h a s fu ll im p le m e n te d s u p p o rt fo r
M o d e lic a . T h e r e s u lts s h o w g o o d a c c o r d a n c e b e tw e e n th e d iffe r e n t s im u la tio n p a c k a g e s .

D is c u s s io n
O b je c t o rie n te d m o d e llin g s h o w s g r e a t a d v a n ta g e s
in th e p ro c e s s o f m o d e llin g p h y s ic a l s y s te m s . W ith
c h a ra c te r is tic s a s e n c a p s u la tio n , o b je c t in s ta n tia tio n a n d n o d e c o n n e c tio n s , th e s im u la tio n m o d e ls
s h o w a s tru c tu r e th a t is fle x ib le , lo g ic a l a n d w ith

s tro n g s im ila ritie s to th e p h y s ic a l s y s te m . N o n c a u s a l m o d e llin g r e m o v e s th e n e e d o f s ta te -s p a c e
m o d e ls , re d u c in g e rro r-p r o n e tra n s fo r m a tio n s . In s te a d , d iffe r e n tia l a n d a lg e b ra ic e q u a tio n s fr o m
h a n d b o o k s c a n b e u s e d d ir e c tly .
T h e M o d e lic a a p p r o a c h is a p ro m is in g e ffo rt to a
s ta n d a r d m o d e llin g la n g u a g e f o r d y n a m ic s y s te m s . If
a s ta n d a r d b e c o m e s w id e ly a c c e p te d , it w o u ld m e a n
a la rg e s te p fo r w a r d in s im u la tio n o f m u lti- d o m a in
d y n a m ic s y s te m s . A s s im u la tio n p a c k a g e s a re b e c o m in g m o r e g e n e ra l a n d c a p a b le o f p e r fo r m in g
s im u la tio n in d iff e r e n t d o m a in s , th e p o s s ib ilitie s
w ith e x c h a n g in g m o d e ls b e tw e e n d iffe r e n t p a rtic ip a n ts in a d e s ig n g r o u p a r e s ig n if ic a n t.
T h e a p p ro a c h p re s e n te d in th is p a p e r is a n im p le m e n ta tio n o f M o d e lic a w h e r e c o m p o n e n t m o d e ls a r e
s im u la te d in a d is trib u te d e n v iro n m e n t u s in g th e
tra n s m is s io n lin e m o d e llin g te c h n iq u e . T h e d e m o n s tra te d tr a n s la to r is c a p a b le o f tra n s la tin g a s u b s e t o f
M o d e lic a w ith th e m a jo r lim ita tio n th a t in h e rita n c e
is n o t im p le m e n te d . T h e lim ita tio n is o n ly o f s ig n ific a n c e fo r th e im p o rt fu n c tio n to H O P S A N a n d h a s
b e e n c o n s id e r e d o f s e c o n d a r y im p o rta n c e in th is firs t
s ta g e . T h e m o s t im p o rta n t th in g is th a t s ta n d a r d
M o d e lic a c o d e c a n b e u s e d w ith o u t m o d ific a tio n s .
T h e o u tlo o k u s in g a n o b je c t-o r ie n te d m o d e llin g
la n g u a g e in a d is trib u te d e n v iro n m e n t is to h a n d le
la rg e s im u la tio n m o d e ls b y p a rtitio n in g th e s y s te m
n o t o n ly th ro u g h th e m o d e llin g p r o c e s s b u t a ls o
th r o u g h th e s im u la tio n . A fle x ib le , n u m e r ic a lly r o b u s t a n d e ffic ie n t e n v ir o n m e n t c a n b e a c h ie v e d
s u ite d fo r la rg e a n d c o m p le x s y s te m s . T h e d is trib u te d a p p ro a c h a ls o fa c ilita te s c o n n e c tio n s w ith
h a rd w a r e a n d e x te rn a l s im u la tio n p a c k a g e s e ith e r
lo c a lly o r o v e r a n e tw o r k . U s in g a s ta n d a rd is e d la n g u a g e a s M o d e lic a w o u ld a ls o a d d a d v a n ta g e s a s
in c r e a s e d in te g ra tio n b e tw e e n p r o je c t m e m b e r s a n d
s u p p o rte d e x c h a n g e o f k n o w le d g e b e tw e e n e n g in e e r in g d is c ip lin e s .

C o n c lu s io n s
B y u s in g a n o b je c t- o r ie n te d m o d e llin g la n g u a g e to g e th e r w ith a d is tr ib u te d m o d e llin g te c h n iq u e , th e
o b je c ts in a s y s te m m o d e l c a n b e k e p t p a rtitio n e d a s
o b je c ts th r o u g h b o th m o d e llin g a n d s im u la tio n . T h e
m a in a d v a n ta g e s c o n c e rn fle x ib ility , s c a lin g p ro p e rtie s a n d p o s s ib ilitie s to h a v e s im u la tio n m o d e ls d is trib u te d o v e r a n e tw o rk . In th is p a p e r, it h a s b e e n
d e m o n s tr a te d h o w to u s e M o d e lic a in a d is trib u te d
e n v iro n m e n t. C o m p o n e n ts w ritte n in s ta n d a r d
M o d e lic a c o d e a re a u to m a tic a lly tra n s la te d to fit in
th e d is trib u te d H O P S A N e n v iro n m e n t.
T h e a u th o rs c o n s id e r th e p re s e n te d a p p ro a c h w ith
M o d e lic a in c o m b in a tio n w ith tra n s m is s io n lin e

m o d e llin g to b e a p o w e rfu l a lte r n a tiv e to th e c e n tra lis e d a p p ro a c h . T h e a d v a n ta g e s p r e s e n te d w ill
p ro b a b ly b e im p o rta n t is s u e s u s in g s im u la tio n a s a
to o l in p r o d u c t d e v e lo p m e n t.

e fe r e n c e s
[1 ] A u s la n d e r D. M ., Dis trib u te d S y s te m S im u la tio n w ith B ila te ra l De la y -L in e M o d e ls , J o
n a o f a ic n g in e e in g T a n
M , pp.
1 9 5 -2 0 0 , J u n e 1 9 6 8 .
[2 ] C e llie r F . E ., O b je c t-O r ie n te d M o d e lin g :
M e a n s f o r De a lin g W ith S y s te m C o m p le x ity ,
in
o c e e d in g o f
t
e n e x M e e tin g o n
y te m a n d C o n t o , T h e N e th e r la n d s , 1 9 9 6 .
[3 ] E lm q u is t E ., B r c k D., a n d O tte r M ., D y m o a
e M a n a , Dy n a s im A B , 1 9 9 9 .
[4 ] J a n s s o n A . a n d r u s P ., R e a l-tim e s im u la tio n
u s in g p a r a lle l p ro c e s s in g , in
o c e e d in g o f
T e n d Ta m p e e n te n a tio n a C o n fe e n c e o n
F id o e , T a m p e r e , F in la n d , 1 9 9 1 .
[5 ] J a n s s o n A . a n d ru s P ., H O P S A N a S im u la tio n
P ackag e
U ser s
u id e ,
h ttp : h y d ra .ik p .liu .s e h o p s a n .h tm l, 1 9 9 8 .
[6 ] J a n s s o n A . a n d P a lm b e rg J .-O ., L o a d S im u la tio n , a fle x ib le to o l fo r a s s e s s in g th e p e rfo r m a n c e o f h y d r a u lic v a lv e s ., in
o c e e d in g o f
FL C M
T e F o t T ie n n ia n te n a
tio n a
y m p o i m o n F id C o n t o F id
M ea em en t a n d
i a i a tio n , T o u lo u s e ,
F ra n c e , 1 9 9 4 .
[7 ] J o h n s P . B . a n d O B rie n M ., U s e o f tr a n s m is s io n lin e m o d e llin g (t.l.m ) m e th o d to s o lv e
n o n lin e a r lu m p e d n e tw o r k s , T e R a d io
ec
t o n a n d n g in e e , v o l. 5 0 , p p . 5 9 -7 0 , 1 9 8 0 .
[8 ]
r u s P ., A n A u to m a te d A p p r o a c h fo r C r e a tin g
C o m p o n e n ts a n d S u b s y s te m s fo r S im u la tio n
o f Dis tr ib u te d S y s te m s , in
o c e e d in g o f t
a t n te n a tio n a F id o e
o k op,
B a th , U , 1 9 9 6 .
[9 ] L a rs s o n J ., Dy n m o c U s e r s g u id e , I P -R 1 0 8 8 , De p t. o f M e c h . E n g ., Div . o f F lu id a n d
M e c h . E n g . S y s te m s , L in k ö p in g U n iv e r s ity ,
L in k ö p in g , S w e d e n , 1 9 9 9 .
[1 0 ] M o d e lic a De s ig n r o u p , M o d e lic a - A U n ifie d O b je c t-O r ie n te d L a n g u a g e fo r P h y s ic a l
S y s te m s M o d e lin g , L a n g u a g e S p e c ific a tio n ,
h ttp : w w w .M o d e lic a .o rg , 1 9 9 9 .
[1 1 ] W o lfra m S ., T e M T M T C
o o k , 4 th
r e v is e d e d , C a m b rid g e U n iv e rs ity P r e s s , 1 9 9 9 .

%-RKDQVVRQ3.UXV
0RGHOLFDLQD'LVWULEXWHG(QYLURQPHQW8VLQJ
7UDQVPLVVLRQ/LQH0RGHOOLQJ
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Mo d e lic a in a D is tr ib u te d E n v ir o n m e n t U s in g
T r a n s m is s io n L in e Mo d e llin g
B jö r n J o h a n s s o n a n d P e tte r K r u s
De p a rtm e n t o f M e c h a n ic a l E n g in e e r in g
L in k ö p in g U n iv e rs ity , S E -5 8 1 8 3 L in k ö p in g , S w e d e n
{ b jo jo , p e tk r } @ ik p .liu .s e

A b s tr a c t
P ro d u c ts a re b e c o m in g in c r e a s in g ly c o m p le x w ith
fu n c tio n a lity a n d c o m p o n e n ts fro m d iff e r e n t e n g in e e r in g d o m a in s . T h e o b je c t- o rie n te d m o d e llin g
la n g u a g e M o d e lic a fa c ilita te s th e m o d e llin g o f s u c h
s y s te m s . H o w e v e r, b y m a k in g it p o s s ib le to c r e a te
c o m p le x m o d e ls , th e re w ill b e a n in c re a s e d fo c u s o n
th e a c tu a l s im u la tio n .
T h e d is trib u te d m o d e llin g c o n c e p t is a w a y to
d e a l w ith s y s te m c o m p le x ity a ls o d u rin g th e s im u la tio n . T h e c o n c e p t im p lie s th a t th e s y s te m c a n b e
p a rtitio n e d in to s u b -s y s te m s a n d e x e c u te d in p a ra lle l. E a c h c o m p o n e n t is e q u ip p e d w ith a s o lv e r fo r
th e c o m p o n e n t s p e c if ic e q u a tio n s . T o a c h ie v e th e
fu ll s y s te m b e h a v io u r, th e c o m p o n e n ts e x c h a n g e
d a ta a t s p e c ific tim e in s ta n ts . T o in c r e a s e th e m o d e l
r o b u s tn e s s , th e c o m p o n e n ts c a n b e n u m e r ic a lly is o la te d fr o m e a c h o th e r u s in g th e tra n s m is s io n lin e
m o d e llin g te c h n iq u e . T h e d e la y w h e n s ig n a ls a r e
p ro p a g a tin g th r o u g h a s y s te m is th e n u s e d to n u m e r ic a lly s e p a ra te th e c o m p o n e n ts .
In th is p a p e r, th e fe a s ib ility o f c o m b in in g M o d e lic a w ith tra n s m is s io n lin e s f o r d is tr ib u te d s im u la tio n is d e m o n s tra te d . A ls o d is c u s s e d a r e th e a d v a n ta g e s c o m p a re d to th e tr a d itio n a l te c h n iq u e s o f
s im u la tio n .

In tr o d u c tio n
A s s im u la tio n is u s e d a s a to o l fo r d e s ig n in g a n d
a n a ly s in g c o m p le x s y s te m s , a n u m b e r o f a s p e c ts
m u s t b e c o n s id e r e d r e g a rd in g m o d e l c o m p le x ity . A n
o b je c t-o rie n te d a n d n o n - c a u s a l m o d e llin g la n g u a g e
lik e M o d e lic a p ro v id e s a b a s e fo r d e s ig n in g w e lls tru c tu r e d s im u la tio n m o d e ls [2 ,1 0 ]. H o w e v e r, th e
p o s s ib ilitie s o f c re a tin g la rg e a n d c o m p le x m o d e ls
s e ts th e fo c u s o n o th e r a s p e c ts th a t n e e d s to b e c o n s id e r e d .
T h e s im u la tio n m o d e l a n d its e x e c u ta b le in te rp re ta tio n m u s t b e n u m e r ic a lly s ta b le , e ffic ie n t a n d
fle x ib le . M u lti-d o m a in m o d e ls c o n s is t o f s u b s y s te m s w ith d iff e r e n t n u m e r ic a l p r o p e r tie s a n d tim e
c o n s ta n ts . T h e p o s s ib ility to c o n n e c t s u b s y s te m s

w ith d iffe r e n t s o lv e r s a n d tim e s te p s is a n a d v a n ta g e w h e n it c o m e s to s im u la tio n o f c o m p le x
m u lti-d o m a in s y s te m s .

D is tr ib u te d m o d e llin g
T h e d is trib u te d m o d e llin g c o n c e p t c a n b e v ie w e d
a s a n o p p o s ite s o lu tio n to th e c e n tra lis e d te c h n iq u e
re g a r d in g th e e x e c u tio n o f th e s im u la tio n m o d e l. A
b rie f d e s c rip tio n o f th e c e n tra lis e d a p p ro a c h is th a t
a ll e q u a tio n s d e s c rib in g th e s y s te m a r e c o lle c te d to
o n e la rg e s e t o f e q u a tio n s . A n in te g r a tio n a lg o rith m is th e n a p p lie d a n d a ll s ta te v a r ia b le s a re
s o lv e d fo r in e a c h tim e s te p d u r in g th e e x e c u tio n .
T h e c e n tr a lis e d c o n c e p t is v e r y c o m m o n a n d u s e d
in s e v e ra l s im u la tio n p a c k a g e s . A d v a n c e d s y m b o lic m a n ip u la tio n o f th e e q u a tio n s is p o s s ib le to
in c r e a s e th e n u m e r ic a l e ffic ie n c y . T h e d r a w b a c k o f
th e c e n tr a lis e d s im u la tio n te c h n iq u e is th o u g h th a t
th e w h o le s y s te m m u s t b e s ta te d in a u n ifo r m w a y .
S in c e th e s o lv e r o fte n u s e v a r ia b le tim e s te p , fa s t
d y n a m ic s in o n e p a rt o f th e s y s te m a ffe c t th e s te p s iz e a n d s im u la tio n tim e o f th e w h o le s y s te m .
U s in g th e d is tr ib u te d m o d e llin g te c h n iq u e , th e
c o m p o n e n ts b u ild in g th e s y s te m m o d e l a re c o n s id e r e d a s o b je c ts , n o t o n ly in th e m o d e llin g p h a s e b u t
a ls o d u rin g th e e x e c u tio n . A lo c a l s o lv e r is a tta c h e d to e v e r y c o m p o n e n t. T h e c o m p o n e n ts a re
th e n e x e c u te d in p a ra lle l e x c h a n g in g th e s a m e in fo r m a tio n a s th e p h y s ic a l c o m p o n e n ts . T h e d is trib u te d e n v iro n m e n t h a s a n u m b e r o f a d v a n ta g e s .
M o s t im p o rta n t is th a t a d is trib u te d e n v iro n m e n t
c a n b e v e ry f le x ib le . A s th e c o m p o n e n ts a r e in d e p e n d e n t o b je c ts , it is ra th e r s tr a ig h tfo rw a rd to c o n n e c t e x te rn a l c o m p o n e n ts to th e s im u la tio n m o d e l.
E x a m p le s o f s u c h e x te rn a l c o m p o n e n ts c a n b e a
p ie c e o f h a rd w a r e (H a r d W a re I n th e L o o p [6 ]) o r a
c o n n e c tio n to a n e x te rn a l s im u la tio n p a c k a g e .
T h e s e c o n n e c tio n s c a n b e e ith e r lo c a lly o n o n e
c o m p u te r o r o v e r a n e tw o r k (L A N , In te rn e t e tc .)
[4 ]. A n o th e r a d v a n ta g e is th a t th e d is tr ib u te d c o n c e p t o ffe rs lin e a r s c a lin g p r o p e rtie s . W h e n th e s iz e
o f th e s y s te m s , i.e . th e n u m b e r o f c o m p o n e n ts is
in c r e a s e d , th e s im u la tio n tim e is in c r e a s e d w ith th e
s a m e m a g n itu d e . A lth o u g h it is p o s s ib le to u s e a

lo t o f in fo r m a tio n fro m th e s y s te m s tru c tu re to in c r e a s e th e c o m p u ta tio n s p e e d u s in g a c e n tra lis e d
m e th o d , lin e a r s c a lin g is v e r y h a r d to a c h ie v e . T h e
s c a lin g p ro p e r tie s fo r c e n tr a lis e d s o lv e r s a r e v e r y
m u c h d e p e n d in g o n th e s y s te m p ro p e r tie s .
In F ig u r e 1 , a p o s s ib le s im u la tio n e n v ir o n m e n t
u s in g a d is trib u te d s tru c tu r e is s h o w n .

th e m e d iu m p a s s in g th ro u g h th e tra n s m is s io n lin e
is d iffe r e n t, b u t th e m a th e m a tic a l v a ria b le s a re
flo w a n d e ff o r t v a r ia b le s , th e s a m e w a y a s in th e
B o n d -g ra p h m o d e llin g te c h n iq u e .
E ffo rt e 1

E ffo rt e 2

F lo w f 1

F lo w f 2

F ig u re 2 : U n it T ra n s m is s io n L in e

T h e e q u a tio n s d e s c rib in g th e tr a n s m is s io n lin e a re

H a rd w a re

E Ex xteternrna al ls simim u ulalatiotion n
p pa ac ck ka ag ge e

e 1 (t + T ) = c 1 ( t ) + Z c f1 ( t + T )

(1 )

e 2 (t + T ) = c 2 (t) + Z c f 2 (t + T )

(2 )

w h e re Z
Da ta e x c h a n g e
S o lv e r
C om ponent
m odel

S o lv e r
C om ponent
m odel

F ig u re 1 : D is trib u te d s im u la tio n e n v ir o n m e n t

A d is tr ib u te d e n v ir o n m e n t w ith o r w ith o u t c o n n e c tio n s to h a rd w a re a n d e x te r n a l s im u la tio n p a c k a g e s
r e q u ir e s c o n tro l b y a to p -le v e l p ro c e s s . T h e m a in
ta s k fo r th is p r o c e s s is to c o n tro l th e s im u la tio n
s p e e d fo r th e s y s te m . A g lo b a l s te p s iz e c a n b e s e t
fo r th e s y s te m w h ile c o m p o n e n ts w ith fa s t d y n a m ic s
c a n b e lo o p e d fa s te r a n d e x e c u te d w ith a s h o rte r
tim e s te p .
T o a c h ie v e n u m e ric a l r o b u s tn e s s fo r a d is trib u te d
a p p ro a c h , it is p o s s ib le to n u m e r ic a lly is o la te th e
c o m p o n e n ts fro m e a c h o th e r. T h is s e p a r a tio n c a n b e
a c h ie v e d u s in g th e tra n s m is s io n lin e m o d e llin g c o n c e p t, T L M [7 ,1 ]. T h e m a in id e a is to in c lu d e th e
p ro p a g a tio n o f in f o r m a tio n th r o u g h th e s y s te m in th e
m o d e l. I n m o s t p h y s ic a l s y s te m s , th e r e is a d e la y in
tim e w h e n a s ig n a l p r o p a g a te s fro m o n e c o m p o n e n t
to a n o th e r. F o r e x a m p le a p r e s s u re p u ls e th a t is
c a u s e d in a h y d ra u lic v a lv e d o e s n o t im m e d ia te ly
a ffe c t th e w h o le s y s te m . T h e d e la y is n o r m a lly d e p e n d in g o f th e s p e e d o f s o u n d in th e tra n s m is s io n
m e d ia . T h is d e la y w h e n in f o r m a tio n p r o p a g a te s is a
v a lu a b le p ie c e o f e x tra in fo r m a tio n th a t c a n b e u s e d
to s e p a ra te th e c o m p o n e n ts n u m e r ic a lly .

Dis tr ib u te d
s io n lin e s

m o d e llin g

u s in g

tra n s m is -

T h e c o r e c o m p o n e n t in T ra n s m is s io n L in e M o d e llin g , is th e U n it T ra n s m is s io n L in e . T h is c o m p o n e n t
c a n b e v ie w e d a s a c a rrie r o f e n e rg y w ith a tim e d e la y . De p e n d in g o f th e s y s te m th a t is to b e m o d e lle d ,

c

is th e c h a ra c te r is tic im p e d a n c e , c 1 a n d

c 2 a re th e c h a ra c te r is tic s d e s c r ib in g th e w a v e fr o m
th e c o n n e c te d c o m p o n e n t. T h e c h a ra c te r is tic s a re
o f th e s a m e m a g n itu d e a s e ffo r t a n d a re d e f in e d a s
c 2 ( t ) = e 1 ( t ) + Z c f1 ( t )

(3 )

c 1 (t) = e 2 (t) + Z c f2 (t)

(4 )

A t e a c h c o m p o n e n t b e tw e e n th e lin e s , th e e q u a tio n s th a t n e e d s to b e s o lv e d a re th e fo llo w in g s e t
o f e q u a tio n s

f = f(e )

(5 )

e = c +Z cf

(6 )

w h e r e f is a v e c to r c o n ta in in g a ll th e flo w v a r ia b le s , e is th e c o rre s p o n d in g e ffo r t v a r ia b le s , c is
th e c h a ra c te r is tic s a n d Z c is a d ia g o n a l m a tr ix w ith
th e c h a ra c te ris tic im p e d a n c e s in th e d ia g o n a l.

T ra n s m is s io n
s y s te m

lin e

c o m p o n e n ts

in

a

In a s y s te m , th e c o m p o n e n ts m o d e lle d a s T L M c o m p o n e n ts a re d iv id e d in to tw o g ro u p s o f c o m p o n e n ts .
• Q -c o m p o n e n ts , c a lc u la tin g flo w
• C -c o m p o n e n ts , c a lc u la tin g c h a ra c te ris tic im p e d a n c e a n d th e c h a ra c te r is tic (th e w a v e , e ff o r t
v a ria b le )
Du rin g th e s im u la tio n , th e d iff e r e n t ty p e s o f c o m p o n e n ts a r e e x e c u te d a lte rn a te ly . F irs t, th e C c o m p o n e n ts a re c a lle d , u p d a tin g th e c h a r a c te ris tic s
a n d c h a ra c te ris tic im p e d a n c e s . T h e n th e Q c o m p o n e n ts a r e c a lle d c a lc u la tin g th e s ta te v a ria b le s a s flo w a n d e ffo rt. E x a m p le s o f Q c o m p o n e n ts a re re s is tiv e c o m p o n e n ts a s e le c tr ic a l
re s is to r s a n d h y d ra u lic o rific e s . E x a m p le s o f C ty p e c o m p o n e n ts a re c a p a c itiv e c o m p o n e n ts a s
v o lu m e s , s p rin g s a n d e le c tric a l c a p a c ito rs . It is n o t
a lw a y s p o s s ib le to s e p a r a te c o m p o n e n ts fro m a

c o m p o n e n t lib ra ry . O n illu s tra tiv e e x a m p le is a re c tifie r b rid g e , w h e r e th e tra n s m is s io n lin e te c h n iq u e
w o u ld re q u ir e s e p a r a tin g th e d io d e s w ith tr a n s m is s io n lin e e le m e n ts . T h is s e p a r a tio n w o u ld th e n a ffe c t
th e b e h a v io u r o f th e s y s te m u n le s s th e tim e s te p is
v e r y s h o rt, c a u s in g lo n g s im u la tio n tim e . T o a v o id
th is , th e re c tif ie r b rid g e c a n b e tre a te d a s o n e c o m p o n e n t a n d s o lv e d a s a n o r d in a ry c e n tr a lis e d m o d e l.

U s in g Mo d e lic a in a tr a n s m is s io n
lin e e n v ir o n m e n t
M o d e lic a is a p o w e rfu l la n g u a g e fo r d e s ig n in g
s im u la tio n m o d e ls w ith a s tru c tu re s im ila r to th e
p h y s ic a l s tru c tu r e . T h e T L M -c o n c e p t k e e p th e o b je c ts s e p a ra te d th r o u g h th e s im u la tio n w ith b e n e fits
a s n u m e r ic a l e ffic ie n c y , lin e a r s c a lin g , p a ra lle l c o m p u ta tio n e tc . A s o lu tio n w h e r e M o d e lic a c o m p o n e n ts
a re im p le m e n te d in a T L M -e n v ir o n m e n t w o u ld h a v e
th e p o te n tia l o f b e in g a p o w e r fu l a lte rn a tiv e to th e
tra d itio n a l im p le m e n ta tio n u s in g th e c e n tra lis e d
te c h n iq u e .
In th is w o r k , a to o l f o r a u to m a tic tra n s la tio n o f
s in g le M o d e lic a c o m p o n e n ts h a s b e e n c r e a te d u s in g
th e M a th e m a tic a p a c k a g e [1 1 ]. M a th e m a tic a is a
s y m b o lic m a th p a c k a g e , e n a b lin g h ig h -le v e l p ro g r a m m in g . B e s id e s th e m a th e m a tic a l p ro c e s s in g ,
a d v a n c e d te x t o p e r a tio n s c a n b e p e rfo r m e d a s w e ll.
T h e to o l tr a n s la te s a M o d e lic a c o m p o n e n t to a c o m p o n e n t w r itte n in F o rtra n th a t c a n b e in s e r te d in a
H O P S A N [5 ] s im u la tio n m o d e l.
H O P S A N is a s im u la tio n p a c k a g e u s in g th e
tra n s m is s io n lin e m o d e llin g te c h n iq u e . T h e m o d e ls
th a t a re s im u la te d in H O P S A N a r e n o r m a lly w ritte n
in th e F o r tra n la n g u a g e , a n d c o m p o n e n ts a re s to r e d
in a lib r a ry . S y s te m m o d e ls a r e c re a te d u s in g a
g r a p h ic a l m o d e llin g to o l [9 ]. T h e fo llo w in g s e c tio n s
w ill d e m o n s tra te h o w a M o d e lic a c o m p o n e n t is
a d a p te d to fit in a T L M e n v iro n m e n t.

T r a n s la tin g M o d e lic a c o m p o n e n ts
Dis trib u te d m o d e llin g u s in g th e T L M -m e th o d re q u ire s m o d e ls d e s c rib e d in a s p e c ific w a y . T h e c o m p o n e n ts s h o u ld h a v e e x tr a v a ria b le s fo r th e w a v e
p ro p a g a tio n a n d a s o lv e r fo r in d e p e n d e n t s o lv in g o f
th e e q u a tio n s in th e c o m p o n e n t. T h e M o d e lic a c o m p o n e n t c o u ld b e s ta te d d ir e c tly in th a t w a y , s till fo llo w in g th e M o d e lic a s y n ta x . It is d e s ire d h o w e v e r
th a t th e m o d e l d e s ig n e r s h o u ld n o t h a v e to c a r e
a b o u t is s u e s th a t a r e s p e c ific to th e im p le m e n ta tio n .
T h e m a in a d v a n ta g e w ith M o d e lic a is th a t th e m o d e l
c o d e s h o u ld b e s e p a ra te d fro m th e im p le m e n ta tio n .
T h is m e a n s th a t th e M o d e lic a c o m p o n e n t m u s t b e
m a n ip u la te d to fit in to th e T L M -e n v ir o n m e n t.

E x te n d in g a p r e v io u s ly c re a te d to o l in th e
M a th e m a tic a p a c k a g e , c a lle d C o m p g e n [8 ], th e
c o m p o n e n t file w ritte n in M o d e lic a c a n b e p ro c e s s e d a c c o r d in g to th e f o llo w in g s e q u e n c e :
S te p 1 : R e a d th e M o d e lic a c o m p o n e n t file
S te p 2 : F in d c o n n e c to r s , v a r ia b le s a n d p a ra m e te r s
S te p 3 : F in d th e e q u a tio n s d e s c r ib in g th e c o m p o n ent
S te p 4 : T r a n s fo rm th e e q u a tio n s to M a th e m a tic a
n o tific a tio n
S te p 5 : A d d th e b o u n d a ry e q u a tio n s a c c o r d in g to
th e ty p e o f c o m p o n e n t
S te p 6 : C a lc u la te p a rtia l d e r iv a tiv e s o f th e e q u a tio n s
S te p 7 : De fin e th e J a c o b ia n fr o m th e p a rtia l d e r iv a tiv e s
S te p 8 : A d d a N e w to n -R a p h s o n s o lv e r fo r th e
e q u a tio n s a n d w rite th e c o m p o n e n t a s
F o r tra n c o d e to a file
T h ro u g h s te p 1 -3 , th e te x t file c o n ta in in g th e c o m p o n e n t is s c a n n e d b y th e M a th e m a tic a p r o g r a m .
U s in g th e M o d e lic a s y n ta x d e fin itio n , th e in f o r m a tio n is th e n s o rte d a n d g r o u p e d . T h e m a th e m a tic a l
n o tific a tio n in M o d e lic a a n d M a th e m a tic a is n o t
th e s a m e , w h ic h is w h y a tra n s la tio n m u s t b e p e r fo r m e d to b e a b le to a n a ly tic a lly m a n ip u la te th e
e q u a tio n s in M a th e m a tic a . A s s e v e ra l c o m p o n e n ts
c a n b e d e s ig n e d a s e ith e r Q o r C -c o m p o n e n ts , it is
fo r th e u s e r to s e le c t a c c o r d in g ly . De p e n d in g o n
th e ty p e , d iffe r e n t v a ria b le s a r e u p d a te d d u rin g th e
e x e c u tio n .
T h e to o l is o n ly a b le to tr a n s la te a s u b s e t o f th e
M o d e lic a la n g u a g e . T h e e ffo rt h a s b e e n f o c u s e d o n
c re a tin g a to o l th a t w o rk s fo r s in g le c o m p o n e n ts
a n d th e m a in p u rp o s e is to fa c ilita te e x c h a n g e o f
c o m p o n e n ts b e tw e e n to o ls a n d p e o p le . T h e m a jo r
lim ita tio n is th a t in h e r ita n c e is n o t h a n d le d , w h ic h
m e a n s th a t a M o d e lic a c o m p o n e n t m u s t b e fu lly
d e s c rib e d w ith th e c o m p le te s e t o f e q u a tio n s .

T h e to p o lo g y d e s c rip tio n
T h e to p o lo g y o f a s y s te m o f c o m p o n e n ts c a n in
M o d e lic a b e d e s c rib e d u s in g th e  s ta te m e n t. T h is is n o t y e t im p le m e n te d in th e to o l p r e s e n te d h e r e . It is th o u g h in te r e s tin g to n o tic e th a t
th e s y s te m d e s c rip tio n fo r th e p r o g ra m g e n e r a to r
DY N M O C , d e v e lo p e d fo r th e H O P S A N e n v ir o n m e n t b y A r n e J a n s s o n in 1 9 9 7 , h a s a v e r y s im ila r
s y n ta x c o m p a r e d to M o d e lic a . In F ig u r e 3 a n d
F ig u r e 4 , th e to p o lo g y o f th e s a m e s y s te m is d e s c rib e d u s in g M o d e lic a a n d H O P S A N s y n ta x . T h e
m in o r s y n ta c tic a l d iffe r e n c e s im p ly th a t it w o u ld

b e s tra ig h tf o r w a rd to c re a te a tra n s la to r a ls o fo r th e
to p o lo g ic a l d e s c rip tio n , m a k in g it p o s s ib le to s im u la te c o m p le te M o d e lic a s y s te m s in H O P S A N .

	
!"
#$#%'&
()!)*(%'&
(+,-).-%/&
0 ,1 0 %'2 03 &
4567
98 0 %/:;,%'2<# 3 :;,%'=&
98>#%/:;, 3 2?(%/:;,%'=&
98;(%/:;, 3 2 03 :;,%'=
98;(%/:;,@/2?-%/:;,%'=
	AB!"C&
F ig u r e 3 : T o p o lo g ic a l d e s c rip tio n in Mo d e lic a

DEB#$#%
DEB()!)F(%
D.(+,-).-%
D 0 ,1 0 %
 0 %G,%G$# 3 ,%
#%G, 3 (H%G,%
.(%G, 3  03 ,%
.(%G,@F-H%G,%

p o rt a m o d e l d e s ig n e d b y e n g in e e rs s p e c ia lis e d in
a n o th e r d o m a in .
va

E x a m p le
C o n s id e r a s im p le s y s te m d e s c r ib in g a h y d ra u lic
tra n s m is s io n . T h e s y s te m is m o d e lle d in th e
H O P S A N p a c k a g e u s in g c o m p o n e n ts fro m th e c o m p o n e n t lib r a ry . U s in g th e m o d e l tra n s la to r p re s e n te d
in th is p a p e r, a m o d e l o f a n e le c tr ic m o to r w ritte n in
th e M o d e lic a la n g u a g e c a n b e a u to m a tic a lly tra n s la te d a n d c o n n e c te d to th e h y d ra u lic tr a n s m is s io n .
T h is e x a m p le c a n a ls o illu s tra te a p o s s ib le in d u s tria l s c e n a rio w h e r e e n g in e e r s th a t a r e s p e c ia lis e d in
o n e s p e c if ic e n g in e e r in g d o m a in w o u ld n e e d to im -

H p

H m

vb
M o d e lic a c o m p o n e n t

F ig u re 5 : H y d r a u lic tra n s m is s io n in th e
H O P S A N e n v iro n m e n t

T h e h y d ra u lic s y s te m c o n s is ts o f a p u m p a n d a
m o to r w ith a n in te r m e d ia te v o lu m e . A m e c h a n ic a l
lo a d is a tta c h e d to th e h y d ra u lic m o to r. T o th e h y d r a u lic p u m p , a p r im e m o v e r c a n b e c o n n e c te d
th ro u g h a m e c h a n ic a l s h a ft, m o d e lle d a s a s tiff
s p rin g . T h is is w h e r e th e M o d e lic a m o d e l o f a n
e le c tric DC -m o to r is to b e a tta c h e d , s e e F ig u r e 5 .
S y s te m o f e q u a tio n s
T h e s im p le s t m o d e l o f a n e le c tr ic DC - m o to r c a n b e
v ie w e d a s a n in d u c ta n c e , a r e s is ta n c e a n d a c o n v e r te r d e s c rib in g re la tio n s b e tw e e n e le c tric a l a n d
m e c h a n ic a l q u a n titie s , s e e F ig u r e 6 . T h e f o llo w in g
e q u a tio n s d e s c rib e th e c o m p o n e n t:

d ia
( v − v b ) − R a ⋅ i a − ω x ⋅ψ m
= a
dt
La

F ig u re 4 : T o p o lo g ic a l d e s c r ip tio n in H O P S A N

O n e p ro b le m is th a t in M o d e lic a , th e s y s te m d e s c rip tio n is n e c e s s a r ily n o t s e p a ra te d fro m th e d e s c rip tio n s o f th e c o m p o n e n ts . C o n n e c tio n s a r e tra n s fo r m e d to n o r m a l e q u a tio n s w h e n th e m o d e l is tra n s fo r m e d to lo w - le v e l c o d e . H O P S A N u s e s a s e p a ra te
file to d e s c rib e th e c o n n e c tio n s o n s y s te m le v e l w ith
th e s y n ta x s h o w n in F ig u r e 4 . T h is m e a n s th a t to b e
a b le to tra n s fo r m a M o d e lic a s y s te m to a d is trib u te d
e n v iro n m e n t lik e H O P S A N , th e c o d e m u s t b e re s tric te d . It m u s t b e s ta te d w h a t d e fin e s th e to p o lo g y
o f th e s y s te m , e x p re s s e d in a s e p a ra te file , o r s e p a r a te d b e tw e e n id e n tifie rs .

Em

u d if f

J ⋅

d ωx
= i a ⋅ψ m − b ⋅ ω x − M
dt

(8 )
x

i a = −i b

va

(9 )

ia
L

a

R

a

ψm
vb

(7 )

Em f

M x , ωx

ib
F ig u re 6 : D C -m o to r c irc u it

If th e e le c tric m o to r is v ie w e d a s o n e c o m p o n e n t,
th e r e a r e th r e e c o n n e c tio n s to s u rr o u n d in g c o m p o n e n ts : tw o e le c tric a l n o d e s a n d o n e m e c h a n ic a l.
F o r th is c o m p o n e n t to fit in a T L M -e n v ir o n m e n t it
is d e s ig n e d a s a Q -c o m p o n e n t. T o m o d e l th e e x c h a n g e o f e n e rg y a n d th e w a v e p ro p a g a tio n , fo u r
v a ria b le s in e a c h c o n n e c to r m u s t b e p re s e n t. T h e s e
v a ria b le s a r e flo w , e ffo rt, th e c h a ra c te r is tic a n d th e
c h a ra c te r is tic im p e d a n c e . In th e c o m p o n e n t, th is is
h a n d le d b y a d d in g o n e e x tra e q u a tio n f o r e a c h

n o d e d e s c rib in g th e b o u n d a r y c o n d itio n s . T h e th r e e
b o u n d a r y e q u a tio n s a r e :

M

v a = c a + Z c ⋅ ia

(1 0 )

v b = c b + Z c ⋅ ib

(1 1 )

x

=cx +Z

cx

⋅ωx

H O P S A N e n v ir o n m e n t a n d s im u la te d . T h e s y s te m
in s e rte d in th e g ra p h ic a l m o d e llin g to o l G D y n m o c
[9 ] c a n b e v ie w e d in F ig u r e 7 .

M o d e lic a
co m p o n en t

(1 2 )

w h e r e c a , c b , a n d c c a re th e w a v e s th a t a re c a lc u la te d fr o m th e c o n n e c te d n o d e s . Z c a n d Z c x a re th e
c h a ra c te r is tic im p e d a n c e a ls o d e liv e re d fro m th e
c o n n e c te d c o m p o n e n ts .

is c a lle d F b . T h e to ta l s e t o f e q u a tio n s c a n th e n b e
e x p re ss e d a s:
F ( F a , F b ,t ) = F ( y ,

2

n

dy d y
d y
, 2 , I , n ,t) = 0
dt dt
dt

(1 3 )

T h e f o llo w in g s te p s a re :
• F ( F a , F b , t ) is tra n s fo r m e d in to tim e d is c r e te
r e p re s e n ta tio n u s in g b ilin e a r tra n s fo r m . T h e r e s u lt is c a lle d G .
• T h e J a c o b ia n J is e v a lu a te d fro m p a rtia l d e riv a tiv e s o f G .
• T h e e q u a tio n s a r e s o lv e d n u m e r ic a lly u s in g th e
N e w to n -R a p h s o n ite r a tio n .

y k +1 ( t ) = y k ( t ) − J k ( t ) −1 G ( y k ( t ))

(1 4 )

A fte r p e r fo r m in g th e s e ite ra tio n s , th e c o m p o n e n t c a n
b e w r itte n to a F o r tra n file w ith th e c o r re c t n o d e in te r fa c e a n d th e s o lv e r. T h e p ro c e d u r e tra n s la tin g th e
DC -m o to r w ritte n in th e M o d e lic a la n g u a g e h a s n o w
r e s u lte d in a c o m p o n e n t th a t c a n b e in s e rte d in to th e

T h e s im u la te d s y s te m

S im u la tio n r e s u lts
F ro m th e c o m p le te s y s te m m o d e l in th e H O P S A N
e n v iro n m e n t, s o m e s im u la tio n r e s u lts c a n b e o b ta in e d .
150.0
Electric motor
100.0

100.0

50.0

50.0
Hydraulic motor

0.0

0.0
Torque on hydraulic motor axis

Power on
-50.0
0.00

0.50

1.00

1.50

2.00

2.50

Torque on hydraulic motor axis [Nm]

150.0

Rotational speed [rad/s]

S o lv in g th e s y s te m
T h e m o d e l m u s t b e e q u ip p e d w ith a n u m e ric a l
s o lv e r to b e c o m e a n in d e p e n d e n t c o m p o n e n t in th e
T L M s y s te m . T h is c a n b e d o n e u s in g a n y s u ita b le
s o lv e r. In th is w o rk , th e N e w to n -R a p h s o n ite ra tio n
a lg o rith m is u s e d b a s e d o n th a t it h a s s h o w n g o o d
r o b u s tn e s s fo r s tiff s y s te m s a n d w o r k s w e ll in c o m b in a tio n w ith th e T L M -m e th o d . A s h o rt d e s c rip tio n
o f th e s te p s p e r fo r m e d in s e rtin g th e s o lv e r to th e
c o m p o n e n t w ill b e g iv e n b e lo w . F o r a d e ta ile d d e s c rip tio n o f th e p ro c e s s , s e e [8 ].
T h e e q u a tio n s (7 )- (9 ) d e s c r ib e th e in te r n a l re la tio n s in th e c o m p o n e n t a n d a re th o s e th a t w e fo u n d
in th e M o d e lic a b a s e c o m p o n e n t. C a ll th is s e t o f
e q u a tio n s F a a n d th e b o u n d a ry e q u a tio n s (1 0 )-(1 2 )

F ig u re

-50.0
3.00

Time [s]

F ig u re

:

e s u lts fr o m th e s im u la tio n

T h e s im u la tio n s h o w s th e s p e e d o f th e h y d ra u lic
m o to r a n d th e e le c tr ic m o to r, s e e F ig u re 8 . W h e n
th e p o w e r to th e e le c tric a l m o to r is tu rn e d o n , th e
s p e e d o f th e e le c tr ic m o to r in c r e a s e s fo llo w e d b y a
s im ila r b e h a v io u r o f th e h y d r a u lic m o to r. T h e d e la y is d u e to th e v o lu m e in th e h y d r a u lic s y s te m ,
w h ic h a ls o a ffe c t th e b e h a v io u r w h e n a s te p in lo a d
is a p p lie d . T h e s p e e d o f th e h y d ra u lic m o to r d e c re a s e s fa s te r a n d m o r e th a n th e e le c tr ic m o to r.
T h e s a m e m o d e l e x e c u te d in H O P S A N h a s a ls o
b e e n s im u la te d in th e Dy m o la e n v ir o n m e n t [3 ].
T h e Dy m o la s im u la tio n p a c k a g e u s e s c e n tra lis e d
s o lv in g a n d h a s fu ll im p le m e n te d s u p p o rt fo r
M o d e lic a . T h e r e s u lts s h o w g o o d a c c o r d a n c e b e tw e e n th e d iffe r e n t s im u la tio n p a c k a g e s .

D is c u s s io n
O b je c t o rie n te d m o d e llin g s h o w s g r e a t a d v a n ta g e s
in th e p ro c e s s o f m o d e llin g p h y s ic a l s y s te m s . W ith
c h a ra c te r is tic s a s e n c a p s u la tio n , o b je c t in s ta n tia tio n a n d n o d e c o n n e c tio n s , th e s im u la tio n m o d e ls
s h o w a s tru c tu r e th a t is fle x ib le , lo g ic a l a n d w ith

s tro n g s im ila ritie s to th e p h y s ic a l s y s te m . N o n c a u s a l m o d e llin g r e m o v e s th e n e e d o f s ta te -s p a c e
m o d e ls , re d u c in g e rro r-p r o n e tra n s fo r m a tio n s . In s te a d , d iffe r e n tia l a n d a lg e b ra ic e q u a tio n s fr o m
h a n d b o o k s c a n b e u s e d d ir e c tly .
T h e M o d e lic a a p p r o a c h is a p ro m is in g e ffo rt to a
s ta n d a r d m o d e llin g la n g u a g e f o r d y n a m ic s y s te m s . If
a s ta n d a r d b e c o m e s w id e ly a c c e p te d , it w o u ld m e a n
a la rg e s te p fo r w a r d in s im u la tio n o f m u lti- d o m a in
d y n a m ic s y s te m s . A s s im u la tio n p a c k a g e s a re b e c o m in g m o r e g e n e ra l a n d c a p a b le o f p e r fo r m in g
s im u la tio n in d iff e r e n t d o m a in s , th e p o s s ib ilitie s
w ith e x c h a n g in g m o d e ls b e tw e e n d iffe r e n t p a rtic ip a n ts in a d e s ig n g r o u p a r e s ig n if ic a n t.
T h e a p p ro a c h p re s e n te d in th is p a p e r is a n im p le m e n ta tio n o f M o d e lic a w h e r e c o m p o n e n t m o d e ls a r e
s im u la te d in a d is trib u te d e n v iro n m e n t u s in g th e
tra n s m is s io n lin e m o d e llin g te c h n iq u e . T h e d e m o n s tra te d tr a n s la to r is c a p a b le o f tra n s la tin g a s u b s e t o f
M o d e lic a w ith th e m a jo r lim ita tio n th a t in h e rita n c e
is n o t im p le m e n te d . T h e lim ita tio n is o n ly o f s ig n ific a n c e fo r th e im p o rt fu n c tio n to H O P S A N a n d h a s
b e e n c o n s id e r e d o f s e c o n d a r y im p o rta n c e in th is firs t
s ta g e . T h e m o s t im p o rta n t th in g is th a t s ta n d a r d
M o d e lic a c o d e c a n b e u s e d w ith o u t m o d ific a tio n s .
T h e o u tlo o k u s in g a n o b je c t-o r ie n te d m o d e llin g
la n g u a g e in a d is trib u te d e n v iro n m e n t is to h a n d le
la rg e s im u la tio n m o d e ls b y p a rtitio n in g th e s y s te m
n o t o n ly th ro u g h th e m o d e llin g p r o c e s s b u t a ls o
th r o u g h th e s im u la tio n . A fle x ib le , n u m e r ic a lly r o b u s t a n d e ffic ie n t e n v ir o n m e n t c a n b e a c h ie v e d
s u ite d fo r la rg e a n d c o m p le x s y s te m s . T h e d is trib u te d a p p ro a c h a ls o fa c ilita te s c o n n e c tio n s w ith
h a rd w a r e a n d e x te rn a l s im u la tio n p a c k a g e s e ith e r
lo c a lly o r o v e r a n e tw o r k . U s in g a s ta n d a rd is e d la n g u a g e a s M o d e lic a w o u ld a ls o a d d a d v a n ta g e s a s
in c r e a s e d in te g ra tio n b e tw e e n p r o je c t m e m b e r s a n d
s u p p o rte d e x c h a n g e o f k n o w le d g e b e tw e e n e n g in e e r in g d is c ip lin e s .

C o n c lu s io n s
B y u s in g a n o b je c t- o r ie n te d m o d e llin g la n g u a g e to g e th e r w ith a d is tr ib u te d m o d e llin g te c h n iq u e , th e
o b je c ts in a s y s te m m o d e l c a n b e k e p t p a rtitio n e d a s
o b je c ts th r o u g h b o th m o d e llin g a n d s im u la tio n . T h e
m a in a d v a n ta g e s c o n c e rn fle x ib ility , s c a lin g p ro p e rtie s a n d p o s s ib ilitie s to h a v e s im u la tio n m o d e ls d is trib u te d o v e r a n e tw o rk . In th is p a p e r, it h a s b e e n
d e m o n s tr a te d h o w to u s e M o d e lic a in a d is trib u te d
e n v iro n m e n t. C o m p o n e n ts w ritte n in s ta n d a r d
M o d e lic a c o d e a re a u to m a tic a lly tra n s la te d to fit in
th e d is trib u te d H O P S A N e n v iro n m e n t.
T h e a u th o rs c o n s id e r th e p re s e n te d a p p ro a c h w ith
M o d e lic a in c o m b in a tio n w ith tra n s m is s io n lin e

m o d e llin g to b e a p o w e rfu l a lte r n a tiv e to th e c e n tra lis e d a p p ro a c h . T h e a d v a n ta g e s p r e s e n te d w ill
p ro b a b ly b e im p o rta n t is s u e s u s in g s im u la tio n a s a
to o l in p r o d u c t d e v e lo p m e n t.

e fe r e n c e s
[1 ] A u s la n d e r D. M ., Dis trib u te d S y s te m S im u la tio n w ith B ila te ra l De la y -L in e M o d e ls , J o
n a o f a ic n g in e e in g T a n
M , pp.
1 9 5 -2 0 0 , J u n e 1 9 6 8 .
[2 ] C e llie r F . E ., O b je c t-O r ie n te d M o d e lin g :
M e a n s f o r De a lin g W ith S y s te m C o m p le x ity ,
in
o c e e d in g o f
t
e n e x M e e tin g o n
y te m a n d C o n t o , T h e N e th e r la n d s , 1 9 9 6 .
[3 ] E lm q u is t E ., B r c k D., a n d O tte r M ., D y m o a
e M a n a , Dy n a s im A B , 1 9 9 9 .
[4 ] J a n s s o n A . a n d r u s P ., R e a l-tim e s im u la tio n
u s in g p a r a lle l p ro c e s s in g , in
o c e e d in g o f
T e n d Ta m p e e n te n a tio n a C o n fe e n c e o n
F id o e , T a m p e r e , F in la n d , 1 9 9 1 .
[5 ] J a n s s o n A . a n d ru s P ., H O P S A N a S im u la tio n
P ackag e
U ser s
u id e ,
h ttp : h y d ra .ik p .liu .s e h o p s a n .h tm l, 1 9 9 8 .
[6 ] J a n s s o n A . a n d P a lm b e rg J .-O ., L o a d S im u la tio n , a fle x ib le to o l fo r a s s e s s in g th e p e rfo r m a n c e o f h y d r a u lic v a lv e s ., in
o c e e d in g o f
FL C M
T e F o t T ie n n ia n te n a
tio n a
y m p o i m o n F id C o n t o F id
M ea em en t a n d
i a i a tio n , T o u lo u s e ,
F ra n c e , 1 9 9 4 .
[7 ] J o h n s P . B . a n d O B rie n M ., U s e o f tr a n s m is s io n lin e m o d e llin g (t.l.m ) m e th o d to s o lv e
n o n lin e a r lu m p e d n e tw o r k s , T e R a d io
ec
t o n a n d n g in e e , v o l. 5 0 , p p . 5 9 -7 0 , 1 9 8 0 .
[8 ]
r u s P ., A n A u to m a te d A p p r o a c h fo r C r e a tin g
C o m p o n e n ts a n d S u b s y s te m s fo r S im u la tio n
o f Dis tr ib u te d S y s te m s , in
o c e e d in g o f t
a t n te n a tio n a F id o e
o k op,
B a th , U , 1 9 9 6 .
[9 ] L a rs s o n J ., Dy n m o c U s e r s g u id e , I P -R 1 0 8 8 , De p t. o f M e c h . E n g ., Div . o f F lu id a n d
M e c h . E n g . S y s te m s , L in k ö p in g U n iv e r s ity ,
L in k ö p in g , S w e d e n , 1 9 9 9 .
[1 0 ] M o d e lic a De s ig n r o u p , M o d e lic a - A U n ifie d O b je c t-O r ie n te d L a n g u a g e fo r P h y s ic a l
S y s te m s M o d e lin g , L a n g u a g e S p e c ific a tio n ,
h ttp : w w w .M o d e lic a .o rg , 1 9 9 9 .
[1 1 ] W o lfra m S ., T e M T M T C
o o k , 4 th
r e v is e d e d , C a m b rid g e U n iv e rs ity P r e s s , 1 9 9 9 .

0/DUVVRQ
2EMHFW6WDE$0RGHOLFD/LEUDU\IRU3RZHU
6\VWHP6WDELOLW\6WXGLHV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

./XQGH
2EMHFW2ULHQWHG0RGHOLQJLQ0RGHO%DVHG
'LDJQRVLV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Object-Oriented Modeling in Model-Based
Diagnosis
Karin Lunde
R.O.S.E. Informatik GmbH, Schloßstr. 34, D-89518 Heidenheim
October 13, 2000
1

Introduction

In this paper, the experience gathered with the
prototype of a Modelica extension for modelbased diagnosis is presented. The paper starts
with the introduction of the special application
field of model-based diagnosis. Basic principles
are illustrated by the example of their realization in the model-based analysis tool RODON.
Its object-oriented modeling paradigm is explained and compared to modeling in Modelica.
Although both modeling philosophies are very
close to each other, there are some additional
requirements of model-based diagnosis. These
are explained and illustrated by examples.

In the life cycle of a product, engineers have to
perform many analysis tasks, from design layout, over system simulation and risk analysis, to
diagnosis during product operation. Most analysis tools are specialized for just a few of these
analysis tasks. This forces the engineer to work
with a whole tool suite using various model formats (often even different models) for the same
product. But modeling a technical system is a
kind of art — it requires both expert domain
knowledge and the ability to structure a problem
and to find out the appropriate level of abstraction for it. It is a creative, time-consuming and
expensive task. To increase efficiency in prod- 2
The Model-Based Analysis
uct development, it would be desirable to have
Tool RODON
analysis tools which reduce the modeling effort
as far as possible, by providing means to reuse
existing models, and by offering multiple ana- The functional analysis tool RODON is a
lyzes of a product on the base of a single prod- model-based simulation, monitoring and diagnosis tool which integrates known engineering
uct model.
For programming languages like Java or
Smalltalk, the advantages of object-oriented
concepts are well-known. They can be employed to support hierarchical structuring of
problems, to allow wide reuse of code, and
maintenance of large and evolving software systems. The same applies to object-oriented modeling languages. They are especially well-suited
to model complex and multi-domain systems. A
very promising attempt to introduce a coherent
object-oriented modeling language based on the
experience of previous languages is Modelica
[Mod99].

 K.Lunde@rose.de

Figure 1: A RODON model of car headlamps.

Figure 2: An automatically generated decision tree for model-supported diagnostics by the service.
methods with AI technology (see [Sei97]). It This leads to more simple and flexible model
provides the following analyzes using the same libraries, which are reusable in many contexts.
knowledge base:
At the same time, it remains possible to formulate certain constraints as assignments if necessary, for instance in subsystems where a behavrequirements analysis (design layout)
ior description by signal flow is an appropriate
design verification
abstraction.
risk analysis
A declarative modeling approach reflects also
– fault tree analysis
the fact that in physical systems, a steady state
– failure mode and effect analysis
is an equilibrium determined by the interaction
– sneak circuit analysis
between all components. For instance, model– tolerance analysis
ing a complex electrical circuit by signal flow
is nearly impossible. Moreover, if the behavprocess monitoring
ior of one component in the circuit changes
model-supported diagnosis
(e. g. in case of a defect), the model had to be
– decision trees
re-designed because of the different signal flow.
– diagnostic rules
This shows that for model-based diagnosis, a
declarative formulation of model behavior is esmodel-based diagnosis (on or off board)
sential.









Risk analyzes as well as diagnostics benefit from the definition of additional behavioral
modes modeling the component behavior in
To build the necessary knowledge base, a techtypical failure states. How behavior modes can
nical system is mapped to a hierarchical model
be used in model-based diagnosis will be deconsisting of a number of functional units which
scribed in Section 2.3.
are connected with each other. The behavior of
each functional unit (component) is described
in terms of physical laws, in the form of con- 2.2 Simulation in RODON
straints. A constraint defines a relation between
model variables. Thus, the component behavior In real technical systems, some model parameis formulated declaratively, in contrast to many ters may be subject to manufacturing tolerances,
conventional simulation tools like Simulink or others may be inaccurate because of measureMatrixX , where all system equations are es- ment errors. For diagnostic purposes, it is essentially assignments, and all component ports pecially important that the simulation results of
have to be either inputs or outputs. The declar- a model match the behavior of the real system,
ative (or non-causal) modeling concept allows because discrepancies are interpreted as defecto model component behavior independently of tive behavior. Hence, it is dangerous to define
the context where the component shall be used. those uncertain parameters by sharp real num-

2.1

Declarative modeling

Figure 3: A diagnosis: in case that gr-node-2 is disconnect, a leakage current causes the high
beam lamps to shine dimmed, although they are switched off.
bers, more or less arbitrarily, as is usually done solver collects all constraints which depend on
with conventional simulation tools.
this variable and puts them on the agenda again.
They
have to be evaluated anew, to propagate
To reflect these uncertainties, in RODON the
basic value type is not the real number but the the new value through the system. This iterainterval. More precisely, since interval opera- tive process does not stop while the agenda contions may result in multiple intervals, the values tains constraints, that means, while some values
of RODON variables are represented by interval keep changing (with respect to some accuracy,
sets, and all operations are carried out by inter- which is adjustable by the user). This algorithm
is called local constraint propagation because
val arithmetics (see [HHKR95], [AH74]).
changes are propagated through the system by
Since product specifications often contain tol- passing them to the immediate neighbors in the
erances or ranges, this value representation also constraint net.
suggests the use of RODON as a tool in requireLocal constraint propagation has a number of
ments analysis or design verification.
advantages. For instance, it allows to solve conThe simulation algorithm of RODON seeks to straint systems which are under- or overdeterconstrict the values of all model variables as mined. This is especially important in modelfar as possible, without losing any solution. It based diagnosis, where a system has to be
bases on a local constraint propagation tech- overdetermined in order to allow conclusions
nique which was adapted for interval constraint about defective components.
propagation by E. Hyvönen (see [Hyv91]). The
iterative algorithm starts by assigning undetermined values to all variables except for those
2.3 Model-based diagnosis
whose values are given by the user (or in case of
diagnosis: where input from the real system is
Suppose one is given a description of a system,
available). An agenda mechanism is initialized
together with an observation of the system’s bewith a list of all constraints. Now, the problem
havior which conflicts with the way the syssolver takes the constraints from the agenda one
tem is meant to behave. The diagnostic probby one and evaluates them. If the value of some
lem is to determine those components of the
variable changes after evaluation, the problem
system which, when assumed to behave abnor-

mally, will explain the discrepancy between the
observed and correct system behavior [Rei87].
The observed system behavior is given by process data, i. e. by a set of values measured by
the real system in operation. A diagnosis starts
with a simulation of the nominal system behavior together with the given process data. The
resulting equation system has to be overdetermined. If it has no solution, a conflict occurs
during local propagation, which means that one
or more components must be defect (i. e. behave
abnormally).
In case of a conflict, RODON analyzes the
conflict and generates hypotheses (candidates)
which may explain the abnormal system behavior. A candidate is a minimal set of violated assumptions, where an assumption can
have a form like ”the component XY behaves
normally”.
For the efficient generation of hypotheses it is
not sufficient to know that a simulation ended
with a conflict. Without additional information
about where the conflict occured candidate generation would be a search in a gigantic search
space. Simulation by local constraint propagation provides us with this information. With
each value set, RODON manages the assumptions the value set depends on. This is done by
means of a truth-maintenance system (TMS). If
a conflict occurs, RODON is able to backtrack
the assumptions corresponding to the conflicting values. They can be used to narrow the
search space to candidates containing these assumptions.

3

Object-Oriented Modeling
in RODON

The tool goes back to ideas of W. Seibold
[Sei92] in the early 80’s, and has developed
over the past 10 years. From the very beginning, an object-oriented modeling approach was
used to define hierarchies of model component
classes. It agrees with the Modelica philosophy
[Mod99] in central points, namely




hierarchical modeling



declarative modeling



multi-domain modeling



component-oriented modeling



quantitative modeling
support by object-oriented model libraries

This remarkable similarity suggests the idea to
support Modelica as a modeling language in
RODON. To gain experience for the integration of Modelica into RODON, we implemented
a prototype of a model representation module,
and combined it with a new version of the
RODON diagnostic engine.
While structure and topology representation of
Modelica models could be adopted without any
changes, the behavior representation had to be
slightly modified.

In the following subsections, we will explain the
alterations made for our application. All examples are written in the Modelica dialect we curThis diagnostic approach is based on the GDE rently use with our prototype implementation.
(general diagnostic engine) introduced by de Its behavior section is fitted to our special needs.
Kleer ([dKW87], [dKW89]). It is characterized Note that the language specification is not fixed
entirely.
by



an incremental diagnostic procedure









3.1

Modeling behavior modes

use of behavioral modes for candidate verification
Let us start with a simple example modela truth-maintenance system (TMS) to ing an electrical wire class with two behavioral modes: the nominal behavior, and the
reuse knowledge in multiple contexts
most common failure modes disconnect, and
a scalable candidate generator
shortToGround. An appropriate class hierarthe ability to diagnose multiple faults as chy could be the following.
well as unspecified faults
package Rose.Electrical
connector Port

type
type
type
type

Current = Interval(unit = "A", quantity = "current");
Resistance = Interval(unit = "Ohm", quantity = "resistance");
Voltage = Interval(unit = "V", quantity = "voltage");
FM = Discrete(min = 0, quantity = "failure mode");

Figure 4: Type definitions in RODON.
Voltage u;
flow Current i;
end Port;
partial model TwoPort
Port p, n;
FM fm (max = 1);
behavior
if (fm==0 | fm==1)
Kirchhoff(p.i, n.i);
if (fm==1) p.i = 0;
end TwoPort;
model IdealWire2
extends TwoPort (fm (max = 2));
protected Interval iGnd;
behavior
if (fm==0 | fm==2) p.u = n.u;
if (fm==2) p.i + n.i + iGnd = 0;
if (fm==2) p.u = 0;
end Wire2;
end Rose.Electrical;

havior section, any variable can participate in
any number of constraints. Our iterative simulation algorithm does not rely on the fact that
the equation system contains exactly the same
number of state variables and equations. It can
handle over- or underdetermined equation systems easily.

3.2

Modeling alternatives

3.2.1 if-clauses in RODON
The example above illustrated one way to model
alternative behavior by means of a syntactical element known from Modelica — the ifclause. However, there are some semantic differences between if-clauses in RODON and
Modelica. In RODON, the clause
if (<condition>) <relation>
means that when the problem solver takes this
constraint from the agenda, it checks first the
condition. Only if the condition is decidable
and true, the relation is evaluated, and the consequent value changes are propagated as usual.
This approach allows the use of many ifclauses in a model without slowing down the
simulation process significantly.

The model TwoPort is a general electrical component providing basic physical laws
for the current in case of nominal behavior
(fm==0) and the failure mode disconnect
(fm==1). The alternative behavior for different behavioral modes is defined using conditional constraints, where the discrete failure
For set-valued variables, logical expressions
mode variable fm serves as a kind of switch.
have not merely two possible values, but three:
The model IdealWire2 extends this base true, false, or undecidable. A condition is declass by adding a constraint for the voltage (it cidable if it is either true or false for all combiis an ideal wire without resistance) as well as nations of values out of the variable’s value sets.
constraints defining the behavioral mode short- For instance, consider the constraint
ToGround (fm==2).
if (2<x & x<5) <relation>
Recall that all variables in a RODON model are
If x has the value set [0 4], there are some
represented by sets of values. This is reflected
elements of the set for which the condition is
by the type definitions in Fig. 4. The basic type
true, but there are other elements in the value
Interval has all attributes of the Modelica
set of x for which it is false. During the iteratype Real, but its value attribute is a set of intive propagation process, the value set of x may
tervals. Accordingly, the value attribute of the
be further constricted so that at some moment
basic type Discrete is a set of integer values.
in the propagation process, the condition will
An important semantic difference to the equa- have a unique logical value. But at the present
tion section in Modelica is that in our be- moment, the problem solver cannot know which

logical value that will be.



y
Note that for set-valued variables, there are
f x
some subtleties when defining correct seman4
tics for conditions. Conditions have to be evalu3
able monotonly, i. e. if a condition has been decided to be true or false once, it must not change
2
this logical value during propagation. This is
due to the fact that if a condition has once been
1
true, the corresponding relation has been evaluated, and the resulting value changes have been
x
1 2 3 4 5 6
propagated further. If later on the condition becomes false, we would have to withdraw all valFigure 6: A piecewise continuous function.
ues which depend on the earlier evaluation of
that relation. To keep track of all these dependencies requires a huge effort.
function:


                                      
                                       
                                       
                                      
                       

Therefore, only monotonously evaluable conditions are allowed. That means that a condition
like (x subset y), where x and y are interval variables, is not permissible, because it
is true for x=[0 10] and y=[-10 20], but
during the iterative propagation process y may
be constricted to y=[-10 2], which renders
the condition undecidable. An overview of all
permissible logical relations for set-valued variables is shown in Fig. 5.

	 


f x





2

	 








x
x
x

 


2 1
6 x
5 5



1

(1)

For real-valued variables, this function can be
modeled adequately by means of if-clauses:
if (x<2) y = 1;
if (x>=2 & x<=6) y = x-1;
if (x>6) y = 5;

But for interval-valued variables, the conditions
of these if-clauses may be undecidable, and
Interval x, y;
the variable y will not be constricted at all
Real a;
by
these constraints, although it is clear that
constant Interval s;
the range of y is y=[1 5]. For instance, if
x==a
x subset s
x=[1.5
4], the evaluation of a constraint repx!=a
x!=s
x!=y
resenting the equation y
f x should result
x<=a
x<=s
x<=y
in
y=[1
3]
(see
Fig.
6).
In this case, not
x< a
x< s
x< y
evaluating
the
corresponding
relations due to
x>=a
x>=s
x>=y
their undecidable conditions x<2 and (x>=2
x> a
x> s
x> y
& x<=6) means waste of information, which
Figure 5: Permissible logical relations for value may be crucial in the propagation process.
sets.
For such situations the modeling language of
RODON has a disjunction element. By means
Another topic is the negation of logical expresof a disjunction, (1) would be modeled like
sions, which have a slightly different meaning for sets than for real values. For instance, or x < 2; y = 1;
x = [2 5]; y = x-1;
the negation of the condition (x==a) is not
x > 5; y = 4;
(x!=a) but (a x). In general, the relation
/
x!=y has to be interpreted as x y==0.
The equations in the alternative cases of the disjunction are evaluated separately, and the result
is the set union of the alternative cases. For set3.2.2 The or-clause
valued variables, such a language element is esThere are situations where it is desirable to have sential.












 

	 




another kind of alternative behavior. Consider Another typical example where a disjunction is
the following definition of a piecewise linear useful is the calculation of a discrete indicator

constraint MyQuadraticSpline
Interval x, y;
extends Spline (final degree = 2, periodic = true,
final values =
0.5, 1 , 1, 1.5 ,
end MyQuadraticSpline;



 

  1.5, 3   );

model UseSpline
Interval a, b;
behavior
MyQuadraticSpline(a, b)(periodic = false, boundary =
end UseSpline;

 1.3  );

Figure 7: An example of a simple constraint class.
value based on a continuous variable. Consider 3.3 Defining constraint classes
the following model of an electrical light bulb.
Very much like function classes in Modelica,
RODON allows the user to define constraint
model Bulb extends TwoPort;
classes. This may be useful for constraints
Discrete light (max = 2);
which are used very often, like Ohm’s law or
parameter Current pNom=20;
Kirchhoff’s
law in the electrical domain. But
parameter Voltage uNom=12.0;
it is also convenient for constraints which are
protected
laborious to define, e. g. characteristic curves
Resistance r;
of engines which are given in table form rather
Power pc;
than in closed form. As for the function classes
constant Power pLow=[-0.1 0.1];
in Modelica, constraint classes define an arguconstant Power pMedium
ment list and provide type checking when the
= [-0.3 -0.1][0.1 0.3] ;
constraint class is used.
constant Power pHigh









= [-2 -0.3][0.3 2] ;
behavior
r = uNom * uNom / pNom;
pc = p.i * (p.u - n.u) / pNom;
if (fm==0) Ohm(p.u, n.u, p.i, r);
if (fm==1) light = 0;
if (fm==0)
or
p.i= 0; light = 0;
pc = pLow; light = 0;
pc = pMedium; light = 1;
pc = pHigh; light = 2;
end Bulb;














The variable light is an indicator for the
mechanic whether the bulb is off (light=0),
is dimmed (light=1) or bright (light=2).
If by some reason the constraint net is underdetermined so that the consumed power of
the bulb pc=[0.2 1], the mechanic gets
the information light= 0,1 , i. e. the bulb
is off or dimmed, which may be an important indication. An analogous definition by
means of conditional constraints would result in
light= 0,1,2 , i. e. the whole range of this
variable.









In the example shown in Fig. 7, the constraint
class Spline is a basic constraint class provided by the RODON modeling language. It
has pre-defined attributes degree, periodic, boundary and values. There are
some other basic constraint classes. Constraint
classes may be parameterized by means of the
usual modification mechanism.

4

Conclusion

The striking correspondence of the modeling
philosophies in Modelica and RODON as well
as the neat class model of Modelica are strong
arguments in favour of Modelica as the future
modeling language of RODON. But there are
some additional requirements caused by our different simulation algorithm and the diagnostic
approach, namely



basic data type: interval set





multiple behavioral modes
alternative behavior: disjunctions




alternative behavior: conditional con- [Sei97]
straints, semantics of conditions for setvalued variables



constraint classes



coping with over- or underdetermined constraint nets
simulation by local constraint propagation

A few of them can possibly be met by providing special libraries. However, our experience
shows that there are features which require an
extension of the Modelica language, or the definition of a separate dialect for behavior description.

References
[AH74]

G. Alefeld and J. Herzberger.
Einführung in die Intervallarithmetik. Bibliographisches Institut
AG, Zürich, 1974.

[dKW87]

J. de Kleer and B. Williams. Diagnosing multiple faults. Artificial
Intelligence, 32:1297–1307, 1987.

[dKW89]

J. de Kleer and B. Williams. Diagnosis with behavioral modes. In
Proceedings of the IJCAI’89, pages
1324–1330, 1989.

[HHKR95] R. Hammer, M. Hocks, U. Kulisch,
and D. Ratz. C++ Toolbox for Verified Computing. Springer, 1995.
[Hyv91]

E. Hyvönen. Constraint Reasoning
with Incomplete Knowledge. PhD
thesis, Helsinki University, 1991.

[Mod99]

Modelica Association. Modelica Language Specification, December
1999.

[Rei87]

R. Reiter. A theory of diagnosis
from first principles. Artificial Intelligence, 32:57 – 95, 1987.

[Sei92]

W. Seibold. Grundlage der Diagnose technischer Systeme — sechs
Thesen. ist – Intelligente SoftwareTechnologien, 2(3), 1992.

W. Seibold. First time right from
layout to repair. In Proceedings
of the 30th ISATA Symposium, Florence (Italy), pages 483–492, June
1997.

6(0DWWVVRQ+2OVVRQ+(OPTYLVW
'\QDPLF6HOHFWLRQRI6WDWHVLQ'\PROD
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Dynamic Selection of States in Dymola
Sven Erik Mattsson, Hans Olsson and Hilding Elmqvist
Dynasim AB, Lund, Sweden
ABSTRACT
The object-oriented modelling language Modelica supports differential-algebraic equations (DAE) to
describe physical phenomena and behaviour. A basic idea is to support flexible and safe reuse of model
components. Model components are made general. When connecting them to form a system model
their behaviours are constrained. It typically means that there are more variables appearing
differentiated than variables needed for the continuous-time state. DAE problems of this kind are said
to have a high DAE index and the solution procedure involves differentiation. There are no reliable
general-purpose numerical DAE solvers for high-index problems. The paper illustrates how Dymola
solves them in a reliable and efficient way by combining symbolic and numerical methods.

Introduction
The object-oriented modeling language Modelica [5,
3] is designed for modeling of large and
heterogeneous physical systems. General equations
are used for modeling of the physical phenomena.
Differential-algebraic equations (DAE) support
modelling of continuous-time behaviour.
Modelica has been designed to allow tools to generate
efficient code automatically. No particular variable
needs to be solved manually. A Modelica tool will
have enough information to do that automatically. The
modelling effort is reduced considerably since model
components can be reused. Tedious and error-prone
manual manipulations are avoided.
Consider a DAE system
F (t , x, x, y) = 0 ,

where t is time, x and y are vectors of unknown
variables. The elements of x are called dynamic
variables since their time derivatives, x , appear in the
equations and the elements of y are called algebraic
variables since none of its derivatives appear in the
equations.
Solving a DAE problem involves more than solving
algebraic loops for y and x and integrating to obtain x.
The solution procedure involves also differentiation if
the Jacobian with respect to x and y is structurally
singular. It means that there are algebraic relations
between the elements of x. In order to be able to solve
for y and x it is then necessary to differentiate some
equations. The state to integrate is only a subset of the
elements of x and the number of initial values to set is
not always equal to the number of dynamic variables.
The first word dynamic in the title of this paper
indicates that there are problems where there is no
fixed set of state variables that works everywhere

along the solution trajectory, i.e., the set of state
variables change dynamically.
A DAE problem for which there is a need for
differentiation in the solution procedure is said to
have a high DAE index. It is well known that there
are no reliable general-purpose numerical DAE
solvers for high-index problems.
This paper illustrates how the Dynamic Modeling
Laboratory, Dymola [2] solves high-index problems
by combining symbolic and numeric methods.

Background and Motivation
Before discussing how to solve the problems some
more thorough explanations and motivations will be
given to the statements of the introduction.
High index DAE problems are natural
As a simple example consider Newton's second law
mx = F

It is a model for the motion, x, of a particle having
constant mass, m, being influenced by a force F.
Newton's second law can be used to solve the
dynamics problem, i.e., to calculate the motion when
m = m0 is a given constant and F = FR (t , x, x ) is
given as a function of time, speed and position. The
problem is solved by integrating the force, FR ,
twice. Position and velocity can be taken as states.
In, for example, robotics, it is of interest to calculate
the force needed to have the body to follow a
prescribed trajectory, x = x R (t ) . This problem has
different mathematical characteristics. To calculate
the force, F, the trajectory, x R , needs to be
differentiated twice. The model contains dynamic
variables, but there are no continuous-time states

and thus no initial values to set. It is a high-index
DAE problem.
The two problems discussed above are in some sense
extremes. There are also mixed problems. To support
reuse it is natural to develop models of bodies moving
freely in 3 dimensions. When such components are
used, connections to other components constrain their
motions. A connection implies that two positions are
equal, which means that there are reaction forces. To
calculate the reaction forces, it is necessary to
differentiate the position constraint twice to get a
constraint in terms of accelerations from which the
reaction forces can be calculated. Moreover, to
support reuse, it should of course also be possible to
use the 3D components to model planar mechanics.
Then there is a constraint x3 = b or more generally
kx = b , with k being a constant vector of size three
and b a scalar constant.
Consequently, high index DAE problems are natural
in object-oriented modelling, because the idea is to
support reuse of model components.
The DAE index

Why do numerical DAE solvers fail?
When solving an ODE the solution procedure
involves only integration, i.e., to calculate x from x .
The solution of a DAE system may also involve
differentiation, i.e., to calculate x from x. The error
in the differentiation will increase with decreasing
step-sizes, due to round-off errors and inaccurate
solutions of algebraic equations in previous steps.
This will introduce large unphysical transients if e.g.
some other part of the system cause a drastic
reduction in the step size. Furthermore it will
invalidate the assumptions of the error control and a
mild increase in the error might a stop the simulation
since it is not possible to reduce the step size to get
an acceptable error estimate. Given the index of
variables, as provided by the index-reduction
procedure, some solvers try to patch the error control
by ignoring errors in high variables or scaling their
errors with a suitable power of the step size. An
additional problem is that all solvers have
restrictions on how high the index of the DAE can
be without reducing the order of the method.

Dummy Derivatives

Consider the DAE problem

y

F (t , x, x ) = 0

x

We assume that it is solvable [1], with a unique,
smooth solution when supplied with an appropriate
number of consistent initial solutions. The index [1] of
the problem equals the minimum number times that all
or part of it must be differentiated with respect to time
t in order to determine x as a continuous function of x
and t.

L

F

For example, an ODE on explicit state space form,
x = f (t , x) ,

is index 0, and the problem
x = f (t , x, y)
0 = g (t , x, y )

is index 1 if the Jacobian of g with respect to y,
∂g / ∂y , is non-singular and it is only necessary to
differentiate if calculation of y is wanted.
By default Dymola assumes that a user is interested in
calculating all variables and appearing derivatives. It
is thus more convenient to allow high order
derivatives as well as purely algebraic variables. There
is then no need for differentiation, if it is possible to
determine the highest order derivatives as continuous
functions of time and lower derivatives. The index is
at most 1. The index is zero if there are no algebraic
variables. To avoid this technical problem, we will
just say that a problem has high index if it is necessary
to differentiate when solving for the highest-order
derivatives.

mg
Figure 1: A planar pendulum.

As an introduction to basic ideas for reducing the
DAE index and selecting state variables, consider a
model in Cartesian coordinates for a planar
pendulum of length L and mass m. Newton's second
law gives
mx = −

x
F
L

(1a)

my = −

y
F − mg
L

(1b)

where F is the force in the rod and g is the
gravitational acceleration. The length constraint is
x 2 + y 2 = L2

(1c)

It is easy to see that it is not possible to use these
three equations to solve for the highest order

derivatives x , y and F , since the length constraint
does not contain any of them. But they will appear if
the length constraint is differentiated twice
xx + yy = 0

(1c')

xx + x 2 + yy + y 2 = 0

(1c'')

Equations (1a), (1b) and (1c'') constitute an index 1
problem, since it is possible to solve for the highest
order derivatives x , y and F . Thus the original
problem (1a), (1b) and (1c) is index 3. The initial
values of x, x , y and y cannot be chosen
independently. They must fulfil (1c) and (1c').
A model including Equations (1a), (1b) and (1c'') and
start values, which fulfil Equations (1c) and (1c'), is
mathematically correct. However, the algebraic
relations of the original DAE problem are now only
implicit. Unless linear, these are generally not
preserved under discretization. As a result the
numerical solution drifts off the algebraic constraints.
For the pendulum, it means that its length will not be
constant.
To avoid such difficulties, one may try to obtain a
low-index formulation, with a solution set identical to
that of the original problem. Let us illustrate the idea
on the pendulum problem. For small oscillations
around the equilibrium point x = 0 and y = − L , it is
possible use to (1c'') to eliminate y . You can
eliminate y by first solving y from (1c'') to get an
expression, which is then used to eliminate y by
substitution. However, since it is not possible to solve
general non-linear equations analytically, this is not a
general method. Since Dymola anyhow must handle
and solve non-linear equations, y can instead be
eliminated by adding (1c'') as an implicit definition of
y . To avoid an overdetermined system, a new
algebraic variable, say y dd , is introduced to represent
y wherever it appears in Equations (1). Similarly, use
(1c') to replace y by y d . This yields an augmented
but determined system, which is index 1. It is
mathematically equivalent to (1a), (1b) and (1c):
mx = −

x
F
L

my dd = −

y
F − mg
L

which appears differentiated twice; the problem has
a single degree of freedom.
The original problem (1) has been augmented with
(1c') and (1c''). For each differentiated equation
appended to the original problem, one ''new''
dependent variable was introduced. The introduced
variables represent derivatives and are called dummy
derivatives. Dummy derivatives are purely algebraic
variables and not subject to discretization. We know
that y dd ≡ y and y d ≡ y , but this is not explicit in
the transformed problem.
The selection of dummy derivatives was done above
for small oscillations. Consider (2c'). It is linear in
y d with the coefficient y . It means that the
problem (2) becomes singular when y = 0 . There are
similar problems with (2c''). When y is small then
instead dummy derivatives have to be introduced for
x and x
 . Thus there is a need for dynamic selection
of dummy derivatives or states.
A dynamic variable, z, is a potential candidate for
being a state. When its derivative z is selected to be
a dummy derivative, you may also say that z is
deselected as state.
Recall Equation (1c), x 2 + y 2 = L2 . For a given x
such that

x ≤ L , (1c) may seem to give two

(2a)

solutions y = ± L2 − x 2 . However, Equation (1b)
implicitly assumes that y is differentiable at least
twice. It means that the solution for y cannot jump
from a down position to an up position. Neither can
y jump from ascending motion to a descending
motion. Fortunately, also numerical solvers have the
property to give a solution that is close to previous
value. However, when the solution for y crosses 0
things become complicated. The numerical solver
may step over zero and give an acceptable solution.
It may also happen that it gets stuck at zero and
signals a singular problem. The solver may be able
to produce the first period, while getting stuck in the
second period. Small changes in error tolerance
settings may give drastic changes in whether and
when the solver gets stuck. The probability of
getting stuck increases with tightened error
tolerance.

(2b)

The Index Reduction Algorithm

x 2 + y 2 = L2

(2c)

xx + yy d = 0

(2c')

xx + x 2 + yy dd + y d 2 = 0

(2c'')

Problem (2) has five equations and five unknowns: x,
y , y d , y dd and F , which all are algebraic except for

The index reduction procedure consists of two major
steps. First, the differentiated index 1 problem is
derived and then it is used for selection of dummy
derivatives.
To find the differentiated index 1 problem, the
algorithm developed by Pantelides [7] is used. It
establishes the minimum number each equation has
to be differentiated to make the differentiated
problem structurally non-singular with respect to

highest-order derivatives. The algorithm can be
viewed as an extension of the algorithms for assigning
equations to variables in sorting procedures.
The idea when selecting dummy derivatives is to start
from the differentiated index 1 problem and work
backwards in the chain of differentiated equations and
variables and for each step find variables that can be
selected as dummy derivatives. The dummy derivative
method is formally described in [4]. It will be
illustrated in next section. An outline of the procedure
is given below. It can be skipped at a first reading.
1.
2.
3.

Let the equations of the differentiated index 1
problem be the current equations.

5.

Consider all current unknowns that are at least of
order one. Collect their predecessors of one order
less and let them be the current candidates for
elimination.

6.

Exploit the current equations for elimination of
candidates.

7.

Repeat from Step 3.

8.

Collect all original and differentiated equations.
In all equation introduce a unique dummy
derivative for each derivative selected in Step 6.

First, the model in pure Cartesian coordinates will be
discussed and then an angular coordinate will be
introduced.

x
F
L

(3a)

mv y = −

y
F − mg
L

(3b)

x 2 + y 2 = L2

(3c)

mv x = −

x
F
L

(3a)

mv y = −

y
F − mg
L

(3b)

xx + x 2 + yy + y 2 = 0

(3c'')

x = v
x

(3d')

= v y

(3e')

y

The highest order derivatives are x , y , v x , v y and
F . To obtain the differentiated index 1 problem,
(3c) was differentiated twice giving (3c'') and
Equations (3d) and (3e) were differentiated once
giving (3d') and (3e'). A solution must fulfil (3c'),
(3d) and (3e). They can be used to eliminate
variables.

Let us apply the dummy derivative procedure
outlined in previous section to the pendulum model:
1.

The first set of current equations is (3a), (3b),
(3c''), (3d') and (3e').

2.

The first set of current candidates are x , y , v x ,
v y and F .

3.

In the set of current equations the equations
(3c''), (3d') and (3e') are differentiated versions
of the original ones. Their predecessors are
(3c'), (3d) and (3e). Let them be the new current
set of equations.

4.

Go on to Step 5, because there are current
equations.

5.

In the set of current candidates the following are
derivatives: x , y , v x and v y . Collecting their

give the equations
mv x = −

(3c')

Then it finds out that (3c') needs to be differentiated
as well as (3d) and (3e) to obtain the differentiated
index 1 problem as

Pure Cartesian coordinates
The model (1) for the pendulum includes second order
derivatives. Modelica supports only first order
derivatives. The equations are easily rewritten by
introducing v x and v y for the velocity components to

(3e)

xx + yy = 0

Application: The pendulum
Let us discuss in more detail the application of the
index reduction method to the pendulum model.

y = v y

Consider state selection for model (3). Pantelides's
algorithm first differentiates (3c)

Consider all of the current equations that are
differentiated versions of the original ones.
Collect their predecessors and let them be the
current equations.
If there is no current equation, go to Step 8.

(3d)

which directly can be used in a Modelica model.

Let the highest derivatives of the differentiated
index one problem be the current candidates.

4.

x = v x

predecessors of one order less is giving: x , y ,
v x and v y . Let them be the new set of current
candidates for elimination.
6.

When exploiting the current equations for
elimination, Dymola first tries to eliminate
derivatives. Equation (3d), x = v x , can always
be used to calculate x which means that x is
selected as a dummy derivative and thus x is

deselected as state. Similarly (3e), y = v y , is used
to select y as a dummy derivative. Equation
(3c'), xx + yy = 0 , has to be used dynamically to
deselect either v x or v y as a state.
7.

Repeat from Step 3.

8.

Step 3 gives the current equations (3c)

9.

Step 4 implies continue.

either x or y as state. The thick line shows the value
of the state. Initially x = 0.6 and y = 0.8. Thus y > x
and (3c) is used to eliminate y and x is then the state.
At around t=0.2, x becomes greater than y and y is
selected as state.

x

state3[1]
1

10. Step 5 gives the new candidates: x and y.

0

11. Step 6: Equation (3c) has to be used dynamically
to deselect either x or y as a state.
12. Step 7 and Step 3-4 lead to Step 8 and collecting
the resulting index 1 problem. In the resulting
problem, x and y are selected as dummy
derivatives. Equation (3c'), xx + yy = 0 , is used
dynamically to deselect either v x or v y as a state
and (3c) is used dynamically to deselect either x
or y as a state.
Unfortunately, the procedure discussed above
introduces some extra derivatives, namely x and y .
Dymola avoids this by identifying simple differential
equations such as (3d) and (3e). You may view them
as introducing alias names for x and y . The chain of
derivatives, x → x → x , is viewed as, x → v x → v x .
Dymola proceeds as follows, when (3d) and (3e) have
been identified as simple differential equations they
are temporarily removed from the problem and all
appearances of x and y in the remaining equations are
substituted. Pantelides's algorithm is then applied on
the Equations (3a), (3b) and (3c) to find the
differentiated index 1 system for the unknowns v x ,
v y and F . When differentiating (3c'), Dymola
substitutes x and y by v x and v y giving
xv x + yv y = 0

(3c')

In the next step Pantelides's algorithm only calls for
differentiation of (5c') giving
xv x + v x 2 + yv y + v y 2 = 0

y

(3c'')

The highest order derivatives are v x , v y and F .
Going back one step in the differentiation chain gives
Equation (3c'). The candidates for elimination are v x
and v y . Going back one step further gives Equation
(3c) and the candidates for elimination are x and y.
The result is similar to Equation (1), but the variables
are named a bit differently. Finally, Equation (3d) and
(3e) are put back.
The plot below shows the result of a simulation in
Dymola. It illustrates the use of Equation (3c) to select

-1

0

1

2

3

4

5

Introducing an angular quantity
Unfortunately, the pendulum model in Cartesian
coordinates requires dynamic selection of states,
because the model has no variable that can function
as a state for all positions. It is well known that a
polar angle works fine as state at any position. Let us
introduce such an angle, ϕ , that is zero, when the
pendulum is hanging downward in its rest position;
x = L sin(ϕ ) and y = − L cos(ϕ ) . Introduce also ω
for the angular velocity and α for the acceleration.
It is convenient to write Newton's equation of
motion in Cartesian coordinates. However, it may be
clearer to use ϕ for the reaction forces from the rod
x
and write mv x = − F sin(ϕ ) instead of mv x = − F .
L
The model can be written as
mv x = − F sin(ϕ )

(4a)

mv y = F cos(ϕ ) − mg

(4b)

x = L sin(ϕ )

(4c)

y = − L cos(ϕ )

(4d)

α = ω

(4e)

x = v x

(4f)

y = v y

(4g)

ϕ = ω

(4h)

To make ω eligible for state selection, it must be a
dynamic variable. Equation (4e) makes ω dynamic.
Dymola exploits (4e) at an early phase of the
translation to eliminate α as an alias variable for ω .
Equation (4f), (4g) and (4h) are identified as simple
differential equations just introducing alias names
for the derivatives x , y and ϕ . Pantelides's
algorithm is applied to Equations (4a-4d) with the

unknowns v x , v y , ω and F . First, Equation (4c) and
(4d) are differentiated
v x = Lω cos(ϕ )

(4c')

v y = Lω sin(ϕ )

(4d')

Then they are differentiated once more
v x = Lω cos(ϕ ) − Lω sin(ϕ )

(4c'')

v y = Lω sin(ϕ ) + Lω cos(ϕ )

(4d'')

Equation (4c') and (4d') are used to eliminate v x and
v y , and (4c) and (4d) are used to eliminate x and y.
Thus Dymola makes a fixed state selection with ϕ
and ω as states.

Application: Quarternions
Consider modelling of the motion of a free, rigid body
in a 3D space. It is a major issue to describe
orientation in a 3D space. Unfortunately, there is no
set of three variables to describe orientation that works
for all positions.
Historically, the most popular approach to describing
orientation has been in terms of Euler angles, where a
general rotation is described as a sequence of rotations
about three mutually orthogonal coordinate axes fixed
in space. However, for a given set of Euler angles
there are rotations that cannot be described by [8]. The
quaternion, which was invented by the great
mathematician Sir William Hamilton in 1843, is a
solution to the problem.
A quaternion, q , is a vector of four elements. A 3dimensional rotation can be described as
n ⋅ sin(ϕ / 2)
q=

 cos(ϕ / 2) 

where n is the unique axis of rotation to transform a
coordinate system 1 into a coordinate system 2 by a
planar rotation via a rotation angle ϕ . The four
elements are not independent from each other, but
have to fulfil the normalization equation
q1 2 + q 2 2 + q3 2 + q 4 2 = 1

(5)

In coordinate system 2, the angular velocity, ω is
ω = 2 Lq

with
 q4
L = − q 3
 q 2

q3
q4
− q1

− q2
q1
q4

− q1 
− q 2 
− q 3 

The complete model of a body includes also the usual
force and torque balances. For more information of

use of quaternions in mechanics, see any good
textbook in mechanics, e.g., [6].
When simulating a free body, one of the four
components of q has to be deselected as state.
Dymola finds that Equation (5) have to be
differentiated and that it is necessary to have a
dynamic selection of states where three of the four
elements of q are selected as state and the
remaining element is calculated from (5).
The structure of Equation (5) is similar to the length
constraint of the pendulum. Dymola treats it in a
similar way as when the Cartesian coordinates x and
y were used. However, for the free body there is no
need for dynamic selection of states at velocity level.
The variable ω can be used as a state all the time. It
was possible to eliminate the need of dynamic
selection of states for the pendulum by introducing
an angular coordinate. Unfortunately, this is not
possible when modelling motion of bodies in a 3D
space. There is no set of three variables to describe
orientation that works for all positions. This is one
reason why multbody mechanics in 3D is much
more difficult than planar 2D mechanics.

Application: Kinematic Loops
The Dymola distribution includes a demonstration
example "Two coupled kinematic loops". It is a
mechanical mechanism with one degree of freedom.
Consider the model diagram in Figure 2 and a 3Dview of it in Figure 3.
The component b5 models the longest rod and to
that is b4 welded orthogonally. The prismatic joint
j3 allows the body b3 to slide along b5. Body b1 is
mounted via a joint j1 to the back end of b5. There is
also a "motor" to drive j1. The other end of b1 is
mounted to j2, which is a rod with spherical joints at
each end. The mass of j2 is given by b2. The
element j2 is also connected to b3. The components
j1, b1, j2, b3, j3 and b5 form a kinematic loop.
There is another kinematic loop j3, j4, b6, j5, b7, j6,
j7 and b4, which are in the front part of the 3D view.
The joint j3 makes the two loops coupled.
When the joint j1 has turned half a revolution, then
b3 will be back in the same position. It means that
the position of b3 cannot be used as a state, because
there is two possible configurations for the same
position. The positions of the components in the
second kinematic loop j3, j4, b6, j5, b7, j6, j7 and b4
are completely determined by the position of b3.
Thus their positional variables cannot be used as
states. Also the angle relative angle between b1 and
b2 is determined by the position of j3. It is possible
to use the angle and angular velocity of j1 as the
states all the time. If this had not been the case, it
had not been possible to run the mechanism by
driving j1.

torque

Conclusions

shaf t
b2

tau

gear=10

J=0.5
b1
j2=1.1

j1={0,0,1}
inertial
y
x

b8

This paper has illustrated how Dymola solves the
important problem of handling high-index DAE
problems and selection of states in an efficient and
reliable way.

r={-0.8,0,0}

Acknowledgements

b5={1.8,0,0}
j3={1,0,0}

b3={-0.2,0,0}

j4
C
b6

This work was in parts supported by the European
Commission under contract IST-199-11979 with
Dynasim AB under the Information Societies
Technology as the project entitled "Real-time
simulation for design of multi-physics systems".

b7={0,0,-0.3}

b4={0,0,0.5}
j7={0,1,0}

j6={-1,0,0}

j5={0,0,1}
shape

Figure 2: A Modelica model of the two coupled
kinematics loops.

Figure 3: Initial configuration of mechanism.

When Dymola translates the model, it identifies two
sets for dynamic selection of states. One is on position
level where the relative angle of the joints j1, j5, j6,
and j7 and the relative distances of j3 and j5 are
potential candidates to be the positional state for this
one degree-of-freedom system. The other set contains
the corresponding velocities. Dymola is not able to
deduce that the angle of j1 can be used as the state all
the time because the Jacobian for the system to
eliminate states is complex including sine and cosine
functions of the joint angles.
At the start of a simulation run, Dymola selects the
angle and angular velocity of j1 as states and keeps
them for the complete simulation run. The overhead to
check the selection of states increases the simulation
time by 10%, which is a marginal increase compared
to manual static selection of the angle and angular
velocity of j1 as state variables.

References
[1] K. Brenan, S Campbell and L. Petzold,
Numerical Solution of Initial Value Problems in
Differential-Algebraic Equations, NorthHolland, Amsterdam, 1989
[2] Dymola  Dynamic Modeling Laboratory,
Dynasim AB, Lund, Sweden. Homepage:
http://www.Dynasim.se
[3] H. Elmqvist, S. E. Mattsson, and M. Otter,
Modelica  A Language for Physical System
Modeling, Visualization and Interaction,
Proceedings of the 1999 IEEE Symposium on
Computer-Aided Control System Design,
CACSD'99, Hawaii, USA, 1999
[4] S. E. Mattsson and G. Söderlind, Index
Reduction in Differential Algebraic Equations
Using Dummy Derivatives, SIAM Journal on
Scientific Computing, Vol. 14, No. 3, pp. 677692, 1993
[5] Modelica, Modelica Association, Homepage:
http://www.Modelica.org/.
[6] P. E. Nikravesh, Computer-Aided Analysis of
Mechanical Systems, Prentice Hall, 1988
[7] C. C. Pantelides, The consistent initialization of
differential-algebraic systems, SIAM Journal on
Scientific and Statistical Computing, Vol. 9, pp.
213-231, 1988
[8] A. Watt and M. Watt, Advanced Animation and
Rendering Techniques: Theory and Practice,
Addison-Wesley, 1992

02WWHU0'HPSVH\&6FKOHJHO
3DFNDJH3RZHU7UDLQ$0RGHOLFDOLEUDU\IRU
PRGHOLQJDQGVLPXODWLRQRIYHKLFOHSRZHUWUDLQV
0RGHOLFD:RUNVKRS3URFHHGLQJVSS

3DSHUSUHVHQWHGDWWKH0RGHOLFD:RUNVKRS2FW/XQG6ZHGHQ
$OOSDSHUVRIWKLVZRUNVKRSFDQEHGRZQORDGHGIURP
KWWSZZZ0RGHOLFDRUJPRGHOLFDSURFHHGLQJVKWPO
:RUNVKRS3URJUDP&RPPLWWHH
 3HWHU)ULW]VRQ3(/$%'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQFKDLUPDQRIWKHSURJUDPFRPPLWWHH
 0DUWLQ2WWHU*HUPDQ$HURVSDFH&HQWHU,QVWLWXWHRI5RERWLFVDQG0HFKDWURQLFV
2EHUSIDIIHQKRIHQ*HUPDQ\
 +LOGLQJ(OPTYLVW'\QDVLP$%/XQG6ZHGHQ
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
:RUNVKRS2UJDQL]LQJ&RPPLWWHH
 +XEHUWXV7XPPHVFKHLW'HSDUWPHQWRI$XWRPDWLF&RQWURO/XQG8QLYHUVLW\6ZHGHQ
 9DGLP(QJHOVRQ'HSDUWPHQWRI&RPSXWHUDQG,QIRUPDWLRQ6FLHQFH/LQN|SLQJ
8QLYHUVLW\6ZHGHQ

Package PowerTrain: A Modelica library for
modeling and simulation of vehicle power trains
Martin Otter, DLR, Germany (martin.otter@dlr.de)
Mike Dempsey, Claytex Services Ltd., U.K. (mike.dempsey@claytex.co.uk)
Clemens Schlegel, Schlegel Simulation GmbH, Germany (cs@schlegel-simulation.de)

Abstract
In this article a new Modelica library to model vehicle power trains is discussed. An overview of the
elements within the library is given, such as planetary gearsets, laminar clutches, torque losses, driver,
warm up model. The library is demonstrated through
the discussion of two illustrative examples, for drive
cycle fuel consumption prediction and for investigating gearshift transition dynamics of an automatic gearbox. Together with the Modelica simulation environment Dymola, this library is suited and used for HIL
(Hardware-In-the-Loop) simulations.

1

Introduction

Vehicle power trains are 1-dimensional, rotational mechanical systems. They transmit mechanical energy
between an engine and the wheels and provide a translation of engine torque and speed. Traditional methodologies for modelling drivelines are described in [5, 7].
In this article a new Modelica library for modelling vehicle power trains is discussed which offers significant
advantages compared to traditional methods.
From a modellers point of view, the PowerTrain
library window is a set of icons representing the components of a power train, such as engine, torque converter, automatic gearbox, etc. The icons are dragged
and moved to a model window and are connected together according to the physical connections. The library together with an appropriate Modelica tool such
as Dymola [2] takes care of all complications which
may arise in the model, such as inertias directly coupled via an ideal gearbox (which leads to a reduction
of the number of states) or locking and unlocking of
frictional elements such as bearing friction, clutches
or brakes.
The actual implementation of all model components is given in the Modelica language. If in an application some variant of a component is needed, users

can simply make a copy of the appropriate element and
change the model according to their needs. Furthermore, it is straight forward to realize and incorporate
new elements as needed for the application.
Using Dymola as a simulation engine, an overall
model is symbolically processed (a) to transform the
system into state space form and (b) to enhance the efficiency. The latter is performed by, e.g., transforming
algebraic loops into smaller loops via permutation of
equations and via ”intelligent“ variable substitution. If
an algebraic loop is linear in the unknowns, a numerical linear solver is used to solve it. If the coefficient
matrix of the linear system is not time varying, an LUdecomposition is performed only once before the simulation starts. Other optimizations are done as well,
e.g., constant expressions are only computed once and
output variables which need not to be computed for the
integrator, are only computed at time instants where
the value has to be stored. The result of the symbolic
processing is stored as a C-function which is compiled
and linked to Dymolas simulation environment. Alternatively, it can be incorporated into other environments, such as SIMULINK. From Dymolas point of
view, power trains are small systems and the symbolic
processing needs usually only seconds.
In the remaining part of this article, an overview of
the PowerTrain library is given, some components are
explained in more detail and two application examples
are discussed.

2 Overview of PowerTrain library
The PowerTrain library contains 1-dimensional rotational mechanical components. It is normally used in
combination with the Modelica.Mechanics.Rotational
sublibrary of the Modelica standard library. A screen
shot of the Rotational library is shown in figure 1. This
library contains basic elements, such as a rotational inertia, ideal gearboxes, shaft elasticity, bearing friction,
clutches, brakes, and sensors. The Rotational library

([DPSOHV

,QWHUIDFHV

/LEUDU\

/LEUDU\

,GHDO3ODQHWDU\

,QHUWLD

6SULQJ

'DPSHU

F

G

UDWLR

3ODQHW5LQJ

,GHDO3ODQHWDU\

' LI I HUHQWLDO

,GHDO*HDU

-

,GHDO*HDU57

3ODQHW3ODQHW

UDWLR

] 

] 

6SULQJ'DPSHU(ODVWR%DFNODVK

%HDULQJ)ULFWLRQ

9DULDEOH*HDU

] 
)UHH:KHHO

E

G

6LPSOH$XWR*HDU
/DPLQDU& OXWF K

*HDU(IILFLHQF\

7RUTXH& RQY HUWHU
*HDU(I I LFLHQF\ 

*HDU

&OXWFK

2QH:D\&OXWFK

3RVLWLRQ

$FFHOHUDWH

SKL
F

D

%UDNH

HWD

7RUTXH

)L[HG

7RUTXH/RV V

6WDUWHU0RWRU

7KHUPRVWDW

(QJLQH

WDX

6HQVRUV

6

/RFN8S7&

(QJLQH

(QJLQH
:DUP8 S0RGHO

:KHHO

/LEUDU\

5HODWLY H6WDWHV
:KHHO

Figure 1: Library Modelica.Mechanics.Rotational.
is part of the standard distribution of a Modelica environment, such as Dymola.
A screenshot of the PowerTrain library is given in
figure 2. The following list contains a short description
of the most important components of the PowerTrain
library. Some of these components are discussed in
more detail in subsequent sections:
PlanetPlanet, PlanetRing: Basic building blocks to
construct any type of planetary gearbox.
Planetary: Planetary gearbox where the planet may
have a different rolling radius with respect to the
sun and to the ring respectively.
Differential: Differential gearbox.
VariableGear: Simple model of a gearbox where the
gear ratio between the driving and driven shaft is
determined by an input signal. The ratio applied
can be continuously or step changed.
LaminarClutch: Lamella clutch defined with technological parameters where the input is the pressure
to engage the clutch.
OneWayLaminarClutch: Series connection of free
wheel and laminar clutch.
LockUpTC: Hydrodynamic torque converter, realized with tables, coupled to a friction clutch to allow the torque converter pump and turbine to be
directly coupled together.
GearEfficiency2: Gear efficiency where the efficiency depends on the gear which is supplied as
an input.
TorqueLoss: Torque loss element which models the

& DU5 HVLVWDQFH

' ULY HU

' ULY HU

'ULYHU

'ULYHU

& DU& RDV W' RZQ

&RQWUROOHUV

([DPSOHV

8WLOLW\

/LEUDU\

/LEUDU\

/LEUDU\

Figure 2: PowerTrain library.
frictional losses in bearings. The friction characteristic is given as input signal to allow any type
of functional dependency of the torque loss to be
modelled.
WarmUpModel: A simple warm-up model that determines coolant and oil temperature based on a
lumped mass system from an energy balance between the engine, block, coolant in the block,
coolant in the radiator, oil system and the surrounding atmosphere.
Engine3: An engine model with inertia, warm-up and
friction models which is based on steady-state
mapped engine data.
Wheel2: A simple model of the wheel where the
wheel radius depends on the vehicle speed.
CarResistance, CarCoastDown: Longitudinal dynamics of a vehicle. Energy losses can either be
defined by resistance forces of wind and rolling
resistances given by tables, or the resistance
forces can be given as 2nd order polynomial.
Driver2: A driver model, for use with automatic
transmissions, that is based on a PI controller and
that is used to determine the throttle and brake
pedal positions. The driver will only control one
pedal at once.
Controls: Several controllers, such as gearbox, fuel
flow, idle controller.

Examples: Example models to demonstrate the usage
of the library.

3

Interfaces

The connector interfaces used for 1-dimensional rotational components are mechanical flanges:

ϕ1
τ1

z

ϕ2
τ2

1 = τ1  ez
2 = τ2  ez
!1 = ϕ̇1  ez
!2 = ϕ̇2  ez

As interface variables the absolute rotation angle
ϕ1 ; ϕ2 and the cut-torque τ1 ; τ2 in a flange are used.
In every flange a coordinate system is defined which is
fixed in the flange. The z-axis of this coordinate system is directed into the positive rotation direction. All
vectors in the flange are resolved in this flange coordinate system. Usually, in a component the coordinate
systems of all flanges of this component are parallel to
each other. This is the reason why the cut-torque τ1
of the left flange in the figure above is directed in the
left flange and the cut-torque τ2 of the right flange is
directed out of the right flange. If two flanges of different components are connected together, this means
that these two flanges are rigidly attached and that the
two flange coordinate systems are identical. In the Rotational library, a 1-dimensional rotational connector is
formally defined as:
connector Flange_a
Modelica.SIunits.Angle
phi;
flow Modelica.SIunits.Torque tau;
end Flange_a;

In this library two identical connectors Flange a and
Flange b are defined. The only difference of these two
connectors is the graphical representation (filled and
non-filled square) in order that different flanges of a
component can be more easily identfied in the graphical view.

4

Ideal planetary gears

There are various kinematical setups of planetary gearboxes. It would therefore be inconvenient to derive
the equations for every type of gearbox manually. It
is, however, possible to build up any type of planetary
gearbox by using two basic components (see the first
two rows in table 1): A planet-planet and a planet-ring
combination. This is demonstrated by the examples in
the two last rows of table 1:

Planet-Planet
combination
ϕ2 τ
2
ϕ1
τ1
ϕ0
τ0
z

Planet-Ring
combination
τ ϕ1
1

τ0

z

i1 = z1 =(z1 + z2 )
i2 = z2 =(z1 + z2 )
ϕ0 = i1  ϕ1 + i2  ϕ2
0 = τ1 + i1  τ0
0 = τ2 + i2  τ0
z j : Tooth number of wheel j

ϕ2
τ2

ϕ0

z j : Tooth number of wheel j

i1 = z1 =(z2 z1 )
i2 = z2 =(z2 z1 )
ϕ0 = i2  ϕ2 i1  ϕ1
τ1 = i1  τ0
0 = i2  τ0 + τ2

Planetary
gearbox
z

Ravigneaux
gearbox
z

Table 1: Ideal planetary gears.

The standard planetary gearbox, shown in the third
row of table 1, is constructed in such a way that the
planet may have a different rolling radius with respect to the sun and to the ring wheel, as is common
in modern load gearboxes. This corresponds to the
case where two planets with different rolling radius are
rigidly attached.
The Ravigneaux gearbox consists of 2 sun wheels,
2 planet wheels and one ring wheel (see, e.g., [4])
and is an example how non-standard gearsets can be
modelled using the two mentioned basic elements. In
the right column of table 1 it is shown, how this gearbox can be modelled by using 3 planet-planet and one
planet-ring combination.
The derivation of the equations for the planetplanet combination shall be discussed briefly: The
needed auxiliary variables are defined in figure 3.
Basically, the well known formula is used, which computes the absolute velocity vP of a point P from the absolute velocity vB of a reference point B on the same
rigid body, from the absolute angular velocity ! of this

b
v3
r1

ω1

P1

wheel 1

ey
r2

ω2

P2 ez

P3

ex

wheel2

carrier

v1

R2
R1

ω0

Figure 3: Planet-Planet combination.

exactly by counting the teeth, where as the radii r1 ; r2
can only be determined up to a certain tolerance.
The kinematic relationship (4.7) is part of the
model equations of the planet-planet combination, see
first row of table 1. The remaining equations can be
derived based on conservaton of energy: Since no energy is stored in an ideal planet-planet combination
and no energy is transmitted to the environment, the
sum of the energy flowing into this component through
all connectors has to vanish, i.e.,
0

=
=

body and from the position vector rBP from B to P:
vP

=

vB

+

!  rBP

(4.1)

=
=

P

(= dE =dt )

ϕ̇0  τ0 + ϕ̇1  τ1 + ϕ̇2  τ2

 τ0 + ϕ̇1  τ1 + ϕ̇2  τ2
(τ1 + i1  τ0 )ϕ̇1 + (τ2 + i1  τ0 )ϕ̇2
(i1 ϕ̇1 + i2 ϕ̇2 )

(4.8)

The two speeds ϕ̇1 ; ϕ̇2 can be selected independently
Application of (4.1) to the points P1 ; P2 ; P3 in figure 3, from each other. In order that the overal power P(t )
and utilizing the closed vector chain of the position always vanishes, the factors in front of ϕ̇ and ϕ̇ have
1
2
vectors R1 ; r1 ; r2 ; R2 leads to:
to vanish, which leads to the equations in the first row
R1 + r1 = R2 + r2
(4.2a) of table 1
Note, that the usage of ideal gearboxes, and espev1 = !0  R1
(4.2b)
cially of the planet-planet and planet-ring combination
v2 = !0  R2
(4.2c) leads always to small algebraic loops. These loops can
v3 = v1 + !1  r1
be treated efficiently with the techniques used in Dy= v2 + !2  r2
(4.2d) mola.
Inserting (4.2a–4.2c) in (4.2d) yields:

!0  (r2

r1 ) + !1  r1

=

!2  r2

5 Friction and loss elements
(4.3)

When the vectors are resolved in the coordinate system
of the carrier (see figure 3), i.e.,

!0 = ϕ̇0  ez ;

!1 = ϕ̇1  ez ;

r1

r2

= r1

 ex

;



= r2 (

ex )

!2 = ϕ̇2  ez ;
(4.4)

inserted in (4.3) and integrate once, the result is:
(r1 + r2 )

 ϕ0 = r1  ϕ1 + r2  ϕ2

(4.5)

If z1 is the number of teeth of wheel 1, z2 the number of
teeth of wheel 2 and b the width of one tooth together
with the distance to the next tooth along the rolling
circle, the girth of the two wheels is given by:
2πr1 = z1  b; 2πr2 = z2  b

(4.6)

Solving these two equations for r1 and r2 , inserting in
(4.5) finally yields the desired kinematic relationship
between the rotational angles and the teeth numbers:
(z1 + z2 )

 ϕ0 = z1  ϕ1 + z2  ϕ2

(4.7)

Note, that (4.7) is better suited than (4.5), because the
teeth number of a given gearbox can be determined

Both the Rotational library and the PowerTrain library contain friction elements, such as bearing friction, clutches, brakes, and gear efficiency. All these
elements are based on a thorough theory which will be
introduced by a brief explanation of a basic Coulomb
friction element. For more details, see [6].
Friction may lock the relative motion of two surfaces. This situation may be modeled (a) with stiff
springs, which only allow small relative displacements
in the stuck mode or (b) in a slightly idealized way as
exact locking element which removes one degree of
freedom if in stuck mode. It is easy to provide a model
for approach (a). However, the corresponding system
becomes stiff and is not suited for realtime simulations. Furthermore, it is usually difficult to determine
an appropriate spring and damping constant which reflects the reality and does not induce vibrations due
to the numerics. For these reasons, in the Rotational
and PowerTrain library, approach (b) is used. However, this leads to difficulties if two or more friction
elements are dynamically coupled.
The essential idea is discussed using translational
friction elements: Here, the friction force f acts between two surfaces and is a function of the relative

velocity v between the friction surfaces when they are
sliding relative to each other. When v becomes zero,
the two surfaces are stuck to each other and the friction
force is no longer a function of v. The element starts
sliding again if the friction force becomes larger than
the maximum static friction force f0 .
The key to the solution is the observation that v = 0
in the stuck mode and when forward sliding starts, but
v̇ > 0 when sliding starts in forward direction and v̇ = 0
in the stuck mode, see figure 4. Since the friction characteristic in figure 4 at zero velocity is no functional
relationship, i.e., a function f = f (a) does not exist, a
parameterized curve description

tinuous/discrete system of equations of the following
structure has to be solved:
m1 v̇1

=

u1 + f2

m2 (v̇1 + v̇2 )

=

u2

v̇1

=

g1 (s1 > 1; s1 <

1; s1 )

f1

=

g2 (s1 > 1; s1 <

1; s1 )

v̇2

=

g3 (s2 > 1; s2 <

1; s2 )

f2

=

g4 (s2 > 1; s2 <

1; s2 )

f1

f2

By applying appropriate time varying external forces
u1 (t ); u2 (t ) on the two blocks, a stick-slip like behaviour occurs. For this situation, a simulation was
carried out with Dymola [2] leading to the simulation
a = a(sa )
results of figure 6. The discontinuities in the friction
f = f (sa )
forces when switching from stuck to sliding mode are
due to the property that the maximum friction force
with a curve parameter sa is used leading to the fol- fmax in the locked mode is a factor of 1.25 higher as
lowing equations for zero velocity:
the sliding friction force f0 at zero velocity.
The process of finding the solution of the mixed
a = v̇
system of equations, i.e., to determine a consistent set
a = if sa > 1 then sa 1 else
of relations and continuous variables, can be manually
checked for demonstration purposes with the followif sa < 1 then sa + 1 else 0
ing settings (m1 = m2 = 1; fmax = f0 = 1):
f = if sa > 1 then f0 else
if sa <

f0 else f0  sa

1 then

At zero velocity, these equations and the equations
of the mechanical elements connected together with
the friction element form a mixed continuous/discrete
set of equations consisting of Real and Boolean unknowns, (Boolean unknowns are: sa > 1; sa < 1).
This mixed system of equations has to be solved at
event instants to determine whether a friction element
remains in the stuck mode or starts to slide. Several
other minor difficulties occur, which are discussed in
more detail in [6].
f

v=0

sa = 1

start forward sliding

f0

sa

.

a=v

start backward sliding

-f0
sa

sa = -1

u1

=

u2

=

0:9  f0

if time < 0:1 then 0 else 1:1  f0

At the beginning of the simulation the two blocks are
stuck. At time = 0.1 s an event occurs and force f2
jumps from 0 to 1:1  f0 . After evaluating all equations under the assumption that both blocks are stuck,
it turns out that both friction forces become larger than
f0 . Therefore, it is natural to have the assumption that
both elements start to slide in forward direction. Reevaluating the corresponding mixed system of continuous/discrete equations leads to a relative acceleration
of block 2 with respect to block 1 which is negative,
i.e., block 2 cannot slide in forward direction. The
assumption that block 1 slides and block 2 is stuck,
finally leads to a consistent configuration.
All friction elements utilized in the Rotational and
PowerTrain library are slight variations of the described basic friction element. In all cases, these elements lead to mixed systems of equations if they are

Figure 4: Friction characteristic at v = 0.
A simple example of dynamic coupling of friction elements is shown in figure 5 where two blocks
are sliding on each other and on every surface friction is present which is described according to the
discussed method. At event instants, a mixed con-

v2

m2

f2
v1

f2
m1

u2(t)
u1(t)

f1

Figure 5: Two blocks with friction.

Relative velocity in [m/s]

1
v1

0.5

0

−0.5
v2
−1

−1.5

0

0.5

1

1.5

2

2.5

3

2.5

3

15
Friction and driving forces in [N]

u1
10
f2

5
u2
0
−5

f1
−10
−15

0

0.5

1

1.5
Time in [s]

2

Figure 6: Simulation results of two block system.
dynamically coupled. Dymola [2] has appropriate numerical algorithms to solve these equations in a reliable and efficient way. For realtime applications, special adaptions of these algorithms are provided.
In the remaining part of this article, it is shown,
how the PowerTrain library can be utilized in different
applications.

6

Application 1: Fuel consumption

In the first application of the PowerTrain library, a vehicle model with an automatic gearbox is discussed
which is suitable for carrying out drive cycle fuel consumption prediction work, see figure 7. Since the
model is mainly used for predicting the energy losses
in a power train, detailed component models, such as
describing the detailed shifting behaviour of the automatic gearbox, are not needed.
The model in figure 7 contains an engine model
which is based on steady-state engine maps but includes a simple warm-up model to account for the effects of cold-starts. To achieve this it incorporates a
look-up table which determines the increased load that
should be applied to the engine due to increased friction when the engine is cold. The additional friction
load is dependant upon the predicted oil temperature.
Engine auxiliaries such as power steering pump, alter-

nator, and others are lumped into one table as a speed
dependant load on the engine. The individual torque
loss curves for these components need to be adjusted
to reflect the load on the crankshaft before entering
them into the model.
The transmission, see lower part of figure 7, is a
simplified model of an automatic transmission and incorporates a torque converter with a lock-up clutch.
The gearbox itself is modelled as a series of fixed
ratios which are jumped between according to the
control system. The control system determines the
shift point based on throttle position and vehicle speed
when compared to the defined shift map.
The driveline model is essentially a rigid model
with no compliance in the drive shafts and no tyreslip modelling. The wheel/tyre model does include a
speed-dependant rolling radius for the tyre. This level
of detail is sufficient for the drive cycle work that this
model has been developed for.
The vehicle itself is modelled as a lumped mass
and the resistance forces associated with the vehicle
are modelled as a second order polynomial dependant
upon vehicle speed. This curve can be determined
from a vehicle coastdown and accounts for all resistance forces such as aerodynamic, rolling, transmission losses, etc.
The driver model is based around a PI controller
which has external controls affecting its performance
so that the driver behaviour is realistic. For example,
the driver will only control one pedal at a time and
will not jump rapidly from throttle to brake pedal. The
change in pedal control is influenced purely by the desired speed-time profile.
In figure 8 typical simulation results of this model
are shown. In the upper part of the figure the desired
and actual speed of the vehicle is displayed. The desired speed is part of the European drive cycle. In
the lower part, the consumption of the vehicle (in liter
per 100 km) is shown. The consumption computation starts a little bit delayed, because at the beginning
the car is not moving which would mean that the consumption in litres per 100 km is infinity.

7 Application 2: Automatic gearbox
In the second application of the PowerTrain library,
the detailed gearshift transition dynamics of an automatic gearbox are investigated. For a demonstration
of the modelling and simulation methodology using
Modelica the automatic gearbox ZF 4HP22 is choosen
[4]. A crossectional view of this gearbox is shown
in figure 9 and the schematic in the lower part of fig-

'ULYHU

GU
LY
HU

7&
8

HF
X

'ULYH6KDI W

HQJLQH

JHDUER[

)LQDO'ULYH 

SD
UD
VL
WLF
/R
V
V

Z

UD
WLR
6
HO
HF
WR
U

LQSXW,QHUWLD

-



9HKLFOH

VSHHG

FOXWFK)RUFH

JHDU
HGH
S
6
WX
SQ
L

FOXWFK

ZKHHO'\ QDPLF

%UDNH

- 

7&

Z

GH
SH6
WX
WSX
R

RXWSXW,QHUWLD

WRUTXH/RVV

IODQJHBD

Y DULDEOH*HDU

-



IODQJHBE

Figure 7: Modelica model of power train for drive cycle fuel consumption prediction.
ure 10. It consists of a hydrodynamic torque converter
and three planetary gear sets, which are connected via
two clutches, four brakes and two free wheels. These
switching elements enable or disable the relative motion between the wheels of the planetary gears in order
to achieve the desired transmission ratios. In the upper part of figure 10 the gear shift scheme is shown,
describing which clutches have to be enganged or disenganged to activate the desired gear.
The clutches and brakes are controlled by electrohydraulic actuators which are in turn controlled by an
electronic control unit (ECU). The control scheme for
the clutches and brakes has to be designed carefully
to achieve a good compromise between gearshift comfort, wear and driving performance. Depending on the
goals of the actual investigation, the dynamic effects of
the hydraulic force generation may be modelled globaly by a first order time delay, or in detail using the
Modelica Hydraulics library [1], or by using any particular modelling level.

To simulate the gearshift transitions accurately, the
input and output torques acting on the gearbox are required. Therefore the whole driveline of engine and
torque converter (for details see [4]), differential gearbox and longitudinal vehicle dynamics (vehicle inertia and driving resistances) has to be included in the
model. For offline-simulations the essential functions
of the engine and gearbox ECUs have to be modelled
too. In a hardware-in-the-loop simulation they are replaced by the actual ECU hardware [8].
These components are shown in the upper part of
figure 11 together with a driver model which uses the
desired driving maneuvre as input. The model is set up
using the PowerTrain library and the Modelica Standard library. In the middle part of the figure, the connection of the switching logic, the clutch control and
the gearbox mechanics are shown. Finally, in the lower
part of figure 11 the mechanical components of the
gearbox, i.e., the 3 planetary gear sets, the clutches,
brakes and free wheels can be seen. The switching el-

Figure 9: Crossectional view of gearbox ZF 4HP22.

VSHHGLQNPK



YHKLFOH6SHHG

GHVLUHG6SHHG

reuse of model components in a simulation model of
an other gearbox without any modification, whitch is
not possible using other modelling methods. Using an
appropriate simulation tool [2] the described Modelica
gearbox model is also very efficient. Therefore it can
be used in realtime applications too [3, 8].


















WLPHLQVHF

FRQVXPSWLRQLQONP

PHDQ&RQVXPSWLRQ








WLPHLQVHF

Figure 12 gives some simulation results: On
the lefthand side engine respectively torque converter
speed and car acceleration during a fullspeed upshift
through all four gears are shown. The plots on the
righthand side are zoomed in time, showing details of
clutch / freewheel C11 opening during upshift from
3rd to 4th gear.
Because clutch C12 starts to close at T=18 the
torque transmitted in C11 increases. C11 starts to open
at T=18 (control input decreasing), but is still strong
enough to stay stuck. At T=18.53 clutch C11 starts to
slide (state lC11 changes from 1 to 0). An increasing
relative speed can be observed. Clutch C11 can now

Figure 8: Simulation results of drive cycle model.
ements are controlled by signals which are generated
in the clutch control component.
The Modelica model of the automatic gearbox has
a variable structure, since the 6 clutches and brakes Ci
allow 26 = 64 different structures. Although, basically
only the 5 different structures according to the gears
from figure 10 occur, during a gear shift every of the
other 59 structures may show up, depending on the
actual clutch control signals and the clutch actuators
performances.
The components of the gearbox as well as the connections of the components are identical in the Modelica model of the gearbox (= lower part of figure 11)
and in the gearbox schematic in figure 10. This enables

Gear

C4

1
2
3
4
R

x
x
x
x

C5

C6

C5

C6

C8

C12

x
x
x

x
x
x
x

C11

x
x

x

C8
C11

C4

C12

Figure 10: Shift scheme of gear ZF 4HP22.

SRZHUWUDLQ

Y

Z

Y

Q
' 0(B

ZKHHO  

- 

-LPSHOOHU

-FUDQN

- 

-WXUELQH

JHDUER[

G
LI
I
H
U
H
Q
W
LD
O




EUDNH

' 0(
HQJLQH

- 

F DU



WRUTXH& RQY HUWHU

ZKHHO  

JHDUER[ZLWK
FOXWFKFRQWURO

OHF
\
&
JQ
LY
ULG

LQ
3
RU
W

*
6

VK
LIW

&R
QW
UR
O

&
OX
WF
K

FOXWFK&RQWURO
6ZLWFKLQJ/RJLF

'ULYHU

UH
YUL
G

JH
DU

Z
Z

IODQJHBD

IODQJHBE

=)+3B

LQ3RUW

GHPXOWLSOH[

PHFKDQLFVRI
DXWRPDWLFJHDUER[

&

&

S

&

&

&

I ODQJHBD

I L[ 

I L[ 

I L[ 

S

- H

- H

LQHUWLD

LQHUWLD

UDWLR 

UDWLR 

S

&

I ODQJHBE

UDWLR 

Figure 11: Modelica model of power train with automatic gearbox ZF 4HP22.
no more transmitt full torque, it breaks down a bit and
decreases as the clutch is opened more and more. At
T=18.65, before the clutch is opened completely, full
relative speed between the disks of clutch C11 can be
observed. At T=18.7 C11 is fully opened (control input 0).
Optimal clutch control would avoid the change of
sign of the transmitted torque in clutch C11 (and other
clutches involved) and therefore avoid the double peak
in the car acceleration.

8 Conclusion
The predecessor of the PowerTrain library was realized with the Dymola language, an object-oriented
modeling language which is superseded by the Modelica language (and will not be developed further by
Dynasim). It has been used successfully to model automatic gearboxes, similiar to the one shown in the
lower part of figure 11, for various hardware-in-theloop simulator projects in the automotive industry.
The Modelica PowerTrain library as successor
of the previous Dymola library offers several bene-

Torque / relative Speed in Clutch C11 (zoomed)
100

Speed of Engine and Converter − Turbine

Torque [Nm]

Speed [Rev / min]

6000
4000
2000
0

0

5

10

15

20

25

50
0
relative Speed [%]
−50
−100
17.8

Acceleration [m / s²]

Car Acceleration

18.2

18.4

18.6

18.8

Control Input / State of C11 (zoomed)

6

1

4

0.5

2

0: free, 1: stuck
0

0
−2

18

0: no Input, 1: full Input
0

5

10

15

20

25

−0.5
17.8

18

18.2
18.4
Time [s]

18.6

18.8

Figure 12: Gearbox simulation results
fits: The friction elements, such as bearing friction,
clutches and brakes are realized differently, based on
the theory scetched in section 5. This leads to more
robust simulations and also to higher efficiency, because 1 or 2 local iterations over the set of dynamically
coupled friction elements are sufficient (previously a
global iteration over the whole model had to be performed). A lot of new elements are included, such as
torque losses and a warm-up model of the engine. Finally, all other available Modelica libraries can be easily utilized, e.g., to model the hydraulics or electronic
components.

References
[1] Beater P.: HyLib. A Modelica Hydraulics Library.
http://www.dynasim.se/
[2] Dymola. Homepage: http://www.dynasim.se/
[3] Elmqvist H., M. Otter, and C. Schlegel: Physical
Modeling with Modelica and Dymola and Realtime
Simulation with Simulink and Real Time Workshop.
1997 Matlab User Conference, San Jose, 6.-8. Okt.,
1997. (http://www.modelica.org/papers/mlconf.ps)
[4] Förster, H.J.: Automatische Fahrzeuggetriebe.
Springer, 1991.
[5] Laschet A.: Simulation von Antriebssystemen.
Springer, 1988.
[6] Otter M., H. Elmqvist, and S. E. Mattsson: Hybrid
modeling in Modelica based on the synchronous data
flow principle. In Proceedings of the 1999 IEEE
Symposium on Computer-Aided Control System

Design, CACSD’99, Hawaii, USA, August 1999.
IEEE Control Systems Society.
[7] Rubin Z.J., S.A. Munns, and J.J. Moskwa: The
Development of Vehicular Powertrain System
Modeling Methodologies: Philosophy and
Implementation. 1997 SAE Congress and Exposition,
Detroit, SAE paper No. 971089.
[8] Schlegel C., and F. Kessler: Modellierung und
Hardware-in-the-Loop Simulation von
Automatikgetrieben. ”Hardware-in-the-Loop
Simulation in der Fahrzeugentwicklung“, Haus der
Technik e.V., Essen, 1998

