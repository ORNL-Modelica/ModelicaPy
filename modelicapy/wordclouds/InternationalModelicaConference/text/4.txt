2005
Proceedings of the
4th International Modelica Conference
March 7-8, 2005
Hamburg University of Technology
Hamburg-Harburg, Germany

Gerhard Schmitz (editor)

Volume 1

organized by
The Modelica Association and
the Department of Thermodynamics, Hamburg University of Technology
All papers of this conference can be downloaded from
http://www.Modelica.org/Conference2005/papers/

Proceedings of Modelica’ 2005
Hamburg University of Technology,
Hamburg-Harburg, Germany, March 2005
Editor:
Prof. Dr.-Ing. G. Schmitz
Published by:
The Modelica Association (http://www.Modelica.org) and
the Department of Thermodynamics,
Hamburg University of Technology (http://www.tt.tu-harburg.de)
Printed by:
COPY-DRUCK
Gesellschaft für Digital- und Offsetdruck mbH

The Modelica Association

Modelica 2005, March 7-8, 2005

Preface
The first Modelica Conference took place October 2000 in Lund, Sweden. Since then, Modelica has
been more and more established as a preferred modelling language for complex multi-domain systems.
This is indicated by the high number of registrations from industry and science for the 4th International Modelica Conference which is held between March 7th and 8th 2005 at Hamburg University
of Technology (TUHH). But it is also indicated by the number of excellent papers submitted to the
program committee which made the task of selecting papers for oral and poster presentation very
difficult and, last but not least, by the exhibition during the conference at which around 10 companies
will present themselves. The proceedings contain the papers of the 60 oral presentations and 9 poster
presentations given at the conference. The ability of Modelica as a multi-domain simulation language
is demonstrated impressively by the various fields that are covered, e.g. digital electronic devices,
hybrid electric power trains, waste water processes or thermodynamic applications.
With the special features of the Modelica language, e.g. object-oriented modelling and the ability to
reuse and exchange models, Modelica has become – among other things – a further step towards of an
integrated engineering design process. In some fields Modelica is being used as a standard platform for
model exchange between suppliers and OEM’s, for example in case of vehicle air conditioning systems.
A key issue for the success of Modelica is the continuous development of the Modelica language by
the Modelica Association under strict observance of backward compatibility to previous versions. The
broad base of private and institutional members of the Modelica Association as a non-profit organization ensures language stability and security in software investments.
The Modelica Conference 2005 was organized by the Modelica Association and by the Department
of Thermodynamics of Hamburg University of Technology (TUHH), Germany. Together with the
entire team of the local organizing committee I would like to wish all participants an excellent and
fruitful conference.

Hamburg-Harburg, March 1, 2005

Gerhard Schmitz

The Modelica Association

1

Modelica 2005, March 7-8, 2005

Program Committee
• Prof. Gerhard Schmitz, Hamburg University of Technology, Germany (Program chair).
• Prof. Bernhard Bachmann, University of Applied Sciences Bielefeld, Germany.
• Dr. Francesco Casella, Politecnico di Milano, Italy.
• Dr. Hilding Elmqvist, Dynasim AB, Sweden.
• Prof. Peter Fritzson, University of Linköping, Sweden
• Prof. Martin Otter, DLR, Germany
• Dr. Michael Tiller, Ford Motor Company, USA
• Dr. Hubertus Tummescheit, Scynamics HB, Sweden

Local Organizers
• Gerhard Schmitz
• Katrin Prölß
• Wilson Casas
• Henning Knigge
• Jens Vasel
• Stefan Wischhusen
• TuTech Innovation GmbH

The Modelica Association

2

Modelica 2005, March 7-8, 2005

Contents
Volume 1
Session 1a
Mechanical Systems

11

I. Kossenko, Moscow State University of Service, Russia: Implementation of Unilateral
Multibody Dynamics on Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F. Schiavo, G. Ferretti, L. Viganò, Politecnico di Milano, Italy: Object-Oriented Modelling and Simulation of Flexible Multibody Thin Beams in Modelica with the Finite
Element Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
T. Pulecchi, M. Lovera, Politecnico di Milano, Italy: Object-oriented modelling of the
dynamics of a satellite equipped with Single Gimbal Control Moment Gyros . . . . . .
H. Elmqvist, M. Otter, J. Dı́az López, Dynasim AB, Sweden; DLR Oberpfaffenhofen,
Germany: Collision Handling for the Modelica MultiBody Library . . . . . . . . . . .

Session 1b
Chemical Systems and Thermodynamic Systems I

13

25
35
45

55

F. Cellier, À. Nebot, ETH Zürich, Switzerland; Universitat Politecnica de Catalunya,
Spain: The Modelica Bond-Graph Library . . . . . . . . . . . . . . . . . . . . . . . . .
J. Ungethüm, German Aerospace Center, Stuttgart, Germany: Fuel Cell System Modeling
for Real-time Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
M. Rubio, A. Urquı́a, L. González, D. Guinea, S. Dormido, UNED and CSIC,
Madrid, Spain: FuelCell Lib - A Modelica Library for Modeling of Fuel Cells . . . . . .
E. Larsdotter Nilsson, P. Fritzson, Linköping University, Sweden: A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems

57
67
75
85

Session 1c
Methods I

95
F. Casella, Politecnico di Milano, Italy: Exploiting Weak Dynamic Interactions in Modelica 97
H. Olsson, H. Tummescheit, H. Elmqvist, Dynasim AB; Modelon AB, Sweden: Using
Automatic Differentiation for Partial Derivatives of Functions in Modelica . . . . . . . 105
L. Saldamli, B. Bachmann, P. Fritzson, H. Wiesmann, Linköping University, Sweden;
FH Bielefeld, Germany; ABB, Switzerland: A Framework for Describing and Solving
PDE Models in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
P. Aronsson, P. Fritzson, Linköping University, Sweden: A Task Merging Technique for
Parallelization of Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123

The Modelica Association

3

Modelica 2005, March 7-8, 2005

Session 2
Poster session

129

D. Aiordachioaie, M. Munteanu, E. Ceanga, University of Galati, Romania: Some
Results on Neutral Modelling of the Steel Continuous Casting Process . . . . . . . . .
C. Clauß, E. Erler, Fraunhofer Institute, Dresden, Berufliches Schulzentrum, Freital, Germany: Switched Capacitor Simulation with Modelica . . . . . . . . . . . . . . . . . . .
K. Berg, K. Nyström, Linköping University, Sweden: Hydrological modeling in Modelica
P. Harman, Ricardo UK Ltd.: Visualisation of Model Transformation Algorithms for a
Modelica Translator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C. Martin,A. Urquı́a, S. Dormido, UNED Madrid, Spain: Modeling of Interactive Virtual Laboratories with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
K. Nyström, P. Aronsson, P. Fritzson, Linköping University, Sweden: Parallelization
in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
S.E. Pohl, J. Ungethüm, DLR Stuttgart, Germany: A Simulation Management Enviroment for Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A. Siemers, I. Nakhimovski, D. Fritzson, Linköping University, Sweden: Meta-modelling
of Mechanical Systems with Transmission Line Joints in Modelica . . . . . . . . . . . .

Session 3a
Automotive Simulation I

131
141
149
155
159
169
173
177

183

J. Eborn, H. Tummescheit, K. Prölß, Modelon AB, Sweden; TUHH, Germany: AirConditioning - a Modelica Library for Dynamic Simulation of AC Systems . . . . . . . 185
D. Limperich, M. Braun, G. Schmitz, K. Prölß, DaimlerChrysler AG; TUHH, Germany: System Simulation of Automotive Refrigeration Cycles . . . . . . . . . . . . . . 193
M. Hommel, Volkswagen AG, Germany: First Results in Cluster Simulation of Alternative
Automotive Drive Trains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201

Session 3b
Thermodynamic Systems II

211

C. Kral, A. Haumer, M. Plainer, Arsenal Research, Vienna, Austria: Simulation of
a thermal model of a surface cooled squirrel cage induction machine by means of the
SimpleFlow-library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
S. Micheletti, S. Perotto, F. Schiavo, Politecnico di Milano, Italy: Modelling Heat
Exchangers by the Finite Element Method with Grid Adaption in Modelica . . . . . .
W. Steinmann, DLR Stuttgart, Germany: Calculation of Thermophysical Properties in
the Modelica Library TechThermo . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
M. Tiller, Ford Motor Company, USA: Development of a Simplified Transmission Hydraulics Library based on Modelica.Fluid . . . . . . . . . . . . . . . . . . . . . . . . .

Session 3c
Methods II

213
219
229
237

245

B. Johansson, P. Krus, Linköping University, Sweden: Probabilistic Analysis and Design
Optimization of Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M.
Otter, Dynasim AB, Sweden; DLR, Oberpfaffenhofen, Germany: Optimization for
Design and Parameter Estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals, DLR Oberpfaffenhofen, Germany: Nonlinear Inverse Models for Control . . . . . . . . . . . . . . . . . . . . . . . . 267
The Modelica Association

4

Modelica 2005, March 7-8, 2005

P. Bunus, Linköping University, Sweden: An Empirical Study on Debugging EquationBased Simulation Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281

Volume 2
Session 4a
Automotive Simulation II

299

L. Morawietz, S. Risse, H. Zellbeck, H. Reuss, T. Christ, TU Dresden, University of
Stuttgart, BMW Group, Germany: Modeling an automotive power train and electrical
power supply for HiL applications using Modelica . . . . . . . . . . . . . . . . . . . . . 301
E. Surewaard, M. Thele, Ford Forschungszentrum Aachen, RWTH Aachen University,
Germany: Modelica in Automotive Simulations - Powernet Voltage Control during
Engine Idle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
T. Bünte, A. Sahin, N. Bajcinca, DLR Oberpfaffenhofen, University of Siegen, Germany:
Inversion of Vehicle Steering Dynamics with Modelica/Dymola . . . . . . . . . . . . . 319

Session 4b
Thermodynamic Systems III

329

W. Steinmann, J. Buschle, DLR Stuttgart, Germany: Analysis of thermal storage systems
using Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
S. Wischhusen, G. Schmitz, TUHH, Germany: Exergy-analysis of a direct-evaporating
cooling plant with heat reclaim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
T. Ziehn, G. Reichl, E. Arnold, TU Ilmenau; Fraunhofer Institute Ilmenau, Germany:
Application of the Modelica library WasteWater for optimisation purposes . . . . . . . 351

Session 4c
Tools I

357
G. Ferretti, M. Gritti, G. Magnani, G. Rizzi, P. Rocco, Politecnico di Milano, Italy:
Real-Time Simulation of Modelica Models under Linux / RTAI . . . . . . . . . . . . . 359
M. Najafi, S. Furic, R. Nikoukhah, Imagine; INRIA-Rocquencourt, France: SCICOS: a
general purpose modeling and simulation environment . . . . . . . . . . . . . . . . . . 367
R. Dorling, Advanced Dynamic Systems, Peterborough, U.K.: Model Validation and the
Modelica Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375

Session 5a
Engines

383

J. Batteh, M. Tiller, A. Goodman, Ford Motor Company, USA: Monte Carlo Simulations for Evaluating Engine NVH Robustness . . . . . . . . . . . . . . . . . . . . . . . 385
S.E. Pohl, M. Gräf, DLR Stuttgart, Germany: Dynamic Simulation of a Free-Piston Linear
Alternator in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393

Session 5b
Thermodynamic Systems IV

401
T. Hirsch, W. Steinmann, M. Eck, DLR Stuttgart, Germany: Simulation of transient
two-phase flow in parabolic trough collectors using Modelica . . . . . . . . . . . . . . . 403
L.J. Yebra, M. Berenguel, S. Dormido, M. Romero, CIEMAT-PSA; Universidad de
Almeria; UNED, Spain: Modelling and Simulation of Central Receiver Solar Thermal
Power Plants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413

The Modelica Association

5

Modelica 2005, March 7-8, 2005

A. Cammi, F. Casella, M. Ricotti, F. Schiavo, Politecnico di Milano, Italy: ObjectOriented Modeling, Simulation and Control of the IRIS Nuclear Power Plant with
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423

Session 5c
Tools II

433
A. Pop, P. Fritzson, Linköping University, Sweden: A Portable Debugger for Algorithmic
Modelica Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
O. Johansson, A. Pop, P. Fritzson, Linköping University, Sweden: ModelicaDB - A Tool
for Searching, Analysing, Crossreferencing and Checking of Modelica Libraries . . . . 445

Session 6a
Automotive Simulation III

455
C. Schweiger, M. Dempsey, M. Otter, DLR Oberpfaffenhofen, Germany; Claytex Services Ltd, UK: The PowerTrain Library: New Concepts and New Fields of Application 457
P. Bengtsson, H. Jansson, N. Pettersson, T. Sandberg, Scania CV AB, Sweden:
Development of a Modelica Heavy Vehicle Modeling Library . . . . . . . . . . . . . . . 467
M. Tiller, Ford Motor Company, USA:: Evaluation of Motor and Battery Requirements
for Hybrid-Electric Powertrains during Cranking . . . . . . . . . . . . . . . . . . . . . 477

Session 6b
Thermodynamic Systems V

485

W. Casas, K. Prölß, G. Schmitz, TUHH, Germany: Modeling of Desiccant Assisted Air
Conditioning Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
B. Oehler, Airbus Deutschland GmbH, Germany: Modeling and Simulation of Global Thermal and Fluid Effects in an Aircraft Fuselage . . . . . . . . . . . . . . . . . . . . . . . 497

Session 6c
Modelica Language

507
J. Mauss, DaimlerChrysler AG, Berlin, Germany: Modelica Instance Creation . . . . . . . 509
P. Fritzson, A. Pop, P. Aronsson, Linköping University, Sweden: Towards Comprehensive Meta-Modeling and Meta-Programming Capabilities in Modelica . . . . . . . . . . 519
C. Nytsch-Geusen et. al., Fraunhofer Institutes, Germany: MOSILAB: Development of
a Modelica based generic simulation tool supporting model structural dynamics . . . . 527

Session 7a
Electrical Systems

537

C. Clauß, U. Donath, A. Schneider, E. Weber, Fraunhofer Institute for Integrated
Circuits, University of Applied Sciences Mittweida, Germany: Standard Package Modelica.Electrical. Digital . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
C. Kral, A. Haumer, Arsenal Research, Austria: Modelica libraries for dc machines, three
phase and polyphase machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
Th. Bödrich, Th. Roschke, Dresden University of Technology; Saia-Burgess Dresden
GmbH, Germany: A Magnetic Library for Modelica . . . . . . . . . . . . . . . . . . . 559

The Modelica Association

6

Modelica 2005, March 7-8, 2005

Session 7b
Real-Time and Reactive Systems

567
M. Otter, K.-E. Årzén, I. Dressler, DLR Oberpfaffenhofen, Germany; Lund Institute
of Technology, Sweden: StateGraph-A Modelica Library for Hierarchical State Machines 569
J. Bäckman, M. Edvall, Metso Paper AB, Sweden: Using Modelica and Control Systems
for Real-time Simulations in the Pulp & Paper industry . . . . . . . . . . . . . . . . . 579

Session 7c
Modelica Interfaces

585
J. Köhler, A. Banerjee, ZF Friedrichshafen AG, Germany: Usage of Modelica for transmission simulation in ZF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
M. Tiller, Ford Motor Company, USA: Implementation of a Generic Data Retrieval API
for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
H. Olsson, Dynasim AB, Sweden: External Interface to Modelica in Dymola . . . . . . . . 603

The Modelica Association

7

Modelica 2005, March 7-8, 2005

The Modelica Association

8

Modelica 2005, March 7-8, 2005

Index of Authors
Elmqvist, Hilding . . . . . . . . . . . . . . . . . 45, 105, 255
Erler, Elisabeth . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
Ernst, Thilo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527

Årzén, Karl-Erik . . . . . . . . . . . . . . . . . . . . . . . . . . 569
Aiordachioaie, Dorel . . . . . . . . . . . . . . . . . . . . . . 131
Arnold, Eckhard . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Aronsson, Peter . . . . . . . . . . . . . . . . . 123, 169, 519

Ferretti, Gianni . . . . . . . . . . . . . . . . . . . . . . . 25, 359
Fritzson, Dag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Fritzson, Peter 85, 113, 123, 169, 435, 445, 519
Furic, S. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367

Bäckman, Johan . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Bödrich, Thomas. . . . . . . . . . . . . . . . . . . . . . . . . .559
Bünte, Tilman . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Bachmann, Bernhard . . . . . . . . . . . . . . . . . . . . . 113
Bajcina, Naim . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Bals, Johann . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
Banerjee, Alexander. . . . . . . . . . . . . . . . . . . . . . .587
Batteh, John J. . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
Bengtsson, Per . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Berenguel, M. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
Berg, Karin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Brück, Dag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
Braun, Marco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Bunus, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
Buschle, Jochen . . . . . . . . . . . . . . . . . . . . . . . . . . . 331

González, Leandro . . . . . . . . . . . . . . . . . . . . . . . . . 75
Goodman, Adam. . . . . . . . . . . . . . . . . . . . . . . . . .385
Gräf, Markus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Gritti, Marco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Guinea, Domingo . . . . . . . . . . . . . . . . . . . . . . . . . . 75
Harman, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
Haumer, Anton . . . . . . . . . . . . . . . . . . . . . . 213, 549
Hirsch, Tobias . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
Holm, Andreas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Hommel, Mathias . . . . . . . . . . . . . . . . . . . . . . . . . 201
Jansson, Henrik . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Johansson, Björn. . . . . . . . . . . . . . . . . . . . . . . . . .247
Johansson, Olof . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
Joos, Dieter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255

Cammi, Antonio . . . . . . . . . . . . . . . . . . . . . . . . . . 423
Casas, Wilson . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
Casella, Francesco . . . . . . . . . . . . . . . . . . . . . 97, 423
Ceanga, Emil . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Cellier, François E. . . . . . . . . . . . . . . . . . . . . . . . . . 57
Christ, Thomas . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Clauß, Christoph . . . . . . . . . . . . . . . . . . . . . 141, 539

Köhler, Jochen . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
Kossenko, Ivan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Kral, Christian . . . . . . . . . . . . . . . . . . . . . . . 213, 549
Krus, Petter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
Kurze, Matthias . . . . . . . . . . . . . . . . . . . . . . . . . . 267

Dı́az López, José . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
Dempsey, Mike . . . . . . . . . . . . . . . . . . . . . . . . . . . .457
Doll, Ulrich . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Donath, Ulrich . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Dorling, Richard . . . . . . . . . . . . . . . . . . . . . . . . . . 375
Dormido, Sebastian . . . . . . . . . . . . . . . 75, 159, 413
Dressler, Isolde. . . . . . . . . . . . . . . . . . . . . . . . . . . .569

Larsdotter Nilsson, Emma . . . . . . . . . . . . . . . . . . 85
Leopold, Jürgen . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Limperich, Dirk . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Looye, Gertjan . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
Lovera, Marco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Magnani, Gianantonio . . . . . . . . . . . . . . . . . . . . 359
Martin, Carla . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Mattes, Alexander . . . . . . . . . . . . . . . . . . . . . . . . 527

Eborn, Jonas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .185
Eck, Markus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
Edvall, Mattias . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
The Modelica Association

9

Modelica 2005, March 7-8, 2005

Mattsson, Sven Erik . . . . . . . . . . . . . . . . . . . . . . 255
Mauss, Jakob . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
Micheletti, Stefano . . . . . . . . . . . . . . . . . . . . . . . . 219
Morawietz, Lutz . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Munteanu, Mihai . . . . . . . . . . . . . . . . . . . . . . . . . 131

Surewaard, Erik. . . . . . . . . . . . . . . . . . . . . . . . . . .309
Thümmel, Michael . . . . . . . . . . . . . . . . . . . . . . . . 267
Thele, Marc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
Tiller, Michael M. . . . . . . . . . . 237, 385, 477, 593
Tummescheit, Hubertus . . . . . . . . . . . . . . 105, 185

Najafi, Masoud . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
Nakhimovski, Iakov . . . . . . . . . . . . . . . . . . . . . . . 177
Nebot, Àngela . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
Nikoukhah, R. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
Nordwig, André . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Nouidui, Thierry . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Nyström, Kaj . . . . . . . . . . . . . . . . . . . . . . . . 149, 169
Nytsch-Geusen, Christoph. . . . . . . . . . . . . . . . .527

Ungethüm, Jörg . . . . . . . . . . . . . . . . . . . . . . . 67, 173
Urquı́a, Alfonso . . . . . . . . . . . . . . . . . . . . . . . 75, 159
Vetter, Matthias . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Viganò, Luca. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25
Weber, Enrico . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Wiesmann, Hansjürg . . . . . . . . . . . . . . . . . . . . . . 113
Wischhusen, Stefan . . . . . . . . . . . . . . . . . . . . . . . 339
Wittwer, Christof . . . . . . . . . . . . . . . . . . . . . . . . . 527

Oehler, Bettina . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
Olsson, Hans . . . . . . . . . . . . . . . . . . . . 105, 255, 603
Otter, Martin . . . . . . . . . . . 45, 255, 267, 457, 569

Yebra, Luis Jose . . . . . . . . . . . . . . . . . . . . . . . . . . 413

Perotto, Simona. . . . . . . . . . . . . . . . . . . . . . . . . . .219
Pettersson, Niklas . . . . . . . . . . . . . . . . . . . . . . . . . 467
Plainer, Markus . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
Pohl, Sven-Erik . . . . . . . . . . . . . . . . . . . . . . 173, 393
Pop, Adrian . . . . . . . . . . . . . . . . . . . . . 435, 445, 519
Prölß, Katrin . . . . . . . . . . . . . . . . . . . . 185, 193, 487
Pulecchi, Tiziano . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

Zellbeck, Hans . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Ziehn, Tilo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351

Reichl, Gerald . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Reuss, Hans-Christian. . . . . . . . . . . . . . . . . . . . .301
Ricotti, Marco E. . . . . . . . . . . . . . . . . . . . . . . . . . 423
Risse, Silvio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Rizzi, Gianpaolo . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Rocco, Paolo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Romero, M. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
Roschke, Thomas . . . . . . . . . . . . . . . . . . . . . . . . . 559
Rubio, Miguel A. . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
Sahin, Akin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Saldamli, Levon . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Sandberg, Tony . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Schiavo, Francesco . . . . . . . . . . . . . . . . 25, 219, 423
Schmidt, Gerhard . . . . . . . . . . . . . . . . . . . . . . . . . 527
Schmitz, Gerhard. . . . . . . . . . . . . . . .193, 339, 487
Schneider, André . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Schneider, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Schwarz, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Schweiger, Christian. . . . . . . . . . . . . . . . . .255, 457
Siemers, Alexander. . . . . . . . . . . . . . . . . . . . . . . .177
Steinmann, Wolf-Dieter. . . . . . . . . .229, 331, 403
The Modelica Association

10

Modelica 2005, March 7-8, 2005

Session 1a
Mechanical Systems

The Modelica Association

11

Modelica 2005, March 7-8, 2005

The Modelica Association

12

Modelica 2005, March 7-8, 2005

Implementation of Unilateral Multibody Dynamics on Modelica

Implementation of Unilateral Multibody Dynamics on Modelica
Ivan I. Kossenko
Moscow State University of Service, Department of Engineering Mechanics
Glavnaya str., 99, Cherkizovo-1, Moscow reg., 141221, Russia

Abstract
The problems of computer modeling and simulation
of dynamics for multibody systems consisting of rigid
bodies with unilateral constraints (MBSUC) are considered in the scope of the obstacles to overcome ones
related to the variation of structure for equations of
motion. The approach to modeling the MBSUC dynamics based on Modelica language is described.
The approach allowing to avoid the growth of the
model structural complexity is described. This approach actively uses the algorithmic features of Modelica and its Dymola compiler. On this way the large
number of objects corresponding to different closed
systems of DAEs (states of hybrid automata) is replaced by only one object. For this object constraint
components vary their states dynamically during the
simulation process.
Another problem of the similar level of complexity relates to the accuracy of simulation is solved here with
the set of special regularization procedures. These
procedures concern particularly transitions of the unilateral constraint: from disconnected state to contact,
from rolling to slipping.
Other methods to improve the quality of the MBSUC
dynamics simulation are also under consideration.
Keywords: unilateral dynamics; multibody systems;
simulation; dry friction; impacts; regularization;
acausal modeling

set of the new generation models allowing description
of unilateral constraints.
Let us suppose that some of constraints are unilateral.
For definiteness and simplicity we state the following
assumptions: (a) unilateral constraint is implemented
as a contact of outer surfaces bounding two rigid bodies; (b) surfaces supposed being regular i. e. the normal vector is always properly defined; (c) the contacting surfaces interact within the model of Coulomb friction for continuous motions as well as for impacts.
For simplicity we investigate the MBSUC comprising
only two bodies, A, and B. Moreover, we suppose
that the body A is a fixed horizontal surface, and the
heavy convex body B is bounded by ellipsoidal surface. These assumptions are not obstacles for generality of the developed MBSUC models.

2 Basic Ideas
According to the approach applied in [1] let us represent the constraint as an object providing information
communications between the objects of bodies A and
B. Such communications are implemented indirectly
using the kinematic and wrench connectors. Information communications are “filtrated” through the mechanism of constraint equations encapsulated in the object C, see Figure 2.1.

1 Introduction
Mechanical system subjected to unilateral constraints
exhibits behavior considerably more complicated than
the system subjected to the bilateral ones. One can
find in such a case new dynamical properties connected with irregular character of appropriate systems
Figure 2.1: Architecture of Unilateral Constraint
of DAEs. Let us develop the approach proposed in [1].
There the Modelica library of classes oriented to sim- Besides the bidirected connections applied in [1] let
ulation the sparse dynamics of multibody systems has us add to the model the set of directed connections.
been developed. We can consider now this library as a Assume that these connections are able to transmit
The Modelica Association

13

Modelica 2005, March 7-8, 2005

I. Kossenko

the impact signals arising in objects of unilateral constraints all over the MBSUC, namely throughout its
connected components. These signals play role of
strobing ones for recalculation of velocities in the
MBSUC.
The nature of unilateral constraint allows us to describe it with the fundamental state variable. This
variable takes one of three values: “Flight”, “Sliding”, “Rolling” at any time instant. The sense of the
enumerated values is transparent. The state “Flight”
means that the constraint is not stretched at the considered instant, i. e. the bodies aren’t in touch and freely
fly one relative to another. As state variable has one of
values “Sliding” or “Rolling” then bodies supposed to
be in a contact. The difference is that the first state permits the relative slipping of the bodies but the second
one doesn’t.
Example 2.1 Consider the set of n balls in a billiard
pool. The system comprises n + 1 rigid bodies: n balls
and the surface of the pool table. Vertical surfaces
around the table are neglected for simplicity. All bodies enumerated can encounter mutually, slip, and roll.
The correct description of this MBSUC involves the
specification of m = n(n + 1)/2 unilateral constraints.
Since each constraint can be in one of three states,
n(n+1)
then the whole MBSUC comprises 3m = 3 2 states.
For the pool with three balls we obtain the total value
of 36 = 729 states.

2.1 Constraint Geometry

Figure 2.2: Area of Constraint
these the equations read
gα (r0 ) = fα [Tα∗ (r0 − rOα )] = 0 (α = A, B).
Here rOA = O0 OA , rOB = O0 OB , TA , TB are the orthogonal matrices determining orientation of the BFA and
BFB with respect to the AF. An asterisk denotes the
matrix transposition. The functions gA (r0 ), gB (r0 ) depend upon the time indirectly through the variables rA ,
rB , TA , TB .
The constraint object of our model has to compute at
each current instant the points PA ∈ A and PB ∈ B realizing the minimal distance between the bodies. These
points depend on relative orientation of the bodies. By
virtue of above assumptions such points are to be evaluated in a unique way. Denote by rPA , rPB the radii
vectors of these points with respect to AF. The simple geometric reasons imply the following system of
algebraic equations

Let us use here the same as in [1] the dynamics of a
rigid body translational–rotational motion. However
the representation of mechanical constraint model undergoes here essential changes. We use the so called
complementarity rules [2] as a base for the unified degrad gA (rPA ) = λ · grad gB (rPB ) ,
scription of the unilateral constraint. By virtue of comrPA − rPB = µ · grad gB (rPB ) ,
plementarity rules any constraint is always defined by
(2.1)
gA (rPA ) = 0,
the three scalar equations. In order to derive these
gB (rPB ) = 0.
equations let us consider the local geometry of the
problem, see Figure 2.2.
The gradients of the functions gA and gB read
The base body of MBSUC supposed to be connected
grad gα (rPα ) = Tα grad fα [Tα∗ (rPα − rOα )] , (2.2)
with the absolute frame O0 x0 y0 z0 (AF) fixed in the inertial space, Oα xα yα zα is the frame BFα fixed in the
body α ∈ {A, B}. The outer surfaces Σα are defined by where α = A, B. The system (2.1) consists of eight
scalar equations with respect to eight scalar variables:
the equations
xPA , yPA , zPA , xPB , yPB , zPB , λ, µ, where λ, µ are auxiliary
variables.
The equations (2.1) are in use either without
fα (rα ) = 0 (α = A, B).
or with a presence of the contact of bodies A, B. In the
with respect to appropriate BFα whose axes are coin- latter case the equation µ = 0 is in use instead of one
cident to the principal central axes of inertia. In AF of the surfaces equations.
The Modelica Association

14

Modelica 2005, March 7-8, 2005

Implementation of Unilateral Multibody Dynamics on Modelica

According to computational experience it is more reliable and convenient to use the equations of constraints (2.1) in a differential form. Such an approach
is used frequently also for analyzing of properties of
mechanical systems.
Normal vector

2.3 Regularization of the Coulomb Friction

In the case of sliding the model equation (2.5) “works”
properly if the relative velocity isn’t very small. However the problem of regularization for the equation of
constraint (2.5) arises at the instance of transition from
“Rolling” to “Sliding”. It turns out that one can apply
±
here the known approximation for Coulomb’s friction
nA = grad gA |grad gA |
(2.3)
using regularized expression for the tangent force
±
½
will play an important role in the further course. NorFAn vrτ |vrτ | as |vrτ | > δ,
FAτ − κnA = d
mal for an outer surface of the body A is chosen here
FAn vrτ /δ
as |vrτ | ≤ δ,
for definiteness. One can use the vector nB as well.
where one supposes that δ ¿ 1.
It is known [3] that in this case the solution of the
2.2 Complementarity Rules
regularized problem remains close to the solution of
Let us perform a unified description of the unilateral the original one at the asymptotically large time inconstraint using kinematic and/or force equations. De- tervals. Implementation and further simulation show
note by FA the force acting on the body A from the that this closeness holds with the very high degree of
body B. And by FB denote the force acting on the accuracy. Such an approach resolves completely the
body B from one of A vice versa. Each force cited acts problem of modeling for accurate transitions between
at the point Pα , α = A, B. In addition, let us introduce states of “Sliding” and “Rolling”.
auxiliary notations

2.4 Simulation of Impacts
FAn = (FA , nA ) , FAτ = FA − FAn nA ,
vr = vPA − vPB , vrn = (vr , nA ) , vrτ = vr − vrn nA .
(2.4)
If the bodies are not in touch and the constraint is in
the state “Flight” then the force of reaction is equal to
zero. Thus we have three scalar equations. To unify
the system of constraint equations and to take into account arbitrary directions of the normal nA let us introduce auxiliary scalar variable κ such that
FAn = 0, FAτ − κnA = 0.
Then the system of four equation with four unknown
variables FAx , FAy , FAz , κ is obtained.
If the bodies are in touch then the condition FAn = 0
is substituted by the kinematic one vAn = 0. States
“Sliding” and “Rolling” differ from each other by conditions in a tangent plane. Implementation of the
Coulomb friction model is supposed for the simplicity.
Then the equation of the force balance in the tangent
space reads
±
FAτ − d · FAn vrτ |vrτ | − κnA = 0,

(2.5)

Let us suppose that the unilateral constraint is allowed
to undergo an impact in any possible states. In state
“Flight” the impact arises at the instant of bodies contact if normal component of the relative velocity vrn
for encountering points is not very close to zero. It
is the case of the so called direct impact. However
in MBSUC consisting of several bodies impact pulses
can propagate through the connected components of
the system and force it to disconnect of any constraints. This leads to the switch of the whole MBSUC
to an another state. Such a case we can consider as an
indirect impact.
The constraint model proposed allows the possibility
both direct and indirect impacts. Let us consider the
equations of the impact theory encapsulated in the objects of the constraint structure, see Figure 2.1. All
these algebraic equations are carried out for all the
time of simulation. From time to time impact events
arising inside the differential part of the whole model
strobe “reading” of impact increments for the velocities from the impact algebraic subsystem and instanteneous change of velocities inside the dynamical subsystem.
Thus the equations

where d is the coeffitient of friction.
For rolling the tangent velocity is:
vAτ − κnA = 0.
The Modelica Association

ω = T,
m∆v = S, I∆ω

(2.6)

are encapsulated in objects A and B of the “Rigid
ω are the increments of the
Body” class. Here ∆v, ∆ω
15

Modelica 2005, March 7-8, 2005

I. Kossenko

center of mass velocity and angular velocity of the
body, S, T are correspondingly the total impulse and
angular impulse acting on the rigid body belonging
to MBSUC. Note that the first equation of the system (2.6) is written in AF. The second one is written,
as usually, in appropriate BFα .
Constraint object, C in Figure 2.1, encapsulates the
simplest impact model with dry friction and the Newtonian model for the normal impact
∆vPα
∆vPα n
∆vrn
∆vPB n
∆vPα τ
SAn
SAτ

=
=
=
=
=
=
=

ωα , rPα − rOα ] ,
∆vOα + [∆ω
(∆vPα , nA ) ,
−(1 + k)vrn ,
∆vPA n − ∆vrn ,
∆vPα − ∆vPα n nA ,
(SA , nA ) ,
SA − SAn nA ,

(2.7)

where the restitution coefficient is equal to k.
To make the model of impact with friction more realistic we apply the simplified formula for the impact
impulse. It is similar to the regularized formular for
the tangent force in the case of slipping with dry friction. Let us note that there exist more realistic models
of impact with the Coulomb friction [4] (see [5] for
comprehensive survey). However they are much more
complicated. These models are suited for the single
impact of two bodies only. But we are interested in a
general case of MBSUC consisting of several bodies
not only of two ones.

2.5 Regularization of Transition between the
States of Flight and of the Contact

that the normal relative acceleration arn = dvrn /dt approximately is a constant. Then the relative normal
motion of the points A and B is similar to the bouncing
ball in field of constant acceleration arn in the vicinity
of the landing instant.
Thus the height
of jumps obeys the known formula
±
h = 0.5v2rn arn . Hence the instant of transition to contact is defined by the condition when h becomes less
then the given value of the tolerance for the constraint
feasibility.
The time between two impacts can be also approximately
¯ ± ¯ computed with the known formula T =
2 ¯vrn arn ¯. This value tends to zero with each new
impact leading to the loss of an accuracy of simulation.
Way out of a situation is the transfer to new independent variable τ such that the duration between successive impacts would stay of order one. The simplest
solution of this problem is the map t 7→ τ according
to the scalar differential equation dt/dτ = T . Such an
approach is found to be sufficiently reliable. Moreover
it is easy to control the accuracy of the model.

3 Implementation
When constructing the model of MBSUC the main
task is to develop the Modelica code allowing to
switch different constraint states inside the same object, see Figure 2.1. It was found the problem can be
resolved using so called acausal [6] approach to build
the system of DAEs for the resulting model. Alternatively if one uses the causal appoach then the structural
complexity of a model code can increase avalanchely.
To make sure of this it is sufficient to remind our example about three balls in a billiard pool. If each state
of the mechanical system corresponding to the closed
system of DAEs is instantiated as an object inside the
container of the hybrid automata model then very soon
developer will encounter with the problem of large
complexity even for a number of balls small enough.
Conversely within the acausal approach there exists a
possibility to construct the model of MBSUC at the
same complexity level as for mechanical system subjected to bilateral constraints only. In this case all variety of MBSUC states is provided by internal capabilities of the constraint objects and, as usually it is
implemented with help of an analytical precompiler.

The most important property of the model developed
consists of the possibility of exact calculation of impact instants and the instants of the change of state.
This property plays a crucial role for the quality of the
model. The landing on the constraint is possible in
particular if restitution coefficient satisfies the condition k < 1. In this case time intervals between impacts
tend to zero as well as the amplitudes of jumps after
successive impacts. Thus for exact determination of
the landing instant there exists a technological restriction: limit of smallness for the value of the integrator
time step.
The change of independent variable, which regularizes
the time, gives the resolution of the problem. Indeed,
let us consider approximate model of dynamics in a
vicinity of the landing instant. In this case we can re- 3.1 Connectors
strict ourselves to analysis of the relative motion for To connect objects we use the classes of kinematic and
points PA and PB in normal direction. Let us assume wrench ports as before [1]. In addition, new connecThe Modelica Association

16

Modelica 2005, March 7-8, 2005

Implementation of Unilateral Multibody Dynamics on Modelica

tors are able to transport data of the velocities incre- partial model RigidBodyImpacts
ments and the impact impulses. Codes of the correextends RigidBody(redeclare
sponding derived classes read
KinematicPortImpacts OutPort);
connector KinematicPortImpacts
extends KinematicPort;
SI.Velocity Deltav[3];
SI.AngularVelocity Deltaomega[3];
end KinematicPortImpacts;
connector WrenchPortImpacts
extends WrenchPort;
SI.Impulse ImpactForce[3];
SI.AngularImpulse ImpactTorque[3];
end WrenchPortImpacts;

To transmit impact signals throughout the MBSUC
one uses standard signal input and output ports:
Interfaces.BooleanInPort,
Interfaces.BooleanOutPort.

from the library Modelica.Blocks.

3.2 Bodies
This category classes were modified to take into account the possibility of impacts in MBSUC. The base
class RigidBody considered in [1] has been slightly
rearranged and now reads as
partial model RigidBody
replaceable KinematicPort OutPort;
···
Real Active(start=1);
equation
der(Active) = 0;
der(r) = Active*v;
der(v) = Active*a;
der(q) = Active*0.5*QMult(q,
{0,omega[1],omega[2],omega[3]});
der(omega) = Active*epsilon;
···
end RigidBody;

SI.Velocity Deltav[3];
SI.AngularVelocity Deltaomega[3];
SI.Impulse ImpactForce[3];
SI.AngularImpulse ImpactTorque[3];
Boolean Impact;
SI.Force F1[3];
SI.Torque M1[3];
WrenchPortImpacts InPort1;
BooleanInPort InImpactSignal1;
BooleanOutPort OutImpactSignal1;
equation
F = InPort1.F + F1;
M = InPort1.M + cross(InPort1.P - r,
InPort1.F) + M1;
OutImpactSignal1.signal[1] = false;
Impact = false or
InImpactSignal1.signal[1];
OutPort.Deltav = Deltav;
OutPort.Deltaomega = T*Deltaomega;
OutPort.Deltav = Deltav;
OutPort.Deltaomega = T*Deltaomega;
m*Deltav = InPort1.ImpactForce +
ImpactForce1;
I*Deltaomega = transpose(T)*
(InPort1.ImpactTorque + cross(
InPort1.P - r,InPort1.ImpactForce)
+ ImpactTorque1);
end RigidBodyImpacts;

Since this class is introduced to process impacts then it
possesses at least one wrench port supposed for at least
one unilateral constraint, which is a potential source
of impacts. The class, cited rather its object can be
instantiated in the models being developed according
to any causality principle. In case of the acausal approach such class is to be completed by the following
model

model RigidBodyImpactsAcausal
extends RigidBodyImpacts;
equation
when Impact then
Dots here mean those parts of the RigidBody class
reinit(v, v + Deltav);
from the previous version which haven’t been reconreinit(omega, omega + Deltaomega);
structed. In addition, one can see easily that the time
end when;
of dynamics can be “stopped” here at all. This can be end RigidBodyImpactsAcausal;
done with auxiliary variable Active putting its value

equal to zero. In this case the model will be transformed from dynamical to the static one, which is defined by algebraic equations only.
Declaration replaceable is aimed to provide the
possibility of choice between modes of simulation
with or without impacts.
To implement impact calculations one uses the following class
The Modelica Association

providing a self-governing possibility of the object to
recalculate velocities at impact. In case of the causal
approach such the calculation should be instantiated
outside the object of the MBSUC state. Note that
in implementations in derived classes for the bodies
of MBSUC we can instantiate any number of wrench
port objects necessary for constraints of the MBSUC
model.

17

Modelica 2005, March 7-8, 2005

I. Kossenko

3.3 Constraints
On the same way as for RigidBody class the base
model Constraint has been slightly rearranged and
now has the following modified form
partial model Constraint
parameter Integer ConstraintNo = 1;
replaceable KinematicPort InPortA;
replaceable WrenchPort OutPortA;
replaceable KinematicPort InPortB;
replaceable WrenchPort OutPortB;
equation
···
end Constraint;

Then one can construct easily the constraint base
model taking into account impacts of bodies in the
form
partial model ConstraintImpacts
extends Constraint(
redeclare KinematicPortImpacts
InPortA,
redeclare WrenchPortImpacts
OutPortA,
redeclare KinematicPortImpacts
InPortB,
redeclare WrenchPortImpacts
OutPortB);
equation
OutPortA.ImpactForce +
OutPortB.ImpactForce = zeros(3);
OutPortA.ImpactTorque +
OutPortB.ImpactTorque = zeros(3);
end ConstraintImpacts;

Now it is time to construct a base model for the unilateral constraint satisfying our assumptions stated earlier and processing impact events correctly
model UnilateralConstraintAcausal
extends ConstraintImpacts;
parameter Real k;
parameter Real f;
parameter SI.Velocity delta;
UnilateralConstraintState State;
Boolean Impact;
Boolean NormalImpact;
Boolean NormalImpactIndicator;
Boolean ImpactMask;
Real[3] normA;
SI.Impulse ImpactForcen;
SI.Impulse[3] ImpactForcet;
SI.Impulse kappa;
SI.Acceleration[3] arA;
SI.Acceleration[3] arB;
SI.Acceleration[3] rela;

The Modelica Association

SI.Acceleration relan;
Real Active(start=1);
···
algorithm
when relan > 0 and not ImpactMask
then
ImpactMask := true;
end when;
when State == 0 and pre(State) <> 0
then
ImpactMask := false;
end when;
equation
···
NormalImpactIndicator = if mu < 0
and State == 0 and ImpactMask
then true else false;
NormalImpact = edge(
NormalImpactIndicator);
Impact = if noEvent(NormalImpact)
then true else false;
Active*arA = der(vrA);
Active*arB = der(vrB);
rela = arA - arB;
relan = rela*normA;
ImpactForcen = OutPortA.ImpactForce*
normA;
ImpactForcet = OutPortA.ImpactForce ImpactForcen*normA;
if noEvent(Impact) then
if relvtsqrt <= delta then
zeros(3) = ImpactForcet +
f*abs(ImpactForcen)*
relvt/delta - kappa*normA;
else
zeros(3) = ImpactForcet +
f*abs(ImpactForcen)*
relvt/relvtsqrt - kappa*normA;
end if;
else
zeros(3) = DeltavrAt + vrAt vrBt - DeltavrBt - kappa*normA;
end if;
der(Active) = 0;
end UnilateralConstraintAcausal;

State of the constraint is tracked here by the variable
State. If State = 0 then the constraint is disconnected. For State = 1 the constraint is in the state
“Sliding”. And for State = 2 corresponding state is
“Rolling”. In a current version of the MBSUC model
we suppose that at each instant of time it is possible to
occur not more than one impact.
Modelica code presented above has the following features:
1. Impact signal is generated if and only if: the con18

Modelica 2005, March 7-8, 2005

Implementation of Unilateral Multibody Dynamics on Modelica

straint be in the state “Flight”, State = 0; outer
surfaces of the bodies arrive to the contact, µ < 0;
and a special impact mask is open. This latter
becomes closed for the only case of the smooth
launching from the constraint. The variable µ is
defined according to the differential version of the
system (2.1) such that for µ > 0 the constraint is
disconnected, and the contact begins as µ = 0.
2. Kinematic formulae and expressions for the impact impulses are implemented.
3. The variable Active is applied here to scale the
independent variable as it has been done for the
RigidBody model.
4. The following parameters of problem are applied:
k is the coefficient of restitution at impact, f is
the friction coefficient, delta is the regularizing
parameter for dry friction.
Dots represent the blocks of an equations implementing the functions: (a) impact signal transmission
through the constraint, now under the further development; (b) computation of an intermediate variables
according to formulae (2.2, 2.3, 2.4, 2.7)
A key role in the whole model plays the following
class
model
UnilateralConstraintAcausalAddOnRegular
extends UnilateralConstraintAcausal;
parameter SI.Length
ClearanceTolerance;
parameter SI.DampingCoefficient
ConstraintAttraction=1;
SI.Force nu;
SI.Force Forcen;
SI.Force[3] Forcet;
SI.Acceleration Drelvn;
Real StateIndicator;
SI.Length Clearance(start=1);
equation
der(relvn) = Active*(Drelvn + (if
StateIndicator > 0.5 then ConstraintAttraction*relvn else
0));
Forcen = OutPortA.F*normA;
Forcet = OutPortA.F - Forcen*normA;
if StateIndicator <= 0.5 then
State = 0;
Forcen = 0;
Forcet - nu*normA = zeros(3);
if mu > 0 and relan < 0 then
StateIndicator = 0;
else
if Clearance < ClearanceTolerance

The Modelica Association

then
if relan < 0 then
// Case of launch
StateIndicator = 0;
else
// Case of landing
if relvtsqrt > delta then
StateIndicator = 1;
else
StateIndicator = 2;
end if;
end if;
else
StateIndicator = 0;
end if;
end if;
else
Drelvn = 0;
if relvtsqrt <= delta then
State = 2;
StateIndicator = if Forcen > 0
then 0 else 2;
Forcet - f*Forcen*relvt/delta nu*normA = zeros(3);
else
State = 1;
StateIndicator = if Forcen > 0
then 0 else 1;
Forcet - f*Forcen*relvt/relvtsqrt
- nu*normA = zeros(3);
end if;
end if;
der(Clearance) = 0;
when Impact then
reinit(Clearance, 0.5*abs(relvn*
relvn/Drelvn));
end when;
when StateIndicator > 0.5 then
reinit(Clearance, 1);
end when;
OutPortA.M = zeros(3);
OutPortA.ImpactTorque = zeros(3);
end
UnilateralConstraintAcausalAddOnRegular;

which implements the real switching of the constraint
states.
The hybrid automata states are controlled by two variables: StateIndicator and State. The first one
is included into the algebraic loops and has the Real
type. Hence in some sense the states themselves correspond to fuzzy values and are identified by the inequalities. It is clear that such a situation is connected with
the compiler restrictions. The variable State doesn’t
belong to the algebraic loops. It has the Integer
type and doesn’t influence on the switching between
19

Modelica 2005, March 7-8, 2005

I. Kossenko

the states.
In frames of the model under consideration in order
to estimate the maximal clearance between the bodies
during the time from one impact to the next one, the
variable Clearance, is introduced to detect the instant of the transition to the state of the bodies contact.
The complementarity rules are also implemented here.
Remark 3.1 We have to perform the regularization of
the independent variable for the case of landing on the
constraint using variables Active of the bodies and
the constraints objects outside these objects but inside the corresponding container of the whole MBSUC
model. In this case we have a possibility for the correct control over the regularization process because
the change of the independent variable should be total throughout the MBSUC.
At last, the models implementing the system of constraint equations complete a chain of inheritance for
the constraint classes. Namely two classes
SurfacesOfConstraintAcausalDifferential,
EllipsoidAndHorizontalPlaneDifferential.

have been constructed. First one doesn’t depend upon
specific type of the outer surfaces. The second model
implements a specific case of the ellipsoidal surface
and the plane as a surfaces of constraint.

4 Examples
Experimental computations and verification of the
models developed were carried out using a well known
example from classical dynamics: motion of heavy
body on/over the horizontal surface. Visual image of
the MBSUC model is presented in Figure 4.1.

of the heavy rigid body is shown on the right hand side
of the Figure 4.1. And the model of total MBSUC for
our example has the following Modelica code
model MBSAcausalDifferential
···
parameter Period TimeScale=1;
Period deltat(start=1);
Time t(start=0);
equation
···
der(deltat) = 0;
der(t) = deltat/TimeScale;
when ConstraintSurfaces.Impact then
reinit(deltat,min(1,2*abs(
ConstraintSurfaces.relvn/
ConstraintSurfaces.relan)));
reinit(FlySlideRollBody.Active,
min(1,2*abs(ConstraintSurfaces.
relvn/ConstraintSurfaces.relan)));
reinit(ConstraintSurfaces.Active,
min(1,2*abs(ConstraintSurfaces.
relvn/ConstraintSurfaces.relan)));
end when;
when ConstraintSurfaces.
StateIndicator > 0.5 then
reinit(deltat, 1);
reinit(FlySlideRollBody.Active, 1);
reinit(ConstraintSurfaces.Active,
1);
end when;
end MBSAcausalDifferential;

To estimate an accuracy of the model developed we
performed a comparison of the results with ones for
the exact model of the hybrid automata built using
causal approach with the three instantiated objects
each corresponding to one state of the mechanical system and having a structural complexity of the whole
MBSUC, see Figure 4.1.
The rigid body already considered in one of the examples of the paper [1] starts its motion from a position
suspended over the surface with the initial data
r(0) = (0, 5, 0)T ,
v(0) = (0.05, 0, 0)T ,
T
q(0) = (1, 0, 0, 0) , ω (0) = (0, −10, 2)T .

(4.8)

Motion is simulated on time segment [t0 ,t1 ] = [0, 150]
and consists of the several stages of flight alternating
by stages of sliding. Note that sliding followed by
rolling as energy decreases. During several decades
of seconds one can observe easily so called stick–slip
phenomena transferring finally to the pure rolling.
Figure 4.1: Visual Model of MBSUC
The results of simulation are presented in the FigThe object HorizontalSurface on the left hand ures 4.2, 4.3, 4.4. The final part of the projection of the
side of the figure represents model of the base body trajectory for the point PB of the ellipsoid corresponddescribing a horizontal plane fixed in AF. The object ing to the stick–slip phase is shown in Figure 4.2.
The Modelica Association

20

Modelica 2005, March 7-8, 2005

Implementation of Unilateral Multibody Dynamics on Modelica

Figure 4.2: Stick–Slip Oscillations, Contact Point Trajectory
An accuracy of the model is of our special interest.
The accuracy of computation for instants of impacts
and of transitions between the MBSUC states is a
causal point for the models of systems with impacts. In
our example the instant of the first transfer to rolling
at the beginning of stick–slip oscillations has a relative error of the order 10−4 . Such an error was accumulated after several thousands of impacts and several transitions between states “Flight” and “Sliding”.
More accurate regularization of the independent variable allows to achieve further reduction of the error. Of
course it needs considerable computational time in addition. For comparison of physical time variables depending on the regularizing time for the models compared see Figure 4.3. As one can see, physical times
almost coincide for the acausal and causal models. In
addition, it would be interesting to observe the initial
interval of the simulation corresponding to the several
stages of a decrementing bouncing of the body, see
Figure 4.4. Here we can see the screenshot of the body
while it perfoms one of jumps. The image of the fisrt
transfer from the flight mode to the mode of sliding is
presented here in details. One can see in this inserted
fragment the regularizing independent “time” counted
The Modelica Association

along x-axis. y-axis represents the variable µ.

Figure 4.3: Physical Times Depending upon Regularizing Time
In the case of motion with a contact the switching between sliding and rolling is observed. For this case
the simulation was performed with the following initial data

21

r(0) = (0, 1, 0)T ,
v(0) = (0.05, 0, 0)T ,
q(0) = (1, 0, 0, 0)T , ω (0) = (0, −2, 2)T .
Modelica 2005, March 7-8, 2005

I. Kossenko

Figure 4.4: Stages of Bouncing
During the time of t1 − t0 = 150 units and after several
hundreds of stick–slip oscillations the relative error accumulated for state switch instants was equal to 10−11 .
Thus the absence of impacts during the simulation improves the quality of the model more than in million
times.
For the sliding/rolling mode the absolute error of determination of the contact point does not exceed 3 ·
10−5 . It was observed that the error grows almost linearly. The error in determination of the position of the
point PB in the mormal direction is equal to 2 · 10−15 ,
while for rolling the error of determination of the tangent component of velocity of this point does not exceed 10−7 .
Let us consider now the motion of the homogeneous
body bounded by an ellipsoidal surface on the horizontal plane [7]. The coefficient of the Coulomb friction
supposed to be equal to d = 0.01. Let us try to repeat
numerically the following experiment described qualitatively by A. P. Markeev. The body touches the horThe Modelica Association

izontal surface by its shortest semi–axis at the initial
instant. Let us put it in rapid rotation. Then the body
tends to the position in which it touches the plane by
its longest semi–axis.
In our example the semiaxes of the body are close one
to another: a1 = 1.2, b1 = 1, c1 = 1.3. Axes of outer
surface ellipsoid coincide with ones of central principal ellipsoid. Choosing the initial data as in (4.8) with
one exception: r(0) = (0, 1, 0)T one obtains the result
cited above: the ellipsoid masscenter “rises” progressively from the height of minimal semi–diameter to
one of maximal semi–diameter, see Figure 4.5. The
angular velocity almost holds its direction with respect
to the AF, see Figure 4.6, blue (lower) curve. At the
initial instant this vector is directed along the minimal semi–axis, red (middle) curve is its projection on
the corresponding axis of the body; while on the final
stage the angular velocity is directed along the maximal ellipsoid semi–axis, green (upper) curve.

22

Modelica 2005, March 7-8, 2005

Implementation of Unilateral Multibody Dynamics on Modelica

Problem 5: How one can implement the dichotomy
slipping/rolling? Solution: Use the regularized tangent force for the Coulomb friction.
Problem 6: How one can implement the exact “landing” on the constraint? Solution: Use the regularizing
independent variable for the total model.
Problem 7: How one can implement switching between states of the constraint in the acausal manner?
Solution: Use the if clause in combination with the
state variable of Real type. This variable is included
to corresponding algebraic loop. As a result the structural complexity of the total model doesn’t increase.
Figure 4.5: Center of Mass Altitude

6 Acknowledgement
The paper was prepared with partial support of Russian Foundation for Basic Research, grants 02–01–
00196, SS–2000.2003.1.

References
[1] Kossenko, I. I., and Stavrovskaia, M. S., How
One Can Simulate Dynamics of Rolling Bodies Via Dymola: Approach to Model Multibody
System Dynamics Using Modelica // Proceedings of the 3rd International Modelica Conference, Linköpings universitet, Linköping, Sweden, November 3–4, 2003, pp. 299–309.
Figure 4.6: Projections of Angular Velocity
[2] Pfeiffer, F., Unilateral Multibody Dynamics //
Meccanica, 1999, Vol. 34, No. 6, pp. 437–451.

5 Conclusions
Summurizing the results obtained while developing
the class library for the dynamics of the MBSUC let
us enumerate several relevant problems and their solutions.
Problem 1: How one can implement the geometry of
the unilateral constraint? Solution: Use the system of
algebraic equations like (2.1).
Problem 2: How one can ensure the reliability of the
implementation of the constraint? Solution: Use the
differential form of the equations (2.1).
Problem 3: How one can implement impacts in
MBSUC in the acausal manner? Solution: Use the independed algebraic subsystem of equations distributed
throughout the MBSUC model.
Problem 4: How one can implement the dichotomy
flight/contact? Solution: Use the complementarity
rule for the normal force of reaction and the derivative
of the normal relative velocity at the contact point.
The Modelica Association

23

[3] Novozhilov, I. V., Fractional Analysis : Methods of Motion Decomposition. — Boston:
Birkhauser, 1997.
[4] Routh, E. J., A Treatise on the Dynamics of a
System of Rigid Bodies. — London: Vol. 1,
1897.
[5] Ivanov, A. P., Dynamics of Systems with Mechanical Impacts. — Moscow: 1997. ISBN 57781-0031-0.
[6] Dymola. Dynamic Modeling Laboratory. User’s
Manual. Version 5.1b — Lund: Dynasim AB,
Research Park Ideon, 2003.
[7] Markeev, A. P., On the Motion of an Ellipsoid
on a Rough Surface with Slippage. // Journal of
Applied Mathematics and Mechanics, Vol. 47,
Iss. 2, 1983, pp. 260–268.

Modelica 2005, March 7-8, 2005

The Modelica Association

24

Modelica 2005, March 7-8, 2005

Object-Oriented Modelling and Simulation of Flexible Multibody Thin Beams in Modelica with the Finite
Element Method

Object-Oriented Modelling and Simulation of Flexible Multibody
Thin Beams in Modelica with the Finite Element Method
Gianni Ferretti, Francesco Schiavo∗, Luca Viganò
Politecnico di Milano,
Dipartimento Di Elettronica Ed Informazione (DEI)
Via Ponzio 34/5, 20133 Milano, Italy
e-mail: {ferretti,schiavo,vigano}@elet.polimi.it

Abstract
In this paper the development, simulation and validation of Modelica models for flexible thin beams is presented.
The models are based on the application of the finite element method. Exploiting the object-oriented
features of the language, mixed-mode models (finite
element-finite volume) are developed as well.
All the models use the standard connectors defined
within the Modelica multibody library, guaranteeing
thus full compatibility with the library components.
The details of the mathematical modelling are fully analyzed, showing the development of the equations of
motion.
The models feature also a graphical interface, with visualization of the simulation outcomes within the same
3D environment used in the multibody library, allowing the user to have an immediate visual feedback.
Finally, the models are analyzed and validated by
mean of selected simulation experiments, with reference both to theoretical predictions and to results commonly accepted within the scientific literature.

1

Introduction

Many engineering applications require the development of simulation models for flexible multibody systems (e.g., robot manipulators, helicopter rotors, aircraft wings, space structures, machining tools, car suspensions, etc.) both dynamically accurate and computationally affordable.
The task of developing models for generic-shaped,
fully deformable bodies is usually demanded to specialized simulation codes and tools, due to the complexity of the task. Such models are usually adequate
∗ corresponding

author

The Modelica Association

for structural analysis and design tasks, while being far
too complex for affordable dynamics simulation and
analysis.
On the other hand, particular classes of deformable
bodies, such as flexible beams, can be represented with
less complex models which are still able to represent
all the dynamically relevant deformation effects.
Flexible beams are continuous non linear dynamical
systems characterized by an infinite number of degrees
of freedom. Obviously, dealing directly with infinite
dimensional models is impractical both for dynamic
analysis and simulation purposes. Hence it is necessary to introduce methods to describe flexibility with a
discrete number of parameters.
Three different approaches have been traditionally
used to derive approximated finite dimensional models: lumped parameters, assumed modes and finite element method [3],[5].
The lumped parameter approach is the simplest one.
In this method each flexible beam is divided into a finite number of rigid beams, introducing pseudojoints,
and the flexibility is represented by springs that restrict
the motion of each pseudojoint. This method is however rarely used because of the difficulty in determining the spring constants of the pseudojoints and then
of achieving a suitable accuracy up to the desired approximation frequency.
The assumed modes model formulation has been
widely used in the literature [6]. It describes beam
flexibility using truncated modal series, based on spatial mode eigenfunctions and time varying vibrational
modes. One of the best features offered by such a
method is the fine control on the accuracy up to the
desired approximation frequency. Although conceptually simple, this description requires to find out the
best selection for spatial modal shapes and the boundary conditions, which is not at all a trivial task. In addition to that, the selection of the appropriate eigenfunc-

25

Modelica 2005, March 7-8, 2005

F. Schiavo, G. Ferretti, L. Viganò

tions and the resulting vibrational modes could depend on the boundary conditions for the specific case
at hand, ruling thus out the possibility of a modular
approach for the model development.
In the finite element method approach [9], the flexible beam is divided into several elements, with a local description of the deformation field by the use of
element-wise basis functions. Although such approach
could be computationally more demanding than the
modal one (it is usually necessary to use a larger number of elements than of modal eigenfunctions to obtain the same approximation), it allows a formulation
which is independent of the actual boundary condition
[7]. The finite element method is then a viable choice
for the representation of flexible beams within a modular environment.
As far as the theory of elasticity to be used is concerned, it must be pointed out that beam deflection,
with respect to the rigid configuration, is generally assumed to be small, which allows to adopt linear theory. In this case the Euler-Bernoulli theory [8] can
be used to describe beam flexibility, neglecting the
effects of shear deformation and assuming uniform
cross-sectional properties along the beam. In this paper, we consider linear elasticity theory for the modelling of flexible thin beams. On the other side, Timoshenko theory [8] should be used for models where
such effects need to be taken into account (e.g., for
short beams).
The paper is organized as follows: in Section 2 the
problem of the representation of a generic deformable
body in a multibody system is introduced; in Section 3
the development of the equations of motions is shown,
with reference both to the finite element method case
and to the mixed-method one; in Section 4 the Modelica implementation is analyzed; Section 5 contains selected simulation results; finally, in Section 6 the main
results are summarized and future developments are
introduced.

2

Deformable Body Degrees of Freedom

Consider a generic multibody system (Fig. 1). The
position, in body coordinates, of a point on a specific
deformable body has the following expression:

Figure 1: Flexible body reference systems
The formal and mathematically sound description of
the generic deformation of a body requires the deformation field to belong to an infinite dimensional functional space, requiring, in turn, an infinite number of
deformation degrees of freedom.
In this paper, the deformation field is described by an
approximation of the functional basis space it belongs
to, supposing such space has a finite dimension, say M,
so that the vector u f can be expressed by the following
finite dimensional product:
uf = Sqf ,

(2)

where S is the [3 × M] shape functions matrix (i.e., a
matrix of functions defined over the body domain and
used as a basis to describe the deformation field of the
body itself) and q f is the M-dimensional vector of deformation degrees of freedom.
The position of a point on a deformable body can then
be expressed in world reference as follows:
r = R + Au = R + A(u0 + Sq f ) = R + Au0 + ASq f ,

(3)

where R is the vector identifying the origin of the body
local reference system and A is the rotation matrix for
the body reference system.
The representation of a generic deformable body in
world reference requires then 6 + M d.o.f. (i.e., 6 corresponding to rigid displacements and rotations and M
to deformation fields):
q = [qr q f ]T = [R θ q f ]T ,

(4)

where θ represents the undeformed body orientation
angles and qr is a vector containing the 6 rigid degrees
of freedom.

3

Motion Equations

The equations of motion for a generic flexible body
in a multibody system can be developed applying the
where u0 is the “undeformed” (i.e., rigid) position vec- principle of virtual work [3]. It should be pointed out
tor and u f is the deformation contribution to position that the same results could be obtained using the clas(i.e., the deformation field).
sical Lagrangian approach (as in, e.g., [5]), though
u = u0 + u f ,

The Modelica Association

(1)

26

Modelica 2005, March 7-8, 2005

Object-Oriented Modelling and Simulation of Flexible Multibody Thin Beams in Modelica with the Finite
Element Method

such approach is quite knotty and difficult to use in following definitions:
practice, due to the complexity of the required analytical differentiation of the kinetic energy expression.
The principle of virtual work states that the virtual
work of the inertial forces δWi must counterbalance
the sum of the virtual work of the continuum elastic
forces δWs and of the external ones δWe :

Z

mRR

=

mRθ

=

ZV
V

Z

mR f
δWi = δWs + δWe .

(5)

mθθ

=
V

= −
=

mf f

=

ZV
V

Z

S

=
V

Z
Z

δWi

=

δWs

= −

δWe

=

V

ρδrT r̈dV ,

Z

Z V
V

(6)

δεT σdV ,

(7)

St

=

e
St

=

ZV
V

Z

δrT Fe dV +

Z
Ω

δrT fe dΩ ,

I θθ

(8)

=
V

Z

Iθ f

ρA (u×)T AT dV ,

(12)

ρAS dV ,

(13)

V

mθ f

The terms of equation (5) are defined as follows:

(11)

Z

Z

Note that, in case δWi = 0, the problem reduces to the
well-known problem of structural statics [9].

ρ dV ,

=
V

ρAu × u × AT dV ,

(14)

ρAu × S dV ,

(15)

ρST S dV ,

(16)

ρSdV = AT mR f ,

(17)

ρudV ,

(18)

ρ (u×) dV = AmRθ AT ,

(19)

ρ (u×)T (u×) dV = AT mθθ A ,

(20)

ρ (u×) SdV = AT mθ f .

(21)

where V is the body volume, ρ is the body density,
δr is an infinitesimal virtual displacement, r̈ is the
body acceleration (in world reference), δε is a vector
of virtual infinitesimal internal strains, σ is the internal stresses vector, Fe is the vector of external volume The vector QRi can then be obtained as follows:
forces, Ω is the body surface and fe is the vector of
external surface forces.
Z
Z
Z
The quantities δr and r̈ can be computed using equaQRi = ρR̈dV + ρω × (ω × u) dV + ρ (α × u) dV
tion (3):
ZV

+
δr =δR + δAu + Aδu = δR + θd × Au + ASδq f ,
r̈ =R̈ + ω × ω × u + α × u + 2ω × Au̇ + Aü ,

V

(9)

V

=mRR R̈ + Aω × ω × A

T

+Aα × AT
Z

+
V

V

ρδrT r̈dV = δRT QRi + θTd Qθi + δqTf Qi .
f

(10)

ZV

V

ρAudV +

ρAudV + 2Aω × AT

Z
V

ρASdV q̇ f

(22)

ρASdV q̈ f =

T

=mRR R̈ + Ae
St α + ASq̈ f + A ω × ω × St + 2ω × Sq̇ f =

=mRR R̈ + mRθ α + mR f q̈ f − AQRv ,

The expressions in (9) can be substituted in 5, leading
to
Z

Z
V

where α and ω are the body angular acceleration and
velocity (in world reference),respectively, and θd =
ω dt represents a virtual-infinitesimal rotation.

δWi =

V

Z

ρ2ω × Au̇ dV + ρAüdV =

being QRv = −ω × ω × St − 2ω × Sq̇ f the quadratic velocity vector (due to Coriolis and centrifugal forces)
associated to translational degrees of freedom.

The terms QRi ,Qθi and Qi can be calculated using the The second term of the generalized inertial forces can
f

The Modelica Association

27

Modelica 2005, March 7-8, 2005

F. Schiavo, G. Ferretti, L. Viganò

be expressed as
Qθi =A
−

Z

Z V

ρ (u×) dV AT R̈ − ω ×

ρu × u × dV α + 2

ZV

V

V

ρu × u × dV ω

ρu × ω × (ASq̇ f ) dV

ρu × (ASq̈ f ) dV =

+
V

St AT R̈ + Aω ×
=Ae
−A

Z

Z

Z
ZV

Z
V

Figure 2: Planar beam deformation

−ρu × u × dV ω

ρu × u × dV α − 2A

Z
V

ρu × (Sq̇ f ) × ωdV

(23) Equation (5) must be satisfied for every virtual dis-

placement so that the following identities must hold:

ρu × SdV q̈ f =
V
=A e
St AT R̈ + ω × I θθ ω + I θθ α + I˙θθ ω+

+ ω × I θ f q̇ f + I θ f q̈ f =

QRi
Qθi

+A

f

Qi

= QRe ,
= Qθe ,

(27)
(28)

= −K f f q f + Qef .

(29)

=mTRθ R̈ + mθθ α + mθ f q̈ f − AQθv ,

where the quadratic velocity vector associated to the
rotational degrees of freedom is Qθv = −ω × I θθ ω −
I˙θθ ω − ω × I θ f q̇ f .
f
The Qi term, which is related to the deformation d.o.f.
q f , can be expanded as follows:
Z

f

Qi =

V

Z

+
V

Z

+
V

Z

+
ZV

+
V
T

ρST AT R̈dV +

Z
V

ρST AT ω × (ω × u) dV

ρST AT (α × u) dV +
T

Z

ρST üdV = S AT R̈ +

V

Z
V

Equations (27), (28) and (29) are the equations for 3D
motion of a generic flexible body characterized by an
elastic constitutive law for its material. In the scientific
literature, such expressions are generally referred to as
the generalized Newton-Euler equations (see e.g., [5]).
The equations of motion can be easily expressed in
body axes, resulting in:


ρST AT 2ω × Au̇ dV






R¨

Iθ f   α  =
q̈ f
mf f



  R 
R
Qe
Qv
O3
θ 
 +  Qθv  + 
O3
=
 Qe  .
f
f
−K f f q f
Qv
Qe
 mRR


ρST α × udV +

ρST (ω × ω × u + 2ω × Sq̇ f ) dV
(24)

ρST SdV q̈ f =

T
e
St
Iθθ

S

(30)

T

=S AT R̈ + I θ f α + m f f q̈ f +
Z
 2

e u + 2ωS
e q̇ f dV =
+ ρST ω
V
=mTR f R̈ + mTθ f α + m f f q̈ f

− Qvf ,

 2

R
f
e u + 2ωS
e q̇ f dV .
being Qv = − V ρST ω
The virtual work of the internal elastic forces, under
the hypothesis of elastic constitutive law for the material, can be expressed as:
δWs = −

Z
V

δεT σdV = −δqTf K f f q f ,

(25)

where K f f represents the structural stiffness matrix.
The form of such matrix depends on the specific material constitutive law and on the body shape.
The virtual work of external forces reads as follows:
δWe = δRT QRe + θTd Qθe + δqTf Qef ,

(26)

where QRe , Qθe and Qe represent, respectively, the generalized components of the active forces associated to
translational, rotational and deformation coordinates.
f

The Modelica Association

Equations (30) are valid for a general deformable
body, though many of the quantities involved (e.g.,
the matrix K f f ) depend on specific body characteristics such as the shape or the material properties.
From now on, the case of a thin beam will be considered. In detail, it will be assumed that the body is
a 1D elastic continuum with constant cross-sectional
properties. Furthermore, it will be assumed that the
beam constitutive material is homogeneous, isotropic
and perfectly elastic (i.e., the elastic internal forces are
conservative). Finally, it will be assumed that the deformation field is restricted to lie within the xy plane
of the beam local reference system (Fig. 2).
It should be pointed out that such assumptions do
not restrict the model validity or generality, since the
model remains still representative for a large number
of dynamic simulation applications (e.g., almost all the
flexible robots commonly studied have flexible links
which can be represented by such model [7]).

28

Modelica 2005, March 7-8, 2005

Object-Oriented Modelling and Simulation of Flexible Multibody Thin Beams in Modelica with the Finite
Element Method

bending moment Mel , as follows [9]:
!
Mel Mel0
Nel Nel0
+
dx =
EA
EJ

1Z 
1
00
0
=
EJu f 22,el + EAu f21,el dx = qTf,el K f f ,el q f ,el ,
2 `
2
(32)

1Z
Uel =
2 `

Figure 3: Element coordinate systems

3.1

The element point of view

The finite element method is based upon a discretization of the beam into N elements. A single element
can itself be viewed as a thin beam characterized by a
planar deformation field. It is then possible to define
the local dimensionless abscissa as ξ = x/`, where x is
the longitudinal local coordinate and ` is the element
length.
In [9] it is shown that the partial differential equations
associated with the deformation problem at hand, under the hypothesis of elastic constitutive law for the
material, require, for a consistent finite element formulation, the use of linear and Hermite cubic polynomials for the approximation of the axial and transversal deformation field, respectively. Thus, for a single
element, the generic equations of motion (30) can be
expanded as follows:

where E is the material Young’s modulus, A is the
(constant) cross-sectional area and J is the (constant)
cross-sectional second moment of area. The analytical
expression for the case at hand for the matrix K f f ,el ,
usually known as the structural stiffness matrix, is reported in appendix A.

3.2

Finite Element Method Equations Assembly

The equations of motion for the entire beam can be obtained by assembling the equations of motion for beam
elements as the one defined in the previous subsection.
The body reference system will be the local reference
system located at the root of the first element, so that
the rigid degrees of freedom, common to all the ele

u f 1,el
ments, will be referred to such coordinate system.
u f ,el =  u f 2,el  = Sel q f ,el ,
Let then m and L be the mass and length of the enu f 3,el
tire beam, and N the number of elements to be used,

→
−
b
1−ξ
0
0
so that ` = L/N. Indicating with X the reference sys1 − 3ξ2 + 2ξ3 `(ξ − 2ξ2 + ξ3 ) · · ·
Sel =  0
(31) tem unit vector along the beam axis, the expression of
0
0
0
the generic position u j of a point of element j can be
 

ξ
0
0
Sel1
expressed as:
· · · 0 3ξ2 − 2ξ3 `(ξ3 − ξ2 )  =  Sel2  ,
Sel3
0
0
0
T

q f ,el = q f 1,el q f 2,el q f 3,el q f 4,el q f 5,el q f 6,el ,

→
−
b
u j = u0 j + Sel B j q f = [ξ j ` + ( j − 1)`] X + Sel B j q f , (33)

where the subscript el is used to refer the quantities to
a single element.
Fig. 3 depicts the element coordinate systems associated with the deformation degrees of freedom: q f 1,el
and q f 4,el are associated with axial compression, q f 2,el
and q f 5,el with transversal displacement and q f 3,el and
q f 6,el with beam extremities rotation.
Since the third row of the shape matrix Sel is composed
only by zeros, it could be noted that, despite the fact
that the motion equations have been developed for a
general 3D case, the deformation field is assumed to
lie within the local xy plane.
The planar deformation hypothesis and the assumption
of a homogeneous, isotropic and elastic material for
the beam, allow to exploit the Euler-Bernoulli theory
and to calculate the elastic potential energy Uel , neglecting the contribution of shear stresses and considering only the work of the resulting axial force Nel and
The Modelica Association

where u0 j is the position of the root of the jth element,
Sel is the shape functions matrix defined by (31), B j
is the so-called connectivity matrix and q f is a vector
containing the deformation degrees of freedom for the
whole beam.
The matrices B j have the following form:
Bj =



O6,3( j−1)

I6

O6,3(N− j)



, ∀ j = 1, · · · , N . (34)

The connectivity matrices are used to relate the vector
q f , which contains the deformation degrees of freedom for the whole beam, to the corresponding jth element, according to the expression:
q f ,el j = B j q f .

(35)

The dynamics of the complete flexible beam can then
be described by equation (30), using the following ex-

29

Modelica 2005, March 7-8, 2005

F. Schiavo, G. Ferretti, L. Viganò

The choice of which of the two set of conditions has
to be used largely depends on the problem at hand.
It should be pointed out that the boundary conditions
names are just conventional and are not referred to the
objects the beam is connected or linked to (e.g., joints
or other bodies), so that enforcing such boundary condition does not limitate in any way the generality and
modularity of the model developed so far.
The enforcement of the boundary conditions is traditionally obtained by introducing suitable matrices in
equations (30) [6, 9]. On the other hand, it can be
observed that such conditions can be enforced by suitable modifications of the connectivity matrices B1 and
BN , by zeroing some entries. For example, for the
clamped-free conditions, BN remains unvaried and B1
becomes

pressions:
N

m
j=1 L

S=∑

Z
Vj

Sel B j dV j ,

N

mZ
St = ∑
u j dV j ,
j=1 L V j

u22 f j
N mZ

I θθ = ∑

j=1 L V j



0

0
 dV j ,
u21 j + u22 f j


O(3N,1)
 dV j ,
O(3N,1)
Vj
u1 j Sel2 − u2 j Sel2
Z

N m
T
T
= ∑ Bj
Sel Sel dV j B j ,
Vj
j=1 L
N

m
j=1 L

Iθ f = ∑
mf f

−u2 f j u1 j
u21

Z



N

K f f = ∑ BTj K f f ,el B j ,
j=1



N

i
m Z h T T e2
e el B j q̇ f dV j .
B j Sel ω u j + 2ωS
Qvf = − ∑
j=1 L V j

B1 =

03
03

03
I3


O6,3(N−1)

.

(38)

(36)

The computation of the above terms can be easily carried out by observing that the integral of a generic 3.4 Extended Formulation of the Equation of
Motion
quantity F , varying along the beam, onto the volume
of a single element can be computed as follows:
In the finite element formulation for the equation of
Z
mZ 1
mZ 1
`F (ξ)dξ =
F (ξ)dξ . (37) motion for a flexible beam, the reference directions of
ρF dV j =
L 0
N 0
Vj
the internal actions are the same for all the elements.
Such representation is acceptable as long as the deformation field is small compared to the beam length, as it
3.3 Boundary Conditions
is the case, for example, when studying the dynamics
The equations of motion for the whole beam must be of vibrations in machining tools.
completed by enforcing suitable boundary conditions On the other hand, when large deformations are infor the finite element approximation of the deforma- volved, the internal actions reference directions should
tion partial differential equations. That means assum- change according to the deformation field. That means
ing prescribed values for some of the deformation dis- that it is necessary to define a local reference system
placements, rotations and velocities (linear or angular) for each element (Fig. 4). This corresponds to the
at the body boundaries which are, for the case at hand, application of the finite volume method to assemble
the equations of motion solved over each element (i.e.,
the beam root and tip.
The most commonly used boundary conditions for over each volume). This representation is valid also
flexible beams are of two kinds, commonly referred for large beam deformation, as long as the deformato as clamped-free and simply-supported conditions. tion field is small compared to the volumes length.
In both cases six conditions are given (as it is re- Furthermore, it is possible to assemble the equation
quired from the underlying partial differential equa- of motion for a mixed (finite element-finite volume)
tions): the clamped-free ones enforce null deforma- formulation by dividing every volume into several eltion at the beam root (i.e., q f 1 , q f 2 , q f 3 , q̇ f 1 , q̇ f 2 , q̇ f 3 ements.
equal to zero for the first element), while the simply- It is not necessary to go into the detailed calculations
supported ones enforce null axial and transversal dis- for the finite volume or the mixed formulation since,
placement at the beam root (i.e., q f 1 , q f 2 , q̇ f 1 , q̇ f 2 as it will be shown in section 4, the equations of moequal to zero for the first element) and transversal dis- tion for such extensions can be automatically calcuplacement at the beam tip (i.e., q f 5 and q̇ f 5 equal to lated with the aid of symbolic manipulation algorithms
applied to the finite element formulation.
zero for the last element).
The Modelica Association

30

Modelica 2005, March 7-8, 2005

Object-Oriented Modelling and Simulation of Flexible Multibody Thin Beams in Modelica with the Finite
Element Method

Figure 4: Volume coordinate systems

4

Modelica Implementation

The finite element formulation for the model has been
implemented using the Modelica language, creating
thus a new component, called FlexBeamFEM (Fig. 5).
The component interfaces are two standard mechanical flanges from the new MultiBody library [4]. The
connectors choice makes the component fully compatible with the library, so that it is possible to connect
directly the flexible beam component with the predefined models such as mechanical constraints (revolute joints, prismatic joints, etc.), parts (3D rigid bodies) and forces elements (springs, dampers, forces,
torques).

Figure 6: Cart with flexible inverted pendulum

to select the flanges moments acting on the deformation field; forces and moments are referred to the root
flange coordinate system.
The model parameters include the beam length and
cross sectional area, the material density and Young
modulus, the cross sectional inertia, the damping factor and the number of elements.

Particular care has been put into the realization of a
3D interface for the model to visualize the simulation
results (Fig. 6), implemented by exploiting the features of the graphical environment of the multibody library. The 3D visualization has revealed itself to be an
Figure 5: Component icon
important feature, giving significative insight and senIn detail, the flexible beam component uses two me- sible feedback about the dynamical behaviour of the
chanical flanges as physical representation of the two model.
ends of the beam while the motion is ruled by equaThe finite volume model and the mixed one can be
tions (30), with addition of a damping term (−D f f q̇ f )
easily obtained by connecting several finite element
for the structural dynamics part. The damping term is
beams composed by one or more elements, respecadded to model the dissipative properties of the matetively. The achievement of such results, which signifrial.
icantly simplify the models implementation, is based
f
The terms QRe , Qθe , Qe (i.e., the external actions) are
computed on the basis of the forces and torques ex- on the modular approach adopted in the finite element
changed at the two connectors with the following model development. The assembly of the equations
code:
of motion for these cases is demanded to Modelicabased simulation environments, which usually employ
QeR=matrix(fa+fb_a);
advanced symbolic manipulation techniques and index
QeTheta=matrix(ta+tb_a+cross(({L,0,0}
reduction algorithms.
+S1*B[N,:,:]*qf),fb_a));
Qef=transpose((transpose(matrix(fb_a))*S1*
B[N,:,:]+transpose(matrix(ta))*dS0*B[1,:,:])
+transpose(matrix(tb_a))*dS1*B[N,:,:]));

where fa and fb_a are the forces at the connectors,
ta and tb_a the moments at the connectors, S1 the
matrix Sel evaluated for ξ = 1, B[N,:,:] the connectivity matrix BN and dS0 and dS1 are matrices used
The Modelica Association

The dynamical properties of the latter models are significantly complex and accurate, featuring a displacement description which is fully non-linear and allowing the simulation of large displacement due to deformation (Fig. 7) at the cost, though, of a significant
increase of the computational complexity with respect
to the “pure” finite element model.

31

Modelica 2005, March 7-8, 2005

F. Schiavo, G. Ferretti, L. Viganò

Mode
1
2
3
4
5
∗

Figure 7: Large deformation of a thin beam

5

Freq.∗ [Hz]
2.0854733
13.0694381
36.5948052
71.7112127
118.543772

Theoretical prediction

†

Freq.† [Hz]
2.0854750
13.0698705
36.6041219
71.7795490
118.842591

Error [%]
8.418e-005
3.308e-003
2.545e-002
9.529e-002
2.521e-001

Simulation result

Table 1: Theoretical and model natural frequencies

Simulations

The different flexible beam models have been validated by several simulation analysis performed within
the Dymola simulation environment [1]. The most significative ones are reported in the following subsections.

5.1

Free Vibration

In this simulation the free vibration of a flexible beam
is analyzed. The test-case has been set up in order to
investigate the models properties with respect to theoretical predictions.
Figure 8: Tip displacement frequency spectrum
The beam component is connected to the world reference system, so that no rigid motion is allowed; furthermore, no gravity field is considered.
sponding to the kth mode of vibration) given by:
s
At the initial time instant the beam is standing still with
EJ
a non-null tip displacement, then it evolves, vibrating,
ωk = β2k
,
(42)
ρ
towards steady state.
The vibration frequencies of a flexible beam clamped
being βk the kth root of the characteristic equation:
at the root can be calculated by solving the following
partial differential equation:
cos (βL) cosh (βL) + 1 = 0
(43)
ρ

∂2 y(x,t)
∂4 y(x,t)
+ EJ
=0
2
∂t
∂x4

(39)

The beam, made by aluminium, has square cross
section A = 1 cm2 , length L = 2 m, density ρ =
with the following boundary and initial conditions:
2700 kg/m3 , Young’s modulus E = 7.2 · 109 N/m2 and

2
3
∂y
∂ y
∂ y
has been discretized with N = 10 elements. The initial

 y(0,t), (0,t),
(0,t), 3 (0,t) = 0
2
∂x
∂x
∂x
(40) tip displacement is 1 cm.
∂y

 y(x, 0) = f (x), (x, 0) = 0
Table (1) contains a comparison between the results
∂t
for for the first five vibrational modes obtained by simwhere x is the axial coordinate, y is the transversal ulation and by solving numerically equation (43). The
displacement and f (x) is the initial deformation field. results are in good accordance, as it is shown also in
In [3] it is shown that the general solution for equation Fig. 8, depicting the tip displacement frequency spec(39) has the following expression:
trum.
∞

y(x,t) =

∑ ϕk (x)αk (t) ,

(41) 5.2

Flexible Pendulum

k=1

This simulation, reported also in [2], involves the analwhere ϕk (x) are the spatial eigenfunctions and αk (t) ysis of the vibrations induced by motion in a flexible
are periodical functions, with natural pulsation (corre- pendulum swinging under the action of gravity.
The Modelica Association

32

Modelica 2005, March 7-8, 2005

Object-Oriented Modelling and Simulation of Flexible Multibody Thin Beams in Modelica with the Finite
Element Method

Figure 11: Slider-crank mechanism (Dymola scheme)
Figure 9: Swing angle

Figure 12: Slider-crank mechanism

The simulation set up involves a slider, a rod and a
crankshaft connected by revolute joints (Fig. 11 and
12)

Figure 10: Tip displacement

The crank has length L = 0.152 m, cross sectional
area A = 0.7854 cm2 and second moment of area J =
4.909 · 10−10 m4 , density ρ = 2770 kg/m3 and modulus of elasticity E = 109 N/m2 . The connecting rod
has the same physical parameters of the crank, apart
from the lenght L = 0.304 m and the Young’s modulus
E = 5 · 107 N/m2 . The crank and the connecting rod
have been discretized with 3 and 8 elements, respectively. Finally, the slider block has been assumed to be
a massless rigid body.

The pendulum, connected to the world reference system by a revolute joint, has a length L = 0.4 m, cross
sectional area A = 18 cm2 , density ρ = 5540 kg/m3 ,
second moment of area J = 1.215 · 10−8 m4 and modulus of elasticity E = 109 N/m2 . Two different models have been simulated: the first one composed by 10
elements and the second one by 5 volumes with 2 ele- During the simulation, the crankshaft is driven by a
ments each.
torque with the following law:
In Fig. 9 the swing angle is depicted for both cases.
The tip deformation, depicted in Fig. 10, appears to be
slightly different for the two models. The results re
M(t) = [0.01 (1 − e−t/0.167 )]Nm , t ≤ 0.7 sec
ported in [2] are in accordance with the ones obtained
0
, t > 0.7 sec
with the mixed model, though.

(44)

5.3

Elastic Slider-crank Mechanism

Fig. 13 and 14 show the slider position and the conThe simulation of an elastic slider-crank mechanism, necting rod tip transverse displacement, respectively.
reported also in [2], has been performed to validate the The results are in perfect accordance with those remodels for use within closed-loop mechanical chains. ported in [2].
The Modelica Association

33

Modelica 2005, March 7-8, 2005

F. Schiavo, G. Ferretti, L. Viganò

A

6 Conclusion and Future Work

Structural Stiffness Matrix


In this paper, a new model for flexible thin beams in
Modelica is introduced. The model, fully compatible
with the MultiBody library, is based on the application of the finite element method. Selected simulation results have been presented in order to validate
the model properties with respect to scientific literature reference cases.

K f f ,el

Future work will include the model extension to handle full 3D deformation and distributed loads. The
model will also be employed for the development of
applications in the field of robot control and satellite
attitude control.

EA
 `













=
















0

0

EA
−
`

12EJ
3`

6EJ
3`

0

−

4EJ
`

0

−

EA
`

0

0

12EJ
3`

6EJ
2`

6EJ
2`

2EJ
`

0
12EJ
3`

0

−

6EJ
2`

4EJ
`






























References
[1] Dymola. Dynamic Modelling Laboratory. Dynasim AB, Lund, Sweden.
[2] J.L. Escalona, H.A. Hussien, and A.A. Shabana.
Application of the absolute nodal co-ordinate formulation to multibody system dynamics. Journal
of Sound and Vibration, 5(214):833–851, 1998.
[3] L. Meirovitch. Analytical Methods in Vibration.
Macmillan Publishing, New York, 1967.

Figure 13: Slider block position

[4] M. Otter, H. Elmqvist, and S. E. Mattsson. The
new modelica multibody library. In 3rd Modelica
Conference, Linköping, Sweden, November 3-4,
2003.
[5] A. A. Shabana. Dynamics of Multibody Systems.
Cambridge University Press, 1998.
[6] A.A. Shabana. Flexible multibody dynamics: Review of past and recent developments. Journal of
Multibody System Dynamics, 1(2):189–222, 1997.
[7] R. Theodore and A. Ghosal. Comparison of the
assumed modes and finite element models for flexible multilink manipulators. International Journal
of Robotics Research, 14(2):91–111, 1995.
[8] S. Timoshenko, D. Young, and W. Weaver. Vibration Problems in Engineering. John Wiley & Sons,
New York, 1974.

[9] O. C. Zienkiewicz and R. L. Taylor. The Finite
Element Method, 2, Solids and Fluid MechanFigure 14: Transverse displacement of the tip of the
ics, Dynamics and Non-Linearity. McGraw Hill,
connecting rod
1991.

The Modelica Association

34

Modelica 2005, March 7-8, 2005

Object-oriented modelling of the dynamics of a satellite equipped with Single Gimbal Control Moment Gyros

Object-oriented modelling of the dynamics of a satellite equipped
with Single Gimbal Control Moment Gyros
Tiziano Pulecchi Marco Lovera
Dipartimento di Elettronica e Informazione
Politecnico di Milano
32, Piazza Leonardo da Vinci, 20133 Milano, Italy

Abstract
The development process for spacecraft control systems relies heavily on modelling and simulation tools
for spacecraft dynamics. For this reason, there is an
increasing need for adequate design tools in order to
cope efficiently with tightening budgets for space missions. In this paper, the main issues related to the modelling and simulation of satellite dynamics are briefly
summarised, and the results obtained so far in developing Modelica tools for spacecraft simulation are presented and illustrated with a case study for a satellite
equipped with Control Moment Gyros as main attitude
control actuators.

1

Introduction

The safe and satisfactory operation of a satellite, in
terms of its mission objectives, is strongly related to
the performance level of its on-board attitude and orbit
control systems, which provide the ability to maintain
a desired orientation in space (or, e.g., carry out predefined attitude maneuvers) and track a desired, nominal
orbit in spite of the presence of external disturbances.
In addition, the recent trend towards missions based on
constellations or formations of small satellites has led
to the formulation of even more complex control problems, related to the relative motion (both in terms of
attitude and position) of more vehicles at a time. However, spacecraft designers are also faced with a general
reduction of space programmes budget, especially for
scientific Low Earth Orbit (LEO) missions, embodied
by the spreading of the ”faster, better, cheaper” philosophy. This has resulted in an increasing need for efficient design tools in every domain involved in spacecraft design, and particularly in the area of control oriented modelling and simulation. Specific tools have
to be developed for the design of both the system architecture and the Attitude and Orbit Control System
The Modelica Association

(AOCS), bearing in mind the principles of reusability, flexibility and modularity. The main issue in the
development of such tools should be to try and work
out a unified environment to be used throughout the
life cycle of the AOCS software, namely, the mission
analysis stage, the preliminary and detailed design and
simulation phases, the generation and testing of the
on-board code, the development of the AOCS Electrical Ground Support Equipment (EGSE) and the postlaunch data analysis activities. A number of commercial tools are available to support one or more of the
above mentioned phases in the development of AOCS
subsystems, however none of them seems capable of
providing complete coverage of the whole development cycle in a sufficiently flexible way.
In particular, the experience gathered in the development of control-oriented spacecraft modelling tools
within a ”signal oriented” simulation environment (see
[2]) showed that a more systematic approach, based on
modern acausal object-oriented modelling languages
such as Modelica (see [3, 6]), might lead to the development of a spacecraft simulation library the use of
which would be made much more efficient by the very
nature of the selected modelling approach. Note, in
passing, that there is an increasing interest for multidomain problems in the spacecraft control design community (see, e.g., [17]), an area which would benefit
from the availability of simulation tools based on the
object-oriented approach.
Surprisingly enough, while the use of Modelica for
aerospace applications has recently led to the development of a library for flight dynamics (see [14]), very
little activity in the spacecraft domain has been reported yet. The development of simulation tools for
satellite attitude and orbit dynamics within the objectoriented paradigm has been the subject of previous
work (see [10]). Since the development of the model
components presented in the cited references, however, a new, more refined version of the Modelica

35

Modelica 2005, March 7-8, 2005

T. Pulecchi, M. Lovera

• Attitude control strategy definition, starting from
mission requirements and platform characteristics;

Multibody library has been released (see [15]) which
turns out to be extremely suitable to serve as a basis for the development of the basic model components for the mechanical parts of spacecraft models.
In particular, the adoption of the above mentioned library would prove specially beneficial for the simulation of spacecraft equipped with momentum exchange
devices, such as, e.g., control moment gyros (CMGs,
see, e.g., [8, 22]).
Therefore, the aim of the paper will be to present the
current state of the development of spacecraft modelling tools based on the Multibody library, with specific reference to the problem of analysing the (open
and closed loop) attitude of satellites equipped with
control moment gyros (CMGs) as main attitude control actuators.
The paper is organised as follows: first a brief introduction to the role of mathematical modelling and simulation in the development cycle of spacecraft control system is given, in Section 2; subsequently, an
overview of the main model components involved in
typical control oriented models will be presented. Finally, the proposed approach to spacecraft modelling
will be described in Sections 3-7 and the results obtained in the implementation and application of such
an approach to the simulation of spacecraft equipped
with CMGs will be presented and discussed in Section
8.

2

Modelling and
AOCS design

simulation

for

• Evaluation of the external force and torque disturbances acting on the spacecraft, depending on
the mission profile. This is normally done using a
simple attitude control algorithm to maintain the
satellite at nominal conditions;
• Selection and sizing of the actuators in order to
counteract disturbances and to maintain the nominal pointing accuracy required by the mission;
• Verification of the possibility to fulfill possible
maneuver requirements with the selected actuators.

Figure 1: Block diagram of preliminary ACS design
process.

The above tasks can be performed without resorting to
As mentioned in the previous Section, the develop- a dynamic simulator for the spacecraft, however they
ment of the AOCS subsystem for a satellite can be de- require accurate modelling capability for orbit dynamcomposed in the following phases:
ics and the availability of reliable models for the space
environment. As an example, consider the problem of
1. Feasibility study (conceptual design).
assessing the external torques acting on the spacecraft.
Clearly their characteristics will depend also on the se2. Preliminary design.
lected control strategy (actuators, sensors and control
laws) for the spacecraft, which however is not entirely
3. Detailed design.
defined at this stage. Therefore only nominal and/or
worst case scenarios need be considered. On the other
4. Code generation and testing.
hand, all the subsequent design phases require the posDuring each of these phases, the designer should be sibility of integrating orbit models and environmental
able to rely on appropriate modelling and simulation models with a fully dynamic spacecraft simulator, in
tools. In particular, modelling tools should be flexi- order to proceed to the refinement of the original deble enough to provide the required level of complexity sign concept. In particular, as the development process
during each of the development phases.
goes on, more and more accuracy in the prediction
For example, consider the tasks for which a simula- of the achievable performance is required, so that the
tion tool would be applied during the feasibility study complexity of the simulation environment is progressively increased.
phase (see Figure 1 and the classical reference [9]):
The Modelica Association

36

Modelica 2005, March 7-8, 2005

Object-oriented modelling of the dynamics of a satellite equipped with Single Gimbal Control Moment Gyros

3

The Modelica Spacecraft modelling library

A library of tools for the modelling and simulation of
spacecraft dynamics based on the Modelica language
is currently being developed. Modelica turns out to
be specially suited for the modelling of spacecraft dynamics under many respects:

flexibility in order to build a simulation model
of increasing complexity and accuracy according to the needs associated with each phase of
the AOCS development process. As an example,
one can carry out an analysis of the external disturbance forces and torques acting on the spacecraft in its nominal orbit and attitude, by defining a ”simplified” spacecraft ideally attached to
its nominal reference attitude.

• Coordinate frames can be simply included in the
model in terms of connectors, describing kine- The original approach to the development of the
matic transformations from one coordinate sys- library contemplated the development of dedicated
components also for the mechanical parts. Howtem to another.
ever, the availability of the recently upgraded (see
• Spacecraft dynamics is modelled by defining a [15]) Multibody Library is leading to some significant
Spacecraft class which can be (almost) directly changes, since the reuse of the Multibody components
implemented in terms of classical equations for would lead to some significant advantages.
rigid body motion. The data structure to be used The main components of the library are the following:
in representing all the quantities involved in a
• A set of basic functions for operations on orspecific spacecraft model arises naturally during
bit parameters (transformations between cartethe modelling process.
sian and orbit elements, see for example [13, 19].
• Specific Modelica constructs are available to deal
with the modelling of physical fields and environmental quantities. This feature turns out to
be extremely useful in modelling the space environment and representing the interaction between
the environment and the spacecraft. In particular, with a suitable choice of the environment
interfaces, models of increasing complexity for
each of the quantities described in Section 5 can
be defined. This feature allows for a simple and
very convenient implementation of the ”scalability” requirement formulated in Section 2.

• A similar set of functions for operation on attitude
parameters (attitude matrix, quaternions, Euler
angles). These have been partially based on the
Rigid Body Kinematics Toolbox (see [18]).
• Class definitions for Planet, Orbit, Spacecraft,
and the most commonly used actuators and sensors.
• Environmental models of various complexity for
gravitational and magnetic field.
• Data sheets for basic model components, such as
orbits, actuators and sensors.

• Sensors and actuators can also be easily represented in the Modelica paradigm. For example,
the generation of magnetic torques is modelled 4 Dynamics of a spacecraft equipped
in terms of the interaction with the geomagnetic
with momentum exchange devices
field, while the momentum exchange between
spacecraft and wheels is modelled via a simple For the purpose of the present analysis, the following
mechanical connector allowing one rotational de- reference systems are adopted:
gree of freedom 1 .
• Earth Centered Inertial reference axes (ECI). The
• Packages of data sheets for each class can be conorigin of these axes is in the Earth’s centre. The
structed and components easily modified within
X-axis is parallel to the line of nodes, that is the
each spacecraft model, using Modelica’s adintersection between the Earth’s equatorial plane
vanced features (see, e.g., [16]).
and the plane of the ecliptic, and is positive in
the Vernal equinox direction (Aries point). The
• Finally, as the components of the library are inZ-axis is defined as being parallel to the Earth’s
dependent from each other, one can exploit this
geographic north-south axis and pointing north.
1 Mounting errors, which may give rise to interaxis coupling
The Y-axis completes the right-handed orthogonal triad.
and vibrations, can be easily accounted for.
The Modelica Association

37

Modelica 2005, March 7-8, 2005

T. Pulecchi, M. Lovera

5

• Earth Centered Fixed reference axes (ECF).
• Pitch-Roll-Yaw axes. The origin of these axes is
in the satellite centre of mass. The X-axis is defined as being parallel to the vector joining the actual satellite centre of gravity to the Earth’s centre and positive in the same direction. The Y-axis
points in the direction of the orbital velocity vector. The Z-axis is normal to the satellite orbit
plane and completes the right-handed orthogonal
triad.
• Satellite body axes. The origin of these axes is in
the satellite centre of mass; the axes are assumed
to coincide with the body’s principal inertia axes.
The equations of rotational motion of a rigid spacecraft
equipped with momentum-exchange actuators such as
CMGs are given by
Ḣ + ω × H = Text

(1)

where H = (H1 , H2 , H3 )T is the angular momentum
vector of the whole system expressed in the spacecraft body-fixed control axes; ω = (ω1 , ω2 , ω3 )T is the
spacecraft angular velocity vector; Text is the global external torque vector applied to the spacecraft, including gravity gradient, solar pressure and aerodynamic
torques, expressed in the body-fixed control axes.
The total angular momentum vector consists of the
spacecraft main body angular momentum and the angular momentum of the exchange devices, that is

Single Gimbal Control Moment
Gyros

A gyroscope, or gyro, is any instrument which uses
a rapidly spinning mass to sense and to respond to
changes in the inertial orientation of its spin axis.
Three basic types of gyroscopes are used on spacecraft: rate gyros (RGs) and rate integrating gyros
(RIGs) are attitude sensors used to measures changes
in the spacecraft orientation; control moment gyros
(CMGs) are used to generate control torques to change
and maintain the spacecraft orientation.
A single gimbal control moment gyro (SGCMG) consists of a rotor spinning at a constant rate around an
axis that is gimballed to allow changes in its spin direction. The gimbal is rigidly attached to the spacecraft, so that torques generated in response to its input
axis rotation apply to the spacecraft itself.
Let θ̂i the unit vector along the i-th SGCMG gimbal
axis, ĥi the unit vector along the instantaneous angular
momentum, jˆi = θ̂i × ĥi
Each angular momentum vector depends upon the relevant gimbal angle (for its direction). With respect to
the reference frame (spacecraft body axes), the total
angular momentum for a system of n SGCMGs is the
vector sum of the individual momenta:
n

h(θ) = ∑ hi (θi ) = f (hi , θi , βi )

(6)

i=1

A typical arrangement for SGCMGs is the one in
(2) which the CMGs are constrained to gimbal on the
where J is the overall inertia matrix of the spacecraft faces of a pyramid and the gimbal axes are orthogonal
and h is the total CMG momentum vector expressed in to the pyramid faces. In this case, the overall angular
momentum is given by
the body-fixed control axes.
H = Jω+h

Combining Eqs. (1) and (2), we obtain

or, introducing the internal control torque vector generated by CMGs τ = −(ḣ + ω × h), we can rewrite
Eq. (3) as
J ω̇ + ω × J ω = τ + Text
(4)

⎡
⎤
⎡
⎤
− cos β sin θ1
− cos θ2
h(θ) = h1 ⎣ cos θ1 ⎦ + h2 ⎣− cos β sin θ2 ⎦ +
sin β sin θ1
sin β sin θ2
⎡
⎤
⎡
⎤
cos β sin θ3
cos θ4
+ h3 ⎣ − cos θ3 ⎦ + h4 ⎣cos β sin θ4 ⎦ (7)
sin β sin θ3
sin β sin θ4

In addition to the dynamic equations of motion, kinematic equations must be included in the model, which
can be easily parameterised in terms of the attitude
quaternion
⎡
⎤⎡
⎡
⎤
⎤
q˙1
0
ω3 −ω2 ω1
q1
⎢ q˙2 ⎥ 1 ⎢ −ω3
⎥
⎢
0
ω1 ω2 ⎥
⎢
⎥ ⎢ q2 ⎥
⎢
⎥
⎣ q˙3 ⎦ = 2 ⎣ ω2 −ω1
⎦
⎣
0
ω3
q3 ⎦
q˙4
−ω1 −ω2 −ω3 0
q4
(5)

where β is the skew angle of the pyramid and h1 =
h2 = h3 = h4 for the considered cluster of four
pyramid-mounted SGCMGs. In particular, when each
CMG has the same angular momentum about its
spin-rotor axis and the skew angle is chosen as β =
54.73 deg, the momentum envelope becomes nearly
spherical.
The total amount of angular momentum for the system
is limited both in value and direction, by individual

(J ω̇ + ḣ) + ω × (J ω + h) = Text

The Modelica Association

(3)

38

Modelica 2005, March 7-8, 2005

Object-oriented modelling of the dynamics of a satellite equipped with Single Gimbal Control Moment Gyros

SGCMGs momenta. The time derivative of the global where A# = [AT P A + Q]−1 AT P. Note that [AT P A +
CMG angular momentum vector con be obtained as
Q] > 0 and, thus, nonsingular for any set of gimbal
angles.
4
ḣ(θ, θ̇) = ∑ ḣi (θi , θ̇i ) = [A(θi )]θ̇
(8) If Q = 0, the singularity robust inverse solution has the
form of the classical, weighted least squares solution
i=1
which exists only for a full rank Jacobian matrix A.
where θ = (θ1 , θ2 , θ3 , θ4 )T is the gimbal angle vector
and A is the instantaneous 3 × 4 Jacobian Matrix.
6.2 Momentum management
The gimbal rate command θ̇ is derived in such a way as
to supply the required angular momentum for control The gimbal angles of a CMG equipped spacecraft may
purposes. A frequently adopted approach is to note drift to various non-optimal values, due to external disturbances. This can force the spacecraft into a sinthat θ̇ can be obtained as
gular state or into a lack of control authority. Typiθ̇ = A† ḣ
(9) cally, a periodic disturbance torque along one spacecraft axis would result in a cyclic variation in the anwhere by A† = AT (AAT )−1 we denote the Moore- gular velocity of the actuation device directed along
Penrose pseudoinverse of the Jacobian matrix A.
that axis, while a constant (secular) disturbance would
lead to a linear increase in angular velocity, as the relevant CMG gimbal angle would be accelerated at a
6 Control system
constant rate in order to transfer to it the excess of angular momentum due to the external disturbance. This
6.1 Attitude control
can be sustained up to the physical limit for the roSince the torque-producing gimbal rates provided by tational speed of the device. In order to prevent this
equation (9) can lead to significant problems in the limit from being reached, the so-called desaturation of
operation of the control law whenever the configura- the actuator must be performed, i.e. an extra set of action of the CMGs is such that the Jacobian matrix A tuators, generating external torques, must be used to
is nearly singular, a new strategy must be adopted in- dump momentum from the spacecraft.
voking an approximate solution to equation (8), which Basically, the idea is to use the CMGs cluster to conmust be capable of both minimizing the errors intro- trol the spacecraft as required by the Attitude Control
duced in the output torque supplied and steering the System, and to achieve their desaturation by means of
system away from singular states configuration neigh- a dedicated controller, that keeps the CMGs gimbal
borhoods. The errors introduced by this approach in rates as small as possible. The goal of the momentum
the torque supplied by the SGCMGs cluster can be control loop is to maintain the CMGs momentum near
dealt by the control system as disturbances torques, zero without interfering with the attitude control loop,
and appropriately compensated.
that is, the momentum control loop must have a conIn order to determine an inverse solution to equation siderably slower response with respect to the attitude
(8) even when the rank of A is less than 3, the Singu- control loop.
larity Robust Inverse solution obtained by solving the The external torque to be applied to the spacecraft refollowing minimization problem must be invoked:
quired to compensate for the gimbal angle offset is
taken as
1
min eT We
(10)
(12)
Tr = −k hcmgs = −A(θ)θ̇e
2

ḣ − Aθ̇
where
e=
θ − θ∗
θ̇
θ̇e =


∆t
P 0
w=
θ∗ is the gimbal angle reference vector and ∆t is the
0 Q
time it takes the current gimbal angles to converge to
where P and Q are positive definite weighting matri- the reference gimbal angles (response time of the momentum control loop).
ces, that is, P = PT > 0 and Q = QT > 0.
Minimizing for θ̇, the singularity robust inverse solu- External torques may be generated by such devices as
thrusters or magnetic coils. Since the compensation
tion can be obtained as
of the external disturbances is better handled continθ̇ = A# ḣ
(11) uously, and given the usual restrictions on waste of
The Modelica Association

39

Modelica 2005, March 7-8, 2005

T. Pulecchi, M. Lovera

• Rotor: Model of a Single Gimbal Control Moment Gyro, including as input the gimbal angular
rate (feeded by the attitude control system) and as
output the gimbal angle. Developed using standard Modelica Multibody Library components.

consumable in space applications, magnetic control is
usually preferred.
A set of three magnetic coils, aligned with the spacecraft principal inertia axes generate torques according
to
Tcoils = mcoils × b
(13)

• Cluster: Model including the classical set of four
pyramid-mounted Single Gimbal Control Moment Gyros arrangement. Developed using standard Modelica Multibody Library components.

R3

is the vector of magnetic dipoles
where mcoils ∈
for the three coils, representing the actual control variables for the coils, and b(t) ∈ R3 is the Earth magnetic
field described in the body reference frame. The dy• Attitude Control System: Block computing the
namics of the electric coils reduce to a very short elecrequired gimbal rates for the four Single Gimbal
trical transient, and as such can be neglected.
Control Moment Gyros used as control torque acBy equating Eqs. (12), (13) and left multiplying by
tuating devices.
b(t), the magnetic dipole to be applied by the coils and
the resulting torque may be derived
For each model component, a short description is
given in the following subsections.
b × (A(θ) θ̇e )
mcoils = −
(14)
b2

7.1

Extended World model

b × (A(θ) θ̇e )
×b
b2

The Extended World Model is an extension of the
(15) former Modelica.MultiBody.World model, including
among the available selections a more sophisticated
model for the Earth’s gravity field (described up to
7 Model components for CMGs
the J2 term of the Earth’s gravitational potential) and
a model for Earth’s magnetic field (modelled up to the
Taking advantage of the recently released New Mod- quadrupole terms).
elica Multibody library (see [15]), a set of simulation As a consequence of Earth’s oblateness and not homotools has been developed for satellite attitude and or- geneity, the geomagnetic and gravitational potentials
bit dynamics. Specifically, the following components are a non linear function of both the point latitude and
have been developed:
longitude, in addition to the distance from the center
of the Earth.
• Extended World Model: a new World model, ex- The Earth’s gravitational potential Ug may be detending Modelica.MultiBody.World has been de- scribed by the function
fined. It accounts for a more refined description
∞
of the Earth’s gravitational potential and introµ
Re
Ug (r, θ, λ) = − {1 + ∑ ( )n Jn Pn (cos(θ))+
duces a model for the geomagnetic field. Such
r
n=2 r
an extension to the basic World model provided
∞ n
Re
in the Multibody library plays a major role in the + ∑ ∑ ( )n Pnm (cos(θ))(Cnm cos(mλ)+Snm sin(mλ))}
n=2 m=1 r
realistic simulation of the dynamics of a spacaecraft as the linear and angular motion of a satellite where Pm are the Legendre polynomials
n
are significantly influenced by its interaction with
1 dn 2
the space environment.
(x − 1)n
Pn (x) = n
2 n! dxn
• Extended rigid body model: similarly, a
d m Pn (x)
new rigid body model, extending ModelPnm (x) = (1 − x2 )m/2
dxm
ica.MultiBody.Parts.Body has been defined. The
main modification is the possibility of taking into Re is the mean equatorial Earth radius, r,θ and λ are
account the interaction between the spacecraft the point’s spherical coordinates and coefficients Jn ,
and the geomagnetic field, i.e., to model the ef- Cnm , Snm are the zonal, sectoral and tesseral coefficients.
fect of magnetic torques applied on the satellite For the purpose of attitude control simulations a satisfactory approximation can be obtained by neglecting
while orbiting around Earth.
Tcoils = −

The Modelica Association

40

Modelica 2005, March 7-8, 2005

Object-oriented modelling of the dynamics of a satellite equipped with Single Gimbal Control Moment Gyros

n
1
1
2
2
2

m
0
1
0
1
2

g [nT]
-29682
-1789
-2197
3047
1685

h [nT]

7.2

5318

This new component extends the Modelica.MultiBody.Parts.Body model to account for
the effects of the Earth’s magnetic field in terms of
torques applied to the satellite. Indeed, if the spacecraft possesses a magnetic dipole m, it experiences an
external torque T given by

-2356
-425

Table 1: Coefficients of the geomagnetic field model.

Extended rigid body model

T = m × B,
(18)
the terms after J2 . The Earth gravitational field components (expressed in spherical coordinates) are then where B is the geomagnetic field vector in body coorgiven by
dinates. Note, in passing, that the ability of taking into
account in the rigid body model the interaction with
∂Ug 1 ∂Ug
1 ∂Ug
,
,
}. (16) the geomagnetic field makes it possible to fulfill two
g = −∇Ug = −{
∂r r ∂θ r sin(θ) ∂λ
different modelling goals: first of all to simulate the
As for the geomagnetic potential Um , it is described by effect on the satellite dynamics of a residual magnetic
the function
dipole, such as due to the internal magnetic field generated by on-board electrical equipment; furthermore,
Re ∞ n Re n+1
it is possible to model the effect on the angular moUm (r, θ, λ) =
∑ ∑ ( r ) Pn m (cos(θ))
µ n=0
tion of the spacecraft of magnetic actuators, which, as
m=0
m
m
previously
mentioned, are frequently used, specially
(gn cos(mλ) + hn sin(mλ))
in small satellite missions, for attitude or momentum
m
where gm
n and hn are the Gauss coefficients appropriate management.
to the Schmidt polynomials Pn m
Pn,0 (x) = Pn0 (x)

7.3

Rotor

The SpacecraftDynamicsLibrary.Rotor model simulates a Single Gimbal Control Moment Gyro, which
has been chosen as the primary actuation source for
A first approximation for the geomagnetic potential the satellite attitude manoeuvering and control. The
is obtained by neglecting the terms after the quadru- following standard Modelica library components have
pole. The coefficients for the geomagnetic poten- been employed:
tial adopted in the simulation environment correspond
to the so-called International Geomagnetic Reference
• MultiBody.Interfaces.Frame a, used as the
Field (IGRF) model for the Earth’s magnetic field and
SGCMG-satellite connecting point.
are given in Table 1. The components of the geomag• MultiBody.Joints.ActuatedRevolute, used to
netic field (expressed in spherical coordinates) are then
model the SGCMG rotational degree of freegiven by
dom. The gimbal speed is driven through a
1 ∂Um
∂Um 1 ∂Um
Mechanics.Rotational.Speed by the input signal
B = −∇Um = −{
,
,
}. (17)
∂r r ∂θ r sin(θ) ∂λ
coming from the satellite attitude control system
(SpacecraftDynamicsLibrary.ACS block).
The new function magneticField, embedded in the
World model, receives as input the body position and
• Two Mechanics.Rotational.Speed
provides as outputs the corresponding components of
• Blocks.Interfaces.InPort, feeding to the SGCMG
the geomagnetic field vector B, expressed in the ECI
the desired gimbal rate.
reference frame. Since the geomagnetic field model
is defined with respect to the rotating ECF reference
• Mechanics.Rotational.Sensors.SpeedSensor
frame, an additional parameter UT0 , defining the initial
value for the Universal Time (UT ) and whose default
• MultiBody.Parts.FixedTranslation
value is set to zero, allows to start the simulation with
a desired initial rotation of the ECF reference frame
• MultiBody.Parts.Rotor1D, used as the physical
with respect to the ECI reference frame.
rotor. Its speed is kept constant by means of
Pn,m (x) = (

2(n − m)! 1/2 m
) Pn (x).
(n + m)!

The Modelica Association

41

Modelica 2005, March 7-8, 2005

T. Pulecchi, M. Lovera

an electrical motor, whose dynamic has not been mission scenario has been considered, namely:
modelled at this stage, and which is represented
• Spacecraft in equatorial orbit (0o inclination).
by a Blocks.Sources.Constant. The rotor rotational inertia has been assigned such that the re• Orbit altitude of 450 Km (a typical altitude for a
sulting angular momentum along the rotor axis is
small scientific mission).
1.76Nms.
• The attitude control must keep an Earth pointing
attitude, aligned with the Pitch-Roll-Yaw reference frame (orbital frame).

• Blocks.Continuous.Integrator
• Blocks.Sources.Constant, forcing the rotor angular rate to the chosen 4000 rpm nominal value.

• The spacecraft is provided with a star sensor for
attitude determination (i.e., an ideal state feedback situation is considered).

• Blocks.Interfaces.OutPort, used to output to the
satellite attitude control system (SpacecraftDynamicsLibrary.ACS block) the actual gimbal angle.

7.4

Attitude Control System

The SpacecraftDynamicsLibrary.ACS block computes
the four SGCMGs gimbal rates required to control the
satellite attitude.
The computation is performed in two separate steps.
First, the required control torques are computed, by
means of a suitable state feedback gain (designed via
LQR control techniques), where the system states considered in the control algorithm are the quaternion
errors and the satellite angular rates errors. Subsequently, the gimbal rates are derived in such a way
as to supply the required torques (via variation of the
SGCMGs cluster angular momentum). To this purpose, the control moment gyro steering logic proposed
by Wie, Bailey and Heiberg [22] was adopted.
The SpacecraftDynamicsLibrary.ACS provides the
four SGCMGs gimbal rates, and receives as inputs the
gimbal angles, the satellite inertial attitude quaternion,
the measured gimbal rates and the unit vectors of the
local orbital frame.

7.5

Cluster

The SpacecraftDynamicsLibrary.Cluster model simulates the classical configuration of four identical pyramid mounted Single Gimbal Control Moment Gyros,
with a skew angle β = 54.73o . It employs four SpacecraftDynamicsLibrary.Rotor models.
Receives as input the SGCMG gimbal rates computed
by the SpacecraftDynamicsLibrary.ACS block.

8

• Attitude control is based on a set of four pyramid
mounted Single Gimbal Control Moment Gyros.

Simulation study

In order to analyze the performance of the spacecraft
dynamics library components developed, a specific
The Modelica Association

• The spacecraft is subject to the effect of a magnetic disturbance torque, due to a residual magnetic dipole for which a value of 1Am2 along each
body axes has been assumed.
As an illustrative example, a simulation has been carried out in which the initial conditions for the spacecraft are characterised by a high value of the components of the angular rate, such as would occur during
the initial acquisition of the desired Earth pointing attitude. Figure 2 shows how three axis attitude control
is achieved by means of the four SGCMG actuators.
In particular, note that the residual pointing error due
to the geomagnetic disturbance torque is hardly visible. The corresponding time history of the geomagnetic field along the considered orbit and of the associated disturbance torque are shown in Figure 3. As expected, since the considered spacecraft is operating in
an equatorial orbit, the only significant component of
the geomagnetic field is aligned with the orbit normal
(Z ECI axis). In spite of this, it is interesting to note
that because of equation (18) the spacecraft is subject
to a disturbance torque along all three axes.
As was mentioned previously, external disturbance
torques force the gimbal angles of the CMGs to slowly
drift away from their optimal value. In particular, the
periodic component of the magnetic torques force a
cyclic variation in the angular rate of the SGCMGs,
while the secular component lead to a linear increase
in the gimbal angular rates. This can be sustained up
to the physical limit for the rotational speed of the device. In order to prevent this limit from being reached,
the actuator must be desaturated, i.e. an extra set of
actuators, generating external torques, must be used to
dump momentum from the spacecraft.

42

Modelica 2005, March 7-8, 2005

Object-oriented modelling of the dynamics of a satellite equipped with Single Gimbal Control Moment Gyros

−6

1
8

x 10

q

B [Tesla]

1

0.98

0.94

0

0.05

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

0.5

q2

0.1

0

0.05

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

BY [Tesla]

10

0.5

q3

0.1

0.05

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

0.5
BZ [Tesla]

0

q4

0

0

0.05

0.1

0.15

0.2

0.25
Orbits

0.3

0.35

0.4

0.45

1.5

2

2.5

3

3.5

4

0
−5
x 10

0.5

1

1.5

2

2.5

3

3.5

4

0

0.5

1

1.5

2
Orbits

2.5

3

3.5

4

0
−5
x 10

0.5

1

1.5

2

2.5

3

3.5

4

0
−5
x 10

0.5

1

1.5

2

2.5

3

3.5

4

0

0.5

1

1.5

2
Orbits

2.5

3

3.5

4

2.43
2.42

0.5
−5

3.5

−3

5

1

2.44

2.41

−0.5

0.5

0

2.45

0.5

0
−6
x 10

5

−5

0

−0.1

4
2

0

−0.1

6

X

0.96

x 10

x 10

T [Nm]

ω1 [rad/s]

3
2.5

X

0

2

−5

1.5
−10
15

0
0.05
−3
x 10

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

0.5

−1.5
T [Nm]

−2.5

Y

ω2 [rad/s]

−2
10
5

−3
0
−5

−3.5
0

0.05

0.1

0.15

0.2

0.25

0.3

0.35

0.4

0.45

0.5

2
1

0.04

TZ [Nm]

ω3 [rad/s]

0.06

0.02

−0.02

0
−1

0

−2
0

0.05

0.1

0.15

0.2

0.25
Orbits

0.3

0.35

0.4

0.45

0.5

Figure 2: Quaternion and angular rates for the attitude Figure 3: Geomagnetic field and magnetic disturbance
torque along the considered orbit.
acquisition.

9

Concluding remarks

The main issues related to the modelling and simulation of satellite dynamics have been described, the
results obtained so far in developing Modelica tools
for spacecraft simulation have been presented and a
case study for a satellite equipped with Control Moment Gyros as main attitude control actuators has been
illustrated by means of a simulation study.

10

Acknowledgements

This activity is supported by the Italian National Research Project “New Techniques of Identification and
Adaptive Control for Industrial Systems”.

MITA platform flight data. In: 52nd IAF International Astronautical Congress, Toulouse, France,
2001.
[2] Annoni, G., De Marchi, E., Diani, F., Lovera, M.
and Morea, G.D. Standardising tools for attitude
control system design: the MITA platform experience. In: Data Systems in Aerospace (DASIA)
1999, Lisbon, Portugal, 1999.
[3] Modelica Association, Modelica - a unified
object-oriented language for physical systems
modelling. Language specification. Technical report, http://www.modelica.org, 2002.
[4] Bate, R.R., Mueller, D.D. and White, J.E., Fundamentals of astrodynamics. Dover Publications
Inc., 1971.

References
[1] Alberti, M., De Rocco, L., Morea, D., and
Lovera, M. Environmental external torques estimation of a low Earth orbiting satellite based on
The Modelica Association

43

[5] Della Torre, A., Lupi, T., Sabatini, P. and Coppola, P. MITA: the Advanced Technology Italian Minisatellite.In: Data Systems in Aerospace
(DASIA) 1999, Lisbon, Portugal, 1999.
Modelica 2005, March 7-8, 2005

T. Pulecchi, M. Lovera

δ1

0.2

ternational Modelica Conference, Oberpfaffenhofen, Germany, 2002.

0.1

0

0

0.5

1

1.5

2

2.5

3

3.5

4

[15] Otter, M., Elmqvist, H. and Mattsson, S. E. The
New Modelica MultiBody Library. In: Proceedings of the 3nd International Modelica Conference, Linköping, Sweden, 2003.

δ2

0.2

0.1

0

0

0.5

1

1.5

2

2.5

3

3.5

4

0

0.5

1

1.5

2

2.5

3

3.5

4

0

0.5

1

1.5

2
Orbits

2.5

3

3.5

4

δ3

0.4

0.2

0

[16] Otter, M. and Olsson, H. New features in Modelica 2.0. In: Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen,
Germany, 2002.

δ4

0.4

0.2

0

[17] Roithmayr, C., Karlgaard, C., Kumar, R. and
Bose, D. Integrated Power and Attitude Control
Figure 4: Gimbal angles for the attitude acquisition.
with Spacecraft Flywheels and Control Moment
Gyroscopes. Journal of Guidance, Control, and
[6] Fritzson, P. and Bunus, P. Modelica - a genDynamics, 27(5):859-873, 2004.
eral object-oriented language for continuous and
discrete-event system modelling and simulation. [18] Schaub, H. and Junkins, J.L. Matlab toolbox for
rigid body kinematics. In: AAS/AIAA Space
In: Proceedings of the 35th IEEE Annual SimuFlight Mechanics Meeting, Breckenridge, CO,
lation Symposium, San Diego, CA, 2002.
1999.
[7] Hughes, P. Spacecraft attitude dynamics. John
[19] Sidi, M. Spacecraft dynamics and control. CamWiley and Sons, 1986.
bridge University Press, 1997.
[8] Lappas, V. J., Steyn, W. H., and Underwood, C.I.
Practical Results on the Development of a Con- [20] Silani, E. and Lovera, M. Magnetic spacecraft
attitude control: A survey and some new retrol Moment Gyro based Attitude Control Syssults. Control Engineering Practice, 13(3):357tem for Agile Small Satellites. In: Proceedings
371, 2005.
of the 16th AIAA/USU Small Satellite Conference, Session SSC02-VIII-8, 2002.
[21] Wertz. Spacecraft attitude determination and
control. D. Reidel Publishing Company, 1978.
[9] Larsen, W.J. and Wertz, J.R., editors. Space mission analysis and design. Kluwer Academic Pub- [22] Wie, B., Bailey, D., and Heiberg, C. Singularlisher, 1992.
ity Robust Steering Logic for Redundant SingleGimbal Control Moment Gyros. Journal of Guid[10] Lovera, M. Object-oriented modelling of spaceance, Control, and Dynamics, 24(5):865-872,
craft attitude and orbit dynamics. In: Pro2001.
ceedings of the 54th International Astronautical
Congress, Bremen, Germany, 2003.
[11] Lovera, M. and Astolfi, A. Spacecraft attitude
control using magnetic actuators, Automatica,
40(8):1405–1414, 2004.
[12] Martinez-Sanchez, M. and Pollard, J.E. Spacecraft electric propulsion - an overview. Journal
of Propulsion and Power, 14(5):688–699, 1998.
[13] Montenbruck, O. and Gill, E. Satellite orbits:
models, methods, applications. Springer, 2000.
[14] Moorman, D. and Looye, G. The Modelica flight
dynamics library. In: Proceedings of the 2nd InThe Modelica Association

44

Modelica 2005, March 7-8, 2005

Collision Handling for the Modelica MultiBody Library

Collision Handling for the Modelica MultiBody Library
1

2

Martin Otter2, Hilding Elmqvist1, José Díaz López1

Dynasim AB, Lund, Sweden, {Elmqvist, Jose.Diaz}@Dynasim.se
DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany, Martin.Otter@DLR.de

Abstract
The Modelica MultiBody library is extended with
collision handling. It is demonstrated how to use this
new feature. Different implementations are explained
based on parametric surfaces, on surfaces described
by algebraic constraints, and on surface descriptions
by primitives and triangles using the collision
package SOLID 3.5. Furthermore, the response
calculation by a resultant contact force and torque is
discussed.

1

Introduction

Modeling of contacts between mechanical objects is
important in many disciplines such as wheel handling for vehicle dynamics, robot gripping, CAM
modeling, etc. The Modelica.Mechanics.MultiBody
library [13] is extended with support for collision
handling. The user interface and the implementation
variants are discussed in the next sections.
Describing collisions between mechanical bodies is
still a difficult topic. The solution can be divided into
two main steps:
(1) Collision detection of surfaces, determining features such as shortest distances, penetration depths
and contact normal vectors. Several software systems are available for this task, e.g., SWIFT [6],
ODE [16] or SOLID [2][3]. This is also an important
part of CAD and FEM systems. Fast real-time solutions are mainly driven by the game industry due to
their particular needs [5][16].
(2) Calculation of the contact response. Several
quite different approaches are in use:
(2a) The response is computed in an idealized way
using impulses based on an impact law such as Poisson’s hypothesis: relating the impulses of the compression and decompression phase of an impact to
each other, see, e.g., [15][10][5]. The main advantage is that only few constants are needed to describe
the impact law and that the integrator step size is not
influenced by the response calculation because it is
The Modelica Association

45

performed in an infinitely small time instant. The
disadvantages are that such idealized impact laws are
only valid for stiff collisions and that the constants of
the impact law cannot be computed by material
properties of the colliding bodies, i.e., they must be
determined by measurements. Furthermore, it is
quite involved to compute the new initial conditions
after an impact in a robust way, especially if several
surface contacts are present at the same time instant.
In the latter case either no or infinitely many solutions may exist using impulse descriptions. For a
physically meaningful response there are cases
where multiple impacts have to be applied one after
each other whereas also cases are present where they
must be applied altogether (for a more thorough discussion, see [5], pp. 256 – 264).
(2b) The response is computed by a simple elastic
spring/damper element. E.g., the spring force is just
proportional to the penetration depth. The advantages of this approach are its simplicity and that it
can be used for stiff and soft contacts. This approach
works also reasonably well if several contact points
are present at the same time instant. The disadvantage is that the integrator step size is reduced significantly in the contact phase in order to catch the rapidly changing contact forces and torques. A necessary and harder task is to determine experimentally
the spring and damper constants. Those are in consequence only valid in situations close to the experimental conditions. The main reason is that the contact force is not only proportional to the penetration
depth but rather to the contact area and the contact
volume.
(2c) The response is computed by taking into account the contact area and the contact volume. This
might be performed by a discretization of the contact
area or the contact volume, see, e.g., [8][9]. Contrary
to (2b), the force and torque computation will be
more precise and the material properties, such as the
E-modul and the contraction number ν, can be used
to calculate the spring constants. Furthermore, the
contact torque can be calculated in a reasonable way.
This torque is particularly important for gripping
operations.
Modelica 2005, March 7-8, 2005

H. Elmqvist, M. Otter, J. Dı́az López

(2d) The response is computed for special situations,
e.g., for wheel/road contact [14]. Solutions that are
specialized to a particular contact problem are usually more precise and practically applicable as the
generic solutions of (2a,b,c).
At the moment, it is not possible to implement the
solution with impulses (2a) in a generic way in
Modelica. For special cases it can be implemented
with the reinit(..) operator. The reason is that an appropriate Modelica language element is missing as
well as the needed symbolic algorithms for the most
general cases. In the European project “RealSim”
basic research was carried out to handle models with
varying index and with dirac impulses. The latter
might be implicitly occurring at switching points
where the number of states, and therefore also the
DAE index, is changing. For certain classes of systems a reasonable solution method was developed
[11]. Still, the algorithms are in a research stage.
For this reason, in this article only elastic response
actions according to (2b) and (2c) are taken into account. A specialized solution for wheel/road contact
is already available in the Modelica VehicleDynamics library [1].

2

The ball is described by a sphere of the component
“FixedShape” together with body properties, such as
mass and inertia. The record “contactData” contains
material constants that are used in the table and
sphere components. No special collision handling
objects are needed. Instead, the existing “MultiBody.Visualizers.FixedShape” component has been
modified to optionally detect and treat collisions for
the supported visual shapes shown in the next figure:

Users View

In this section the user’s view of the library is shortly
sketched. This view is independent of the implementation variants discussed in subsequent sections.
Components are provided to handle collisions between bodies using elastic force/torque laws at contact points. An example is shown in the following
figure where a ball is thrown on a table. The ball first
bounces on the table, then into the wall and finally
rolls on the table.

For collision detection, shapes "pipe", "gearwheel"
and "spring" are treated as full cylinders. There are
currently limitations for shapes using “*.dxf” files
(AutoCAD R12 descriptions): Only sets of triangles
are supported and only one contact point between
two surfaces is taken into account, although more
contact points might be present for non-convex objects. Note, all objects can be scaled in the 3 coordinate axes by providing length, height and width of
the shape. E.g., ellipsoids are also supported by defining shapeType="sphere" and appropriate length,
height, and width scaling.
The following new parameters are present in a
FixedShape object:

This example is defined by the Modelica model of
the next figure. In brief, there is a modified MultiBody.World component with a new subcomponent
named "collisionHandling". This new object performs collision detection and contact response calculations. The table is defined by two boxes of the
component “MultiBody.Visualizers.FixedShape”.

The Modelica Association

46

The collision handling has to be explicitly activated
by setting "contactHandling = true". The effect in
Modelica 2005, March 7-8, 2005

Collision Handling for the Modelica MultiBody Library

this case is that the distance between this object and
all other objects that have contactHandling = true is
continuously computed and monitored. When the
distance between two objects becomes zero, an event
is triggered and a contact response is applied.
If two FixedShape objects are rigidly attached to
each other (see, e.g., the two boxes representing the
table in the example above), a contact would permanently be present. To avoid this, all objects are reduced in size by a factor of "1 - 1.e-9" for the collision detection. As a consequence, shapes that are
fixed together, do not lead to an unnecessary contact
response computation.
Parameter “bodyIndex” is a unique Integer identifier
for each “FixedShape” object. For instance, if 4
FixedShape objects with contactHandling = true are
present, they must have bodyIndex = 1, 2, 3, and 4.
Additionally, in the "World" object, parameter
"nContactBodies" has to be set to the number of
FixedShape objects with contactHandling = true. In
the example above, nContactBodies = 4 is required.
There is currently a Modelica language enhancement
under development, in order that this user input is no
longer required since it can be automatically deduced
by a Modelica translator.
The data for the response calculation are provided
via parameter record "contactProperties", see next
figure. It defines material data of the corresponding
surface. The type of response calculation used for all
collisions is defined in the World object: If parameter simpleResponse = true, a linear spring and a linear damper force acts in contact normal direction.
Additionally, linear rotational damping proportional
to the relative angular velocity is present in contact
normal direction, and a sliding friction force acts in
opposite direction to the tangential sliding velocity at
the contact point. If simpleResponse = false, the contact area is discretized and a resultant force and
torque is computed by summation of appropriate
forces over the contact area. The latter option is currently under development. More details of the
force/torque calculations are given in section 4.5.

figure below. For “*.dxf” files, a layer of spheres
with radius “edgeRadius” is put on the surfaces to
get a smooth surface description, too, see right part
of figure below. The edge rounding and the “layer of
spheres” is used for collision detection and response
calculation. It is currently not shown in the rendering
(animation). It is recommended to use a non-zero
edgeRadius because the collision detection will be
usually faster and more robust. Still, it is possible to
set edgeRadius=0. The technique of smoothing the
surfaces with spheres is from [3][2].
edgeRadius
edgeRadius

In sublibrary MultiBody.Parts the available body
components have now also optional collision handling support. Furthermore, new body types have
been added, as shown in the next figure:

For example, “BodyEllipsoid” is a part that defines
an ellipsoid by length, width, height and material
properties. From this information, the body properties (mass, center of mass, inertia tensor) are computed and the rendering and collision handling is
deduced.

3

Applications

In this section some applications of the library are
shown.
3.1

Free Flying Objects

Five different free flying objects are colliding with
each other. The start configuration is shown in the
next figure. The 4 objects on the right are in rest at
the beginning and the sphere at the left side is flying
in the direction of the other objects.
Finally, parameter “edgeRadius” defines how much
the edges of primitive shapes, such as boxes, cylinders etc., are “rounded” with spheres, see left part of
The Modelica Association

47

Modelica 2005, March 7-8, 2005

H. Elmqvist, M. Otter, J. Dı́az López

After some time we observe how the trajectory of the
pyramid evolves. Due to friction, the velocity and
angular velocity of the pyramid is permanently reduced.

Several collisions between all objects occur after a
few seconds:

The final position after gliding over the surface is
shown in the next figure

This system is defined with the following Modelica
model:

as the pyramid is falling over the edge of the table
with a velocity that is almost zero.
3.3

3.2

Gripping

The sequence of images below shows two blue fingers gripping a lying red object (all cylindrical dxfdefined objects). The fingers are attached with prismatic joints to a revolute joint. The lying object is
gripped since it is squeezed between the fingers. Due
to the friction torque between the surfaces, the red
cylinder is elevated after gripping it and rotating the
revolute joint.

Collision of triangularized surface
with a table

A simple application of AutoCAD files in the library
is shown in the following example: An AutoCAD
generated pyramid is rotating around his main axis
and falls to a table.

The Modelica Association

48

Modelica 2005, March 7-8, 2005

Collision Handling for the Modelica MultiBody Library

The model of this experiment setup is shown below.
“Horizontal” is the lying red cylinder and “Finger1”
and “Finger2” are the two fingers. This example
shows the important role of the friction torque. If this
feature would not be present in the model, then the
red cylinder would rotate after gripping.

(1) If a public array component, A, is declared using
the subscript [each], e.g. Real A[each], it has the
same access restriction as though it were protected
except the "uniqueElement" operator can be applied
to the array. This is the only allowed use of the
uniqueElement operator and the only allowed use of
the array name outside the declared scope.
(2) The size of all array components with declared
size [each] starts at zero and is then increased as follows. This is performed before size() of the array can
be determined (e.g. to determine the size of other
arrays).
(3) For each use of the uniqueElement(..) operator
the size of the array component is increased by one
and a unique element of the array is referenced.
These new language elements will allow an implementation where the unique collision object indices
are automatically derived without requiring them
from the user. This feature will be also useful for
other purposes.
4.2

4

Implementation

In this section implementation details and variants
for the collision handling are discussed.
4.1

Central Collision Handling

Since distances and contact response calculations are
needed between any two collision objects, a central
collision handling is present in the modified World
component. In order that this is possible, every collision object needs a unique Integer identifier. The
surface data, position, orientation, forces and torques
are copied in appropriate arrays using the corresponding Integer identifier as index in these arrays.
Currently, this identifier has to be provided manually
by the user as shown in section 2.
As already mentioned, a Modelica language enhancement is under development to get rid of this
unnecessary user input. The current plan is to introduce the new dimension qualifier “each” and the new
operator “uniqueElement(..)” to automatically provide a unique array index for objects. Examples:
Real
Real
Real
Real

vec[each,5,3];
subvec[5,3] = uniqueElement(vec);
x[each];
xv = uniqueElement(x);

The first implementation variant for the collision
handling uses parametric surfaces. That is, the absolute position vector r to each surface point is described as a vector valued function of two parameters, called α and β .

r = r (α , β )
Two tangent vectors eα and eβ are defined by partial
derivatives from which the normal n to the surface
can be computed:

∂r
= rα (α , β )
∂α
∂r
eβ =
= rβ (α , β )
∂β
eα =

n = eα × e β = n (α , β )
Both position and orientation of the surface patch
close to a possible contact point are defined as functions of α and β . The tangential planes of two surfaces that are potentially colliding are constrained to
be parallel, i.e., their normal vectors are parallel
(quantities belonging to surface “a” are denoted by
superscript “a”, e.g., x a ):

n a (α a , β a ) + λ1 ⋅ nb (α b , β b ) = 0
Furthermore, the relative position vector of the contact point candidates is constrained to be parallel to
the surface normals:

The following rules apply:

The Modelica Association

Variant 1: Parametric surfaces

r b (α b , β b ) − r a (α a , β a ) = λ2 ⋅ n a (α a , β a )
49

Modelica 2005, March 7-8, 2005

H. Elmqvist, M. Otter, J. Dı́az López

These constraints constitute 6 scalar equations in the
unknown variables α a , β a , α b , β b , λ1 , λ2 . These
equations are in general nonlinear and have to be
solved per each potential collision point pair. We
may encounter computational problems since multiple solutions may exist. For closed surfaces, at least
4 different solutions exist (closest-closest, closestfarthest, farthest-closest, farthest-farthest). A feasible
solution must have a positive scalar product between
the surface normal and the relative distance:

n a (α a , β a ) ⋅ (r b − r a ) > 0
For convex surfaces, the solution of the above
nonlinear system of equations, taking into account
the inequality constraints, gives the two closest
points when the bodies are apart. It is possible to
track the correct closest points also for non-convex
surfaces provided good starting values are given for
the unknown variables.
The local coordinate systems at these points as well
as the relative position vector are illustrated below as
rendered by Dymola during animation
.

leftmost valley with the fixed point following the
same path.
The major drawback of closed parameterized surfaces is the occurrences of singular points. For example, every closed surface has at least one singular
point where the calculation of the normal vector fails
because at least one of the tangent vectors becomes
zero. For a sphere, these are the “north” and “south”
pole of the sphere. Therefore, in general it is not possible to get a robust solution of the non-linear system
of equations. For special cases where it is guaranteed
that the singular points are outside of the operation
region, a parametric surface might be used without
re-parameterization, see, e.g., [12] that demonstrates
collision handling of a CAM. However, for a generic
collision handler, parametric surfaces are difficult to
treat, since singular points require a reparameterization of the surface description.
4.3

Variant 2: Algebraic constraint surfaces

An alternative is to describe especially closed surfaces with constraint equations

0 = h(r )
For example, a sphere can be defined by

h(r ) = x 2 + y 2 + z 2 − 1
An approximate representation of a box can be made
by

h(r ) = x 20 + y 20 + z 20 − 1
Certain special surfaces such as ellipsoid, plane and
parabola have been implemented as parameterized
surfaces. It is easy to add other surfaces by defining
corresponding parametric functions.
An example for a non convex parameterized surface
is shown below where a ball is thrown towards left
on a “cosine” surface.

and an approximation to a cylinder can be made by

h(r ) = x 20 + ( y 2 + z 2 )10 − 1
as shown below.

By choosing higher values of the exponent, the edges
get sharper. It is possible to define cones and pyramids as well by such closed formulas. However, it is
difficult to find the closed formula for arbitrary surfaces.
This representation allows the smooth normal to be
calculated as the gradient

 ∂h

n(r ) = grad ( h(r ) ) = 

 ∂x

∂h
∂y

,

∂h 



∂z 

It should be noted that there are no singular points
when using this surface representation. Inserting the

The side view shows the trajectory of one point on
the ball. The ball oscillates forth and back in the

The Modelica Association

,

50

Modelica 2005, March 7-8, 2005

Collision Handling for the Modelica MultiBody Library

definition of the normals into the same constraint
equations as used in variant 1, and considering the
constraint equations for each surface, 8 scalar equations in the unknown variables r a , r b , λ1 , λ2 are obtained. Note, that start values are easier to give in
this representation since the position vectors themselves are unknowns.
This approach has the advantage to get smooth surface descriptions. The drawback are the highly
nonlinear equations closed to the edges, especially
for high exponents.
In both variant 1 and 2, partial derivatives of functions defining the surfaces are required in the model
code. This can be achieved by a special operator in
the Modelica code and automatic differentiation. For
details see, [12].
4.4

Variant 3: Collision handling with SOLID

As a third variant, the collision detection of shapes
and the computation of the penetration depth between shapes is performed with the software system
SOLID 3.5 [3][2]. The SOLID software is free for
non-commercial purposes. Commercial use requires
a license. The SOLID software supports collisions
between primitives such as spheres and cylinders, as
well as between complex convex and non-convex
objects described by a set of polytopes (point, line
segment, triangle, tetrahedron, convex polygons, and
convex polyhedrons).
The software provides a good interface to define "response functions" that are called when contact happens. In these response functions, contact forces and
torques could be programmed. The disadvantage of
this interface is that the integrator does not have information about occurred collisions and reduces the
step-size around a collision only due to the sharp
changes in contact response. Experiments showed
that it is difficult to get a robust solution. In general,
the integrator may stop for a corrector failure. The
reason is that integrators require that the equations
describing the system are continuous with a smooth
first or higher derivative. At a contact point, these
assumptions are not fulfilled and since the changes in
the contact forces and torques are so drastic, it is understandable that an integrator may fail. This is also
the reason why slight changes in the tolerances of the
integrator or the tolerances of the contact detection
may change the simulation time very significantly.
For this reason, another interface of SOLID is used
to explicitly compute either the distance of two objects or the penetration depth of two colliding objects. This allows to compute indicator functions for
the root finder of an integrator, in order that an event
The Modelica Association

51

is generated when contact occurs. The solution is
more robust and usually more efficient than the solution with "response functions".
The main disadvantage is that the calling environment has to perform all distance function calls by its
own. In the current implementation a brute force
method is used by computing the distances between
all defined objects. The "broad phase" present in the
"response function" interface of SOLID to reduce the
number of distance tests significantly (based on
"axis-aligned-bounding-boxes" approximations of
the objects), is not present with the chosen "rootfinding" approach. This will be improved in the future.
The SOLID package uses a generalized version of
the GJK algorithm [7] to compute the distances between convex polytopes in a finite number of steps
and for other convex surfaces converges globally
with a fast convergence rate. For the penetration
depth calculation an algorithm is used that is based
on similar principles as the GJK algorithm. Details
are described in the book [2].
In order that the two algorithms can be applied, a
"support mapping" of the corresponding surface is
needed. This is a function sA that maps a vector n to
a point on a convex shape A according to:
sA(n) returns a point on the surface of A
such that “n·sA(n) = max(n·r for all r in A)”
This definition is visualized in the next figure for a
cylinder:

The arrow in this figure is vector "n" of the support
mapping. This vector is proposed and changed by the
distance and penetration depth algorithm. The "grey"
shape in the figure above is a plane that is perpendicular to "n" and is moved to the cylinder such that
the plane touches the cylinder. The support mapping
function has to return the coordinates of this touching point. If this is not unique, one of the points is
returned. For a smooth surface this just means that a
point r on the surface is defined as a function of its
normal n: r = r(n).
Due to this simple basic definition of a convex object
via a support mapping, a user can introduce additional base shapes in a simple way.
Modelica 2005, March 7-8, 2005

H. Elmqvist, M. Otter, J. Dı́az López

The "penetration depth" algorithm adds in every iteration an additional edge to a simplex that defines
the penetration volume. From this simplex, two
points are selected in such a way that both points are
on the surface of the respective shape and the distance between these two points is as small as possible. When moving the two collided objects along the
connection line of these two points, until the two
points coincide, then the two shapes are in touching
contact. These two points are reported as result of the
penetration depth calculation. The penetration depth
is then the distance between these two points and the
contact normal is on the connection line along these
two points.
The SOLID interface functions are used in the
World.collisionHandler component that has the following basic structure:
equation
// Compute signed distances
(signedDistance, ...) =
surfaceDistances(..);
// Generate event when distance is zero
for i in 1:nContactPairs loop
contact[i] = signedDistance[i] < 0.0;
end for;

1

if vt > vmin,m
ft = µm ⋅ f n ⋅ 
 vt / vmin,m else
 −1 if ωn < − ωmin,m

1
if ωn > ωmin,m
τ n = d w, m ⋅ f n ⋅ 
ω / ω
 n min,m else
f = f t ⋅ et + f n ⋅ e n
τ = τ n ⋅ en
where
fn
ft
τn
f
t
s
vn
vt

en
et

Function “surfaceDistances(...)” returns vector
“signedDistance”. An element of this vector signals
the shortest distance of two objects that are not yet in
contact by a positive value. A negative element characterizes the penetration depth of two objects that are
in contact. The for loop in the code fragment above
triggers events whenever two objects get in contact
and whenever two objects are separating. Finally, the
function “contactForces(...)” is used to perform the
response calculation. It returns the resultant forces
and torques acting at appropriate reference frames of
the corresponding surfaces.
Response calculation

Contact forces and torques are applied when the relative distance along the normal vector is negative,
signaling an interpenetration. As already shortly discussed in section 2, two different response calculations are provided: The first one uses simple
spring/damper elements. The second one discretizes
the contact area and a resultant response force and
torque is computed by summation of appropriate
forces over the contact area. This more precise calculation is currently under development. In the following, the first option is discussed in some more detail:

The Modelica Association

f n = min(cm ⋅ s + d m ⋅ vn , 0)

ωn

// Contact response calculation
(frame_a_f, ...) =
contactForces(contact, ...);

4.5

The response is computed according to the following
equations:

52

contact force in normal direction
contact force in tangential direction
contact torque in normal direction
resultant contact force
resultant contact torque
penetration depth (≤ 0)
relative velocity in normal direction
relative velocity in tangential direction
relative angular velocity in normal
direction
unit vector in normal direction
unit vector in tangential direction

In other words, a linear spring/damper element is
used to compute the force in contact normal direction. In tangential direction a sliding friction force is
taken into account, if the tangential velocity is larger
as vmin. Below vmin, the friction force is reduced so
that it is zero, when the tangential velocity becomes
zero. Sticking is currently not implemented. For
gripping operations, it is important to take into account the friction torque. This is accomplished by a
linear rotational damper that is proportional to the
normal force and the relative angular velocity. Finally, all force and torque parts are summed up resulting in the contact force and torque. Note, if the
normal force would become positive since the damping part is too large, it is reduced to zero, since a
positive normal force is physically not correct.
For the equations above material constants are
needed, e.g., for the spring and the dampers. However, only material data for the respective surfaces
are provided. The correct solution would be to apply,
say, (1) a spring/damper element on surface A using
the material constants of surface A, (2) a
spring/damper element on surface B using the material constants of surface B and (3) connect the
spring/damper elements of surfaces A and B in series. Due to the linear dampers, this would result in
Modelica 2005, March 7-8, 2005

Collision Handling for the Modelica MultiBody Library

additional differential equations depending on the
number of contact points. To avoid complications
and to enhance efficiency, the following approximation is used: A resultant spring constant is computed
from the surface data under the assumption of a series connections of two springs. For all other data,
mean values are used:

cm =

c A ⋅ cB
c A + cB

d m = 12 ⋅ ( d A + d B )

d w, m = 12 ⋅ ( d w, A + d w, B )

µm = 12 ⋅ ( µ A + µ B )

vmin , m = 12 ⋅ ( vmin,A + vmin,B )

ωmin,m = 12 ⋅ (ωmin,A + ωmin,B )

5

Outlook

An overview was given, in which way the Modelica
MultiBody library is extended with collision handling. The current stage is already useful for applications. Development continues to improve the collision handling:
• Using the “broad-phase” of SOLID to reduce the
number of collision tests significantly.
• Support more than one contact point between
two surfaces. This is important for non-convex
surfaces.
• Optionally, provide a more detailed response
calculation by discretization of the contact area.
• Reduce the limitations of “*.dxf” files.

Acknowledgements
Partial financial support of this work by the Toyota
Motor Corporation is gratefully acknowledged.

References
[1] Andreasson J. (2003): Vehicle Dynamics library.
Proceedings of Modelica’2003, ed. P. Fritzson, pp.
11-18. Download: http://www.Modelica.org/Conference2003/papers.shtml/
h28_vehicle_Andreasson.pdf
[2] Bergen G. van den (2004): Collision Detection in
Interactive 3D Environments. Elsevier and Morgan
Kaufmann Publishers.

The Modelica Association

53

[3] Bergen G. van den (2003): SOLID 3.5 - User’s
Guide to the SOLID Collision Detection Library.
On the CD of the book of G. van den Bergen [2].
[4] Dynasim (2005): Dymola – Users Manual
(http://www.dynasim.com)
[5] Eberly D.H., and Shoemake K. (2004): Game
Physics. Elsevier and Morgan Kaufmann Publishers.
[6] Ehmann S. H. (2000): SWIFT - Speedy Walking via
Improved Feature Testing. Version 1.0. Download:
http://www.cs.unc.edu/~geom/SWIFT/
[7] Gilbert E.G., Johnson D.W., and Keerthi S.S. (1988):
A fast procedure for computing the distance
between complex objects in three-dimensional
space. IEEE Journal of Robotics and Automation,
4(2), pp. 193-203.
[8] Hasegawa S., and Sato M. (2004): Real-time Rigid
Body Simulation for Haptic Interactions Based on
Contact Volume of Polygonal Objects.
EUROGRAPHICS 2004, ed. M.-P. Cani and M.
Slater, Volume 23, Number 3. Download:
http://eg04.inrialpes.fr/Programme/Papers/PDF/paper
1209.pdf
[9] Hippmann G. (2003): An Algorithm for Compliant
Contact between complexly shaped Surfaces in
Multibody Dynamics. Multibody Dynamics, Jorge
A.C. Ambr´osio (Ed.), IDMEC/IST, Lisbon, Portugal,
July 14. Download: http://www.pcm.hippmann.org/doc/eccomas03_hippmann.pdf
[10]Leine R.I., and Glocker C. (2003): A set-valued force
law for spatial Coulomb–Contensou friction.
European Journal of Mechanics A/Solids 22, pp. 193–
216.
[11]Mattsson S.E., Olsson H., and Elmqvist H. (2001):
Methods and Algorithms for Varying Structure
Hybrid DAE Simulation. EC IST Project RealSim
under contract IST-1999-11979, Internal Report 2.2.
[12]H. Olsson, H. Tummescheit, H. Elmqvist (2005):
Modeling with Partial Derivatives of Modelica
Functions and Automatic Differentiation.
Modelica’2005 conference, Hamburg, March 7-8.
[13]Otter M., Elmqvist H., Mattsson S.E. (2004): The
New Modelica MultiBody Library. Proceedings of
Modelica’2003, ed. P. Fritzson, pp. 311-330.
Download: http://www.Modelica.org/Conference2003/papers.shtml/h37_Otter_multibody.pdf
[14]Pacejka H.B. (2002): Tyre and Vehicle Dynamics.
Butterworth-Heinemann.
[15]Pfeiffer F., and Glocker C. (1996): Multibody
Dynamics with Unilateral Contacts. John Wiley &
Sons.
[16]Smith R. (2004): Open Dynamics Engine – V0.5
Users Guide. Download from http://ode.org.
[17]Wriggers P. (2002): Computational Contact
Mechanics. John Wiley & Sons.

Modelica 2005, March 7-8, 2005

The Modelica Association

54

Modelica 2005, March 7-8, 2005

Session 1b
Chemical Systems and Thermodynamic Systems I

The Modelica Association

55

Modelica 2005, March 7-8, 2005

The Modelica Association

56

Modelica 2005, March 7-8, 2005

The Modelica Bond-Graph Library

The Modelica Bond Graph Library
François E. Cellier
Institute of Computational Science
Swiss Federal Institute of Technology
ETH-Zentrum HRS H28
CH-8092 Zürich
Switzerland
FCellier@Inf.ETHZ.CH

Àngela Nebot
Llenguatges i Sistemes Informàtics
Universitat Politècnica de Catalunya
Jordi Girona Salgado, 1-3
Barcelona 08034
Spain
Angela@LSI.UPC.ES

Abstract
Bond graphs offer a domain-neutral graphical technique for representing power flows in a physical system. They are particularly powerful for representing
systems that operate in multiple energy domains,
such as thermal models of electronic circuits, mechanical vibrations in acoustic systems, etc. A bond
graph library was created for Modelica with graphical Dymola support. The library is presented in this
paper. Applications from different domains are offered to document its use.
Keywords: bond graph; energy modeling; thermodynamic modeling; Biosphere 2

1

Introduction

electrical power is being delivered from a voltage
source to a resistor. The corresponding bond graph
is:

where a source of effort, U0, delivers the electrical
power, Pel = U0·i, to the resistor, R1.
In our implementation, a third variable is also associated with each bond, a directional variable, d.
This variable indicates the direction of positive
power flow. It is encoded by setting d = −1 at the
emanating bondgraphic connector and d = +1 at the
receiving connector. The directional information is
used in the computations associated with junctions.
Bond graphs offer two types of junctions, the 0junction, and the 1-junction:

A bond represents the flow of power, P, from one
point of a physical system to another.

It is represented by a harpoon. There are two physical variables associated with each bond, an effort, e,
and a flow, f. The product of these two variables
represents the power:
P=e·f
In an electrical circuit, the effort variable is identified with the voltage, u, whereas the flow variable is
identified with the current, i.
In the electrical circuit:

The Modelica Association

In a 0-junction, the efforts are set equal, whereas the
flows add up to zero:
e[2:n] = e[1:n-1]
d’ · f = 0
In a 1-junction, the flows are set equal, whereas the
efforts add up to zero.
f[2:n] = f[1:n-1]
d’ · e = 0
Thus, the two junction types are duals of each other.
In an electrical circuit, the 0-junctions correspond to nodes, whereas the 1-junctions correspond
to meshes. We are now able to translate the circuit
diagram of an arbitrary electrical circuit into a corresponding bond graph.

57

Modelica 2005, March 7-8, 2005

F. Cellier, À. Nebot

2

Bond Graphs of Electrical Circuits

Given the electrical circuit:

Finally, junctions with only two bonds attached to
them can be amalgamated away. Thus, the final
bond graph can be drawn as follows:

we can represent each node, except for the ground
node, by a 0-junction, and we can represent each circuit element connecting two nodes by a 1-junction,
from which the circuit element is suspended. The
directions of positive power flows are chosen to coincide with the directions of positive current flow in
the circuit diagram.
For simplicity, let us first redraw the circuit diagram with the ground node split into multiple separate nodes.

This circuit diagram can be translated directly into a
corresponding bond graph:

Since the ground potential, v0, is equal to zero, the
bonds connecting to the ground don’t carry any
power. They can thus be eliminated.

The Modelica Association

3

Causal Bond Graphs

Since there are two physical variables associated
with each bond, we need two equations to compute
their values. It turns out that each end of the bond
computes one of the two variables. We can mark the
side that computes the flow variable by a short bar:
the causality stroke.
The Modelica Bond Graph Library offers causal
and a-causal bonds. Whereas the a-causal bonds
were implemented as Modelica models, the causal
bonds were implemented as blocks.
We recommend using causal bonds as much as
possible. The causalities associated with bonds attached to sources are fixed. Since an effort source
computes the effort, the causality stroke of its bond
must be away from the source. Since 0-junctions are
characterized by a single flow equation, there must
be exactly one causality stroke at a 0-junction. Since
1-junctions are characterized by a single effort equation, there are exactly n-1 causality strokes at a 1junction.
Capacitors and inductances have preferred causalities. Since we like to end up with differential
equations (integral causality), capacitors like to
compute the effort, whereas inductors prefer to compute the flow. Thus the preferred position for causality strokes of bonds attached to capacitors is away
from the capacitor, whereas the preferred position of
causality strokes of bonds attached to inductors is at
the inductor. The causalities of resistive elements
are free.

58

Modelica 2005, March 7-8, 2005

The Modelica Bond-Graph Library

In the case of the given circuit, the preferred
causality of all bonds is fixed. The causal bond
graph can be presented as follows:

On the other hand, if not all preferred causalities
can be satisfied, i.e., when the causality stroke of a
bond attached to either a capacitor or an inductor is
located at the incorrect end of the bond, the model
contains a structural singularity, i.e., consists of a
higher-index DAE system. Also in that case, acausal bonds should be used to give Modelica a
chance to reducing the perturbation index on its own.

5
We are now capable of reading out the causal equations from the bond graph. These are:
u0 = f(t)
i 0 = iL + i1
uL= u0
diL/dt = uL / L
v1 = u0
u1 = v1 – v2
i1 = u1 / R1
v2 = uC
i C = i1 – i2
duC/dt = iC / C
u2 = uC
i2 = u2 / R2
There is no advantage of using an a-causal bond
graph instead of a circuit diagram when modeling an
electrical circuit. The two representations are totally
equivalent to each other. However, there is a certain
advantage of using a causal bond graph, since the
equations describing the circuit can be read out of
the causal bond graph directly in their causal form.
Of course, there is no need to ever use causal
bonds in Modelica, as Modelica is perfectly capable
of determining the computational causality of all
equations on its own. Yet, we recommend using
causal bonds as much as possible, as they help the
modeler in analyzing his or her model.

4

Algebraic Loops and Structural
Singularities

When the mandated and preferred causalities of all
elements do not lead to a single assignment of all
causality strokes, the model contains one or several
algebraic loops. A-causal bonds must be used wherever the causality assignment is free.

The Modelica Association

A Hydraulic Motor Control System

We wish to model the following hydraulic motor by
a bond graph:

In hydraulic bond graphs, it is customary to identify
the pressure, p, with the effort variable, whereas the
volumetric flow rate, q, is identified with the flow
variable. The product of pressure and volumetric
flow is the hydraulic power.
Due to the compressibility of the liquid, the
change of pressure in each chamber is proportional
to the difference between inflow and outflow. In
terms of a bond graph, this looks like a capacitor attached to a 0-junction.
The flows qi, qe1, and qe2 are laminar leakage
flows. They are proportional to the pressure difference. Thus, they can be represented as linear resistors.
On the mechanical side, power can be written as
either force times velocity or torque times angular
velocity. Among bond graph practitioners, it has
become customary to identify the forces and torques
with effort variables, and the velocities and angular
velocities with flow variables.
Newton’s law states that the change in velocity
(or angular velocity) is proportional to the sum of all
forces (or torques). In terms of a bond graph, this
looks like an inductor attached to a 1-junction.

59

Modelica 2005, March 7-8, 2005

F. Cellier, À. Nebot

The two domains are coupled by a transformer,
as the force on the piston (or the torque on the screw,
depending on the geometry of the motor) is proportional to the difference between the pressures in the
two chambers.
We are now ready to draw the bond graph of the
hydraulic motor:

The two 0-junctions to the left and to the right represent the two hydraulic chambers with the pressures
p1 and p2, respectively. Each of them has been
pulled apart into two separate 0-junctions connected
by a bond for graphical reasons. Same sex junctions
neighboring each other can always be considered as
a single junction. The two capacitors symbolize the
compressibility of the liquid. The three resistors at
the top half of the bond graph represent the leakage
flows, one of which, qi, is an internal leakage flow,
whereas the others, qe1 and qe2, are external leakage
flows.
The transformer, TF, separates the hydraulic
from the mechanical side. The inductor represents
the inertia of the (rotational) screw, whereas the resistor represents the friction of the screw. The flow
detector element, Df, detects the angular velocity,
ωm, of the screw. It converts the bond graph representation to a signal.
The hydraulic motor is controlled by a servo
valve:

The Modelica Association

The inflow pressure, ps, is the load pressure of the
hydraulic motor. The outflow pressure, p0, is the
ambient pressure of the environment. The four valve
flows, q1, q2, q3, and q4, are turbulent flows. Hence
they are proportional to the square root of the pressure difference. In terms of a bond graph, they can
be represented either as nonlinear resistors (Relements) or as nonlinear conductors (G-elements).
Since the causalities are those of a conductive element, we chose the latter representation to prevent
Modelica from having to turn these nonlinear equations around symbolically.
All four valve flows are modulated by the position of the tongue, x.
We are now ready to draw the bond graph of the
servo valve:

The tongue position, x, is an input signal. It influences the bond graph by means of modulation of the
four hydraulic conductance elements.
We still need to model the motion of the tongue
of the servo valve:

60

Modelica 2005, March 7-8, 2005

The Modelica Bond-Graph Library

end, an additional 0-junction was placed between the
1-junction and the capacitor.
We are now ready to model the control circuit:

The tongue of the servo valve is an electromechanical converter. The input signal, u, modulates an effort source that generates a magnetic field in a coil.
The magnetic field induces a mechanical force in the
tongue that is proportional to the current through the
coil. Thus, the converter can be modeled as a bondgraphic gyrator, GY. Whereas a transformer sets the
output effort proportional to the input effort (and the
input flow proportional to the output flow), the gyrator sets the output effort proportional to the input
flow (and the input effort proportional to the output
flow).
We are now ready to draw the bond graph of the
device:

The modulated effort source translates the signal, u,
to a power flow. The 1-junction to the left of the
gyrator symbolizes the electrical mesh. The inductor
here represents the coil, whereas the resistor represents the electrical resistance.
The gyrator converts the electrical power, Pel =
ui · i, where ui is the induced voltage, to mechanical
power, Pmech = f · v. The 1-junction to the right of
the gyrator symbolizes the velocity of the tongue.
The inductor here represents the mass of the tongue,
the resistor represents the mechanical damper, and
the capacitor represents the mechanical spring.
We could have attached a flow detector, Df, to
the 1-junction to detect the velocity of the tongue.
We could then have integrated the resulting signal to
obtain the tongue position, x. Yet, we chose another
route. The tongue position, x, is proportional to the
spring force. Thus, we can use an effort detector,
De, to detect the spring force. However, an effort
detector needs to be attached to a 0-junction. To this

The Modelica Association

From the outside, the control circuit looks like a
regular block diagram. However, three of the blocks
have been modeled by bond graphs internally.

6

The Thermal Budget of Biosphere
2 without Air-conditioning

As a second example, we shall model the thermal
behavior of Biosphere 2, an experimental research
facility located in the vicinity of Tucson, Arizona,
without air-conditioning by means of bond graphs.
Rather than using a bottom-up approach, as we
did in the previous example, we shall this time
around use a top-down approach.
Biosphere 2 was designed as a materially closed
structure to investigate the ability of humans to survive in a materially closed structure for extended
periods of time. The main idea was to investigate
whether space colonies are feasible with today’s
technologies.

Biosphere 2 was constructed as a large glass building
on 3 acres (12.000 m2). The structure is held together by a metallic frame construction and is closed
off by glass panels.
The structure contains a number of different biomes. The pyramidal structure to the right contains a
tropical rain forest. The elongated structure to the
left contains a pond, a savannah, saltwater marshes
with mangroves, and a southwestern desert landscape.

61

Modelica 2005, March 7-8, 2005

F. Cellier, À. Nebot

The air pressure inside Biosphere 2 is kept constant
by two lungs, one of which is shown below:

The lungs operate as follows. A heavy cement ceiling is suspended from the dome by a rubber flange.
The bottom part of the lung is inside the materially
closed structure, whereas the top part is outside air.

There are a number of different elements in that
model: the inside air, the dome, the pond, the vegetation, and the soil, each of which are allowed to be at
a different temperature. Only the inside air also contains humidity.
In a bond graph, thermal power, i.e., heat flow,
can be written as the product of temperature and entropy flow. It is customary to identify the temperature with the effort variable, and the entropy flow
with the flow variable.
Each of the five elements is represented as a 0junction with a (non-linear) capacitor attached to
represent the heat capacity of the element. Heat
flows between the elements are represented as nonlinear resistors modeling physical effects such as
convection and radiation.
The inside air is represented by two separate 0junctions, one modeling the temperature of the air,
the other modeling its humidity. Non-linear resistors
between the thermal and humidity junctions are used
to model the effects of evaporation (conversion of
sensible heat to latent heat) and condensation (conversion of latent heat to sensible heat).
A conceptual model of Biosphere 2 is shown below:

When the temperature inside Biosphere 2 rises, the
inside pressure increases as well. Consequently, the
ceilings in the two lungs are lifted up, thereby increasing the total volume of Biosphere 2. In this
way, the inside pressure remains the same as the ambient pressure irrespective of the temperature.
Although air-conditioning keeps the temperature
and humidity values different in the different biomes,
Biosphere 2 was modeled by us as a single structure
with one inside temperature and humidity.

The Modelica Association

62

Modelica 2005, March 7-8, 2005

The Modelica Bond-Graph Library

Each black dot represents a modeling element, i.e., a
0-junction with a heat capacity attached to it. The
flows between these modeling elements are represented by two-port elements modeling the effects of
conduction, convection, radiation, evaporation, and
condensation.
The model starts in the upper right corner with
the simulation clock. The ambient temperature and
the apparent temperature of the night sky are computed by tabular look-up functions.
The temperature values are then converted to
power flows by the use of modulated effort sources.
Temperature sources are physically dubious, but it is
okay to use them here, since the model doesn’t contain any physical explanation as to how the environment reaches its temperature. The temperature values are simply being observed.
Since the dome is in physical contact with the
outside air, convection takes place across the dome.
Furthermore, the dome is exposed to diffuse radiation from and to the sky.
The 0-junction representing the dome was split
into two separate 0-junctions connected by a bond
for graphical reasons. The thermal capacitor attached to the 0-junction computes the temperature of
the dome.
Biosphere 2 is also exposed to direct solar radiation. The Solar Input model, symbolized by the sun,
computes the position of the sun in the sky, and
thereby computes the total amount of direct solar
radiation input reaching the Biosphere 2 structure.

The Modelica Association

Since the different glass panels have many different orientations, it would have been computation
intensive to calculate accurately the amount of radiation that gets transmitted, absorbed, and reflected by
each of the glass panels. Thus, a much more global
approach was taken. It is assumed that roughly 60%
of the solar input gets transmitted across the glass
panels, 20% gets absorbed by them, whereas the final 20% get reflected to the outside.
The Glass1, Absorption, and Glass2 models railroad the available solar input to the individual elements, where they arrive in the form of flow (entropy) sources. The vegetation, soil, and inside air
absorb all of the arriving solar input. The pond absorbs some of it, and reflects the rest. The reflected
solar input is partly absorbed by the inside air, and
partly reaches the dome again from the inside, where
it is partly absorbed, and partly transmitted back out.
Thus, a global balance approach was used to
model the direct solar input. The end effect is that
each of the 0-junctions representing the five different
modeling elements has a modulated flow source attached to it that models the amount of direct solar
input absorbed by that element.

7

Convection

Let us now look at the processes of convection between modeling elements. Since the air-conditioning
was left out of the model, there are no forced flows.
Thus, the convection is simply driven by temperature

63

Modelica 2005, March 7-8, 2005

F. Cellier, À. Nebot

differences, i.e., by potential equilibration. This is a
resistive phenomenon.

To this end, we shall require a flow detector and
two switch elements:

The two 0-junctions symbolize the two modeling
elements that exchange heat among each other.
They are at the temperature values, T1 and T2, respectively.
The 1-junction between them computes the temperature difference, ∆T, which drives the entropy
flow.
The problem with this model should become
evident at once. What happens with the power flow
into the resistor? It may make sense to model with
resistors in an electrical circuit, because we may not
care about the entropy that is being generated by the
resistor. However here, we are operating already in
the thermal domain. Additional entropy is being
generated by the resistor, and this entropy needs to
be routed somewhere.
It has become customary to replace thermal resistors by resistive source elements, RS, and route the
generated entropy to the nearest 0-junction. The so
modified bond graph is shown below:

The bondgraphic switch element, Sw, has a Boolean
input. If that input has a value of true, the switch is
open, i.e., there is zero flow. In that case, the causality stroke is at the switch element. On the other
hand, if the Boolean input has a value of false, the
switch is closed, and in that case, there is zero effort.
Thus by now, the causality stroke has moved away
from the switch. Hence a-causal bonds must be used
at the switches.
Since the 1-junctions must have n-1 causality
strokes, another bond must also change its causality.
This has to be the bond that leads to the resistive
source element, RS.

8

As convection is a symmetric phenomenon, we could
alternatively route half of the generated entropy flow
to the right and the other half to the left:

Finally, we may choose to route the generated entropy down-wind, i.e., if T1 > T2, all of the generated
entropy flow is routed to the right, otherwise to the
left.

The Modelica Association

Conclusions

In this paper, a bond graph library has been introduced that was designed to be used with Dymola.
Since bond graphs are a graphical modeling tool, it
may be much less desirable to use this library with
Modelica alone, i.e., in an environment that is based
on an alphanumerical representation of models.
This is already the second presentation of the
Modelica Bond Graph Library. An earlier paper [4]
had been prepared for a conference on bond graph
modeling. Thus, whereas the earlier paper had been
prepared for an audience that knew a lot about bond
graphs, but little if anything about Modelica and/or
Dymola, the current paper was written for an audience that is expected to be knowledgeable about
Modelica and Dymola, but probably knows little if
anything about bond graphs.
An earlier presentation of the Biosphere 2 model
was published in [5]. The model presented in that
paper had been developed using a much earlier version of Dymola, prior to the design of Modelica. At

64

Modelica 2005, March 7-8, 2005

The Modelica Bond-Graph Library

that time, a strictly alphanumerical version of a bond
graph library had been used [1].
Bond graphs offer a fairly low-level interface to
modeling physical systems. Thus, bond graphs
should be used hierarchically in the context of complex systems [2]. The Biosphere 2 model demonstrates how bond graphs can be hierarchically structured. The hydraulic motor example demonstrates
how bond graphs can be hidden inside other modeling metaphors, such as block diagrams.
The primary strength of bond graphs is their domain independence. For this reason, bond graphs are
particularly suitable for the description of physical
systems that operate in multiple energy domains.
Energy conversions can be modeled easily and conveniently using transformers and gyrators.
As with any other modeling paradigm, there is
nothing unique about bond graphs. Every single one
of our models could have been developed using other
modeling paradigms as well. Modeling paradigms
offer a means for modelers to organize their knowledge about the physical systems they wish to describe. Some researchers will find bond graphs a
convenient way to organize their knowledge,
whereas other researchers won’t. To us, bond graphs
have become the ultimate tool for understanding the
basic principles covering all of physics [3].

References
[1]

[2]

[3]

[4]

[5]

Cellier, F.E. (1991), Continuous System
Modeling, Springer-Verlag, New York,
ISBN: 0-387-97502-0, 755p.
Cellier, F.E. (1992), “Hierarchical NonLinear Bond Graphs: A Unified Methodology for Modeling Complex Physical Systems,” Simulation, 58(4), pp. 230-248.
Cellier, F.E. (1995), “Bond Graphs: The
Right Choice for Educating Students in
Modeling Continuous-Time Physical Systems,” Simulation, 64(3), pp. 154-159.
Cellier, F.E. and R.T. McBride (2003), “Object-oriented Modeling of Complex Physical
Systems Using the Dymola Bond-graph Library,” Proc. ICBGM’03, 6th SCS Intl. Conf.
on Bond Graph Modeling and Simulation,
Orlando, Florida, pp. 157-162.
Nebot, A., F.E. Cellier, and F. Mugica
(1999), “Simulation of Heat and Humidity
Budget of Biosphere 2 without its Air Conditioning,” Ecological Engineering, 13, pp.
333-356.

The Modelica Association

Biographies
François E. Cellier received his
B.S. degree in electrical engineering from the Swiss Federal
Institute of Technology (ETH)
Zürich in 1972, his M.S. degree
in automatic control in 1973, and
his Ph.D. degree in technical
sciences in 1979, all from the
same university.
Dr. Cellier
joined the University of Arizona
in 1984 as associate professor, where he is currently
a full tenured professor of Electrical and Computer
Engineering. Dr. Cellier's main scientific interests
concern modeling and simulation methodologies,
and the design of advanced software systems for
simulation, computer aided modeling, and computeraided design. Dr. Cellier has authored or co-authored
more than 200 technical publications, and he has edited several books. He published a textbook on Continuous System Modeling in 1991 with SpringerVerlag, New York. He served as general chair or
program chair of many international conferences,
and serves currently as president of the Society for
Modeling and Simulation International.
Àngela Nebot received licentiate and Ph.D. degrees in computer science from the Universitat Politècnica de Catalunya
(UPC), Barcelona, Spain, in
1988 and 1994, respectively.
From 1988 until 1992 she was
with the Institut de Cibernètica, holding a predoctoral research grant from
the government of Catalunya, and completing the
doctoral courses in software and artificial intelligence. She joined the department of Llenguatges i
Sistemes Informàtics in 1994 as an assistant professor, and since March 1998, she has been associate
professor in the same department. She currently belongs to the soft-computing group of the UPC. She is
an associate editor of the journal Simulation: Transactions of the Society for Modeling and Simulation
International, and serves as a reviewer for other international journals such are the International Journal
of General Systems, Neurocomputing, Artificial Intelligence in Environmental Engineering, and Artificial Intelligence Communication. Her current research interests include fuzzy systems, neuro-fuzzy
systems, genetic algorithms, simulation, and
e_learning.

65

Modelica 2005, March 7-8, 2005

The Modelica Association

66

Modelica 2005, March 7-8, 2005

Fuel Cell System Modeling for Real-time Simulation

Fuel Cell System Modeling for Real-time Simulation
Jörg Ungethüm∗
German Aerospace Center, Institute of Vehicle Concepts
Pfaffenwaldring 38-40, 70569 Stuttgart

Abstract
In this paper a model of a subsystem of an automotive fuel cell power generation unit is presented. The
subsystem model describes the cathode side of the fuel
cell, containing the air supply system. As far as possible, standard libraries were used to accomplish a high
level of compatibility with other models. The model
runs in real-time on dSPACE hardware and is used in a
Hardware-In-the-Loop (HIL) simulation environment.
Keywords: fuel cell, automotive simulation, real-time
simulation, hardware-in-the-loop

1

Introduction

In the context of future vehicle development, models
are needed for the simulation of the fuel cell system
and its periphery. These models are used for off-line
system simulation as well as for HIL simulation with
respect to controller development. Most of the existing models are built upon MATLAB/Simulink. The
model which is presented in this paper serves particularly in the evaluation of object-oriented modeling
in Modelica as an alternative to modeling in MATLAB/Simulink. Apart from modeling potentialities,
flexibility and simulation performance, the code administration is also relevant in this context.
In figure 1 a sketch of the modeled subsystem is
shown, which covers the cathode side of a PEM fuel
cell system. The fuel cell is supplied with compressed
and cooled air. Due to the electro-chemical reaction in
the stack, the rate of oxygen in the air is reduced and
at the same time the air takes up the major part of the
reaction water. Heat is rejected by means of a cooling
medium. The remaining pressure difference between
the stack outlet and the environment is used in an exhaust gas turbine. Therefore, and to recover reaction
water, liquid water is dragged from the air in a separator. Using the recirculation valve, air can be led back
∗ joerg.ungethuem@dlr.de

The Modelica Association

Figure 1: Sketch a the fuel cell subsystem to simulate

directly to the entrance of the compressor. Compressor and exhaust gas turbine are mounted together with
an electrical drive engine on a common shaft.

2

Model design

The model covers the process engineering part of the
system, whereby the focus has been the description of
the thermodynamic behavior. The mechanical part is
built up with simple models, the fuel cell stack is realized as thermal inertia and a source of heat and humidity. The model realistically reproduces the most
important influences on the dynamic behavior of the
system. These are the volumes and thermal capacities
of the components and the inertia of the common shaft
of compressor, exhaust gas turbine and electrical machine. The top level of the model is shown in figure 2.

67

Modelica 2005, March 7-8, 2005

J. Ungethüm

Figure 2: The Modelica system model

3

Aspects of real-time simulation

ever, this leads to bad performance of the simulation.
In real-time simulation the situation is even worse, be3.1 Toolchain
cause the iteration can prevent the deterministic solution behavior which is required. On the other hand it
As the model is used in context of HIL simulation on
is not strictly necessary to avoid any implicit equation.
a dSPACE system, it has to run in real-time on the tarAs long as the required number of iterations is moderget. To enable real-time simulation of potentially stiff
ate, real-time requirements can be fulfilled anyway.
models, Dymolas inline integration approach is used
[1]. The model is embedded as a S-function into a
simple Simulink wrapper model (figure 3) using Dy- 3.2.2 Use of simple medium models
molas Simulink interface block. The MATLAB Real- The evaluation of medium properties in thermodyTime Workshop and the dSPACE target compiler are namic models can take up a major part of the comneeded to compile the compounded Simulink model. puting time. Therefore properties should not be forVisualization is realized using the dSPACE Control- mulated more complicated than absolutely necessary.
Desk program.
In particular numeric problematic functions, e.g. logarithm, high polynomial degrees and broken exponents
should be avoided. Within the implementation extra3.2 Real-time model requirements
ordinary care must be put on good performance and
The central requirements of real-time modeling are de- numeric stability. Using Horner’s scheme instead of
terministic computing time and high computing speed. the pow() function for polynomial evaluation might
In order to provide a deterministic computing time, it- be mentioned as an example.
erative solution algorithms should be avoided. High
computing speed is reached by keeping model equa3.2.3 Properties and state variables
tions as simple as possible.
In most cases, thermodynamic variables of state are
also state variables of the model. The medium proper3.2.1 Avoidance of nonlinear sets of equations
ties should be present as explicit, fast evaluable funcNonlinear sets of equations must be solved by itera- tions of the actual set of state variables. Therefore, the
tion, if they cannot be eliminated symbolically. How- choice of the variables of state depends on the used
The Modelica Association

68

Modelica 2005, March 7-8, 2005

Fuel Cell System Modeling for Real-time Simulation

Figure 3: The Simulink wrapper model

states derivatives
∂ρ
∂ρ
p, ρ
∂h | p , ∂p |h
∂u
∂u
ρ, T ∂ρ
|T , ∂T
|ρ

However, the necessary derivatives can be provided
explicitly by the user [4].
3.2.5

Avoidance of numerically disadvantageous
functions

Table 1: Extra 2nd order derivatives needed in trans- Some mathematical built-in functions are problemformed balance equations
atic in numeric simulations. The square root function and the logarithm function have limited definition
property model. Most property models are explicit in ranges, the derivation of the root function has an addensity ρ and temperature T or enthalpy h and pres- ditional singularity at zero. These functions should be
sure p. As a result the thermodynamic balance equa- avoided or should be replaced by smooth approximations should be formulated in such a way that either tions. Note, due to the symbolic equation treatment,
density and temperature or enthalpy and pressure are the inverse functions of the above can also lead to troucomputed by differential equations. Since in the pri- ble.
mary form of mass and energy balance density ρ and
internal energy u are calculated, these equations must 3.2.6 Avoidance of redundant events
be transformed. The transformed balance equations
contain additional partial differentials of the thermo- Due to event propagation events require additional
dynamic state variables, which must be computed in evaluations of the set of equations, which can lead to
injury of the computing time restriction [2]. Events
the property model (table 1, [7]).
can be avoided if discontinuous equations and functions are replaced by continuous approximations.
3.2.4 Avoidance of numeric Jacobians
Numerical Jacobian approximation is a common
source of instability and inaccuracy. In Dymola nu- 4 Selection of Modelica libraries
meric Jacobians are used only if the necessary partial
derivatives cannot be computed symbolically. There An aim of the project is to use standard libraries as far
are few cases where symbolic derivative generation is as possible to achieve good compatibility with other
models. Apart from proprietary developments [6] the
not possible yet:
ThermoFluid library [7] and in particular the new li• external functions (library calls, calls to routines braries Modelica.Fluid and Modelica.Media [3] are of
written in C or Fortran)
special interest. Although the Modelica.Fluid library
• Modelica functions with the exception of one- is still in an early development state, this library was
liners (at least up to Dymola 5.2)
selected as the base library. Modelica.Fluid itself is
The Modelica Association

69

Modelica 2005, March 7-8, 2005

J. Ungethüm

based on the Modelica.Media library. As an unique
feature Modelica.Fluid allows the implementation of
models which are in fact medium-independent. In order to achieve good performance, the formulation of
the thermodynamic balance equations must be adapted
to the material property routines. In the ThermoFluid
library this adaption is done explicitly by the user, as
a suitable state transformation is selected. In the new
Modelica.Fluid library this transformation takes place
automatically via skillful use of the index reduction algorithm.
The Modelica.Fluid library is currently under construction. Substantially components like discretized
pipes or control valves are still missing. Nevertheless the library is already usable. The interfaces (connectors), a control volume and throttling devices are
already available. The Modelica.Media library is already developed further. Property models for ideal
Figure 4: The ModelicaFluidX component library
gases, several models for water (among other the
IAPWS97 formulation [8]) are implemented. Mixtures are implemented likewise. However, these could
spline interpolation near 0"
input Real x;
not be used because of implementation problems in
input Real deltax;
the version that was used. The library already offers
output Real y;
a sufficiently good documentation including a tutorial, algorithm
which makes the implementation of additional prop- /*
erty models possible.
// pipe this through ’cpp -P -’ to

5 Component library
To implement the fuel cell subsystem model outlined
in chapter 1, component models like heat exchanger,
mixer, separator, compressor and exhaust gas turbine
are needed. These component models go beyond the
scope of the Modelica.Fluid library. Therefore, a new
component library ModelicaFluidX is built on basis of
Modelica.Fluid. The structure of the library is shown
in figure 4. Due to the level of development of the base
libraries, structure and implementation are still subject
of change. The library is developed aiming real-time
applications.

5.1 The CommonFunctions folder
The folder CommonFunctions was taken over from
the ThermoFluid library. The functions were partly
redesigned as one-liners in order to ensure their automatic differentiability. As an example the function
ThermoRoot is shown. The actual Modelica code was
generated using the C Preprocessor:
function ThermoRoot
"Square root function with cubic

The Modelica Association

// generate Modelica one-liner below
#define adeltax abs(deltax)
#define C1 (5/(4*adeltaxˆ(0.5)))
#define C3 (-1/(4*adeltaxˆ(2.5)))
algorithm
y := noEvent(if (x > adeltax)
then sqrt(x)
else
if (x < -adeltax)
then -sqrt(-x)
else (C1
+ C3*x*x)*x);
// EOF
*/
y := noEvent(if (x > abs(deltax))
then sqrt(x)
else
if (x < -abs(deltax))
then -sqrt(-x)
else ((5/(4*abs(deltax)ˆ(0.5)))
+ (-1/(4*abs(deltax)ˆ(2.5))) *x*x)*x);
end ThermoRoot;

The function extends the root function into the range
of negative arguments and avoids the singularity of
the 1st derivative in the origin (see figure 5). In contrast to the implementation in the ThermoFluid library,
this version can be differentiated automatically. As
side effect the restriction to constant approximation
radii of the original implementation is void. Since

70

Modelica 2005, March 7-8, 2005

Fuel Cell System Modeling for Real-time Simulation

Figure 6: The SimpleHeatExchanger model

Figure 5: The ThermoRoot library function

the function is continuously differentiable, the auto- has an additional n-dimensional fluid connector. Usmatic event generation can be suppressed by using the ing this connector, mass or heat can be transferred to
each individual control volume.
noEvent() function.

5.2

The Interfaces folder

The library uses mainly the container models which
are available in Modelica.Fluid. However these are not
always sufficient, so additional interfaces must be provided. This applies especially for the discretized models, since Modelica.Fluid does not offer vectorized interfaces yet.

5.3.2

The SimpleHeatExchanger model

The simple model of a heat exchanger consists of two
LongPipeS models, the model of a massless wall and
two very simple convection models. The models of
the wall and of the convection are implemented in the
subfolder SubComponents and can be replaced easily,
if e.g. the thermal capacity of the wall has to be consid5.3 The Components folder
ered. On the other hand, the designs for heat exchangers are so various that generally appropriate abstract
The Components folder contains the subfolder Base- models can hardly be indicated.
Components and SubComponents. The first contains
abstract base models for components, the second contains component models, which are used only within
other components. To give an idea of the level of im- 5.3.3 The SimpleCompressor and SimpleExplementation, some component models are discussed
pander models
more explicitly.
5.3.1

The LongPipeS model

Hence Modelica.Fluid does not contain a useful model
of a discretized pipe, a provisional model was implemented, which consists of a variable number alternating successively arranged control volumes and throttling devices. These two components are available as
JunctionVolume and ShortPipe in Modelica.Fluid. In
contrast to the more sophisticated implementation in
the ThermoFluid library only the stationary impulse
balance is implemented. For convenience, the model
The Modelica Association

For compressors and exhaust gas turbines abstract base
models are implemented. The models consider the
volumes, the heat capacities and the rotating masses
of the machines. The individual behavior of a machine
is usually available as characteristic diagrams of mass
flow and efficiency. These characteristics are implemented as replaceable class parameters, so that arbitrary machines can be modeled. The characteristic diagrams can take off either only the stationary or also
the dynamic behavior of the machine. In most cases
only stationary characteristics from measurements are
available.

71

Modelica 2005, March 7-8, 2005

J. Ungethüm

time
t=0s
t=5s
t=7s
t=8s
t = 10 s

action
The desired pressure ratio is set to 2.2,
compressor and turbine starts.
The stack begins to deliver heat and
water.
The recirculation valve begins to open.
The recirculation valve reaches 25 %
opening.
Simulation stops.

Table 2: Simulation of the system startup

Figure 7: The BaseCompressor model

6

Medium properties

For the computation of the medium properties the
Modelica.Media library is used. This library does
not contain any model suitable for fuel cell systems
computation yet. A model for humid air is needed,
whereas both, the humidity and the gas composition
are variable. The implementation of such a property
model is already possible within the Modelica.Media
library, this, however, did not succeed due to general problems concerning the mixture models. As a
temporary solution the single component model SimpleAir is used, whereas the restriction of the temperature range was waived. This model is well suitable for
real-time simulation in particular because of the simple implementation with constant heat capacity. With
the exception of the compressor outlet the temperature
of the air remains below 100 o C. In order to simulate the humidification and the drying process of air, a
crude workaround is implemented into some component models. The heat of the condensation is computed directly in the component model and the absolute humidity of the medium is passed on as signal
to the following component.

Figure 8: Simulation of system startup: angular velocity of common shaft
solver 1.01 s CPU time was used on a Intel Centrino
1400 MHz. During the entire starting process 16 state
events occurred.
For comparison the same model was simulated using
the mixed implicit/explicit Euler inline solver. The
startup with angular velocity at zero is not possible in
this case due to a division by zero. In figure 11 and
12 the deviations between the two simulation runs are
shown. The difference between the simulation results
is with exception of the very beginning less than approximately 2 %. Larger differences occur in the case
of fast changes of the system states.

8
7

Simulation of the model

The model which is shown in figure 1 consists of 1761
unknowns, 704 time-varying variables and 31 continuous time states. To enable offline tests, some simple controllers were added to the model. Thus a system startup was simulated using the Dassl variable step
solver. The timetable of the system startup is shown in
table 2. In figure 8, 9, 10 some results are arranged.
For simulation of the startup process with the Dassl
The Modelica Association

Real-time simulation
dSPACE HIL target

on

the

The system model (figure 2) is inserted into a simple
Simulink wrapper model (figure 3) and compiled with
the help of the MATLAB Real-Time Workshop for a
dSPACE target. The model runs with a stepsize of
2 ms on a dSPACE DS1005 PPC board in real-time.
On the target, a certain number of overruns must be allowed, since in particular during the startup phase several overruns arises. Note, such adjustment is not pos-

72

Modelica 2005, March 7-8, 2005

Fuel Cell System Modeling for Real-time Simulation

Figure 13: Screenshot of dSPACE ControlDesk with running simulation on a DS1005 target

Figure 9: Simulation of system startup: mass flow rate Figure 10: Simulation of system startup: air temperathrough compressor, exhaust gas turbine and recircu- ture at humidifier and separator, compressor, exhaust
lation valve
gas turbine and heat exchanger outlet
sible on any arbitrary real-time hardware. On various
real-time platforms an overrun is a fatal error which
aborts the simulation. In figure 13 a screen shot of the
running simulation is shown. The two gages show the
number of revolutions of the common shaft and the
mass flow through the compressor. Right beside the
The Modelica Association

temperature in the compressor discharge line and in
the outlet of the fuel cell are shown. Above the task
counter, the number of overruns, the sample time and
the actual turnaround time are indicated. The simulation clock is shown in the upper left corner. Although

73

Modelica 2005, March 7-8, 2005

J. Ungethüm

References
[1] Hilding Elmqvist, Sven Erik Mattsson, Hans
Olsson. New Methods for Hardware-in-the-loop
Simulation of Stiff Models. In: Proceedings of
the 2th Modelica Conference 2002, Oberpfaffenhofen, Germany, Modelica Association, 18-19
March 2002.

Figure 11: Comparison of simulation results using
Dassl solver and fixed-step inline integration: difference of compressor mass flow

[2] Hilding Elmqvist, Sven Erik Mattsson, Hans
Olsson, Johan Andersson, Martin Otter, Christian Schweiger, Dag Brück. Real-time Simulation of Detailed Automotive Models. In: Proceedings of the 3rd Modelica Conference 2003,
Linköping, Sweden, Modelica Association, 3-4
November 2003.
[3] Hilding Elmqvist, Hubertus Tummescheit, Martin Otter. Object-Oriented Modeling of ThermoFluid Systems. In: Proceedings of the 3rd Modelica Conference 2003, Linköping, Sweden, Modelica Association, 3-4 November 2003.
[4] Dymola User’s Manual Version 5.1a. Dynasim
AB, Research Park Ideon, SE-22370 Lund, Sweden.
[5] Peter Fritzson. Object-Oriented Modeling and
Simulation with Modelica 2.1. John Wiley &
Sons, Inc.

Figure 12: Comparison of simulation results using
Dassl solver and fixed-step inline integration: difference of compressor outlet temperature

the mean turnaround time is more than 75 % (ca. 1.5 1.8 ms) of the sample time, overruns are rare after the
startup phase.

9

Conclusion

[7] Hubertus Tummescheit, Jonas Eborn, Falko
Wagner. Development of a Modelica Base Library for Modeling of Thermo-hydraulic Systems. Modelica 2000 Workshop, Lund, Sweden.
http://www.modelica.org/events/workshop2000

On basis of a relatively simple model substantial requirements for real-time modeling of fuel cell systems
in Modelica were worked out. Using the Dymola inline integration approach it is possible to use Modelica
models in the HIL simulation on dSPACE hardware.
The generation and compilation of the target code with
the help of the MATLAB Real-Time Workshop is a
complex and expensive solution. Direct generation of
the target executable without any MATLAB tools is already possible, but should be better supported by Dymola.
The Modelica Association

[6] Peter Treffinger, Martin Goedecke. Development
of Fuel Cell Powered Drive Trains With Modelica. In: Proceedings of the 2nd Modelica Conference 2002, Oberpfaffenhofen, Germany, Modelica Association, 18-19 March 2002.

74

[8] Wolfgang Wagner, Alfred Kruse. Properties of
water and steam. Berlin, Springer Verlag 1998.

Modelica 2005, March 7-8, 2005

FuelCell Lib - A Modelica Library for Modeling of Fuel Cells

FuelCellLib - A Modelica Library for Modeling of Fuel Cells
Miguel A. Rubio+, Alfonso Urquia*, Leandro González+, Domingo Guinea+, Sebastian Dormido*
+

Instituto de Automática Industrial (IAI), CSIC
Ctra. Campo Real, Km. 0,200 – La Poveda, 28500 Arganda del Rey, Madrid, Spain
E-mail: {marubio, leandrog, domingo}@iai.csic.es
* Departamento de Informática y Automática, E.T.S. de Ingeniería Informática, UNED
Juan del Rosal 16, 28040 Madrid, Spain
E-mail: {aurquia, sdormido}@dia.uned.es

Abstract
The design, implementation and use of FuelCellLib
library are discussed. FuelCellLib is a Modelica
library for the dynamic modeling of fuel cells (FC).
It is intended to be used for: (1) enhancing the
understanding of the physical-chemical phenomena
involved in the fuel-cell operation; and (2)
optimizing the performance of the fuel cells.
Physical phenomena are modeled using different
hypotheses, in order to allow different levels of
detail in the fuel-cell description. FuelCellLib
version 1.0 (release on January, 2005) is free
software, and it will be available on the website of
the Modelica Association.

1

Introduction

During the last decades, the planet has been suffering
a serious environmental decay, partially due to the
use of fossil fuels. As a consequence, a great effort is
being made to find alternative sources of energy. The
fuel-cells (abbreviated: FC) constitute an alternative
source of energy for automotive and residential use.
The modeling and simulation of the fuel-cells is an
active research field. Some existing fuel-cell
libraries, developed by otˆ#
authors, have been
implemented by using causal simulation languages
(for instance, SIMULINK [1]) and fluid-dynamic
simulation programs [2]. However, these approaches
do not facilitate the modeling task and the model
reuse.
The approach adopted in the FuelCellLib
implementation is different. In order to facilitate easy
upgrade and reuse of the models, it has been
designed and programmed following the objectoriented modeling methodology.

FuelCellLib is not the only library for fuel-cell
modeling written in Modelica language. The library
implemented by Steinmann and Treffinger is
presented in [3]. Its models are intended for
describing the steady-state behavior of the fuel cells,
and they do not take into account the dependence
with the spatial coordinate. On the contrary,
FuelCellLib models are intended for describing the
dynamic behavior, taking into account the spatial
coordinate. The FuelCellLib modeling hypothesis
are discussed next.

2

Fuel-cell design and operation

The fuel-cell is composed of the following seven
fundamental parts: the active layers, the diffusion
layers, the terminals of the anode and the cathode,
and the membrane (see Fig. 1).
The membrane is placed between the catalytic layers
of the anode and the cathode. Protons migrate
through the membrane, from the anode to the
cathode, along with water. Generally, the protonexchange membranes are made of Nafion, which
guarantees a high protonic conductivity.

Figure 1: Schematic representation of PEMFC

The Modelica Association

75

Modelica 2005, March 7-8, 2005

M. Rubio, A. Urquı́a, L. González, D. Guinea, S. Dormido

Usually, the catalyst employed in the active layer is
platinum. A small percentage of ruthenium is added,
in order to inhibit the poisoning effect of the carbon
monoxide. The catalyst is mixed with coal and
electrolyte. This catalytic ink is usually deposited
over the surface of the anode and cathode diffusion
layers.
The diffusion layers are made of porous material to
allow the gases and water transport to the catalytic
layer. In addition, this diffusion material needs to be
a good electric conductor, to allow the flow of
electrons between the collector plates and the
catalytic layers. The diffusion layer is usually
manufactured from coal, paper or cloth. Their
conductivity and their resistance to corrosion make
these materials adequate.
The collector plates are made of metallic material or
non-porous
coal.
The
three
fundamental
characteristics of these materials are the following:
(1) their high electric conductivity; (2) their capacity
to maintain a tight cell; and (3) their ability to allow
the correct distribution of reagents through the
channels.

3

Phenomena modeled

The most outstanding phenomena of PEMFC (i.e.,
fuel cells with combustible hydrogen) take place in
the cell cathode [4,5]. The physical-chemical
phenomena modeled in FuelCellLib include the
following (see Fig. 2):
Membrane:
- Transport of water in liquid and steam phase.
- Protonic conduction.
Catalytic layer of cathode:
- Transport of water in liquid and steam phase.
- Transport of oxygen in steam phase.
- Protonic and electronic conduction.
- Electro-catalytic reaction.

Figure 3: Polarization curve simulated using FuelCellLib

Figure 2: Species involved in the FuelCellLib model of PEMFC

The Modelica Association

Diffusion Layer of cathode:
- Transport of water in liquid and steam phase.
- Transport of oxygen in steam phase.
- Electronic conduction.
Therefore, the FuelCellLib models include the
following physical-chemical phenomena: the
diffusion of gases in porous media, the electronic
and protonic conduction and electrochemical
reactions. The method of finite volumes is applied
for discretizing the PDE.
In addition, the FuelCellLib models can be used to
simulate the steady-state behavior [6] of the fuel
cells along their complete range of operation. For
instance, the polarization curve (I-V) of a fuel cell
model, composed using FuelCellLib, is shown in
Fig. 3. The three operation areas (A, B and C) are
indicated in the figure: A) fall due to the activation
losses; B) fall due to the ohmic losses; and C) fall
due to the mass transport at high current value.
The FuelCellLib models are based in physicalchemical principles. The balances of the species (i.e.,
water, oxygen, protons and electrons) are enunciated,
in each physical layer of the fuel cell, by means of
the definition of control volumes.
The properties of the medium inside the control
volume are considered time-dependent, but
independent of the spatial coordinates. The control
volumes exchange the different species with their
environment through certain control planes. All the
interactions between the control volumes are
considered transport phenomena in FuelCellLib. The
physical layers of the fuel cell (i.e., the membrane
and the catalytic and diffusion layers of the cathode)
are modeled by decomposition into control volumes,
which are connected to each other by means of
transport phenomena.

76

Modelica 2005, March 7-8, 2005

FuelCell Lib - A Modelica Library for Modeling of Fuel Cells

•

These control volumes and transport phenomena can
be modeled with different levels of detail, i.e., using
different modeling hypothesis. A feature of the
FuelCellLib models of control volumes and transport
phenomena is that they describe different modeling
hypotheses. This allows the model user to select the
set of hypothesis to be used in a particular simulation
run.

Pseudo-capacitance of double layer in catalyst
layer.
• Pore size dependence in Knudsen diffusion.
• Electro-Osmotic drag effect in electrolyte.
• Variable electrolyte conductivity with water
load.

5
4

Modeling hypotheses

The following considerations and approaches are
taken in the model
- The FC model is composed of the membrane, the
catalytic layer of the cathode and the diffusion
layer of the cathode.
- The mixture of gases is considered an ideal gas.
- The flow speed and the gradients of gas pressure
are considered small.
- The diffusion electrodes and the catalytic layer
have a porosity and a homogeneous tortuosity,
with a single pore size, which relates to the
considerations of the macro-homogeneous
model [9,10].
- The electrodes, the catalytic layer and the
membrane are considered isotropic and
homogeneous. This is equivalent to consider that
the catalyst is evenly distributed in the catalytic
layer.
- The model is one-dimensional. The variables
change in the direction of the normal to the
surface of the membrane and the electrodes.
This direction is the x axis.
- The temperature of each cell layer is considered
uniform. Nor the Joule effect for movement of
species, neither the heat obtained in the
electrochemical reaction, is taken into account.
- The movement of the gases is due to the
concentration gradients and to the gas pressure
in the electrodes.
- The overvoltage of the anode is considered
negligible.
- The models are dynamic. They should be able to
represent time-dependent behaviors.
- The proton concentration inside the membrane is
considered constant.
- The crossover of oxygen in the membrane is not
modeled.
- The library user is allowed to choose among the
following four mutually exclusive hypotheses:

The Modelica Association

77

Modeling equations

The equations used to model the three fundamental
physical parts of the PEMFC are described in this
section.
The thermodynamic open-circuit voltage is
calculated [9] from Eq. (1).
1/ 2

Eoc = Eref − 0.9 × 10−9 (T − 298) +

pO p H 2
RT
ln( 2
)
2F
p H 2O

(1)

5.1 Diffusion layer equations
- Balance of gas O2
p O2 ∂ε g
RT ∂t

+

ε g ∂p O
RT ∂t

2

=−

dJ O2

(2)

dx

where ε g is the pore volume of the porous media.

p O2 and J O2 are the pressure and the flow of oxygen
respectively.

⎡ ⎛ χ ⎞m ⎤
s ⎟
⎥
ε g = ε g0 ⎢1 − ⎜⎜ max
⎢ ⎝ χ s ⎟⎠ ⎥
⎣
⎦

(3)

The pore equations are common to all physical
layers. The pore volume, calculated from Eq. (3),
depends on the load of water of the porous material.

χ s max =

ρ l H O (1 − ε s − ε e )
ρs
εs +εs
2

(4)

is the maximum load of water of the
where χ s
porous media. It depends on the pore volume. In the
diffusion layer, the term that corresponds to the
volume of the electrolyte material does not exist.
max

εs = 1 − ε g − εe
0

(5)

The total volume of any layer is equal to the sum of
the pore, the solid and the electrolyte volumes, as
shown in Eq. (5).

Modelica 2005, March 7-8, 2005

M. Rubio, A. Urquı́a, L. González, D. Guinea, S. Dormido

- Balance of gaseous H2O
p H 2O ∂ε g
RT

∂t

+

ε g ∂p H O
2

RT

∂t

dJ g H 2O α v β
( p H 2O − p sat H 2O )
=−
−
dx
RT

where p H 2O and J

g

H 2O

p

H 2O

= p0

H 2O

e

1
1 Lv M H 2 O
− )
R
T sat 0 T

Lv = 1.73287x106 + 1.03001x10−4 T − 4.47755x101T 2 +

(7)

J l H 2O = −

(8)

M H 2O

J e = −σ s ε s

(10)

(11)

T

ref

dV s
dx

(15)

current and σ s is the electronic conductivity of the
solid.
The electronic conduction depends on the
conductivity of the solid diffuser and the porosity of
the porous media.
5.2 Catalytic layer
- Balance of gas O2
pO2 ∂ε g
RT ∂t

+

ε g ∂pO

2

RT ∂t

=−

dJ O2
dx

−

1 dJ e
4 F dx

(16)

The right term of the equation constitutes the oxygen
balance in the catalytic layer. The last term
represents the effect of the electrochemical reaction.
- Balance of gas H2O

The binary diffusion coefficient [7] can be calculated
from Eq. (11). pc

(14)

where Vs is the voltage of solid, J e the electronic

the term τ represents the tortuosity of the porous
material, p c is the complete pressure and Dik is the
binary diffusion coefficient.
The gas flow is described by Eq. (10). It depends on
the following two phenomena: the Stefan-Maxwell
diffusion and the Knudsen diffusion.

⎞⎛ T ⎞1.5
⎟⎜
⎟⎝ T ref ⎟⎠
⎠

dχ s
dx

(9)

the molar mass of water. χ s and J l H 2 O are the load
and flux of liquid water respectively.
- Transport of gases

⎛ pc
Dik = Dik0 ⎜⎜ ref
⎝ pc

M H 2O

D H 2O

coefficient of the liquid water in the porous media.
The flow of liquid water is produced by a gradient in
the load of liquid water. This is equivalent to assume
that the superficial diffusion is predominant [4].
- Electronic conduction

where ρ s is the density of the solid and M H 2 O is

i
RTJ j
ε g dp i
RT
=
( pi N k − N i p k ) +
∑
2
ε
τ dx k =1 p c Dik
g
Dj
τ2

ρs

where the term D H 2O corresponds to the diffusion

The saturation pressure can be calculated from Eqs.
(7-8). It essentially depends on the temperature.
- Balance of liquid H2O
∂χ s
dJ l H 2 O α v β
=−
+
( pH 2 O − p sat H 2 O )
∂t
dx
RT

(13)

The Knudsen diffusion coefficient can be calculated
from Eq. (12) or (13). In the first case, it is
considered a constant [8]. In the second case, it
depends on the pore size. The library user has to
choose one of these two modeling hypotheses.
- Transport of liquid H2O

+ 7.6629x10−2 T 3 − 5.5058x10−5 T 4

ρs

2 RT
⎛4⎞
DKnudsen = ⎜ ⎟rp
π ⋅M
⎝3⎠

(6)

are the pressure and the

(

sat

(12)

0

flow of water in steam phase respectively.
The condensation and evaporation of water are taken
into account in the water balance equation. The two
phases are considered to be in balance, and it
depends on the specific surface of the porous media.
sat

DKnudsen = DKnudsen

is the reference pressure and
pH2O ∂ε g

ref

is the reference temperature used to measure
the binary diffusion coefficient.

The Modelica Association

RT ∂t

78

+

ε g ∂pH O
2

RT ∂t

=−

dJ g H2O 1 dJe αv β
( pH2O − psatH2O )
+
−
2F dx RT
dx

(17)

Modelica 2005, March 7-8, 2005

FuelCell Lib - A Modelica Library for Modeling of Fuel Cells

In Eq. (16) and (17), the balance of water in the
catalytic layer depends on the electrochemical
reaction.
- Transport of liquid H2O
J l H 2O = −

ρs
M H 2O

DH 2 O

dχ s
dx

(18)

- Protonic conduction
J p = − K pε m

dVe
dx

(24)

where Ve represents the electrolyte voltage , J p the
protonic current, K p the protonic conductivity and

ε m the electrolyte volume.

Two alternative modelling hypotheses are supported.
The user has to decide whether include in Eq (18) or
not the electro-osmotic drag term shown in Eq. (19).
J l H 2 O T = J l H 2 O + ndrag

Jp

The protonic conduction is produced by a voltage
gradient in the protonic conductive material.
- Electrochemical reaction

(19)

F

⎡ pO
⎛ α nF
⎞
⎛ − 1(1 − α )nF
⎞⎤
∇ J e = a act i0 ⎢ 0 2 exp ⎜
η D ⎟ − exp ⎜
η D ⎟⎥
RT
⎝ RT
⎠
⎝
⎠⎦
⎣ p O2

The liquid water flow depends on: (1) the
concentration gradient of liquid water; and (2) the
electro-osmotic drag, which is due to the proton
conduction produced inside the active-layer
electrolyte. The coefficient of electro-osmotic drag
can be calculated from Eq. (20). This equation is also
valid for the electro-osmotic drag in the membrane.
ndrag =

2.5LSO3 ε e

(20)

22

ndrag = 0.0029LSO3 + 0.05LSO3 − 3.4 x10−19
2

(21)

Eq. (20) is determined experimentally. The electroosmotic drag mainly depends on the water content of
the membrane [10]. Eq. (21) is also empiric [11].
The user needs to choose between Eq. (20) and (21).
(22)
LSO3 = 14
LSO3 =

χs
⎛ ρs
⎜⎜
⎝ Mm

(25)

where i0 is the exchange current in open circuit, a act
is the specific active surface in catalytic layer , p 0 O2
is the reference partial pressure of oxygen, α is the
transfer coefficient of charge in cathode y η D is the
overvoltage between the solid and electrolyte.
Eq. (25) is the Butler-Bolmer expression of the
electrochemical reaction. The anode contribution can
be neglected [1,4,5].
The model allows the user to choose between Ec.
(25) or (26). The pseudo-capacitance is considered in
Eq. (26) [1].

∇J Te = ∇J e + C dl

∂η
∂t

(26)

The term ∇J e in Eq. (26) is calculated from Eq.

(23)

⎞
⎟⎟ − (0.0126 χ s )
⎠

The electro-osmotic drag coefficient depends on the
LSO term. This term is a function of the load of

(25). Cdl is the capacitance of the double layer
between the solid and the electrolyte.
The characteristics of the macro-homogeneous
model lead to an underestimation of the overvoltage
effect associated to the defect of mass in high current
densities. To characterize this phenomenon we
introduce in the model Eq. (27), (28) and (29).

3

water in the electrolyte. Two possible expressions
are considered in the library. The first one is the
constant value shown in Eq. (22), which has been
calculated from saturated water vapor at 30ºC. The
second one is the expression shown in Eq. (23),
which takes into account the dependence with
respect to the water load.

The Modelica Association

79

⎛ J ⎞
i o = i ref o ⎜⎜1 − e ⎟⎟
⎝ Jl ⎠

(27)

⎛ pO
J l = ⎜⎜ 0 2
⎝ p O2

(28)

⎞
⎟ J lim
⎟
⎠

Modelica 2005, March 7-8, 2005

M. Rubio, A. Urquı́a, L. González, D. Guinea, S. Dormido

6
J lim =

AD effO2

(29)

δ

where A is the active surface of the catalytic layer. In
the macro-homogeneous model, δ defines the
thickness of the catalytic layer [12].
The balance equations of the liquid water, the
transport of gases and the electronic conduction are
similar to the correspondent equations of the
diffusion layer.
5.3 Membrane
- Balance of gas H2O
p H 2O ∂ε g
RT

∂t

+

ε g ∂p H O
2

RT

∂t

=−

dJ g H 2O α v β
( p H 2O − p sat H 2O )
−
dx
RT

(30)

- Balance of liquid H2O
ρ s ∂χ s
M H 2O ∂t

=−

dJ l H 2O α v β
+
( p H 2O − p sat H 2O )
dx
RT

(31)

Library structure

The hierarchical structure of FuelCellLib library is
represented in Fig. 4. In addition, FuelCellLib
includes models for experimenting with the fuelcells. For instance, it contains the model of a binary
pseudo-random signal generator of electric load.
These components are used to perform for dynamic
analysis of the fuel-cell. For instance, the voltage of
a FC, which has been connected to a step-signal
generator of electric load, is shown in Fig.5.
The electric parts of FuelCellLib models can be
connected to the models of the Electrical package of
the Standard Modelica library. This feature allows
combining the use of FuelCellLib and other
Modelica libraries.
The structure of the library allows the user to choose
among different modelling hypotheses. This
selection is performed by setting the value of certain
model parameters. This structure facilitates
extending the library with new alternative
hypotheses, and also comparing the dynamic
behavior of the models built by using the different
hypotheses.

- Transport of liquid H2O
J l H 2O = −

ρs
M H 2O

D H 2O

Jp
dχ s
+ n drag
dx
F

(32)

- Transport of gas H2O
Figure 4: Packages and models of FuelCellLib

J l H 2O = −

dp H O
τ 2 RT g
D HO
εg
dx
2

2

(33)

- Protonic conduction

J p = −K pε m

dV e
dx

(34)

k p = k p0
k p = ( 0 . 005139 L SO 3 − 0 . 00326 ) e

(35)
1
⎛ 1
⎞
1268 ⎜
−
⎟
⎝ 303 273 + T ⎠

(36)

The model supports two alternative hypotheses. The
first one is to consider constant conductivity, as
shown in Eq. (35). The second one is to consider the
effect of the water load on the conductivity of the
electrolyte [10], as shown in Eq. (36).

The Modelica Association

80

Figure 5: Effect of step load in the cell voltage. Dynamic
simulation.

Modelica 2005, March 7-8, 2005

FuelCell Lib - A Modelica Library for Modeling of Fuel Cells

Four sets of alternative hypotheses are supported by
FuelCellLib. Different hypotheses leads to different
dynamic behaviour of the model (see Figs. 6 and 7).
Two case studies are presented in this work: (1) the
simulation of two physical layers (membrane and
active layer); and (2) the simulation of the three
physical layers (membrane, active and diffusion
layer). The results are discussed in the next section.

7

Validation of library

PEMFCs and DMFCs are developed in the
Renewable Energy Laboratory of the Industrial
Automatic Institute (IAI) of CSIC (see Fig. 8). These
fuel-cells have been employed to carry out the
experimental validation of the FuelCellLib library.
The simulation results obtained using FuelCellLib
agree with the theoretical and the experimental data.
A simulated polarization curve, obtained using
FuelCellLib, and experimental data, measured from
a PEMFC manufactured in the I.A.I, are shown in
Fig. 9.

Figure 8: Fuel-cell (left) developed in the Renewable Energy
Laboratory of the Industrial Automatic Institute (IAI) of CSIC,
Madrid, Spain (right)

Figure 9: Experimental and simulated polarization curve, exp.
(o), model (- -), (2x105 Pa of O2, T= 340ºK).

Simulation results using FuelCellLib are shown in
Fig. 10. They can be compared with the results
obtained using the model of K.Broka [5] (see Fig.
11). Both results predict the fall of the oxygen
concentration along the catalytic layer, and how the
fall is bigger as the current increases.
Simulation results obtained using FuelCellLib are
compared in Fig. 12 with the experimental data
presented by J. Larminie [13]. Both predict the effect
of the Tafel slope on the polarization curve (see
Fig.12).
The simulated voltage of the fuel-cell, obtained in
response to a step change in the load, is shown in
Fig. 5. It agrees with the experimental data provided
by J. Larminie [13].
In addition, FuelCellLib can be used to predict
phenomena which can not be measured
experimentally. For instance, the effect of flooding
of the cathode, (see Fig. 13), the water load in the
catalytic layer and the membrane. The production of
water in the catalytic layer, associated to the
diffusion in the catalytic layer and the membrane, is
shown in Fig. 13.

Figure 6: Dynamic simulation of voltaje of FC with a psuedocapacitance hypothesis dependence (- - -) and without psuedocapacitance hypothesis dependence (___).

Figure 7: Dynamic simulation of flux of water in membrane with
electro-osmotic drag hypothesis dependence (- - -) and without
electro-osmotic drag hypothesis dependence (___).

The Modelica Association

81

Modelica 2005, March 7-8, 2005

M. Rubio, A. Urquı́a, L. González, D. Guinea, S. Dormido

Figure 14: Effect of limit current in polarization curve (. . .) no
limit current dependence, (- - -) limit current with no pressure
dependence, (___) limit current with pressure dependence.

Figure 10: Pressure of oxygen along the catalyst layer with
three different current density, 12mA/cm2 (. . .), 90mA/cm2
(- - -), 230mA/cm2 (___); (2x105 Pa of O2, 340ºK).

The effect of the limit current on the polarization
curve, simulated using FuelCellLib is shown in Fig.
14.
The simulated polarization curves (see Fig.3, 9, 12,
14) are obtained by reaching a stationary value in the
dynamic simulation of the models.

8

Conclusions

FuelCellLib has demonstrated to be useful for
improving the understanding of the phenomena
involved in the fuel-cell operation. The objectoriented design of the library facilitates the
extension, modification and reuse of its code. In
addition, the library structure facilitates introducing
new modelling hypotheses and comparing the results
obtained by using these different hypotheses. The
code of the library models is easy to understand by
other developers.

Figure 11: Oxygen pressure in the cathode in x axis in K.Broka
model, (.....)250, (- - - -) 500, (_ _ _ ) and 1000 (____) mA /cm2.

9

Future works

Future releases of the library will support the
following capabilities: (1) 2D and 3D models, which
allow to represent in a detailed way the fluiddynamics phenomena; (2) new modeling hypotheses
that describe the electro-catalytic phenomena with
higher level of detail, such as the thin film or
agglomerate models; and (3) new models to simulate
DMFC (direct methanol fuel cell) and SOFC (solid
oxide fuel cell).
Finally, we will be able to obtain a greater quantity
of experimental data of the FCs, to achieve a more
detailed experimental validation of the library.

Figure 12: Influence of Tafel slope in polarization curve (I-V) in
the library (---150mv),(__200mv).

Figure 13: Water load in cathode along the x axis.

The Modelica Association

82

Modelica 2005, March 7-8, 2005

FuelCell Lib - A Modelica Library for Modeling of Fuel Cells

References
[1]

[2]

[3]

[4]

[5]
[6]
[7]
[8]
[9]
[10]
[11]
[12]
[13]

M.Ceraolo, C.Miulli, A.Pozio, Modeling static
and dynamic behaviour of PEMFC on the
basis of electro-chemical description, J. Power
Sources 113 (2003).
A.Kumar, R.Reddy, Effect of channel
dimensions and shapes in the flow-field
distributor on performance of PEMFC, J.
Power Sources 113 (2003).
W.D.Steinmann, P.Treffinger, Simulation of
Fuel Cell Powered Drive Trains, Modelica
WorkShop 2000 Procedings.
D.Bevers, M.Wöhr, K.Yasuda, K.Oguro,
Simulation of polymer electrolyte fuel cell
electrode.J.Appl. Electrochem.27 (1997).
K.Broka, P.Ekdunge, Modelling the PEM fuel
cell cathode, J.Appl. Electrochem.27 (1997).
J.Larminie, A.Dicks, Fuel Cell Systems
Explained, Wiley 2000.
A.A.Kulikovsky, Fuel Cells 2001,1(2).
V.Gurau, H.Liu, S.Kakac,AIChE J.2000
46(10).
D.M.Bernardi,
M.W.Verbrugge,
J.
electrochem. Soc. 139,9 (1992).
T.E.Springer,
T.A.Zawodzinsky,
J.Electrochem.Soc. 138 (1991).
S.Dutta, S.Shimpalee, J.Appl.Electrochem.
(2000), 30(2).
D.B.Genevey, Thesis, F.V.P.I. (2001).
J. Larminie, A.Dicks, Fuel Cell System
Explained, Wiley (2000).

The Modelica Association

83

Modelica 2005, March 7-8, 2005

The Modelica Association

84

Modelica 2005, March 7-8, 2005

A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems

A Metabolic Specialization of a General Purpose
Modelica Library for Biological and Biochemical Systems
Emma Larsdotter Nilsson and Peter Fritzson
Linköpings universitet, PELAB – Programming Environment Laboratory
Department of Computer and Information Science, SE-581 83 Linköping, Sweden
{emmni,petfr}@ida.liu.se

tems modeling and simulation of the lead compound’s
effects on different metabolic pathways are included.
A metabolic pathway can be seen a complex web
made up out of several hundred substances and more
than twice as many reactions. Substances that are expected to interact in a harmful or lethal way with essential metabolic pathways can be removed at an early
stage and a reduced number of promising lead compounds can be chosen for the concluding tests.
In theory, simulations of a single or a few interconnected pathways can be useful when the metabolic
pathways under study are relatively isolated from each
other. In practice, even the simplest and most wellstudied metabolic pathways can exhibit complex behavior due to connections in-between different levels
of the whole-cell or whole-organism system.
In light of this, the need for a consistent framework for
modeling, simulation, and visualization of metabolic
pathways is quite obvious. The object-oriented approach for large scale systems has previously been
proven successful in many areas and there is no reason
to believe that it should not be useful for metabolic
pathway systems.
Given Modelica’s previous success with huge and
complex technical, physical, electrical, and thermodynamic systems it is likely that it will also be suitable
language for modeling, simulation, and visualization
of metabolic pathway systems.
So far two Modelica libraries for biological and biochemical applications have been specified. The first
library, BioChem, is an abstract general-purpose library for biological and biochemical systems. The
BioChem library is not intended, nor designed to be
used directly for creating models and running simulations. The intention with the library is to provide some
common basic behaviors, attributes, and environmental properties to be used in special-purpose libraries.
The second library, Metabolic, is a special-purpose
library extended from the partial models in BioChem.
Metabolic is designed to be used for modeling,
simulation, and visualization of metabolic pathways.
The models specified in the library describe basic sub-

Abstract
In the drug industry the later a substance is discharged
from the drug development pipeline, the higher the
financial cost. In order to reduce the number of lead
compounds a number of systems have been suggested,
and in most of these systems modeling and simulation
of the lead compound’s effects on different metabolic
pathways are essential. In these systems, substances
that are expected to be harmful or lethal can be removed at an early stage. Consequently, a reduced
number of promising lead compounds can be chosen
for the concluding tests.
Given Modelica’s previous success with huge and
complex systems it is likely that it will also be suitable
for modeling, simulation, and visualization of metabolic pathway systems, i.e., those systems used in the
drug industry. A Modelica library designed to be used
for modeling, simulation, and visualization of metabolic pathways is the special-purpose library Metabolic, an extension of the abstract Modelica library
BioChem.
KEYWORDS: Metabolic pathways, pathway modeling, pathway libraries, template models, BioChem,
Metabolic.

1

Introduction

There is currently a great interest in the development
of novel analytical technologies for rapid screening of
biological dysfunctions in pharmaceutical and clinical
applications. In the drug industry the later a substance
is discharged from the drug development pipeline, the
higher the financial cost. Not only is it costly to test
many substances, the price of the tests increase along
the development pipeline. Minimizing the number of
substances that are fully tested, i.e., becoming lead
compounds, is therefore one of the most important
aims of all pharmaceutical discovery programs [1].
In order to reduce the number of lead compounds a
number of systems have been suggested, out of which
some have been realized [2-5]. In most of these sys-

The Modelica Association

85

Modelica 2005, March 7-8, 2005

E. Larsdotter Nilsson, P. Fritzson

stances and general reactions that are common in
metabolic pathways.
Provided with the reactions in Metabolic it is possible to build a library of metabolic pathway templates.
The idea is that these general model-templates can
easily be extended and adapted to concrete speciesspecific models. The concrete models can then be used
in standalone and connected simulations of metabolic
pathways.
1.1

tion of cellular processes, addressing the whole chain
of processes starting with DNA, on to the transcription
of DNA into RNA, further on to the translation of
RNA into proteins, and finally all the way to the endconcentrations of proteins.
2.1

A chemical reaction involves one or more transformations of one or several substances, called substrates,
resulting in one or several new substances, called
products. A reaction can be either irreversible, meaning transforming substrate into product, or reversible,
meaning not only transforming substrate into product
but also the other way around. Strictly speaking, all
reactions can be seen as reversible, but for irreversible
reactions the re-transformation of substrate into product is essentially so small and/or slow that it is ignored. A reversible reaction can also be seen as two
separate irreversible reactions.
Nature’s struggle to reach balance is the driving force
for all chemical reactions. The speed with which this
balance is reached is highly dependent on the environment surrounding the substrates in question. A specific set of substrates, physical variables, and other
substances present during the reaction should always
result in the same reaction type, progress, and result as
long as all the initial values and conditions are the
same.

Outline

Modelica has so far mainly been used to model technical, physical, electrical, and thermodynamic systems.
Hence the area of biology and biochemistry might be
somewhat unfamiliar to some of the readers. For those
readers not familiar with some basic concepts and notions in biological and biochemical science this paper
will first give an introduction to the area of research.
The reader will be acquainted with the concept of seeing the cell as a system and the different levels within
this system. A short overview of the data used for
modeling and simulation of metabolic pathways is also
given. The readers who are familiar to the information
presented in the first part of the paper can skip to the
fourth section where the work on using Modelica for
modeling, simulation, and visualization of biological
and biochemical systems is presented.
The second part of the paper starts with pointing out
the most significant reasons to use Modelica for biological and biochemical systems, i.e., the benefits of
performing modeling and simulation of such systems
using Modelica. Subsequently the development of the
two Modelica libraries, BioChem and Metabolic will
be in focus, i.e., out-lining the basic design idea behind the two libraries and the environment that they
have been developed in. From here on, the paper is
concerned with the details of the two libraries and
their use. The paper is concluded with some conclusion of the work done so far, and some future work
and possible improvements.

2

2.2

Reaction Networks

A number of sequential and/or parallel substance
transformations can be arranged into a graph, with the
edges representing the reactions and the nodes representing the substances. Depending on the reaction in
focus most of the substances in a network can function
both as substrates and products. Each reaction network
will have in-flows and out-flow points, which in turn
can be viewed as the substrates and products of a reaction network at a higher level. At this higher level,
several of the more specialized reaction networks can
be connected through these in-flows and out-flows to
form a large super-network.

Introduction to the Area of Research: The Cell as a System

2.3

During the past ten to fifteen years the development
and introduction of new analytical techniques in the
area of biology and biochemistry have greatly increased the amount of experimental data obtained
from experiments performed in the area. Automated
DNA sequencing, microarray-analysis of gene expressions, and protein profiling are just a few of the methods that have made a significant contribution to the
extensive amount of data available. The obtained data
can be useful in modeling, simulation, and visualiza-

The Modelica Association

Chemical Reactions

Metabolic Pathways in Cells

Cells are the basic building blocks of all living organisms. No matter if the cells are part of a multi-cellular
organism, or constitute uni-cellular organisms, the
processes inside them do not differ greatly. A cell’s
metabolism involves the uptake, decomposition, and
rebuilding of different compounds and can be seen as
several complex webs transporting matter and energy.
These complex webs, made out of several hundred
substances and more than twice as many reactions, are
referred to as cellular or metabolic pathways e.g. the

86

Modelica 2005, March 7-8, 2005

A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems

Starch and sucrose metabolism, the Glycolysis, the
Gluconeogenesis, and the Citrate cycle (Figure 1).
Many of the reactions participating in these pathways
are more or less the same in all cells, while others are
highly dependent on the species, the type of cell, or
even on the individual that the cell belongs to.
Phosphoenolpyruvate Pyruvate

Some of the reactions in these metabolic pathways are
already well-known as well as mathematically defined.
Other parts of these pathways are more or less undetermined, ranging from not being fully mathematically
defined to not being fully discovered yet.
Each metabolic pathway is highly compartmentalized
with a few in-flows and/or out-flows that can be connected to preceding and following metabolic pathways, e.g. the Starch and sucrose metabolism is a preceding pathway and the Citrate cycle is a following
pathway of the Glycolysis while the Gluconeogenesis
is both a preceding and following pathway of the Glycolysis (Figure 3).

Acetyl-CoA

Icocitrat dehydrogenase NAD+
Phosphoenolpyruvate
carboxylkinase

Citrate Cis-Aconitrate

Isocitrate

Oxaloacetate
Aconitate hydratase 1

Citrate synthase

Icocitrat dehydrogenase NADP+

Malate dehydrogenase

Malate

Fumarate hydratase

Oxalosuccinate

FAD Flavoprotein

Dihydrolipoamide Lipoamide

CO2
ThPP

Fumarate
Succinate
dehydrogenase

2-Oxoglutarate
Dihydrolipoyl
transsuccinylase
SuccinateCoA ligase

S-Succinyldihydrolipoamide

Succinate

3-Carboxyl-1hydroxypropyl-ThPP
Α-Ketoglutarate dehydrogenase

Succinyl-CoA

Figure 1. The metabolic pathway Citrate cycle for Bakers yeast (Saccharomyces cerevisiae). The enzymes that
control the metabolic reactions are connected to the reaction arrows and shown in italic. The circles represent
substances that participate in the pathway.
Phosphoenolpyruvate Pyruvate

Acetyl-CoA

Citrate Cis-Aconitrate

Isocitrate

Oxaloacetate

Malate

Oxalosuccinate
CO2

Dihydrolipoamide Lipoamide

Figure 3. Interconnection of the four metabolic pathways, the Starch and sucrose metabolism, the Glycolysis,
the Glucogenesis and the Citrate cycle. More pathways
do connect to each one of the four pathways, but for simplicity these have been edited out.

ThPP

Fumarate

2-Oxoglutarate

S-Succinyldihydrolipoamide

3-Carboxyl-1hydroxypropyl-ThPP

Succinate
Succinyl-CoA

2.4

Figure 2. The metabolic pathway Citrate cycle for Bakers yeast (Saccharomyces cerevisiae) seen as a subsystem. The dark circles represent substances that are
connection points to other metabolic pathways while the
light circles represent substances that are internal with
respect to the metabolic pathway. (Compare to Figure 1.)

The connection of all possible metabolic pathways for
a cell will result in a fully functional system level in
the whole-cell system, i.e., the metabolic level. But in
order to understand and get a complete view of the
entire whole-cell system one needs to look beyond the
metabolic level. Apart from the metabolic level the
whole-cell system also contains a gene-expression
level. The latter level involves not only the transcription of DNA into RNA and the subsequent translation
of the RNA into proteins, i.e., enzymes involved in
metabolic reactions, but also all interactions inbetween DNA, RNA, and proteins. Interactions inbetween metabolites, i.e., substances taking part in the
metabolic reactions, and DNA, RNA, and proteins are
also considered to some extent at this level. Figure 4

Most of the reactions in these pathways are, in one
way or another, controlled by enzymes, i.e., proteins.
Proteins are the result of the transcription of DNA into
RNA, and the subsequent translation of RNA into
amino acid sequences. Enzymes (Figure 1) can either
activate or inhibit the reaction in question and the
amount of a protein in the cell is controlled by the expression of the gene that codes for that specific protein. One of the greatest challenges in the area right
now is to figure out which proteins interact with which
reactions and then try to find the corresponding coding
gene in the DNA for these proteins.

The Modelica Association

Levels in the Whole-cell System and Multicellular Systems

87

Modelica 2005, March 7-8, 2005

E. Larsdotter Nilsson, P. Fritzson

provides a somewhat simplified view of the two levels
of the whole-cell system.

Although all the above resources together represent a
good general reference in the work of modeling and
simulation of metabolic pathways, they also have significant limitations. The usually non species-specific
information causes many errors and inconsistencies,
and in many cases the amount of data that can be
found for a pathway is not enough for building accurate pathway models [12]. Yet another problem with
these databases is that the data contained in different
databases might be inconsistent. But even with the
mentioned limitation it is still possible to perform
modeling and simulation of metabolic pathways with
the information provided by the above resources.

4

Biological and biochemical systems can often easily
be described using mathematical relations and expressions. This makes the equation-based Modelica [13] a
suitable programming and modeling language for
modeling of such systems. First of all, Modelica
classes are acausal, i.e., can adapt to more than one
data flow context [14], which is a great benefit when
dealing with chemical reactions where the flow of
matter can move in two directions.
The complexity of biological and biochemical models
can be rather high, containing several hundreds of
items. However, this will not be a problem since Modelica’s strength as a modeling language for complex
technical systems is well proven [15].
Moreover, Modelica’s strong software component
model also makes it ideal as an architectural description language for complex systems [15], e.g. metabolic
pathway webs. It is also possible to model both discrete and continuous systems, as well as hybrids
thereof [14]. Especially hybrid systems are quite common in the subject area of biology and biochemistry.
Finally, since the complexity of the biological and
biochemical models can be rather high. Since Modelica is an object-oriented language the realization of
the several hundreds of items within a metabolic
pathway will be greatly facilitated through instantiating only a few basic components.

Figure 4. The whole-cell system with the geneexpression and the metabolic levels.

Beyond the whole-cell system there is a meta-level of
different kinds of multi-cellular systems that all involves some kind of interchange of substances, and/or
communication. Cellular specializations and/or differentiations are common in multi-cellular organisms and
the assembly of them can be referred to as an organism level. Both uni-cellular and multi-cellular species
can be part of large aggregated multi-species system,
i.e., ecological systems.

3

Data Used for Modeling and Simulation of Metabolic pathways

Much of the data regarding metabolic pathways obtained through experiments and analysis is accessible
in different public and commercial reference databases. In order to be able to model metabolic pathways
one needs to know the participating substances and the
reactions in-between them. The organization of entire
blocks of metabolic pathways can be found in humancurated maps in public databases, i.e., KEGG [6] and
BioCarta’s “Proteomic Pathway Project” [7]. The
equations specifying the reactions can, however not be
found in those maps. This information can instead be
retrieved from databases that provide data on individual enzymatic reactions, i.e., BRENDA [8] and EMP
[9], and in databases that provide data on multi-step
metabolic pathways, i.e., MPW [10] and EcoCyc/HumanCyc [11].

The Modelica Association

Benefits of Using Modelica for Biological and Biochemical Systems

5
5.1

Development of the Libraries
Development Environment

The BioChem and Metabolic libraries have been
developed using the MathModelica [16, 17] environment that consist of the Dymola kernel [18], the
Mathematica notebook environment [19], and the
graphical Model Editor.

88

Modelica 2005, March 7-8, 2005

A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems

In the MathModelica environment the Modelica code
along with the documentation for each library is integrated in Mathematica notebooks. This does not only
make it easier for non-computer science users to navigate the code, it also facilitates for these users to write
their own Modelica classes. The Model Editor is a
graphical drag-and-drop interface currently based on
Microsoft Visio [20]. The user creates models in the
graphical environment by dragging and dropping
components from existing model libraries onto the
diagram area and then connecting them in a suitable
manner. Models can also be created in the Mathematica notebook textual environment, but the models
must then first be transferred to the Model Editor in
order to get a graphical view of the model.
Once a model has been created it can either be transferred to a notebook for further processing and documentation or simulated in the simulation environment
provided by MathModelica. The Dymola kernel handles the simulations by receiving, compiling, and executing the model. The result from the simulation can
then be presented with different types of diagram. The
parameters and the initial values of the model can also
be altered in-between simulations.
5.2

used in special-purpose biological and biochemical
libraries. With the basic features provided in BioChem
it is easy to create new special-purpose libraries without extensive addition of new code.
So far the Modelica library Metabolic is the only
library to use the features provided by BioChem
(Figure 5). The design idea behind Metabolic was to
create a special-purpose Modelica library for modeling, simulation, and visualization of metabolic pathways, i.e., modeling, simulation, and visualization of
the metabolic level in cells. The classes implemented
in Metabolic describe substances and reactions that
can take place in-between these substances in a diverse number of metabolic pathways.
5.3

The BioChem library

Most substances and reactions, respectively, have
some common basic features. For instance, all substances must have a concentration and all reactions
must have at least one substrate and one product. The
design objective behind the BioChem library is to collect these basic features of substances and reactions
along with units, compartment properties, and other
attributes that are commonly used in these kinds of
systems in a general-purpose biological and biochemical Modelica library.

Basic Idea of Library Design

The design idea behind the BioChem library is to create a general purpose Modelica library for modeling
and simulation of biological and biochemical systems
(Figure 5).

package BioChem
package Units
"Units used in sub-packages of BioChem"
end Units;
package CompartmentProperties
"Properties for compartments used in sub-libraries"
end CompartmentProperties;
package Icons
"Icons used in the package"
end Icons;
package ConnectionPoints
"Connector interfaces used in sub-libraries"
end ConnectionPoints;
package ReactionNodes
"Reaction nodes"
package Basics
"Basic components for reaction nodes in the package"
end Basics;
package Substances
"Partial models for substances in sub-libraries"
end Substances;
end ReactionNodes;
package Reactions
"Reaction edges"
package Basics
"Basic compnents for reaction in the package "
end Basics;
package ReactionTypes
"Reaction types for reactions in sub-libraries"
end ReactionTypes;
end Reactions;
package Metabolic
"Package for metabolic cellular reactions"
end Metabolic;
end BioChem;

Figure 6. Structure of the BioChem library.

In order to avoid recreating model code for the basic
features of substances and reactions for each new
Modelica library for biological or biochemical systems
these features can instead be collected in one library.
Along with substances and reactions it is also practical
to define a default environmental container in which
the substances are contained and where the reactions
can occur. From the visualization’s point of view it is
also practical to define some default interfaces and

Figure 5. Simplified view of the structure of the BioChem and the Metabolic libraries.

The BioChem library is not intended, nor designed to
be used directly for creating models and running simulations, but rather to provide some common basic behaviors, attributes, and environmental properties to be

The Modelica Association

89

Modelica 2005, March 7-8, 2005

E. Larsdotter Nilsson, P. Fritzson

icons which later might be replaced in each sublibrary. Not only the icons and interfaces are designed
to be easily changed and/or replaced, most of the
classes in BioChem are designed in such a way that
they easily can be extended, and some parameters can
also be replaced. The structure of the package is
shown in Figure 6.
Due to the design of BioChem some restrictions on the
types of systems that BioChem can be used for arise.
The systems that the classes in BioChem can be used
for are only those biological and biochemical systems
that contain chemical reactions. Only for those systems fully functional models that can be used for
simulation can be specified.

models. The structure of the Metabolic package is
shown in Figure 7.
As mentioned earlier, many of the reactions that occur
in metabolic pathways are more or less the same in all
cells no matter what species one look at. This is utilized in Metabolic to create a collection of partial
models of different metabolic pathways that through
small changes and/or additions are turned into fully
functional species-specific metabolic pathways.

6

Since the design objective for BioChem was to provide properties and attributes that are common in biological and biochemical systems the library contains
several packages holding classes and partial models.
The classes can be used as they are in sub-libraries to
BioChem, while the partial models must be further
extended to fully functional models.

within BioChem;
package Metabolic
"Package for metabolic cellular reactions"
package Units
"Units used in the package"
end Units;
package Compartments
"Different types of compartments used in the package"
end Compartments;
package Substances
"Reaction nodes"
end Substances;
package Reactions
"Reaction edges"
package Kinetics
"Kinetic reactions"
package UniUni
"A->B kinetic reactions"
end UniUni;
package UniBi
"A->B+C kinetic reactions"
end UniBi;
package UniTri
"A->B+C+D kinetic reactions"
end UniTri;
package BiUni
"A+B->C kinetic reactions"
end BiUni;
package BiBi
"A+B->C+D kinetic reactions"
end BiBi;
package BiTri
"A+B->C+D+E kinetic reactions"
end BiTri;
package TriUni
"A+B+C->D kinetic reactions"
end TriUni;
package TriBi
"A+B+C->D+E kinetic reactions"
end TriBi;
package TriTri
"A+B+C->D+E+F kinetic reactions"
end TriTri;
end Kinetics;
package SBML
"Reactions pre-defined in SBML"
package MichaelisMenten
"Michaelis-Menten kinetics reactions"
end MichaelisMenten;
package Hill
"Hill kinetics reactions"
end Hill;
package Activation
"Activation kinetics reactions"
end Activation;
package Inhibition
"Inhibition kinetics reactions"
end Inhibition;
package Modifier
"Modifier kinetics reactions"
end Modifier;
package Misc
"Miscellaneous SBML-defined reactions"
end Misc;
end SBML;
end Reactions;
end Metabolic;

6.1 BioChem.Units
A number of physical types are needed in order to be
able to declare most parameters and variables in the
BioChem package. Some of the types can be found in
Modelica.SIunits and are here re-defined in order
to avoid long name paths. The SI-types used in Bio-3
Chem are volume (m ), amount of substance (mol),
and concentration (mol m-3).
Most of the other types in the package are non-SI
types and thus need to be fully declared. In order for a
reaction to actually transport something it has to have
a flow of some kind. For a chemical reaction this flow
is the volumetric reaction rate (mol m-3 s-1). Together
with the concentration, the molar flow rate of a substance (mol s-1) is used in the interfaces between connected components.
6.2

The Metabolic library

Most classes in the Metabolic library extend one or
more classes in the BioChem library. Generally the
partial models specified in BioChem are extended, and
with only a few additions, turned into fully functional

The Modelica Association

BioChem.Compartments

In order to be able to control the environment of the
reaction during a simulation a chemical reaction must
take place in a restricted screened-off container.
Within this container the basic physical properties, e.g.
volume and temperature, are the same for all reactions
that take place and all substances contained in that
container.
In BioChem.Compartments this is solved using the
inner-outer construct, i.e., a global variable. An inner
volume is declared in the partial compartment model,
giving all objects placed within an extension of the
partial model the same surrounding volume. The objects that need to have knowledge of the global volume can use the declaration of an outer volume to
reach it. The package so far only contains partial mod-

Figure 7. Structure of the Metabolic library.

5.4

BioChem Sub-packages

90

Modelica 2005, March 7-8, 2005

A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems

though.). For the reaction arrows, connectors are
placed at each intended connectable end. For the enzymes regulating the reactions the connectors are
placed at the enzyme signs. Finally for substances,
eight connectors are placed on the rim of the circle
that represents the node of substance.

els for some different types of containers that can be
found in cells.
6.3

BioChem.Icons

The package BioChem.Icons contains icons used in
the drag-and-drop interface of the Model Editor in
MathModelica. A substance is represented by a circle
and the fill color is changed depending on the type of
substance represented, i.e., substance in solution, fixed
concentration, gaseous substance, etc. Since the substance only come in a few flavors there is one icon for
each type of node.
The reactions on the other hand come in many different variations. A reaction is represented by an arrow
with two or more ends. The number of ends an arrow
can have is determined by the numbers of substrates
and products that are involved in the reaction. Substrate-ends are, by convention, on the left side of the
arrow, while product-ends are on the right side. Arrowheads indicate the direction of the reaction, i.e.,
irreversible reactions only have heads on the productends while reversible reactions have heads on both
ends.
Instead of creating one icon for each type of reaction
the final graphical interface for a reaction is built out
of several partial icons. The reaction arrow is divided
into three parts, substrates side (left part of the reaction arrow), middle, and products side (right part of
the reaction arrow). The middle is the same for all reactions, while the two other parts differentiate depending on the number of substrates and products participating in the reaction.
Enzymes can affect reactions, which is represented by
a small arrow and an enzyme sign. The sign represent
the type of effect that the enzyme have on the reaction,
i.e., inhibition, activation, or a combination of both,
and are indicated with a ─, +, and M respectively.
6.4

within BioChem.ConnectionPoints;
connector SubstanceConnector
"Connection point for substance transfer"
extends Icons.SubstanceConnector;
Units.Concentration c
"Concentration of substance at the connection";
flow Units.MolarFlowRate r
"Molar flow rate of substance at the connection";
end SubstanceConnector;

Figure 8. SubstanceConnector, the connector used
in BioChem and later on also in Metabolic.

6.5

The package BioChem.Substances contains partial
models of different kinds of nodes needed to represent
substances in biological and biochemical systems. The
basic attributes corresponding to the properties that are
studied during simulations, i.e., the amount and the
concentration of the substance, are declared in these
partial models. All partial substance models also extend the partial model BioChem.ConnectionPoints.Node, which contains the connector interface.
6.6

BioChem.Reactions.Basics

All reactions need some basic components in order to
work properly. In the package BioChem.Reactions.Basics these basic components are collected in
a partial reaction model, Reaction.
BioChem.Reactions.Basics also contains components that are not needed in all types of reactions, but
can rather be seen as roles assigned in some reactions
while left vacant in others. Using the role-approach,
the directions of a reaction can be seen as two roles.
The role for a forward directed reaction is almost always appointed, while the role for a backward directed
reaction only is assigned for reversible reactions.
The different types of enzymes that can affect a reaction can also be seen as a set of roles. When no enzymes affect the reaction, all enzyme roles are vacant.
The different roles that are possible to assign are activator, inhibitor, and modifier. A modifier is a situation
dependent enzyme that can react as either an inhibitor
or an activator, depending on the environmental context. These roles are also directional, i.e., they can be
appointed in both a forward and a backward context.
In BioChem.Reactions.Basics model for all the
above roles are defined.

BioChem.ConnectionPoints

The package BioChem.ConnectionPoints contains
the connector SubstanceConnector (Figure 8) that
is used when connecting the different components in a
model. In order to be able to make simulations using a
connected model, the connector has to have a flow
variable. For chemical reactions this flow variable is
the molar flow rate of a substance (mol s-1). There is
also a non-flow variable in the connector, the concentration of a substance. The concentration is later on
used in equations with relations to the reaction rate in
reaction models.
The connector is used in several partial models in
BioChem.ConnectionPoints. Each partial model
relate to the graphical interface of at least on icon in
BioChem.Icons (Not more than one icon at a time

The Modelica Association

BioChem.Substances

91

Modelica 2005, March 7-8, 2005

E. Larsdotter Nilsson, P. Fritzson

6.7

In order to be able to run a simulation of a model all
substances, reactions, and other constructs in the
model must be placed within a compartment model.
Otherwise the global volume cannot be reached with
the outer-declaration.
Reactions and substances that require different properties than the ones provided by the main-compartment
can be placed in new compartments within or adjacent
to the main-compartment.

BioChem.Reactions.ReactionTypes

BioChem.Reactions.ReactionTypes contains a
collection of partial models for different types of reactions that can take place in biological and biochemical
systems. The reaction types are obtained by combining
some different types of classes from other packages in
BioChem. First, there is the combination of substrates
and products. Then there is the appointment of the two
reaction-direction roles. Finally, there is the possibility
to appoint an enzyme role. At this point only three
substrates and three products are allowed and only one
of the enzyme roles can be appointed at a time.
Given the above restrictions four irreversible and
seven reversible reaction types for each possible combination of substrates and products are generated,
giveing 99 different reaction types to choose from in
the sub-libraries.
Parts of the graphical interface for the MathModelica
Model Editor are also defined in this package. Each
partial model has a graphical representation in the
form of a reaction arrow. If the role for the backward
directed reaction is appointed, all the arrow-ends have
heads, otherwise only the product-ends have heads. A
small arrow perpendicular to the reaction arrow is
used to indicate that there is an enzyme-role assigned
in the reaction. An enzyme-arrow above the reaction
arrow indicate that the enzyme is involved in the transformation of substrate into product, while an enzyme
arrow below the reaction arrow indicate that the enzyme is involved in the reverse transformation.
Along with the graphical interface the partial models
Biofor
connector
interfaces
in
Chem.ConnectionPoints are also extended. Since
each of the connector interfaces have been defined in
relation to an icon the extensions are quite straightforward.

7

7.2 Metabolic.Substances
The package Metabolic.Substances contains different types of nodes needed for representing a substance in a metabolic pathway. The substance models
are specified by extending the partial models of substance nodes in BioChem.Substances and adding
some additional attributes and equations. Thus both
normal substance nodes and nodes with different types
of restrictions, e.g. on the concentration of the substance, can be specified.
Typically the concentration in a substance node is allowed to change without restrictions during a simulation, while the total amount of substance in the node is
conserved at all times. Some of the models have an
assert statement that checks that the concentration
never drop more than the tolerance below zero than.
The tolerance is a parameter and can thus be changed
for every node in a model as well as for each simulation run.
7.3

Metabolic.Reactions contains a collection of
models for different types of reactions that can take
place in metabolic pathway systems. The reactions are
obtained by extending at least one of the 99 reaction
types in BioChem.Reactions.ReactionTypes and
then adding an equation for the relation between the
reaction rate and the participating substances, i.e., substrates, products, and interacting enzymes.
Using more or less all of the possible the reaction
types in BioChem.Reactions.ReactionTypes
four irreversible and sixteen reversible reaction types
for each possible combination of substrates and products are generated, giving 180 different reaction models to choose from in the drag-and-drop interface in
MathModelica.
The Systems Biology Markup Language (SBML) is a
computer-readable format for representing models of
biological and biochemical systems. SBML is,
amongst other, applicable to metabolic pathways, cellsignaling pathways, and genomic regulatory networks
[21, 22]. SBML has some predefine reactions, which
are common in SBML-models of metabolic pathways.
All these 32 SBML-reactions are also included in
Metabolic.Reactions in order to facilitate the

Metabolic Sub-packages

The Metabolic library consists of several subpackages containing fully functional classes that can
be used for building models and running simulations
of metabolic systems.
7.1 Metabolic.Compartments
The Metabolic.Compartments package contains
models for some of the different types of containers
that can be found in cells when dealing with modeling
and simulation of metabolic pathways. The partial
compartment models in BioChem.Compartments are
extended in order to obtain the basic properties of a
compartment.

The Modelica Association

Metabolic.Reactions

92

Modelica 2005, March 7-8, 2005

A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems

translation of SBML-models into Modelica, and vice
versa. The translation of models is performed with a
two-way Modelica-SBML parser [23].

8

models in Modelica has been done with inspiration
from the BioChem library [26]. These models can now
easily be added as a sub-library under BioChem.
As for Metabolic, the limitations on the number of
substrates and products for a reaction will be removed.
The construction of a library with metabolic pathway
templates will also continue. The idea is that these
model templates can easily be extended and adapted to
concrete models. The concrete models can then be
used in standalone and connected simulations. For all
of the above tasks, the data contained in the different
resources mentioned in Section 3 will be useful.

Conclusions

During the work with the BioChem and the Metabolic libraries some limitations of the Modelica language has forced us to re-design the libraries’ structure
at several points. The original BioChem library [24,
25] was at a point divided into two libraries, i.e., BioChem and the Metabolic, which made a significant
improvement of the library design and hence the underlying library structure. The design that is presented
in this paper is currently being extensively tested and
has not shown any major shortcomings this far.

9

Acknowledgments
The authors would like to thank MathCore Engineering AB for supplying the MathModelica tool and Andreas Idebrant for providing essential software support. Morgan Ericsson, Växjö universitet, has provided
valuable feedback on the text. Emma Larsdotter Nilsson was in part funded by the Swedish National
Graduate School in Computer Science (CUGS).

Future Work

The BioChem package will probably have few additions of classes and models in the future, while there
will surely be more packages added. As mentioned
before, the main purpose of BioChem is to serve as a
general-purpose package for biological and biochemical Modelica-packages. Some work with ecological

The Modelica Association

93

Modelica 2005, March 7-8, 2005

E. Larsdotter Nilsson, P. Fritzson

References
[1]

[2]

[3]

[4]

[5]

[6]

[7]
[8]

[9]

[10]

[11]
[12]

[13]
[14]

[15] Fritzson, P. and P. Bunus. Modelica - A General
Object-Oriented Language for Continuous and
Discrete-Event System Modeling and Simulation.
in The 35th Annual Simulation Symposium.
2002. San Diego, California, USA: IEEE.
[16] Fritzson, P., J. Gunnarsson, and M. Jirstrand.
MathModelica - An Extensible Modeling and
Simulation Environment with Integrated Graphics and Literate Programming. in The 2nd International Modelica Conference. 2002. Oberpfaffenhofen, Germany.
[17] MathCoreAB, MathModelica website,
www.mathcore.com.
[18] DynasimAB, Dymola website,
www.dynasim.se/dymola.htm.
[19] Wolfram, S., The Mathematica Book. 2003:
Wolfram Media.
[20] Microsoft, Visio website,
http://office.microsoft.com/enus/FX010857981033.aspx.
[21] Hucka, M., et al., The systems biology markup
language (SBML): a medium for representation
and exchange of biochemical network models.
Bioinformatics, 2003. 19(4): p. 524-31.
[22] Finney, A. and M. Hucka, Systems biology
markup language: Level 2 and beyond. Biochem
Soc Trans, 2003. 31(Pt 6): p. 1472-3.
[23] Vollmar, D., A two-way SBML translator and
graphical icons for BioChem, in Deppartment of
Computer and Information Science. 2004,
Linköpings universitet: Linköping.
[24] Larsdotter Nilsson, E. and P. Fritzson. BioChem
- A Biological and Chemical Library for Modelica. in The 3rd International Modelica Conference. 2003. Linköping, Sweden.
[25] Larsdotter Nilsson, E. Simulation of Biological
Pathways using Modelica. in The Huntsville
Simulation Conference 2003. 2003. Huntsville
(AL), USA.
[26] Edelfeldt, S., Evaluation and comparison of
ecological models simulating nitrogen processes
in treatment wetlands, implemented in Modelica,
in Department of Science and Technology. 2005,
Linköpings universitet: Norrköping.

Nicholson, J.K., et al., Metabonomics: a platform for studying drug toxicity and gene function. Nat. Rev. Drug. Discov., 2002. 1(2): p.
153-161.
Klopman, G., M. Dimayuga, and J. Talafous,
META. 1. A program for the evaluation of metabolic transformation of chemicals. J Chem Inf
Comput Sci, 1994. 34(6): p. 1320-5.
Talafous, J., et al., META. 2. A dictionary model
of mammalian xenobiotic metabolism. J Chem
Inf Comput Sci, 1994. 34(6): p. 1326-33.
Darvas, F. and G. Dormán, High-throughput
ADMETox estimation : in vitro and in silico approaches. 2002, Westborough, MA: Eaton Pub. ;
BioTechniques Press. x, 89.
Greene, N., et al., Knowledge-based expert systems for toxicity and metabolism prediction:
DEREK, StAR and METEOR. SAR QSAR Environ Res, 1999. 10(2-3): p. 299-314.
Kanehisa, M., The KEGG database. Novartis
Found Symp, 2002. 247: p. 91-101; discussion
101-3, 119-28, 244-52.
BioCarta, Proteomic Pathway Project,
http://www.biocarta.com. 2004.
Schomburg, I., et al., BRENDA, the enzyme database: updates and major new developments.
Nucleic Acids Res, 2004. 32 Database issue: p.
D431-3.
Selkov, E., et al., The metabolic pathway collection from EMP: the enzymes and metabolic
pathways database. Nucleic Acids Res, 1996.
24(1): p. 26-8.
Selkov, E., Jr., et al., MPW: the Metabolic
Pathways Database. Nucleic Acids Res, 1998.
26(1): p. 43-5.
Karp, P.D., et al., The EcoCyc and MetaCyc databases. Nucleic Acids Res, 2000. 28(1): p. 56-9.
Bugrim, A., T. Nikolskaya, and Y. Nikolsky,
Early prediction of drug metabolism and toxicity: systems biology approach and modeling.
Drug Discov Today, 2004. 9(3): p. 127-35.
ModelicaAssociation, Modelica webpage,
www.modelica.org.
Fritzson, P., Principles of Object-Oriented
Modeling and Simulation with Modelica. 2003:
IEEE Press and Wiley.

The Modelica Association

94

Modelica 2005, March 7-8, 2005

Session 1c
Methods I

The Modelica Association

95

Modelica 2005, March 7-8, 2005

The Modelica Association

96

Modelica 2005, March 7-8, 2005

Exploiting Weak Dynamic Interactions in Modelica

Exploiting Weak Dynamic Interactions in Modelica
Francesco Casella
Dipartimento di Elettronica e Informazione
Politecnico di Milano
Piazza Leonardo da Vinci, 32 - 20133 Milano ITALY
e-mail: casella@elet.polimi.it

Abstract
The simulation of complex systems can be made
more efficient by splitting the system into several,
weakly interacting subsystems, and then integrating
their equations separately. The paper discusses the
required extension to the Modelica language, as well
as the corresponding integration algorithms. Possible
applications include real-time integration of large
systems, distributed simulation, and the integration
of Modelica with external simulators.

1

Introduction

Consider a complex dynamical system, obtained by
connecting fast and slow subsystems. The simultaneous integration of the corresponding large set of
DAEs can become highly inefficient, especially
when a fixed-step algorithm is employed (e.g., for
real-time simulation): the fast dynamic subsystems
force the adoption of a very small integration time
step, and the system of coupled DAEs to be solved
at each step is very large.
In some cases, however, the system can be decomposed into two (or more) weakly interacting subsystems, whose describing DAEs can be solved independently at each time step. This allows to split the
overall numerical integration task into many smaller
tasks, which can be carried out more efficiently;
moreover, it opens the way to distributed simulation,
where each integration task runs on a different CPU.
This method can offer very significant performance
improvements in real-time, fixed time-step simulators, e.g. for hardware-in-the-loop and training applications.
The weak dynamic interaction method has been extensively investigated in our research group in the
past 10 years. The first notable example is the general-purpose, object-oriented modelling and simulation
environment MOSES [1], which relied on an objectoriented database for system modelling, and on

The Modelica Association

97

DASSL-RT to perform variable step-size integration. The second example is the ProcSim package
[2], a simulation environment for power plant simulation, based on the visual LabView environment,
relying on ad-hoc, implicit Euler integration algorithms.
A brief paper on the basic concepts of weak interactions in object-oriented modelling appeared several
years ago on the Eurosim Simulation News Europe
magazine [3]; the purpose of this paper is to propose
an implementation of those concepts in the Modelica
framework. The mathematical foundations of weak
dynamic interaction are first introduced in Section 2.
The extension of the Modelica language is then discussed in Section 3, with reference to a simple example; the problem of generating the corresponding
numerical simulation code, as well as the application
to distributed simulation are also dealt with. Section
4 follows with further discussion, including the comparison of the proposed approach to other existing
methods to speed up real-time simulations. Section 5
concludes the paper with some proposals for future
work.

2

Weak Dynamic Interaction: Mathematical Foundations

The concept of weak dynamic interaction is introduced with the aid of a simple example. Consider the
electrical circuit represented in Fig. 1.
The complete set of the component and connection
DAEs is:
I1
VA
E

R1

I2

I4

VB

R2

I5

VC

C1

C2

R3

I3

Figure 1: A simple electrical circuit

Modelica 2005, March 7-8, 2005

F. Casella

I1

E−V A=0
V A−V B =R1 I 1
C 1 V˙ B =I 4
V B −V C =R1 I 2
C 2 V˙C =I 5
V C =R3 I 3
I 1− I 4− I 2=0
I 2−I 5−I 3=0

VA

I4

E

VB

R2

I5
VC

C1

I2

VC

C2

R3

I3

(1)
Figure 2: The electrical circuit split into two interacting subsystems.

In this particular case, it is straightforward to solve
the algebraic equations for the algebraic variables,
and to rewrite the system in ODE form:

ẋ= AxBu
where x=[ V B

R1

I2

(2)

V C ] ' and u=E.

Suppose that the system (2) is solved by Euler's implicit formula; at each time step, the following linear
system has to be solved:

H x k 1= x k  f k 1

G L x k 1=G R x k  f k 1

(3)

where H = I – A∆t, f = Bu∆t, and ∆t is the integration time step. The integration algorithm is A-stable
for any ∆t. Note that, in the case of a non-linear system, the role of matrix H would be played by the
system Jacobian, which should be inverted at (almost) each time step.
If the system is solved by Euler's explicit formula,
the solution is given by

x k 1=F x k  f k

(4)

where F = I + A∆t. In this case, no matrix inversion
is needed; on the other hand, the algorithm is A-stable only if ∆t < 2Tmin, where Tmin is the minimum
time constant of matrix A. Explicit integration formulae are not convenient if the system is stiff, i.e. if
there are mixed fast and slow dynamics, as the fast
one dictates the maximum possible time step.
Suppose now that both R2 and C2 are sufficiently
large: the variation of the voltage VC within a time
step is likely to be small, compared to the voltage
drop across the resistor, thus having a weak influence on the current I2; conversely, the current I2 cannot vary VC substantially over a single time step, and
thus has a weak influence on VC. With reference to
the R2-C2 connection, the voltage is thus a weak
connection variable on the resistor side, while the
current is a weak connection variable on the capacitor side. In other words, an approximate dynamic decoupling can be applied at the connection between
R2 and C2. It is then possible split the model in two
parts, as shown in Fig. 2.

The Modelica Association

The left part of the circuit is connected to a fictitious
voltage generator VC, and the right part of the circuit
is connected to a fictitious current generator IC.
The idea is now to adopt a mixed implicit-explicit
integration algorithm to the system of Fig. 2. At each
time-step, the equations of each sub-circuit are integrated using Euler's implicit formula, while taking
into account the last computed value of the boundary
variable IC or VC. The corresponding integration formula is:

98

(5)

where GL and GR are the following triangular matrices:

[ ]
[ ]

t
0
R1 C 1
G L=
t
t
−
1
R2 C 2
R3 C 2
1

t
R2 C 1
G R=
t
0 1−
R2 C 2
1

As matrix GL is now triangular (due to the dynamic
decoupling), the solution of equation (5) is trivial,
and has almost the same computational weight of the
explicit formula (4). However, the integration formula remains A-stable for much larger time steps
than the fully explicit formula; for large values of R2,
it is even unconditionally stable. For example, if the
following values are taken:
R =0.1; C =1; R =1; C ={1,3,10}; R =[0.1-10];
1
1
3
2
2
the stability regions shown in Fig. 3 and 4 are obtained; the stable region is below the limit curve for
each value of C2. It is apparent how the algorithm
based on the weak interaction method allows far
larger integration time steps than the explicit algorithm, while requiring a comparable computational
time, as no matrix inversion is required.
Modelica 2005, March 7-8, 2005

Exploiting Weak Dynamic Interactions in Modelica

3
3.1

Figure 3: Stability regions of explicit Euler's integration algorithm.

Figure 4: Stability regions of the weakly interacting
integration algorithm.

Going beyond the simple example shown here, the
advantages of the proposed modelling and numerical
integration strategy become more and more substantial if the systems are nonlinear, and as the order of
the weakly coupled subsystems grows larger.
Finally, if the dynamics of the weakly coupled subsystems is very different (i.e. one is fast and one is
slow), a multirate integration algorithm could be
adopted, in which the time step of the slow subsystem is a multiple of the time step of the fast subsystem. This kind of strategy, whose detailed analysis is
outside the scope of this paper, can lead to even larger computational savings, if the fast subsystems have
a few states, while the slow subsystems contains the
majority of the states.

The Modelica Association

99

Weak Interaction in the Modelica
Framework
The weak modifier

The weak interaction method will now be introduced
in the Modelica framework with the help of a representative example, i.e., the simulation of a power
generation system. The system (see Fig. 5) is composed by the connection of two main sub-systems:
the mechanical power generation unit (e.g. a gas turbine unit, or a boiler-steam turbine unit), and a synchronous generator, connected either to the grid or to
local loads. The aim of the simulation is to simultaneously represent the control system dynamics of
both units, with time scales ranging from less than a
tenth of a second (swing dynamics of the synchronous generator), to several minutes (boiler pressure dynamics).
Assuming that the rotational inertia has been lumped
on the MechGen side, the high mechanical inertia of
the gas turbine shaft provides a dynamic decoupling
between the thermo-mechanical system on the left
side of the connection and the electro-mechanical
system on the right side of the connection. In other
words, a step variation of the torque applied to the
shaft by the electrical generator cannot vary the shaft
speed substantially over time scales smaller than 0.20.5 seconds; this means that the torque is a weak
connection variable on the mechanical generator
side. On the other hand, since the shaft speed cannot
vary substantially over such a time scale, the shaft
angle is a weak connection variable on the electrical
generator side.
If the two subsystems are connected by means of
standard Modelica.Mechanics.Rotational connectors, this situation could be described by adding the
weak modifier to the Modelica language, and by introducing the concept of weak connection:
connect(MechGen.Shaft(weak tau),
ElecGen.Shaft(weak phi));

MechGen

ElecGen
Shaft

Shaft

G

Network

Figure 5: Model of a power generation system.

Modelica 2005, March 7-8, 2005

F. Casella

Alternatively, the weak attribute could be directly
built in the two sub-system connectors, which should
be declared as follows:
import Modelica.Mechanics.Rotational.*;
model MechGen
Interfaces.Flange_a Shaft(weak tau);
...
end MechGen;
model ElecGen
Interfaces.Flange_b Shaft(weak phi);
...
end ElecGen;

It should also be possible to apply the weak modifier to variables declared inside a model, if their influence on the object behaviour across a single timestep is small; for example, the air temperature at the
gas turbine air intake.
3.2

Integration Algorithms

The weak variables can now be exploited by the integration algorithm. The basic idea is that every
weak variable can be treated as an input variable by
the numerical integration algorithm, regardless of its
actual physical causality; the corresponding input
value will correspond to last computed value available to the integration algorithm.
If the weak variables are replaced by input variables, the Modelica compiler could then easily decompose the dynamics of the whole system in two
weakly interacting subsystems, as shown in Fig. 6.
The numerical integration task could then be decomposed into two smaller sub-tasks. Each sub-task will
read the last computed value available of its input
variables to compute the next value of its output
variable, as explained by the following pseudo-code
(an explicit integration algorithm is assumed for
simplicity):
T := 0.05; // Time step length
loop
(phi,x_mech) :=
MechGenInt(tau,x_mech,T);
(tau,x_elec) :=
ElecGenInt(phi,x_elec,T);
end loop;

Each subsystem can be integrated with the method
of choice, represented here by the MechGenInt
and ElecGenInt functions. If implicit algorithms
are used, the dynamic decoupling leads to two smaller sets of nonlinear equations, to be solved sequentially. This has beneficial effects on the computation
time, as already discussed in Section 2.
In the simple example shown above, the two integration algorithms are synchronous (i.e., they share the
same time step). However, since the two corresponding subsystems are characterised by widely different
dynamic time constants, it is also possible to choose
different step lengths for each one, as shown in the
following pseudo-code:
Tmech := 0.1;
Tel := Tmech/N;
loop
(phi,x_mech) :=
MechGenInt(tau,x_mech,Tmech);
for h in 1:N loop
(tau,x_elec) :=
ElecGenInt(phi,x_elec,Tel);
end for;
end loop;

This scheme has a big potential for the real-time,
fixed time-step simulation of complex systems: instead of dealing with a huge coupled system, which
must be integrated with a small time step dictated by
its fastest subsystem, it is possible to split the integration task into many independent sub-tasks, each
one having the appropriate step length. In this way,
each subsystem is neither under-sampled or oversampled, and the computational resources are used
efficiently.
3.3

Distributed Simulation

If a system can be decomposed into several, weakly
interacting subsystems, it is also straightforward to
devise a distributed simulation strategy: the integration tasks of each sub-system can be allocated on
different CPUs, communicating e.g. through a
shared memory database or TCP/IP sockets (Fig. 7).

MechGen
Integrator

where x_mech and x_elec are the state vectors of
the two subsystems.

ElecGen
Integrator

...

tau

MechGen

phi

ElecGen

Figure 6: Weakly interacting subsystems.

The Modelica Association

Shared process variable database

Figure 7. Distributed simulation architecture.

100

Modelica 2005, March 7-8, 2005

Exploiting Weak Dynamic Interactions in Modelica

A further possibility is to support co-simulation, by
introducing “external simulator” objects, which are
an extension of the already existing Modelica external functions. In this case, a Modelica “wrapper”
model, defining the input, output, and weakly interacting connector variables, could be written and then
linked to external simulation applications. The actual communication between the Modelica-based simulator and the other ones could then be performed
via TCP/IP sockets, DLLs, DDE, or any other interprocess communication mechanism. In this way, it
would become possible to merge parts of a simulator
obtained from a Modelica model with other parts
provided by different simulators (e.g. a CFD code,
or a digital controller emulator), or by interactive
user interfaces.
3.4

Further extensions to the proposed method.

When introducing the example in Section 3.1, the assumption was made that the shaft inertia was entirely contained in the MechGen model; in other words,
that the electrical generator model inside ElecGen
had no inertia at all. If this is not true, the weakening
method cannot be applied directly as explained: the
ElecGen.Shaft.phi variable, far from being
weakly interacting with the MechGenShaft.phi
variable, has some inertia rigidly connected to it.
The corresponding decoupled integration algorithm
would probably be unstable for rather small time
steps.
This case could be easily recognised by the symbolic
manipulation engine: the weakly interacting model
(Fig. 6) would have more state variables corresponding to the weak connection variable phi, if compared with the original, rigidly connected model. It
could then be possible to devise a symbolic manipulation procedure to remove the inertia contribution
from the weak side (i.e., ElecGen) and add to the
other side (i.e., MechGen). This could widen the
range of applicability of the proposed method.

4

Discussion and Outlook

The proposed method requires a very limited modification to the Modelica language, i.e., introducing the
weak modifier to the variable declarations. It also
requires a very limited intervention to the user's
models, i.e. redeclaring some connector variables as
weak, in order to obtain faster simulation code. The
weak modifier can be thought of as a modelling attribute, stating that a particular variable has a weak
dynamic influence on the model behaviour, as well

The Modelica Association

as a hint to the compiler on how to produce more efficient simulation code.
The main drawback is that an “expert” user is needed, who knows by experience which connection (or
model) variables are good candidates to be considered as weak, in order to speed up the simulation. In
fact, if the “wrong” weak variables are selected, the
integration algorithm could become unstable even
for small values of the time step.
The stability analysis of the simulation of an electrical or hydraulic network split into two weakly interacting sub-networks is discussed in detail in [4]. The
stability criterion is formulated in terms of the
impedances of the two sub-networks; a heuristic rule
can then be derived, stating that the sub-network
with a weak flow connection variable should have
low resistance and/or high capacitance, while the
one with a weak effort connection variable should
have high resistance and/or low capacitance. A similar, physical-based analysis could be carried out for
mechanical connections, such as the case discussed
in Section 3.
Another possibility could be to devise numerical indicators (for generic models), based on the analysis
of the linearised equations, to help the user determine which connection variables can be considered
weak. An exhaustive search of all the potential candidates should not be computationally too expensive,
as the number of connections is limited; moreover,
only connections between higher-level subsystems
could be considered, e.g. the shaft connection in the
example of Fig. 5, while ignoring the connections inside the MechGen and ElecGen models.
The proposed numerical method has already been
tested with both variable step-size [1] and fixed stepsize [2] integration algorithm. Although a reduction
around 30% has been reported in a variable step-size
robotic simulation, the application of the weak interaction method to variable step-size, higher-order integration algorithm can only give a limited benefit,
as it is hampers the lengthening of the time step, as
well as the switching to higher order formulae;
moreover, devising multirate, variable step-size algorithms is very difficult. The most significant performance enhancements can be obtained with fixed
time-step algorithm, in particular for real-time applications. A typical case is a large physical system
with mixed slow and fast dynamics, possibly controlled by digital control systems with widely different sampling times. Such systems are often encountered in industrial practice.

101

Modelica 2005, March 7-8, 2005

F. Casella

The proposed method can readily benefit from the
inline integration method [5], which can be directly
applied to the integration of the weakly interacting
sub-systems.
There are some similarities between the weak dynamic interaction method and the mixed-mode integration method proposed in [6], as both try to exploit
mixed implicit-explicit algorithms to break large
non-linear systems of equations into smaller ones.
The method proposed in [6] tries to suitable partition
the overall model into a “fast” and a “slow” part, by
linear eigenvalue analysis and some heuristics to
limit the search space, while the method presented
here focuses on a system-level approach, i.e. tries to
exploit the weak coupling between sub-systems at
their connections. It is nevertheless possible that the
two methods could be suitably integrated, as their
approaches are somehow complementary to each
other.
Another method which has been proposed to decouple the equations of large systems is the Transmission Line Method [7, 8]. In this case, the finite propagation speed of physical quantities along connecting elements is exploited to allow the implicit integration of each connected subsystem, using only past
values from the other ones. The main advantage in
this case is that decoupling comes naturally from the
system equations, which are exact; in some cases,
such as hydraulic networks or high-frequency electrical circuits, this can be very convenient. On the
other hand, there are cases where the “physical”
propagation speed is too high, so that the TLM
method could unnecessarily introduce fast dynamics
when there is no need to; moreover, the exact value
of the integration time step becomes tightly coupled
with the connecting element parameters. It could be
interesting to investigate if the stability analysis
studies carried out for the TLM method could be
somehow extended to the weak interaction method.

while retaining all the advantages of a fully objectoriented description.
Possible applications range from real-time hardwarein-the-loop simulation, to interactive training simulators, to the interfacing of system-level models with
detailed (e.g. CFD) models of specific system components.
The implementation of this concept would require
the following steps:
1. Extend the definition of the Modelica language to
include the weak modifier keyword.
2. Implement the symbolic manipulation algorithm
to split weakly coupled subsystems, as well as
decoupled numerical integration algorithms, into
an existing Modelica compiler (e.g., Dymola or
OpenModelica)
3. Validate the method on selected case studies (e.g.
robotics, power generation systems).
Step 2. could be initially limited to very simple integration schemes, such as synchronous explicit Euler,
and then possibly extended to more sophisticated solutions, such as implicit, high-order, multi-step, and
multirate algorithms.

References
[1]

[2]

[3]

5

Conclusions

The introduction of the weak variable concept allows to widen the applicability of the Modelica
framework in these directions:
• efficient fixed-step simulation of weakly interacting complex systems, possibly having different
time scales;
• distributed simulation;
• co-simulation of Modelica-based simulators and
other simulation engines;
• user interaction by means of standard SCADA
tools;
The Modelica Association

[4]

C. Maffezzoni, R. Girelli “MOSES: Modular
Modelling in an Object Oriented Database”,
Mathematical Modelling of Systems, v. 4, pp
121-147, 1998.
A. Leva, A. Bartolini, C. Maffezzoni: “A process simulation environment based on visual
programming and dynamic decoupling”, Simulation, v.71, n. 3, pp.183-193, 1998.
F. Casella, C. Maffezzoni: "Exploiting Weak
Interactions in Object Oriented Modeling",
EUROSIM Simulation News Europe, Mar.
1998, pp. 8-10.
F. Casella: “Modelling, Simulation, and Control of a Geothermal Power Plant”, Ph.D. Dissertation, Politecnico di Milano, Italy, 1999,
pp. 27-46.
http://www.elet.polimi.it/upload/casella/tesi.pdf

[5]

102

H. Elmqvist, S.E. Mattsson, H. Olsson: “New
Methods for Hardware-in-the-loop Simulation
of Stiff Models”, Proceedings of the Modelica
Conference 2002, Oberpfaffenhofen, Germany, March 18-19 2003, pp. 59-64.

Modelica 2005, March 7-8, 2005

Exploiting Weak Dynamic Interactions in Modelica

[6]

[7]

A. Schiela, H. Olsson: “Mixed-Mode Integration for Real-Time Simulation”, Proceedings
of the Modelica 2000 Workshop, October 2324 2000, pp 69-75.
D. M. Auslander: “Distributed System Simulation with Bilateral Delay-Line Models”, Jour-

The Modelica Association

[8]

103

nal of Basic Engineering, Trans. ASME pp
195-200, June 1968.
B. Johansson, P. Krus: “Modelica in a Distributed Environment Using Transmission
Line Modelling”, Proc. Modelica Workshop
2000, October 23-24 2000, pp. 193-198.

Modelica 2005, March 7-8, 2005

The Modelica Association

104

Modelica 2005, March 7-8, 2005

Using Automatic Differentiation for Partial Derivatives of Functions in Modelica

Using Automatic Differentiation for Partial Derivatives of Functions
in Modelica
Hans Olsson1
Hubertus Tummescheit2
Hilding Elmqvist1
1
Dynasim AB, Lund, Sweden (Hans.Olsson@Dynasim.se, Elmqvist@Dynasim.se)
2
Modelon AB, Lund, Sweden (Hubertus.Tummescheit@Modelon.se)

of that. The examples are using the implementation
of partial derivative generation in Dymola.

Abstract
The Modelica language has been enhanced with a
notation for partial derivatives of Modelica functions. This paper presents how Dymola [4] enables
the use of partial derivatives in certain modeling applications in the Modelica language. It is shown that
using partial derivatives is natural and supported in
Dymola, and solves several advanced modeling
problems.

1

Introduction

Partial derivatives of functions arise naturally in a
number of modeling applications. Accurate fluid
property functions can be expressed as partial derivatives of a Gibbs- or Helmholtz function with respect to a few variables, e.g. for single-substance
fluids as g(T,p), the Gibbs free energy, or f(T,ρ), the
Helmholtz energy of the fluid, see [3]. Partial derivatives are also required to handle non-linear constraints in MultiBody mechanics and contact handling. For contact handling involving parametric surface descriptions, the tangents of each surface is required to specify the constraint equations for the
contact point. The tangents are the partial derivatives
of the parametric surface description function with
regards to the two independent parameters.
These examples demonstrate that partial derivatives
of functions occur in several modeling domains. Recently, the Modelica Design group took up this need
and a language extension has been made to express
partial derivatives of functions in the Modelica language. For this to be actually useful, a Modelica tool
like Dymola has to have efficient techniques to generate computationally efficient code for the partial
derivatives. In the following sections of the paper we
are going to elaborate on the necessary techniques of
code generation and give a few application examples

The Modelica Association

2

Automatic
Differentiation
Modelica Functions

of

Using the Gibbs-function as an illustrative example,
we will explain how partial derivatives are generated
and used. Since the other thermodynamic properties
of a fluid are described as partial derivatives the
most natural way of expressing these partial derivatives is to directly express them in Modelica and let
the tool, Dymola, differentiate the expressions.
Some simple examples are given in the table:
Property
Formula
Specific volume
v = (∂g / ∂p)T
Specific entropy

s = −(∂g / ∂T ) p

Modelica 2.2 has thus been extended with the syntax:
function Gibbs_pp=der(Gibbs, p, p);
function Gibbs_pT=der(Gibbs, p, T);
to express that Gibbs_pp is the partial derivative of
the function Gibbs with respect to p and p, and
Gibbs_pT is the partial derivative of Gibbs with respect to p and T. Dymola’s existing symbolic differentiation of expressions has been extended with a
symbolic variant of automatic differentiation [1],
which works for almost any Modelica function (including the Gibbs-functions). It uses forward-mode
automatic differentiation. For systems of equations
and index-reduction Dymola automatically uses additional derivatives (time-derivatives), and for indexreduction they are also constructed automatically.
For the future it is planned to also automatically construct these when needed for Jacobians. Note that

105

Modelica 2005, March 7-8, 2005

H. Olsson, H. Tummescheit, H. Elmqvist

even if time-derivatives and partial derivatives are
different they share the same underlying framework.
The Gibbs-function is often fitted as a special polynomial in two variables (and some additional expressions). Generating optimized code for these special
polynomials require special care, and is currently
only implemented for the simple case of positive and
negative integer powers. Extending it to handle rational powers will be straightforward. Due to the
sparseness of the powers a simple use of Horner’s
scheme is not optimal, and obviously the powfunction is ruled out because of computational cost.
It is important that the automatic differentiation is
done symbolically prior to the code generation since
the code for special polynomials can reuse expressions for computing powers. Later this will be extended to include intra-function optimizations between the different partial derivatives. Using code
optimization is the key to making symbolic differentiation an efficient form of automatic differentiation,
see e.g. [2].
2.1

+:2

*:2

log : 0

+:1

x:2

y : -1

Thus if x = 2, y = −1 we get z = 2 . For automatic
differentiation we replace the values at the bottom by
Taylor-series and propagate these upwards:
+ : 2+10t+…

* : 2+7t+…

log : 0+3t+…

+ : 1+3t+…

Basics of automatic differentiation

We will here present the basics of automatic differentiation in a general setting, even though we have
only implemented the features needed for partial derivatives of functions. We will then consider the implementation choices, and the special cases in
Modelica.

2.1.1 Forward mode
When performing automatic differentiation real variables and expressions are replaced by Taylor/powerseries1 (in one variable ‘t’ – representing a directional derivative) whereas non-reals, e.g. the conditions of if and while-clauses are kept unchanged.
The rules for propagating Taylor-series through
functions and expressions can be found in [6], and
we will here only consider a trivial example

z := x ⋅ ( x + y ) + log( x + y )
The computation of this expression can be computed
from its corresponding directed acyclical graph by
propagating the numerical values.

1

For higher order differentials a different scaling of the
coefficients is more efficient – we will ignore that in this
paper.

The Modelica Association

x : 2+t

y : -1+2t

Thus if x = 2, ∂x / ∂t = 1, y = −1, ∂y / ∂t = 2 we obtain z = 2, ∂z / ∂t = 10 and by including higher terms
we would get higher order derivatives. For each node
we only have to consider the values on the arrows
entering it, which lead to efficient computations of
directional derivatives, and is thus efficient for computing both partial derivatives and time-derivatives.
The result of this assignment-statement (in terms of
Taylor-series) can then be used directly in the next
statement in Modelica.

2.1.2 Reverse mode
Reverse-mode automatic differentiation [1] is an efficient technique for computing the derivative of one
variable with respect to many. Since it is not as efficient for computing partial derivatives we will only
present an example of how it works and not the underlying theory.
Consider the above example and augment the graph
with the partial derivatives for each primitive operation (using the numerical values). Then start from the
top where ∂z / ∂z = 1 , and for each node compute
the sum of the products of nodes above times the
value along the edge.

106

Modelica 2005, March 7-8, 2005

Using Automatic Differentiation for Partial Derivatives of Functions in Modelica

In order to indicate that values are propagated
downwards the arrows have been reversed:
+:1
1

1
* : 1*1=1
2

log : 1*1=1
1

1

+ : 1*2+1*1=3
1

1

x : 1*1+3*1=4

The symbolic derivative is a new function that
can be manipulated further by Dymola’s kernel
(e.g. to compute another derivative).
• No need to modify the code-generation in Dymola, and the generated code can be compiled
with compilers on realtime platforms where
C++-compilers are not always available.
The fact that the symbolic derivative is a new function is also used in this paper since it allows us to
present the result of automatic differentiation as
Modelica functions.

2.1.4 Special cases in Modelica

y : 3*1=3

The interpretation of the result is that the value at
each node represents the partial derivative of z with
respect to this value: ∂z / ∂x = 4, ∂z / ∂y = 3 (which
is consistent with the result above).
To implement reverse mode one first go through the
algorithm once to compute the values for each node,
and then once in reverse order using these values.
This requires that all intermediate results are stored.

2.1.3 Implementation choices
Automatic differentiation can be implemented in
several ways [1, 5], and forward-mode is in general
simpler to implement than reverse-mode. We have
selected to perform forward-mode symbolically in
the Dymola kernel.
Another possibility that has attracted attention recently is to generate code that numerically propagates derivatives e.g. by overloaded operators in C++
or by modifying the code-generation for each primitive operation.
The derivative annotation in Modelica was designed
with this in mind and can thus be used when computing Jacobians for non-linear systems using the
‘time-derivative’ of the function and also internally
to compute partial derivatives.
Furthermore the ‘time-derivative’ functions (i.e.
functions propagating a numerical directional derivative) can be constructed automatically by Dymola by automatic differentiation. This could have
been implemented by modifying the code generation
for each operation to also numerically propagate directional derivatives.
However, the symbolic variant has the advantage [5]
that:
• Expressions independent of e.g. T do not have to
propagate the derivative of T.

The Modelica Association

•

In Modelica, functions can contain simple expressions, matrix expressions, expression with iterators
and if-, while- and for-clauses. The symbolic differentiation handles all of them, which has required
special care, e.g. the rules for simple differentiable
expressions with iterators are (where we use the special notation x’= ∂x / ∂t ):
•

{x(j)+x’(j)*t for j in 1:n}=
{x(j) for j in 1:n}+{x’(j) for j in 1:n}*t
• sum(x(j)+x’(j)*t for j in 1:n)=
sum(x(j) for j in 1:n)+sum(x’(j) for j in 1:n)*t
• product(x(j)+x’(j)*t for j in 1:n)=
product(x(j) for j in 1:n)+sum(product(if j==k
then x’(j) else x(j) for k in 1:n) for j in 1:n)*t+…
The Modelica expert will note that we have not included the rules for min- and max-expressions with
iterators, since these are more complex to compute,
often discontinuous, and currently not needed.
If the function being differentiated contains calls of
other functions the directional derivative is propagated through it by its derivative-function, which is
either specified in the derivative-annotation, or constructed by Dymola through automatic differentiation of the function (the latter case assumes the
function is non-external).

2.1.5 Non-differentiable functions
A basic limitation of automatic differentiation is that
it can provide a derivative even at points where the
function does not have a derivative. Verifying that a
function with branches (if-statements, if-expressions,
or while-statements) is continuous is a difficult
problem, see [7]. Furthermore in this reference it is
shown that automatic differentiation may produce
incorrect results for specific inputs if the function
contains equality tests on real values.
For functions declared as partial derivatives (as is the
focus of this paper) one can view the continuity as

107

Modelica 2005, March 7-8, 2005

H. Olsson, H. Tummescheit, H. Elmqvist

the responsibility of the modeler declaring the partial
derivative function. When using automatic differentiation for index-reduction this is not feasible, and
the declarative approach in Modelica is that automatic differentiation for index reduction requires the
function to specify the degree of continuity.

3

Fluid Property Modeling using
Gibbs- or Helmholtz functions

The Gibbs-function is often fitted as a polynomial in
two variables:
Ji

ai p T

g(T,p) =

Ki

This type of function can be differentiated efficiently
with the implementation of automatic differentiation
in Dymola. The code for expressing the other thermodynamic properties has become much shorter than
in previous implementations of fluid properties.
Furthermore, conditions such as the phase equilibrium are also expressed as an equation involving the
partial derivatives. Thus it is possible to describe
phase equilibrium conditions, e.g. between gas and
liquid phases, in a completely declarative way, without resorting to special algorithms. Initial numerical
experiments seem to indicate that this works for
typical working fluid in thermodynamic cycles, e.g.
water or refrigerant R134a.
3.1

Definition of Thermodynamic Properties

A complete application example is the definition of
phase equilibrium in two phase fluids. In particular
when validity above the critical point is necessary,
Helmholtz functions are used to describe high accuracy thermodynamic surfaces. A typical equation
from [3] is the one for R134a using a dimensionless
Helmholtz energy composed of an ideal (aid) and a
residual term (ares) with the general form:
1− 4 k i − k i +1

ares (τ , δ )
=∑
RT
i

∑nτ
j

tj

δ

dj

∂


p = RTρ  1 + ρ
ares (τ , δ ) 
∂δ


Which results in a nice, compact definition in Modelica:
function pressure "pressure"
input SI.Temperature T;
input SI.Density d;
output SI.Pressure p;
protected
Real delta = d/DCRIT "dim-less density";
Real tau = TCRIT/T
"dimensionless inverse temperature";
algorithm
p := R*T*d*(1+delta*ar_d(tau,delta));
end pressure;

The Gibbs energy is computed as:
function gibbsEnergy "Gibbs free energy"
input SI.Temperature T;
input SI.Density d;
output SI.SpecificEnergy g;
protected
protected
Real delta = d/DCRIT "dim-less density";
Real tau = TCRIT/T
"dimensionless inverse temperature";
algorithm
g := R*T*(1+a0(tau,delta)+ar(tau,delta)
+ delta*ar_d(tau,delta));
end gibbsEnergy;

In an equivalent manner, all other properties of interest are defined.
3.2

exp( −δ di )

j

3
aid (τ , δ )
t
= ln(δ ) + a1 ln(τ ) + ∑ ai+1τ i
RT
i=1

Where τ is a reduced inverse temperature and δ is a
reduced density. This Helmholtz function uses fractional powers and for the test implementation it was
more efficient to transform all exponents into integers via a variable substitution. All properties of interest are then computed by automatic differentiation
The Modelica Association

using the new syntax form, and by computing the
partial derivatives of a_r(τ,δ) and a_i(τ,δ) first, e.g.:
function ar_t=der(ar, tau);
function ar_tt=der(ar, tau, tau);
function ar_d=der(ar, delta);
and so on for all partial derivatives up to order two.
The properties themselves are then defined as functions of these partial derivatives, e.g. the pressure

Declarative Definition of Phase Equilibrium conditions

All current Modelica libraries define two phase fluids for dynamic simulation via auxiliary equations,
e.g. splines generated from accurate phase boundary
data, that are a very good approximation to the correct thermodynamic equilibrium conditions. There is
one fundamental drawback to that approach: the approximation accuracy is fixed and has to be chosen
quite high to prevent numerical inconsistencies at
tight solver tolerances. From a perspective of a de-

108

Modelica 2005, March 7-8, 2005

Using Automatic Differentiation for Partial Derivatives of Functions in Modelica

clarative, equation based language, a declarative
definition of the phase equilibrium condition has the
advantage that it is always solved to the current accuracy of the numerical solver. This means that in
contrast to current implementations that have a
maximum accuracy that is limited by the accuracy of
the phase boundary approximation, a declarative
definition does not have this drawback. Even though
in Modelica it would be possible to define an iterative scheme to compute phase equilibrium conditions, the algorithm would need the current solver
tolerance as a user-defined input, again an undesirable drawback. The declarative definition for phase
equilibrium are the two equations:

p(T , ρliquid ) = p (T , ρ vapour )
g (T , ρ liquid) = g(T , ρvapour ),
i.e. equality of the pressures and Gibbs energies
computed from the same saturation temperatures and
the liquid and vapour densities ρliquid and ρvapour respectively.
With the property functions defined in the last sections, the phase equilibrium conditions only need the
variables and equations in the following code fragment:
SI.Density dl(start = 1500.0) "liquid”;
SI.Density dv(start = 5.0) "vapour";
SI.Temperature T(start = 270.0);
equation
p = pressure(T,d);
h = enthalpy(T,d);
pressure(T,dv) = pressure(T,dl);
gibbsEnergy(T,dl) = gibbsEnergy(T,dv);

From these equations the non-linear solver will compute the liquid and vapour densities for the saturation
temperature T. The equations are taken from the
context of a dynamic control volume model that assumes the pressure p and the enthalpy h as dynamic
states.
3.3

Discussion

These equations have so far been tested in simple
setups, and robustness, speed and convergence were
excellent, provided that the initial values for ρliquid
and ρvapour were close to the initial equilibrium point.

that come from a supercritical state and go to a subcritical state. The main problem here is that the equilibrium conditions, for the Helmholtz equation
above, has several non-physical, numerically valid
solutions in the unstable region inside the two-phase
dome.
Dymola can handle inequality-constraints on the solutions of non-linear systems, but we have not yet
determined the best way specify these inequalities in
Modelica, because we need to be sure to find only
the thermodynamically stable solutions outside of the
spinoidal lines. There are inequality conditions on
some partial derivatives for these non-physical solutions, see [3], that could be used to disambiguate
unwanted solutions.
A combination of some auxiliary functions for start
values and to disambiguate non-physical solutions
with the declarative definition of the phase boundary
through equations is likely to be a compromise that
works robustly under all conditions and avoids the
disadvantages of both approaches.
In the test implementation, Jacobians for the nonlinear equations have not yet been derived automatically. This would further improve the robustness and
solution speed. In dynamic simulation, Dymola uses
the last solution point as a start for the next iteration
and that makes the otherwise time consuming equilibrium iterations quite fast. For large systems of
non-linear equations arising from steady-state problems, the method of using auxiliary functions for the
saturation pressure and temperature is likely to be
more robust and more flexible. Often the auxiliary
functions can be chosen in a way that explicit
evaluation is possible in cases when the proper thermodynamic definition inevitably leads to a nonlinear equation system.
The main advantage of automatic differentiation for
medium properties is the economy of code: the thermodynamic surface for R134a, the computation of
the phase boundary and all derived properties is less
than 5% of the amount of code with conventional
programming “by hand” and auxiliary functions representing the phase boundary.

Unfortunately, there are still some unsolved problems that prevent to use this formulation in many
applications: above the critical point these equations
loose a meaning and it was numerically not possible
to obtain meaningful results for dynamic simulations
The Modelica Association

109

Modelica 2005, March 7-8, 2005

H. Olsson, H. Tummescheit, H. Elmqvist

4

Non-linear Constraints in MultiBody Mechanics and Contact handling

Partial derivatives are sometimes required to handle
non-linear constraints for contact handling in MultiBody mechanics, see also [9].
As a detailed example, we will consider the CAM
mechanism shown below, [8]. The CAM has straight
flanks between the circle segments. The follower is
roller-ended.

if thetamod > 0 then
fi1 := pi/2 - fi0 - thetamod;
else
fi1 := - pi/2 + fi0 - thetamod;
end if;
fi2 := atan2(R2*cos(fi0), d +
R2*sin(fi0));
if abs(thetamod) > pi/2-fi0 then
x :=R1*cos(theta);
y :=R1*sin(theta);
elseif abs(thetamod) >= fi2 then
L := R1/cos(fi1);
x := L*cos(theta);
y := L*sin(theta);
else
L := d*cos(abs(thetamod)) +
sqrt(R2^2 - d^2*sin(abs(thetamod))^2);
x := L*cos(theta);
y := L*sin(theta);
end if;
r := {x,y};
end straightFlanksCam;

The mechanism can be described by the following
equations (three dimension vectors are used for convenience although the mechanism is planar).

r (θ ) = shape(θ )
T(ϕ ) ⋅ (r (θ ) + n_n(θ ) ⋅ ( R + dist )) = { x, y , z}

The CAM shape will be described by a replaceable
function defining the two dimensional position vector of every point of the circumference as a function
of a free parameter theta.

rθ (θ ) = shape _ theta(θ )
n(θ ) = rθ (θ ) × {0,0,1}
n_n(θ ) =

partial function shapeFunction
input Real theta;
output Real r[2];
end shapeFunction;

The straight flanks CAM can be defined as follows:

n(θ )
n(θ ) n(θ )

T(ϕ ) ⋅ F _ n ⋅ n_n(θ ) = {Fx, Fy , Fz}
where
r

vector to closest point
angle to closest point
angle of CAM
Transformation matrix for rotation around z axis
position of center of follower
radii of follower
distance between CAM and follower
normal of CAM shape
normalized normal
force on follower
normal force

θ
function straightFlanksCam
ϕ
extends shapeFunction;
input Real R1=1
"Base circle radii";
T
input Real R2=0.5 "Nose radii";
input Real d=2
"Centre distance";
x,y,z
import Modelica.Math.*;
R
protected
constant Real pi=Modelica.Constants.pi;
dist
Real fi0;
n
Real fi1;
Real fi2;
n_n
Real L;
Fx,Fy,Fz
Real x;
F_n
Real y;
Real thetamod;
The partial derivative of the replaceable shape funcalgorithm
tion is needed. The Modelica language has recently
thetamod := atan2(sin(theta),
been extended to allow the der-operator to define
cos(theta))
"to get angle in interval -pi..pi"; partial derivatives of Modelica functions.
fi0 := asin((R1 - R2)/d);
The Modelica Association

110

Modelica 2005, March 7-8, 2005

Using Automatic Differentiation for Partial Derivatives of Functions in Modelica

replaceable function shape =
shapeFunction;
function shape_theta =
der(shape, theta);

This allows to write equations in the following form:
r = shape(theta);
r_theta = shape_theta(theta);

A tool needs to use automatic differentiation to obtain the required partial derivative. Dymola generates
the derivative function in Modelica format:
function shape_theta
input Real theta;
protected
Real r[2];
public
input Real R1 := 1 "Base circle radii";
input Real R2 := 0.5 "Nose radii";
input Real d := 2 "Centre distance";
protected
constant Real pi := 3.14159265358979;
Real fi0;
Real fi1;
Real fi2;
Real L;
Real x;
Real y;
Real thetamod;
Real theta_d13 := 1;
public
output Real r_d13[2];
protected
Real fi0_d13, fi1_d13, fi2_d13;
Real L_d13, x_d13, y_d13;
Real thetamod_d13;
algorithm
thetamod_d13 := theta_d13;
thetamod := arctan2(sin(theta), cos(theta));
fi0_d13 := 0;
fi0 := arcsin((R1-R2)/d);
if (thetamod > 0) then
fi1_d13 := -(fi0_d13+thetamod_d13);
fi1 := 0.5*pi-fi0-thetamod;
else
fi1_d13 := fi0_d13-thetamod_d13;
fi1 := fi0-0.5*pi-thetamod;
end if;
fi2_d13 := -((d+R2*sin(fi0))*R2*fi0_d13*
sin(fi0)+R2*cos(fi0)*R2*fi0_d13*cos(fi0))/
((R2*cos(fi0))^2+(d+R2*sin(fi0))^2);
fi2 := arctan2(R2*cos(fi0), d+R2*sin(fi0));
if (abs(thetamod) > 0.5*pi-fi0) then
x_d13 := -R1*theta_d13*sin(theta);
x := R1*cos(theta);
y_d13 := R1*theta_d13*cos(theta);
y := R1*sin(theta);
elseif (abs(thetamod) >= fi2) then
L_d13 := R1*fi1_d13*sin(fi1)/cos(fi1)^2;
L := R1/cos(fi1);
x_d13 := L_d13*cos(theta)-L*theta_d13*
sin(theta);
x := L*cos(theta);
y_d13 := L_d13*sin(theta)+L*theta_d13*
cos(theta);
y := L*sin(theta);
else

The Modelica Association

L_d13 := -(d*thetamod_d13*simplesign(thetamod)*
sin(abs(thetamod))+d^2*sin(abs(thetamod))*
thetamod_d13*simplesign(thetamod)*
cos(abs(thetamod))/sqrt(R2^2d^2*sin(abs(thetamod))^2));
L := d*cos(abs(thetamod))+sqrt(R2^2d^2*sin(abs(thetamod))^2);
x_d13 := L_d13*cos(theta)-L*theta_d13*sin(theta);
x := L*cos(theta);
y_d13 := L_d13*sin(theta)+L*theta_d13*cos(theta);
y := L*sin(theta);
end if;
r_d13 := {x_d13, y_d13};
end shape_theta;

The dist variable can be used to define a spring acting when there is penetration:
F_n = if dist < 0 then k*(-dist) else 0;

Consider the follower connected to a mass which is
connected to a spring and damper to ground and that
the CAM is rotating at a fixed angular velocity. For
high speeds, the follower will leave the nose and
bounce back on the flank. Such a case is illustrated
below in several frames from an animation.

It should be noted that the redeclared shape function
is also used to define the parametric surface used for
the animation.
If the contact model also contains damping, the derivative of the shape_theta function is also needed
during index reduction. Such contact models are very
stiff. In certain cases an idealized contact model with
the constraint dist=0 might be sufficient. In such a
case, F_n is the constraint force. Index reduction will
in that case require the second derivative of
shape_theta. It is clear already by inspection of the
automatically generated shape_theta function that
automatic differentiation to obtain this function and
its derivatives saves the modeler much tedious and
error-prone work.

111

Modelica 2005, March 7-8, 2005

H. Olsson, H. Tummescheit, H. Elmqvist

5

[4]

Conclusions

The paper demonstrates that extending Modelica
with partial derivatives of functions is natural and
solves a number of advanced modeling problems.
Dymola automatically handles the differentiation of
the partial derivatives of the functions thus reducing
the work needed by the modeler, while preserving
the efficiency of the generated simulation code.

[5]

References

[7]

[1]

[2]

[3]

Juedes D.W. (1991): Taxonomy of Automatic Differentiation tools, in Automatic
Differentiation of Algorithms. SIAM
Char B.W. (1991): Computer Algebra as a
Toolbox for Program Generation and
Manipulation, in Automatic Differentiation
of Algorithms. SIAM
Span R. (2000): Multiparameter Equations
of State, an accurate Source of Thermodynamic Property Data. Springer Verlag.

The Modelica Association

112

[6]

[8]

[9]

Dynasim (2005): Dymola User’s Manual,
www.dynasim.se
Olsson H. (1993): Applications of automatic and symbolic differentiation in numerical computations. Master Thesis,
Department of Computer Science, Lund Institute of Technology, Lund Sweden.
Rall L.B. (1981): Automatic differentiation: Techniques and applications. vol.
120 of Lecture Notes in Computer Science,
Springer-Verlag.
Fischer H. (1991): Special problems in
Automatic Differentiation, in Automatic
Differentiation of Algorithms. SIAM.
Hannah J., Stephens R. C. (1972): Mechanics of Machines. Second edition, SI units,
Edward Arnold.
Otter M., Elmqvist H., Lopez J.L. (2005):
Collision Handling for the Modelica
MultiBody Library. Modelica’2005 conference, Hamburg, March 7-8.

Modelica 2005, March 7-8, 2005

A Framework for Describing and Solving PDE Models in Modelica

A Framework for Describing and Solving PDE Models in Modelica
Levon Saldamli∗ , Bernhard Bachmann† , Hansjürg Wiesmann‡ , and Peter Fritzson∗

Abstract
Currently, the Modelica language [3, 4] has limited support for solving partial differential equations
(PDEs). There is ongoing work for introducing PDE
support at the language level [5, 6]. This paper describes a prototype for describing PDE problems using the Modelica Language without any extensions, as
an intermediate step. The goal is to define standard
PDE models independent of specific domains, boundary conditions or any spatial discretization, and allow a user to reuse this without manual discretization.
Modelica packages are used to define continuous domain boundaries, domains, and field variables over domains. Corresponding space discrete version of these
packages are used to solve the space discretized PDE
problem.

1

Introduction

package PDE =
PDEbhjl . FEMForms . E q u a t i o n s . P o i s s o n 2 D (
r e d e c l a r e package domainP = omegaP ) ;
PDE . E q u a t i o n pde (
domain =omega ,
g_rhs =1);
end G e n e r i c B o u n d a r y P o i s s o n E x a m p l e ;

First, two Dirichlet boundary conditions are declared,
dirzero and dirfive with the right-hand side values 0 and 5, respectively. Then, a boundary component
mybnd of type MyGenericBoundary (see Section 6)
is declared, and the boundary conditions are assigned
to the boundary components bottom, right, top and
left of mybnd. A domain named omega is then declared using the boundary object mybnd. Finally, the
PDE model is instantiated using omega as its definition domain.
Each declaration requires two actual declarations, one
for the package and one for the data of the object, as
explained in the following section.

A PDE problem can be specified and solved as fol- 2 The Package Approach
lows using the approach in this paper (see Section 6
for more details):
In order to use an object-oriented approach with polymodel G e n e r i c B o u n d a r y P o i s s o n E x a m p l e
morphism in Modelica, we use packages for defining
parameter B o u n d a r y C o n d i t i o n . D a t a d i r z e r o (
new types such as Domain, Field, and Boundary.
bcType= B o u n d a r y C o n d i t i o n . d i r i c h l e t ,
g=0);
Each type Type contains at least a record called Data,
containing
the member variables needed in objects of
parameter B o u n d a r y C o n d i t i o n . D a t a d i r f i v e (
type Type. The member functions are declared in the
bcType= B o u n d a r y C o n d i t i o n . d i r i c h l e t ,
g=5);
Type package. Each member function has at least one
input
argument, of the record type Type.Data. Thus,
package myBoundaryP = MyGenericBou nd a ry ;
parameter myBoundaryP . D a t a mybnd (
when calling member functions on objects, the objects
b o t t o m ( bc = d i r z e r o ) ,
data is passed as the input record argument. Declaring
r i g h t ( bc = d i r f i v e ) ,
t o p ( bc = d i r z e r o ) ,
an object of type Type is implemented by declaring
l e f t ( bc = d i r f i v e ) ) ;
a local package, e.g. typeP which extends Type and
possibly
modifies parts of it, and then declaring a compackage omegaP = Domain (
r e d e c l a r e package b o u n d a r y P =myBoundaryP ) ;
ponent of type typeP.Data which contains the data
parameter omegaP . D a t a omega ( b o u n d a r y =mybnd ) ;
of the object of the modified type. This way, replace∗ Dept. of Computer and Information Science, Linköpings uni- able functions can be declared in a package, and reversitet, Linköping, Sweden. {levsa,petfr}@ida.liu.se
placeable packages extending these can exchange the
† Fachhochschule
Bielefeld,
Fachbereich Mathematik functions as required. In other words, the packages
und Technik, Studiengang Mathematik, Bielefeld, Germany.
define the class hierarchy for lookup of functions to
bernhard.bachmann@fh-bielefeld.de
‡ ABB Corporate Research, CH-5405 Baden, Switzerland. work, and the data records define the object hierarchy
storing the object instance data.
hj.wiesmann@bluewin.ch

The Modelica Association

113

Modelica 2005, March 7-8, 2005

L. Saldamli, B. Bachmann, P. Fritzson, H. Wiesmann

When types contain instances of other types, they declare a local package extending the other types package, and declare the objects data inside the Data
record. For example, an equation model declares a domain and a field as follows:

Boundary

1

Domain

1
1

BoundaryCondition

Field

model E q u a t i o n " P o i s s o n e q u a t i o n 2D"
r e p l a c e a b l e package domainP = Domain ;
parameter domainP . D a t a domain ;
package f i e l d P = F i e l d (
r e d e c l a r e package domainP = domainP ) ;
parameter f i e l d P . D a t a u ( domain = domain ) ;
end E q u a t i o n

ConstField

Figure 1:

This approach allows the equation model to be reused
with any domain without changing other parts of the
model. The package fieldP redeclares the replaceable domain package in the Field package. This way,
the package hierarchy is correctly set up. The actual
data records are declared separately, in order to build
the object hierarchy of the model. The record u has
the type fieldP.Data and will contain the correct
domain data type from the given package domainP.
The domain data must be initialized with the local values though, which is done with the modification when
declaring the record u. When the domain is to be discretized, the shape function of its boundary package
is called. Since the boundary package of the domain
package is replaced when the domain is declared, the
correct shape function is called. This is handled automatically through the package DiscreteDomain,
explained in Section 5.1.1, which is declared in the
discrete parts of the equation models.
The drawback of this approach is that each instantiation requires definition of a local package extending
the type package, together with a declaration of the
Data record of the local package. The advantage is
that the local package can be declared as replaceable,
and the correct version of the package will be used
without knowing the type in advance.

3

Continuous Model Description

This section describes the packages used for continuous model description of domains and fields. These
are Boundary, Domain, and Field, which are discretization independent information needed for the
PDE problem. An overview of the packages in the
framework is shown in Figure 1.
The geometry of a domain is described using continuous parametric curves, which is a fairly general representation and is easy to discretize. Each domain object contains a boundary object describing its boundary, i.e., the boundary defines the domain. The direc-

The Modelica Association

Overview of the packages for continuous do-

main and field description. ConstField inherits Field, i.e.,
it is a field with a known value (time-dependent or timeindependent). Arrows represent aggregate, e.g. a domain
object contains one boundary object, which contains one
boundary condition object.

tion of the parametric curve representing the boundary
decides on which side of the boundary the domain resides. Usually, the domain is on the left of the boundary, i.e., the curve is followed in counter-clockwise direction around a point in the domain.

3.1 Boundary Definition
A boundary contains a shape function representing the
parametric curve defined for parameters in the range
[0, 1]. The shape function can be seen as a mapping
from a real value, the parameter, to the coordinate vector x. In two dimensions, one parameter suffices, in
three dimensions, two parameters are needed. The
specific return value of the shape function has the type
BPoint, which is a point with additional information
about the boundary conditions in that point.
The base package for all boundary types is the package
called Boundary:
package Boundary
replaceable function shape
input Real u ;
input Data d a t a ;
output BPoint x ;
end s h a p e ;
replacea bl e record Data
parameter B o u n d a r y C o n d i t i o n . D a t a bc ;
end D a t a ;
end Boundary ;

The formal parameter data to the shape function contains the actual data of the specific boundary object.
The record BPoint, representing a point with boundary condition information, is defined as follows:
t y p e B P o i n t = R e a l [ 3 ] " x , y and b o u n d a r y p a r t i n d e x " ;

Here, index 1 and 2 represent the coordinates in twodimensions, while the third value is the boundary con-

114

Modelica 2005, March 7-8, 2005

A Framework for Describing and Solving PDE Models in Modelica

dition index, needed by the discretization and solution
steps.

end v a l u e ;
end F i e l d ;

The function value represents the mapping, which
can be defined when specifying fields with known val3.2 Domain Definition
ues. Fields with unknown values that must be solved
A base domain type called Domain is declared with a
boundary instance defining the actual geometry of the for during simulation may use value functions that interpolate the values for given coordinates.
domain:
package Domain
r e p l a c e a b l e package b o u n d a r y P = Boundary
e x t e n d s Boundary ; / / b a s e c l a s s r e s t r i c t i o n

3.3.1

An example showing a field with time-constant values
follows:

replaceab l e record Data
parameter b o u n d a r y P . D a t a b o u n d a r y ;
end D a t a ;

model F i e l d E x a m p l e
function myfieldfunc
input Point x ;
input myFieldP . Data d ;
output myFieldP . FieldType y ;
algorithm
y : = c o s ( 2 ∗ P I ∗x [ 1 ] / 6 ) + s i n ( 2 ∗ P I ∗x [ 2 ] / 6 ) ;
end m y f i e l d ;

function discretizeBoundary
input I n t e g e r n ;
input boundaryP . Data d ;
output BPoint p [ n ] ;
algorithm
for i in 1: n loop
p [ i , : ] := boundaryP . shape ( ( i − 1 ) / n , d ) ;
end f o r ;
end d i s c r e t i z e B o u n d a r y ;
end Domain ;

restriction specifies that if the package
boundaryP is replaced, the replacing package
must be a subtype of Boundary.
The function discretizeBoundary must reside in
the Domain package in order that the correct shape
function is called, depending on the replaceable package boundaryP. The discretization simply calculates
a given number of points uniformly distributed on the
boundary. The data record of the domain contains the
boundary record, which is the actual data record of
the selected boundary type.

package omegaP =
Domain ( r e d e c l a r e package b o u n d a r y P = C i r c l e ) ;
package m y F i e l d P =
F i e l d ( r e d e c l a r e package domainP =omegaP ,
redeclare function value =myfieldfunc ) ;

The

3.3

Fields

A field represents a mapping from a domain to scalar
or vector values. The domain is declared as a replaceable package, which can be replaced by a package extending the Domain package described in Section 3.2. The replaceable type FieldType determines
the value type of the field. The data record contains
the data of the domain:
package F i e l d
replaceable type FieldType = Real ;
r e p l a c e a b l e package domainP = Domain
e x t e n d s Domain ; / / b a s e c l a s s r e s t r i c t i o n
replaceab l e record Data
parameter domainP . D a t a domain ;
end D a t a ;
replaceable function value
input Point x ;
input Data d ;
output FieldType y ;
algorithm
y := 0;

The Modelica Association

A Field Example

parameter C i r c l e . D a t a bnd ( r a d i u s = 2 ) ;
parameter omegaP . D a t a omega ( b o u n d a r y = bnd ) ;
parameter m y F i e l d P . D a t a m y f i e l d ( domain =omega ) ;
end F i e l d E x a m p l e ;

The field function myfieldfunc defines the mapping
from the space coordinates to the field values of type
Real.

3.4 Included Boundaries
Some predefined boundaries can be found in the package Boundaries. All these packages extend the basic package Boundary. Therefore the data records
in each boundary contain the parameter bc of type
BoundaryCondition.Data, containing the boundary condition information. Boundary conditions are
described in Section 4.3. An overview of the included
boundaries can be seen in Figure 2. They are also
briefly described in the following sections.
3.4.1

Line

Line is a straight line defined by two points, the start
and the end points of the line. The data record of Line
follows:
redeclare record extends Data
parameter P o i n t p1 ;
parameter P o i n t p2 ;
end D a t a ;

The shape function simply interpolates the points linearly between the end points:

115

Modelica 2005, March 7-8, 2005

L. Saldamli, B. Bachmann, P. Fritzson, H. Wiesmann

n

1

Boundary

package C i r c l e
e x t e n d s Arc ( D a t a ( a _ s t a r t =0 , a _ e n d =2∗ p i ) ) ;
end C i r c l e ;

BoundaryCondition

n

Line

Arc

HComposite

Composite

Bezier

Generic

3.4.4
Circle

A rectangle declares four lines as components, with
the names bottom, right, top and left. For example bottom is declared as follows:

Rectangle

Figure 2: Predefined boundaries contained in the pack-

parameter L i n e . D a t a b o t t o m (
p1=p ,
p2=p + {w, 0 } ,
bc ( i n d e x =1 , name =" b o t t o m " ) ) ;

age Boundaries. Composite is a boundary consisting of
boundary parts of different types. HComposite (homogeneous composite) consists of boundary parts of the same
type. Generic is a boundary type that can represent the
other concrete boundary types and is used in the Composite
boundary.

redeclare function shape
input Real u ;
input Data d ;
output BPoint x ;
algorithm
x [ 1 : 2 ] : = d . p1 + u ∗ ( d . p2 − d . p1 ) ;
x [ 3 ] : = d . bc . i n d e x ;
end s h a p e ;

The parameters of the rectangle are p, w and h, representing the bottom left corner, the width and the
height, respectively.
The rectangle class extends the HComposite package,
which is a container for several boundary parts of the
same type, as described below. The Rectangle package is defined as follows:
package R e c t a n g l e
e x t e n d s HComposite (
r e d e c l a r e package P a r t T y p e = L i n e ) ;

The boundary condition index is passed through to the
points on the boundary.
3.4.2

Rectangle

Arc

An arc is part of a circular boundary with given start
and end angles around a center and with a given radius:

redeclare record
extends Data ( bnddata (
n =4 ,
p a r t s ={ bottom , r i g h t , t o p , l e f t } ) ) ;
parameter L i n e . D a t a b o t t o m (
p1 =p ,
p2 =p + {w, 0 } ,
bc ( i n d e x =1 , name =" b o t t o m " ) ) ;
/ / r i g h t , t o p and l e f t d e f i n e d s i m i l a r l y
end D a t a ;
end R e c t a n g l e ;

Hence, bnddata is a data record inside the rectangle
record, with the parts initialized to the vector containing the four declared lines, and as the PartType declared as Line, accordingly.

redeclare record Data
e x t e n d s Boundary . D a t a ;
parameter P o i n t c = { 0 , 0 } ;
parameter R e a l r = 1 ;
parameter R e a l a _ s t a r t = 0 ;
parameter R e a l a _ e n d =2∗ p i ;
end D a t a ;

3.4.5 Bézier
Default values for the parameter gives a full circle.
The shape function calculates the position using sin The Bézier boundary package uses a number of conand cos functions:
trol points given as parameters to calculate the coordinates of the points on a bézier curve, using De Castelredeclare function shape
input Real u ;
jau’s Algorithm [2]. The data record for Bezier packinput Data d ;
age follows:
output BPoint x ;
protected
Real a =( d . a_end − d . a _ s t a r t ) ;
algorithm
x [ 1 : 2 ] : = d . c + d . r ∗{ c o s ( d . a _ s t a r t + a ∗u ) ,
s i n ( d . a _ s t a r t + a ∗u ) } ;
x [ 3 ] : = d . bc . i n d e x ;
end s h a p e ;

3.4.3

redeclare record extends Data
parameter I n t e g e r n = 1 ;
parameter P o i n t p [ n ] ;
end D a t a ;

The shape function implements the algorithm for calculating the coordinates of a point on the curve, given
the parameter u:

Circle

A circle is simply defined by extending Arc and giving
the angles for a full circle:

The Modelica Association

redeclare function shape
input Real u ;
input Data d ;
output BPoint x ;
protected

116

Modelica 2005, March 7-8, 2005

A Framework for Describing and Solving PDE Models in Modelica

3.4.7

Point q [:]= d . p ;
algorithm
for k in 1 : ( d . n − 1) loop
for i in 1 : ( d . n − k ) loop
q [ i , : ] : = ( 1 − u ) ∗ q [ i , : ] + u∗q [ i + 1 , : ] ;
end f o r ;
end f o r ;
x [ 1 : 2 ] := q [1 , : ] ;
x [ 3 ] : = d . bc . i n d e x ;
end s h a p e ;

3.4.6

The Composite boundary simply uses a given number of Generic boundaries to build a complete boundary using parts of different types:
package P a r t T y p e = B o u n d a r i e s . G e n e r i c ;
redeclare replaceab l e record extends Data
parameter I n t e g e r n = 1 ;
parameter P a r t T y p e . D a t a p a r t s [ n ] ;
end D a t a ;

Generic

The boundary package Generic is needed in order
to define composite boundaries containing boundary
parts of different types. Since there are no pointers or
union types in Modelica, it is not possible to declare a
container for boundary parts where each part can be a
subclass of Boundary which is not known at the time
of library development. Hence, the Generic package
contains an enum parameter deciding the type of the
boundary part, and data records for each of the existing
types that can be selected. This leads to a lot of overhead, since only one of the records are actually used,
but unused parameters are optimized away during the
compilation and this does not affect the resulting simulation code. In future implementations, union types
or other solutions for polymorphism might allow more
efficient implementation of generic boundary types.
The enumeration type and the data record for the
Generic boundary type follows:
t y p e PartTypeEnum = e n u m e r a t i o n (
line ,
arc ,
circle ,
rectangle );
redeclare replacea bl e record Data
parameter PartTypeEnum p a r t T y p e ;
parameter L i n e . D a t a l i n e ;
parameter Arc . D a t a a r c ;
parameter C i r c l e . D a t a c i r c l e ;
parameter R e c t a n g l e . D a t a r e c t a n g l e ;
end D a t a ;

Composite

The shape function simply calls the shape function in
the Generic boundary package, using the index calculated by dividing the formal parameter u uniformly
among the existing parts:
redeclare function shape
input Real u ;
input Data d ;
output BPoint x ;
protected
R e a l s =d . n∗u ;
Integer is=integer ( s );
algorithm
x := PartType . shape ( s − is , d . p a r t s [1 + i s ] ) ;
end s h a p e ;

Here, is contains the part index corresponding to the
value of the formal parameter u, and s-is is the new
parameter value scaled to map to the parameter range
of that particular boundary part. For example, if the
shape function is called for a boundary containing four
parts with u = 0.8, the value of is will be integer(4 ∗
0.8) = 3 and the value of s−is will be 4∗0.8−3 = 0.2,
mapping to the u value on the fourth boundary part.
HComposite is a simplified version of the
Composite boundary, containing only parts of
the same type.

4 Equation Models

Because of lack of polymorphism, e.g. virtual functions, the shape function must check the enumeration The Equation models contain all the different components of the PDE model, and handle the spatial disvariable and call the correct shape function:
cretization and the declaration of the discrete model
redeclare function shape
input Real u ;
equations. The continuous components of the model,
input Data d ;
i.e., the domain, its boundary, the boundary conditions
output BPoint x ;
and the field, are declared here. Their discrete counalgorithm
i f d . p a r t T y p e == PartTypeEnum . l i n e t h e n
terparts are declared and initialized automatically from
x := Line . shape ( u , d . l i n e ) ;
the continuous components, using given discretizae l s e i f d . p a r t T y p e == PartTypeEnum . a r c t h e n
x : = Arc . s h a p e ( u , d . a r c ) ;
tion parameters. The spatial discretization is done by
e l s e i f d . p a r t T y p e == PartTypeEnum . c i r c l e t h e n
calling the finite element solver, which can be imx := C i r c l e . shape ( u , d . c i r c l e ) ;
e l s e i f d . p a r t T y p e == PartTypeEnum . r e c t a n g l e t h e n
plemented in Modelica, or an external solver called
x := Rectangle . shape ( u , d . r e c t a n g l e ) ;
through the Modelica external function interface. The
end i f ;
end s h a p e ;
declared equations use the spatially discretized model.

The Modelica Association

117

Modelica 2005, March 7-8, 2005

L. Saldamli, B. Bachmann, P. Fritzson, H. Wiesmann

4.1

The Poisson Equation

5.1 The Finite Element Package

The Poisson equation is a simple example of a station- For the finite element solver, the domain is represented
ary (time-independent) model. In differential form, the by a triangular mesh. The mesh generator used in
this work requires a polygon describing the boundequation is
ary of the domain as input. This polygon is generated
−∇ · (c∇u) = f
in Ω
(1) by discretizing the domain boundary using the shape
function. A simple discretization function sampling a
where u is the unknown field, c is a space-dependent given number of points uniformly on the boundary is
implemented as follows:
coefficient, f is the source term and Ω is the domain.

4.2

function discretizeBoundary
input I n t e g e r n ;
input boundaryP . Data d ;
output BPoint p [ n ] ;
algorithm
for i in 1: n loop
p [ i , : ] := boundaryP . shape ( ( i −1)/n , d ) ;
end f o r ;
end d i s c r e t i z e B o u n d a r y ;

The Diffusion Equation

The diffusion equation for a field u is:
∂u
− ∇ · (c∇u) = f
∂t

in Ω

(2)

The resulting polygon is given to the mesh generator
where c is a space-dependent coefficient, f is the
bamg [1]. The triangulation is then imported to Modsource term and Ω is the domain.
elica. Figure 3 shows the overview of the packages
used in this process.

4.3

Boundary conditions

Continuous

In both cases the boundary conditions may be Dirichlet, Neumann or mixed. The Diriclet boundary conditions is used where the value of the unknown field is
known on the boundary:
u=g

on Ω

Domain

DiscreteDomain

(3)

The Neumann boundary condition is used when the
value of the normal derivative of the field is known on
the boundary:
∂u
=g
∂n

on Ω

∂u
a + bu = g
∂n

5

on Ω

(5)

Discretization

So far only the continuous parts of the packages have
been discussed. These are independent of the discretization, and thus also the solution method, e.g. the
finite element method or the finite difference method.
The method for discretization of the domain depends
on which solution method is used. The finite element
package is described in the following section. Packages for the finite difference method exist for an earlier prototype of the framework. Also, packages for
the finite volume method are being considered.

The Modelica Association

Mesh

(4)

The mixed boundary condition, also called the Robin
boundary condition, contains both the value of the
field and the normal derivative:

Field

BoundaryCondition

DiscreteField

Equations

PoissonEquation

BCType

Solver

DiffusionEquation
Discrete (FEM package)

Figure 3: Packages involved in the discretization using the
finite element method. The user has only to deal with the
continuous part when using the equation packages.

The complete discretization and solution process is depicted in Figure 4. The external stiffness matrix calculation can be exchanged with internal code, i.e., functions implemented in Modelica. A prototype implementation in Modelica exists for discretization of the
Poisson equation with homogeneous Dirichlet boundary conditions.
5.1.1

DiscreteDomain

DiscreteDomain is the discrete version of Domain.
It contains a replaceable package domainP, rep-

resenting the continuous version of the domain.

118

Modelica 2005, March 7-8, 2005

A Framework for Describing and Solving PDE Models in Modelica

ing a given discrete domain. A discrete field contains
two separate arrays of discrete points in the domain,
one array containing the unknown values and one containing the known values, e.g. from given boundary
conditions. This representation corresponds to the representation used in Rheolef [7], in order to simplify
the solver interface. Both arrays are indirect, e.g. they
contain indices of the actual points in the mesh representation. The DiscreteField package is defined as
follows:

Continuous
Modelica definition

Boundary
Discretization
Discrete
Modelica definition
(boundary)

Discrete
Modelica Definition

External
Grid Generation
External
Stiffness Matrix
Calculation

package D i s c r e t e F i e l d
r e p l a c e a b l e package f i e l d P = F i e l d ;
r e p l a c e a b l e package ddomainP = D i s c r e t e D o m a i n ;
replacea bl e record Data
parameter ddomainP . D a t a ddomain ;
parameter f i e l d P . D a t a f i e l d ;
parameter FEMSolver . F o r m S i z e f o r m s i z e ;
parameter I n t e g e r u _ i n d i c e s [ f o r m s i z e . nu ] ;
parameter I n t e g e r b _ i n d i c e s [ f o r m s i z e . nb ] ;
f i e l d P . F i e l d T y p e v a l _ u [ f o r m s i z e . nu ] (
s t a r t = z e r o s ( f o r m s i z e . nu ) ) ;
f i e l d P . F i e l d T y p e v a l _ b [ f o r m s i z e . nb ] ;

Simulation of
Modelica Model
Results

Figure 4: Solution diagram. The boxes on the left show
the data flow. The rounded boxes show tools implemented

parameter I n t e g e r f i e l d S i z e _ u = s i z e ( v a l _ u , 1 ) ;
parameter I n t e g e r f i e l d S i z e _ b = s i z e ( v a l _ b , 1 ) ;
end D a t a ;

in Modelica, and ellipses show external tools.

The discretization is done automatically, once
DiscreteDomain is declared with a given Domain
package. DiscreteDomain is defined as follows:
package D i s c r e t e D o m a i n
r e p l a c e a b l e package domainP = Domain
e x t e n d s Domain ; / / b a s e c l a s s r e s t r i c t i o n
replaceab l e record Data
parameter I n t e g e r nbp ;
parameter domainP . D a t a domain ;
/ / A p a r a m e t e r t o t h e mesh g e n e r a t o r
/ / s p e c i f y i n g d e t a i l l e v e l , l e s s e r means
/ / more t r i a n g l e s
parameter R e a l r e f i n e = 0 . 7 ;
/ / A r r a y o f d i s c r e t e p o i n t s on t h e b o u n d a r y
parameter B P o i n t b o u n d a r y [ nbp ] =
domainP . d i s c r e t i z e B o u n d a r y ( nbp ,
domain . b o u n d a r y ) ;
parameter Mesh . D a t a mesh (
n= s i z e ( b o u n d a r y , 1 ) ,
polygon=boundary [ : , 1 : 2 ] ,
bc = i n t e g e r ( b o u n d a r y [ : , 3 ] ) ,
refine=refine );
parameter I n t e g e r b o u n d a r y S i z e =
s i z e ( boundary , 1 ) ;
end D a t a ;
end D i s c r e t e D o m a i n ;

DiscreteField

The package DiscreteField is incapsulates the
conversion of a continuous field to a discrete field, us-

The Modelica Association

Here, the default start values for the unknowns are set
to zeros. This value is overridden in the discrete parts
of the equation models, for appropriate initial value
setting. FormSize contains the sizes of the two arrays
of discrete values, and is imported from the external
solver since the sizes depend on the boundary conditions actually used in the model. Basically, Dirichlet
and mixed boundary conditions decides the number of
known variables.

5.1.3

The actual mesh generation is done when the mesh
component is instantiated by the compiler, i.e., the
Mesh package contains the actual calls to the external
mesh generator.
5.1.2

end D i s c r e t e F i e l d ;

Equation Discretization

The spatial derivatives in the equations are discretized
using the external solver Rheolef [7], which is automatically called from the equation models through external functions. Rheolef performs the assembling of
the matrix needed for the space discrete DAE system.
The result of the assembly is a coefficient matrix for
the unknown field values at the discrete points of the
domain. The resulting matrices are imported to Modelica through external functions and used in the actual
equations in the equation models. The final, possibly time-dependent, equation system, is simulated in
Dymola. An example solved using this framework is
shown in the following section.

119

Modelica 2005, March 7-8, 2005

L. Saldamli, B. Bachmann, P. Fritzson, H. Wiesmann

6

Example

package MyGenericBoun da r y
e x t e n d s Boundary ;

The result of the discretization of the equation, i.e., the
assembly step, is a coefficient matrix for the unknown
field values at the discrete points of the domain. The
discrete part can be completely handled by the equation model, hiding the details from the user, as shown
in the example using the PoissonEquation model:

redeclare record extends Data
parameter P o i n t p0 ;
parameter R e a l w ;
parameter R e a l h ;
parameter R e a l cw ;
parameter R e a l ch =h ;
parameter P o i n t c c =p0 + {w, h / 2 } ;

model G e n e r i c B o u n d a r y P o i s s o n E x a m p l e
import PDEbhjl . B o u n d a r i e s . ∗ ;
import PDEbhjl . ∗ ;
parameter
parameter
parameter
parameter
parameter
parameter
parameter

parameter
p1 =p0 ,
p2 =p0 +
parameter
p1 =p0 +
p2 =p0 +
parameter
p1 =p0 +
p2 =p0 ) ;

I n t e g e r n =40;
Real r e f i n e =0.5;
P o i n t p0 = { 1 , 1 } ;
R e a l w= 5 ;
Real h =3;
Real r =0.5;
R e a l cw = 5 ;

{w , 0 } ) ;
Line . Data top (
{w, h } ,
{0 , h } ) ;
Line . Data l e f t (
{0 , h } ,

parameter B e z i e r . D a t a r i g h t (
n =8 ,
p= f i l l ( cc , 8 ) +
{ {0.0 , −0.5} ,{0.0 , −0.2} ,{0.0 ,0.0} ,
{ −0.85 , −0.85} ,{ −0.85 ,0.85} ,{0.0 ,0.0} ,
{0.0 ,0.2} , {0.0 ,0.5}
} ∗ { {cw , 0 } , { 0 , ch } } ) ;

package myBoundaryP = MyGenericBou nd ar y ;
parameter myBoundaryP . D a t a mybnd (
p0 =p0 ,
w=w,
h=h ,
cw=cw ,
b o t t o m ( bc = d i r z e r o ) ,
r i g h t ( bc = d i r f i v e ) ,
t o p ( bc = d i r z e r o ) ,
l e f t ( bc = d i r f i v e ) ) ;

parameter C o m p o s i t e . D a t a b o u n d a r y (
p a r t s 1 ( l i n e = bottom ,
p a r t T y p e = PartTypeEnumC . l i n e ) ,
parts2 ( bezier=right ,
p a r t T y p e = PartTypeEnumC . b e z i e r ) ,
p a r t s 3 ( l i n e =top ,
p a r t T y p e = PartTypeEnumC . l i n e ) ,
parts4 ( line=left ,
p a r t T y p e = PartTypeEnumC . l i n e ) ) ;
end D a t a ;

package omegaP = Domain (
r e d e c l a r e package b o u n d a r y P =myBoundaryP ) ;
parameter omegaP . D a t a omega ( b o u n d a r y =mybnd ) ;
parameter B o u n d a r y C o n d i t i o n . D a t a d i r z e r o (
bcType= B o u n d a r y C o n d i t i o n . d i r i c h l e t ,
g =0 ,
q =0 ,
i n d e x =1 ,
name =" d i r z e r o " ) ;

redeclare function shape
input Real u ;
input Data d ;
output BPoint x ;
algorithm
x := Composite . shape ( u , d . boundary ) ;
end s h a p e ;

parameter B o u n d a r y C o n d i t i o n . D a t a d i r f i v e (
bcType= B o u n d a r y C o n d i t i o n . neumann ,
g =5 ,
q =1 ,
i n d e x =2 ,
name =" d i r f i v e " ) ;

end MyGenericBoun da ry ;

The basic contents of the Poisson2D equation model
used above is defined as follows:

parameter B o u n d a r y C o n d i t i o n . D a t a b c l i s t [ : ] =
{ dirzero ,
dirfive };

package P o i s s o n 2 D " P o i s s o n p r o b l e m 2D"
package u D F i e l d P = D i s c r e t e F i e l d (
r e d e c l a r e package ddomainP = ddomainP ,
r e d e c l a r e package f i e l d P = u F i e l d P ) ;

package PDE =
PDEbhjl . FEMForms . E q u a t i o n s . P o i s s o n 2 D
( r e d e c l a r e package domainP = omegaP ) ;
PDE . E q u a t i o n pde (
domain=omega ,
nbp =n ,
refine=refine ,
g0 =1 ,
nbc = s i z e ( b c l i s t , 1 ) ,
bc = b c l i s t ) ;
end G e n e r i c B o u n d a r y P o i s s o n E x a m p l e ;

Here, two different boundary conditions are assigned
to different parts of the boundary. The boundary used
here is defined as follows:

The Modelica Association

Line . Data bottom (

uDFieldP . Data fd (
ddomain = ddomain ,
f i e l d =uField ,
formsize=formsize ,
u_indices =u_indices ,
b_indices =b_indices ,
v a l _ u ( s t a r t ={1 f o r i i n 1 : f o r m s i z e . nu } ) ) ;
equation
laplace_uu ∗ fd . val_u
= mass_uu ∗ g _ r h s . v a l _ u + mass_ub ∗ g _ r h s . v a l _ b
− laplace_ub ∗ fd . val_b ;
f d . v a l _ b = b v a l s ; / / known b o u n d a r y v a l u e s
end E q u a t i o n ;
end P o i s s o n 2 D ;

120

Modelica 2005, March 7-8, 2005

A Framework for Describing and Solving PDE Models in Modelica

The matrices laplace_uu, mass_uu, mass_ub and
laplace_ub are retrieved from the external solver
Rheolef. Also bvals is calculated by the external
solver. For diffusion problems, additional matrices are
retrieved for the coefficients for the time derivatives of
the unknowns.
The plot of the simulation result can be seen in Figure 5. For comparison, same model is exported to and
solved in FEMLAB. Figure 6 shows the result generated by FEMLAB. The triangulation of the domain in
both cases can be seen in Figure 7.

3
3.5
3

2.5

2.5
2

2
1.5

1.5

1
0.5

1
0
4
3.5

6

3
4
2

3
1.5

2
1

Figure 5:

0.5

5

2.5

0

1

Results from solving the Poisson equation

(steady-state) in Dymola.

7 Conclusion and Future Work
The packages presented here give a general framework
for easily defining general domains over which the
predefined PDE models from the framework can be
solved. New boundaries are easy to define using the
existing boundaries as components, as shown in Section 6. Additional standard boundaries can also be
added to the Boundaries package for future use.
New PDE models are also easy to add to the framework. Models that can be formulated using forms as
described in the Rheolef User Manual [8] can be added
to the framework by using the external function interface and implementing necessary extensions.
Further work is needed on the finite difference and
the finite volume packages and adapt them to the current continuous definition framework. Also, the finite difference solver can be improved to support nonrectangular domains.
A simple extension of the framework is to include domains that use the existing standard boundaries. For
example, a CircularDomain can be defined in the
framework as follows:
package C i r c u l a r D o m a i n
e x t e n d s Domain (
r e d e c l a r e package b o u n d a r y P = C i r c l e ) ;
end C i r c u l a r D o m a i n ;

Such a domain can be used directly when defining new
problems, instead of declaring a general domain each
time and replacing the boundary manually.

8 Acknowledgments
This work has been supported by Swedish Foundation
for Strategic Research (SSF), in the VISIMOD project.

Figure 6:

Results from solving the Poisson equation

(steady-state) in FEMLAB.

4

4

3.5

3.5

3

3

2.5

2.5

2

References
[1] BAMG home page.
http://www-rocq.
inria.fr/gamma/cdrom/www/bamg/
eng.htm.
[2] Gerald Farin and Dianne Hansford. The Essentials
of CAGD. A K Peters, 2000.

2

[3] Peter Fritzson. Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1.
Wiley-IEEE Press, 2003.
http://www.
Figure 7: The meshes automatically generated from domathcore.com/drmodelica/.
1.5

1

1.5

1

1.5

2

2.5

3

3.5

4

4.5

5

5.5

6

1

1

1.5

2

2.5

3

3.5

4

4.5

5

5.5

6

main description in Modelica. Bamg mesh on the left, FEMLAB solution mesh on the right.

The Modelica Association

[4] Modelica Association. Modelica – A Unified
Object-Oriented Language for Physical Systems

121

Modelica 2005, March 7-8, 2005

L. Saldamli, B. Bachmann, P. Fritzson, H. Wiesmann

Modeling - Language Specification Version 2.1,
Jan 2004. http://www.modelica.org/.
[5] L. Saldamli and P. Fritzson. Field Type and Field
Constructor in Modelica. In Proc. of SIMS 2004,
the 45th Conference on Simulation and Modelling,
Copenhagen, Denmark, September 2004.
[6] Levon Saldamli. PDEModelica - Towards a HighLevel Language for Modeling with Partial Differential Equations. Linköping Studies in Science
and Technology, Licentiate Thesis No. 990, December 2002.
[7] Pierre Saramito, Nicolas Roquet, and Jocelyn Etienne.
Rheolef home page.
http://www-lmc.imag.fr/lmc-edp/
Pierre.Saramito/rheolef/, 2002.
[8] Pierre Saramito, Nicolas Roquet, and Jocelyn
Etienne. Rheolef users manual. 2002. http:
//www-lmc.imag.fr/lmc-edp/Pierre.
Saramito/rheolef/usrman.ps.gz.

The Modelica Association

122

Modelica 2005, March 7-8, 2005

A Task Merging Technique for Parallelization of Modelica Models

A Task Merging Technique for Parallelization of Modelica Models
Peter Aronsson, Peter Fritzson
PELAB – Programming Environment Lab, Dept. Computer Science
Linköping University, S-581 83 Linköping, Sweden

Abstract
This paper presents improvements on techniques of
merging tasks in task graphs generated in the ModPar
automatic parallelization module of the OpenModelica
compiler. Automatic parallelization is performed on
Modelica models by building data dependency graphs
called task graphs from the model equations. To handle
large task graphs with fine granularity, i.e. low ratio of
execution and communication cost, the tasks are
merged. This is done by using a graph rewrite system(GRS), which is a set of graph transformation rules
applied on the task graph. In this paper we have solved
the confluence problem of the task merging system by
giving priorities to the merge rules. A GRS is confluent
if the application order of the graph transformations
does not matter, i.e. the same result is gained regardless
of application order.
We also present a Modelica model suited for automatic parallelization and show results on this using the
ModPar module in the OpenModelica compiler.

1

to a new set of users, with little or no knowledge of
parallel programming or even parallel computers.
Our parallelization tool is plugged into the OpenModelica compiler developed at the Programming Environments Laboratory (PELAB) at Linköping University. Figure 1 presents an overview of the components
of the OpenModelica compiler and the parallelization
tool which is called ModPar. The OpenModelica compiler reads Modelica models and produces a set of variables, equations, algorithms, blocks, etc. This is fed
into the ModPar module which performs a set of optimizations on the equations. First, simple algebraic
equations on the form a=b are removed, which can
substantially reduce the number of equations and variables of the system.

OpenModelica
frontend

Introduction

Parallel computers have been used in simulations for a
long time. In fact, many of the large simulation applications are driving the parallel computer industry, like
modeling and simulation of atomic explosions, or modeling and simulation for weather forecasting. These
models are typically hand written for dedicated parallel
computers. Modeling of such systems requires both
knowledge of the modeling domain and knowledge in
parallel programming. Thus, such models are mostly
used by experts and the models tend to be used for a
long period of time, since it is to expensive to change
them.
In this paper we instead present techniques that enable a fully automatic approach to parallel simulation.
We have developed an automatic parallelization tool
for Modelica that can translate a Modelica model into a
platform independent parallel simulation program. By
having a fully automated process of producing the parallel simulation code, parallel simulation is opened up

The Modelica Association

Equation opt.
BLT, Index
reduction

Task Graph
Builder

Task Merging

Task
Scheduling

Code
Generation

Parallel
MPI
program

ModPar
Figure 1. The ModPar Architecture.

The next optimization performed on the equations is
the equation sorting. Equations are sorted in a Block
Lower Triangular(BLT) form, resulting in a set of

123

Modelica 2005, March 7-8, 2005

P. Aronsson, P. Fritzson

equation blocks, where each block consists of one or
more equations that need to be solved simultaneously.
In conjunction with sorting the equations, index reduction using dummy derivatives is applied[6]. Index
reduction is used on high index systems of equations,
where some equations need to be differentiated in order
to solve the system. The index of a system corresponds
to how many times some equations needs to be differentiated before the set of equations can be transformed
into an ODE (also called the underlying ODE).
A task graph is built, based on the sorted BLT form.
A task graph is a Directed Acyclic Graph (DAG), with
costs associated with edges and nodes. It is described
by the tuple G = (V , E , c ,τ ) where
• V is a set of vertices (nodes), i.e. tasks in the task
graph. A task is generated for each sub expression
in the model equations. For instance, an addition between two scalar values (a+b) or a function call
(sin(x)) constitutes a task. In this paper tasks
and nodes are used with the same meaning.
• E is a set of edges, which imposes a precedence
constraint on the tasks. An edge e = (v1 , v 2 ) indicates that node v1 must be executed before v 2 and
send data (resulting from the execution of v1 ) to
v2 .
• c (e ) gives the communication cost of sending the
data along an edge e ∈ E .
• τ (v ) gives the execution cost for each node
v ∈V .
The immediate predecessors (or parents) of a node n
are all nodes having an edge leading to the node n.
They are denoted by pred(n). The immediate successors (or children) of a node n are all nodes having an
edge leading to it from node n. They are denoted by
succ(n). Similarly the predecessors of a node n is the
transitive closure of pred(n), i.e. the set of all tasks
having a path leading to the node n. Analogously, the
successors of a node n are all the tasks having a path
leading to them from the node n. These sets are denoted
predm(n) and succm(n) respectively.
Blocks containing more than one equation need to
be solved before the task graph can be built. Such a
block can either be a linear system of equations or a
non-linear system of equations. For certain blocks the
solution cannot be found at compile time and thus a
numerical solver is integrated in the task graph itself.
For example, the solution of a linear system of equations can be done in parallel, making the corresponding
task possible to execute on more than one processor.
Such tasks are referred to as malleable tasks.
The next step in the ModPar tool is to perform task
merging and task clustering. Task clustering performs a
mapping of tasks to virtual processors by forming clus-

The Modelica Association

ters of tasks. This means that tasks that belong to the
same cluster have a communication cost of zero, while
tasks between clusters still have their original communication cost. Task merging differs from task clustering
in the sense that tasks of the task graph are collapsed
into a single node that represents the complete computational work of the included tasks. The data packets
sent to and from the merged task are also combined.
The goal of a task-merging algorithm is to increase the
granularity, i.e., the relation between communication
and execution cost of the task graph. This paper presents improvements on a task-merging algorithm based
on earlier work in [1].
The result from the Task Merging algorithm is a
new task graph with a smaller number of tasks (with
larger execution costs). This is fed into the taskscheduling algorithm that maps the task graph onto a
fixed number of processors. Each task in the task graph
is assigned a processor(s) and starting time(s).
The final stage in the ModPar module is code generation. The ModPar outputs simulation code with MPI
(Message Passing Interface) calls[7] to send and receive code between processors. Processor zero runs the
numerical solver. In each integration step, work is distributed to other slave processors, which then calculate
parts of the equations and send the result back to processor zero. Model parameters are only read once from
file and distributed to all processors at the start of the
simulation.
The rest of the paper is organized as follows. Section 2 introduces the method of merging tasks using a
graph rewrite system formalism. Section 3 presents a
Modelica application example suitable for parallelization, followed by results in section four. Section 5 presents the conclusions of the work and section six shows
how the work relates to other contributions.

2

Task Merging using Graph Rewrite Systems

In previous work we have proposed a task-merging
algorithm based on a graph rewrite system (GRS). A
Condition
Pattern

Redex

Invariants
Figure 2. The X notation for GRS.

GRS is a set of graph transformation rules with a pattern, a condition, and a resulting sub-graph (called redex). We use a graphical notation (called the Xnotation) depicted in Figure 2.

124

Modelica 2005, March 7-8, 2005

A Task Merging Technique for Parallelization of Modelica Models

tlevel ( c ) > max tlevel(p i ) + ∑ τ (p i ) +τ ( c )
pi j ∈ C tlevel ( pi j ) > tlevel ( c´) + c ( pi , pi j ) / B + L

A GRS applies the transformation rules on the graph
until there are no more matching patterns found in the
graph. When this happens the GRS terminates. The
termination of a GRS is an important property both
theoretically and in practice. If it is not terminating, the
GRS must be interrupted somehow in a practical implementation.
Our task merging rewrite rules are based on the
condition that the top level of a task should not increase. The top level of a task is defined as the longest
path from the task to a task without any ingoing edges,
accumulating execution cost and communication cost
along the path. The communication costs are described
using two parameters, the bandwidth B and the latency,
L. The communication cost of sending n bytes becomes
n / B + L . The transformation rules, first presented in
[2] are given below.

p1

p2

pn

∀pi j ∈ succ ( pi ) ≠ c , pi ∈ pred ( c )

c´

pi ∉ C : { pb1 ,.., pbn }
p´b1 ... p´bn
...
...

pa1 ... pan

c

p2

p2

succ ( pa i ∈ C )

n

tlevel( j ) j ∈ pred ( p )
i

: { pa1 ,.., pan }

Figure 4. Rule of Merging of all parents to a task, called
mergeallparents.

3. The third and final rewrite rule deals with
split nodes. A split node is a node with several successors, or children. The transformation will replicate the split task and merge it
with each individual successor task, ci. However, the successor tasks can also have other
predecessors for which the top level cannot
be allowed to increase. Therefore, analogously as for the join task rewrite rule we also
divide the successor tasks into two disjoint
sets. The successor tasks that have other
predecessors not increasing the top level are
put in the set C. Thus, predecessors belonging
to C are replicated and merged with the task
c, while predecessors not belonging to C are
left as they are.

1. The first and simplest rewrite rule is given in
Figure 3. It merges a parent task that has only
one child with the child. This can always be
performed, i.e., without any condition, since
such transformation will not reduce the level of
parallelism in the task graph.

τ ( p ) ≤ L + c ( p , c ) / B ∀i = 1..n

i
ci ∈ C tlevel ( c i ) ≥ tlevel ( p ) + L
j
+ c( p , c ) / B + τ ( p ) + τ ( p)
j i
j
∀p j ∈ pred ( ci ) ≠ c , p j ≠ p
∀i = 1..n

p
p´
c

p

n

tlevel ( j ) j ∈ pred ( p )
c1

Figure 3. Merging of single children rule, called
singlechildmerge.

2. The second rule handles join nodes, i.e., a task
that has several incoming messages from a set
of parent tasks, see Figure 4. The condition for
this rule to apply is that the top level of task c
does not increase when the transformation is
performed. However, it is also necessary to
make sure that other successors of the parents
of the join node (pij) are not increasing their top
levels. The rule therefore divides the parents
into two disjoint sets, one that has successors
fulfilling the condition and one that has successors increasing their top level by the merge and
therefore not fulfilling the condition. The parents not fulfilling the condition are therefore not
merged into the join task, c.

The Modelica Association

C : {c1 ,.., cm }
c1´

c2

...

cn

n
tlevel ( j ) j ∈ pred ( p )

p

cm´

cl

...

ck

ci ∉ C : { c ,.., c }
l
k

Figure 5. Replicating a parent and merging into each child
task, called replicateparentmerge.

An unanswered question so far has been if the GRS is
confluent or not. A confluent GRS gives the same resulting graph independently of the order of the applied
rules. In earlier work, we investigated empirically
whether the GRS was confluent, but now we have
found a counter example that the rewrite rules are not
confluent as they appear above. There are several alternatives to try to remedy this fact:

125

1. One could limit the order of matching of the
patterns on the task graph. An idea of this is
for instance to traverse the graph once in a
top down fashion to prevent the confluence
problem to occur. It is however not clear if
this would work or not, without a more thorough investigation.

Modelica 2005, March 7-8, 2005

P. Aronsson, P. Fritzson

2. Another alternative is to instead use the simpler rewrite rules first presented in [2]. This
approach might be taken for specific types of
graphs, e.g. trees or forests, but in the general case, this is not sufficient. The simple
rules did not succeed so well in reducing fine
grained tasks graphs as produced by the task
graph builder in ModPar.
3. A third, and the best practical alternative, is
to give priorities to the rewrite rules. This
means that a rewrite rule with a higher priority is always applied before other rules with
lower priority. This will effectively prevent
the GRS from being non-confluent, since
only applications of transformations in priority order is allowed.

equation
connect(load.flange_b,
spring.flange_a);
connect(load.flange_a,flange_a);
connect(spring.flange_b,flange_b);
end ShaftElement;

The ShaftElement model describes a onedimensional shaft element with a spring and a damper.
By instantiating this component as an array and connecting each array component to the next, we get a
simple model of a flexible shaft.
model FlexibleShaft "model of a flexible
shaft"
import Modelica.Mechanics.Rotational.*;
extends Interfaces.TwoFlanges;
parameter Integer n(min=1) = 20 "number
of shaft elements";
ShaftElement shaft[n];
equation
for i in 2:n loop
connect(shaft[I-1].flange_b,
shaft[i].flange_a);
end for;
connect(shaft[1].flange_a, flange_a);
connect(shaft[n].flange_b, flange_b);
end FlexibleShaft;

The priority order solution to the confluence problem
was chosen in ModPar. The chosen priority is:
1. singlechildmerge
2. replicateparentmerge
3. mergeallparents
This means that the singlechildmerge rule has the highest priority and is always applied first. This rule is also
the cheapest to apply since it does not have any condition, only a sub-graph pattern. Therefore, it makes
sense to apply it with highest priority.
The second highest priority has the replicateparentmerge rule, thus giving the mergeallparents rule the
lowest priority. The order between the last two rules is
chosen so that rules limiting the amount of parallelism
of the task graph are given lower priority. Since mergeallparents merges independent tasks (the successor
of the parent), it reduces the amount of parallelism,
which replicateparentmerge does not. Therefore, this
order is chosen.

3

Application example

Lets consider a simple application example that can
easily be scaled up using the array of components feature in Modelica. It uses the Modelica standard library
and the one-dimensional Rotational package to create a flexible shaft. The shaft element is implemented
as:
model ShaftElement "Element of a flexible
one dimensional shaft"
import Modelica.Mechanics.Rotational.*;1
extends Interfaces.TwoFlanges;
Inertia load;
SpringDamper spring(c=500,d=5);

1

Unqualified imports are not recommended to use. They
are used here for space considerations.

The Modelica Association

Finally, we create a test model to test our shaft.
model ShaftTest
FlexibleShaft shaft(n=20);
Modelica.Mechanics.Rotational.Torque
src;
Modelica.Blocks.Sources.Step c;
equation
connect(shaft.flange_a, src.flange_b);
connect(c.outPort, src.inPort);
end ShaftTest;

The structural parameter n controls the number of element pieces of the model, i.e., the number of discretization points of the model. It is therefore directly proportional to the number of variables and equations of the
model. Due to its simplicity and structure, it is suitable
for parallelization.

4

Results

The confluence problem is successfully solved in this
paper by introducing priorities on the task merging
rules. These priorities makes the task merging GRS
confluent, according to measurements made on a large
set of random task graphs from the Standard Task
Graph Set (STG)[10], as well as task graphs generated
from the ModPar module.
The application example in section 3 can substantially be reduced in size but still reveal sufficient parallelism. When running the task-merging algorithm on
the task graph produced from the example, it results in
a set of independent tasks, which can then be allocated

126

Modelica 2005, March 7-8, 2005

A Task Merging Technique for Parallelization of Modelica Models

to a set of processors in a simple load balancing manner, i.e., evenly distributing them among the processors. Thus, for this example, no scheduling is even required. This reduction is possible since the graph rewrite rules allow replication of tasks, such that dependencies between tasks of the task graph are completely
removed.
Table 1 shows the increase of granularity2 when applying the task merging for another Modelica example
from the Thermofluid package. With realistic figures
on bandwidth (B) and Latency (L), we see a substantial
increase of granularity.

Model

Granularity
before merge
0.000990

Granularity
after merge
0.106

PressureWave
(B=1, L=100)
PressureWave
0.0000990
0.0562
(B=1, L=1000)
Table 1. Granularity before and after Task Merging.
The status of the parallelization tool is that we can generate C code with MPI calls for execution of parallel
machines, such as the Linux cluster monolith at NSC
(Swedish National Supercomputer Center). We have
successfully executed smaller examples on this cluster
computer but without obtaining any speedups. The application example in Section 3 can only be translated in
reasonable time with about 9000 equations (using 1000
discretization points), which is a bit too small for obtaining sufficient speedups. In order to handle larger
system of equations, the equation optimization and
other parts of the compiler must be implemented in a
more efficient way. In addition, the amount of work per
state variable in the Flexible Shaft example is not so
large, so in order to get better speedups, other applications must be considered.

5

Conclusions

We have proposed improvements on earlier work of
merging tasks in a task graph using a graph rewrite system formalism. Earlier improvements made the task
merging GRS non-confluent, thus giving different results depending of order of application. We proposed
several alternative solutions to make the GRS confluent
and have chosen and implemented the best-suited solution for our application area, parallelization of simulation code from Modelica models.

The task merging technique is implemented in the
ModPar module, a part of the OpenModelica compiler.
It successfully reduces the number of tasks of task
graphs built from Modelica simulation code to a suitable degree such that existing scheduling algorithms
can succeed in producing parallel programs that give
sufficient speedup.

6

There is much work on scheduling of task graphs for
multi-processors, like the DSC[11] algorithm, the
TDS[4] algorithm or the Internalization algorithm[9],
all working on unlimited number of processors, so
called clustering algorithms. They all treat each task in
the task graph as a non-preemptive atomic task, and do
not consider merging of tasks. Therefore, they do not
work well on very fine-grained task graphs.
There are other attempts to merge tasks, like the
grain-packing algorithm[5]. The difference between
this approach and ours is that our approach is iterative
by nature and allows task replication.
Related work on parallelization of simulation code
includes distributed simulation where the numerical
solver is split into several parts, each handling a subset
of the equations. The interaction between the subsystems is then delayed in time such that the subsystems
becomes independent of each other in each time step.
This division of the model equations into subsystems is
implemented using a transmission line component in
the system, giving the technique the name Transmission Line Modeling (TLM)[3].
Other related work on parallel simulation includes
using parallel solvers, where the numerical solvers
themselves are parallelized, like for instance Runge
Kutta based solvers[8].

Acknowledgements
This work has been supported by the Swedish Foundation for Strategic Research (SSF), in the VISIMOD
project and in the ECSEL graduate school, and by Vinnova in the GridModelica project.

References

2

The relation between communication and execution cost
of the task graph.

The Modelica Association

Related Work

127

[1] P. Aronsson, P. Fritzson, Automatic Parallelization in OpenModelica, Proceedings of 5th EUROSIM Congress on Modeling and Simulation,
Paris, France, 6-10 Sep 2004. ISBN 3-901608-281
[2] P. Aronsson, P. Fritzson, Task Merging and Replication using Graph Rewriting, Tenth International Workshop on Compilers for Parallel Com-

Modelica 2005, March 7-8, 2005

P. Aronsson, P. Fritzson

puters, Amsterdam, the Netherlands, Jan 8-10,
2003
[3] Casella F. Maffezzoni C., The Transmission Line
Modeling Method, EEE/OUP Series on Electromagnetic Wave Theory, 1995
[4] S. Darbha, D. P. Agrawal. Optimal Scheduling
Algorithm for Distributed-Memory Machines.
IEEE Transactions on Parallel and Distributed
Systems, vol. 9(no. 1):87{94, January 1998.
[5] B. Kruatrachue. Static Task Scheduling and Grain
Packing in Parallel Processor Systems. PhD thesis, Dept. of Electrical and Computer Engineering,
Oregon State University, 1987.
[6] S.E. Mattsson, G. Söderlind, Index reduction in
differential-algebraic equations using dummy derivative, Scientific Computing Vol. 14 , Issue 3
1993
[7] Message Passing Interface Forum. MPI: A message-passing interface standard. Technical Report
UT-CS-94-230, 1994.
[8] T. Rauber, G. Runger, Iterated Runge-Kutta
Methods on Distributed Memory Multiprocessors.
In Proceedings of First Aizu International Symposium on Parallel and Distributed Processing,
pages 12-19. 1995.
[9] V. Sarkar. Partitioning and Scheduling Parallel
Programs for Multiprocessors. MIT Press, Cambridge, MA, 1989.
[10] Standard
Task
Graph
Set
(STG),
http://www.kasahara.elec.waseda.ac.jp/schedule/,
accessed 2004-12-02.
[11] T. Yang, A. Gerasoulis. DSC: Scheduling Parallel Tasks on an Unbounded Number of Processors. Transactions on Parallel and Distributed Systems, vol. 5(no. 9), 1994.

The Modelica Association

128

Modelica 2005, March 7-8, 2005

Session 2
Poster session

The Modelica Association

129

Modelica 2005, March 7-8, 2005

The Modelica Association

130

Modelica 2005, March 7-8, 2005

Some Results on Neutral Modelling of the Steel Continuous Casting Process

Some Results on Neutral Modelling
of the Steel Continuous Casting Process
Dorel Aiordachioaie
Mihai Munteanu
Emil Ceanga
“Dunarea de Jos” University of Galati, Electrical Engineering Faculty,
Domneasca-47, Galati – 800008, Romania.
Emails: Dorel.Aiordachioaie@ugal.ro, mmunteanu@tcinf.ro, Emil.Ceanga@ugal.ro

Abstract
The modelling goal is to obtain a neutral
representation of the process with enough
information to generate qualitative information about
the behaviour of the process. Such a representation
must be able to change models on different levels
among the user’s world. The obtained models have
physical structure and parameters, under declarative
and neutral format, as the Modelica modelling
language provides. The behaviour of the models is
obtained by considering and properly modelling the
basic phenomena running on different modelling
levels. More sophisticated models could be obtained
by adding more knowledge and information at the
place where the model is used of.
Keywords: Process Modelling; Neutral modelling;
Metamodelling; Continuous casting; Modelica.

framework is based on Modelica, which is a very
promising standard in neutral modelling [1], [2],
especial for very complex processes, like the
considered process.
The physical process is described in section 2. Its
description is made at the physical level and based
on the involved phenomena. The methodology of
modelling is presented using metamodelling
concepts presented and described in section 3. Three
basic sub-models are considered in this work, based
on physical decomposition of the process: the ladle,
the tundish and the cooling model. Each of these
models is considered by describing and modelling
separately for validation purposes. It is the scope of
sections 4, 5 and 6. Finally, in the section 7, some
simulation results are presented and discussed.

2. Description of the Process
1. Introduction
The considered process is steel continuous casting.
Most previous advances in continuous casting
modelling have been based on empirical knowledge
gained from experimentation with the process. Such
models are mainly equation based and describe only
parts of the process. Meanwhile model exchange
among different simulation environments is a strong
and real need. No model can reveal all the
phenomena running within a process.
The modelling goal is to obtain a neutral
representation of the process. Such a model must
have enough information to generate qualitative
information about the behaviour of the process. A
more sophisticated model could be obtained by
adding more knowledge and information at the place
where the model is used.
The model has a physical structure and is based on
running phenomena, which have measurable
parameters and physical meanings, e.g. temperature,
pressure, volumetric flows. The modelling

The Modelica Association

In the continuous casting process, molten material
(metal) is delivered from the bottom of a transfer
vessel (the tundish) into a mold cavity. Here, the
water-cooled walls of the mold extract heat to
solidify a shell that contains the liquid pool. The
shell is withdrawn from the bottom of mold at a
“casting speed” that matches the inflow of metal, so
that the process ideally operates at a steady state.
Below the mold, water sprays extract heat from the
surface, and the strand core eventually becomes fully
solid when it reaches the “metallurgical length”.
Heat flow and solidification phenomena models are
used for basic design and troubleshooting of this
process. Heat transfer in the mold region is
controlled mainly by heat conduction across the
interface between the surface of the solidifying shell
and the mold. In steel slab casting operations with
mold flux, such models feature a detailed treatment
of the interface, including heat, mass, and
momentum balances on the flux in the gap and the
effect of shell surface imperfections on heat flow [3].
Heat flow models which extend below the mold are
needed for basic machine design to ensure that the

131

Modelica 2005, March 7-8, 2005

D. Aiordachioaie, M. Munteanu, E. Ceanga

last support roll and torch cutter are positioned
beyond the metallurgical length for the highest
casting speed. Below the mold, air mist and water
spray cooling maintain surface temperature of the
strand, while the interior solidifies.
Continuous casting involves a staggering complexity
of interacting phenomena at the mechanistic level.
Some of the important phenomena include, [4], [5],
[6], [7], [8], [9], [10], [11], and [12]:
• fully-turbulent, transient fluid motion in a
complex geometry (inlet nozzle and strand liquid
pool), affected by argon gas bubbles, thermal
and solute buoyancies;
• thermodynamic reactions within and between the
powder and steel phases;
• dynamic motion of the free liquid surfaces and
interfaces, including the effects of surface
tension, oscillation and gravity-induced waves,
and flow in several phases;
• thermal, fluid, and mechanical interactions in the
meniscus region between the solidifying
meniscus, solid slag rim, infiltrating molten flux,
liquid steel, powder layers, and inclusion
particles;
• heat transport through the solidifying steel shell,
the interface between shell and mold, (which
contains powder layers and growing air gaps)
and the copper mold;
• solidification of the steel shell, including the
growth of grains and microstructures, phase
transformations, precipitate formation, and
microsegregation;
Because of this complexity, no model can include all
of the phenomena at once. An essential aspect of
successful model development is the selection of the
key phenomena of interest to a particular modelling
objective and by making of reasonable assumptions.
The basic phenomena considered in this work are
related to heat transfer among material’s phases and
flow of the processed material.
Mechanistic models are based on satisfying the laws
of conservation of heat, mass, force and momentum
in an appropriate domain with appropriate boundary
conditions. In this work, each considered
phenomenon is represented by term(s) in these
governing equations, excepting the force and
momentum.
Other phenomena can be ignored or incorporated
using empirical constants, obtained through
experimentation and model calibration.

The Modelica Association

3. The modelling methodology
Following the above hypothesis the phenomena from
two domains were considered: thermal and fluid
phenomena. In the thermal domain the considered
phenomena are conduction and radiation. From the
fluid domain, fluid flow is considered as effect of
difference pressure. For each domain, ports (some
time interfaces called) must be defined, in order to
describe the quantitative behaviour of the process
and to write mass and energy balances.
By metamodel is understood a model of the
modelling methodology. From the methodology
point of view two metamodels are presented in Fig.1
and Fig. 2. The first metamodel shows the highest
point of view of the methodology. The process
model in considered being an aggregation of
physical model with one or more material models
and one or more phenomena models. Material and
phenomena models need properties models to
compute the thermodynamic and transport
properties. The physical model, in association with
the properties model, generates constraints related to
the behaviour of the model.
The second metamodel is closer to the structure of
the model. The process model is composed of two
basic models: a phenomena model and a
mathematical model. The phenomena model
describes the level of the modelling and the
interaction among considered phenomena. The
quantitative behaviour of the model needs a
mathematical model, which depends on the
considered phenomena. The mathematical model
contains balance and constitutive equations. The
interaction of phenomena and mathematical model is
described by properly considering ports.
There are two types of ports: external (or static) to
describe the input-output flow of the material and
internal (or dynamic) to describe the phase
transformations of the material during processing.
There are two external models, in the sense they
could be defined in an independent approach,
possible in different (distributed) places and by
different modellers. It is the material model and the
geometry model.
The material model describes the thermodynamic
properties and the interaction of phenomena running
on different modeling levels. Based on the context,
i.e. the composition of the devices that support the
processed material, a model of constraints must be
considered and defined.

132

Modelica 2005, March 7-8, 2005

Some Results on Neutral Modelling of the Steel Continuous Casting Process

Model
1

1
1

1

1..*

1..*
uses

Physical

Material

generates

Phenomena

has

generates

Constraints

depends

Properties

Figure 1: A partial metamodel of the process model

Figure 2: A more detailed metamodel
The Modelica Association

133

Modelica 2005, March 7-8, 2005

D. Aiordachioaie, M. Munteanu, E. Ceanga

The constraints model is developed in correlation
with the model of the geometry of the plant, where
the processing of the material takes place.

sources such as liquid steel. It is expected that the
temperature of the environment to rise, near the
space of the ladle. Such a model can be as

Both metamodels are the base of the design a
modelling tool, under computed aided modelling
environment. Such a tool must assist the modeller to
take in account the all the interactions and all
necessary phenomena at the considered level of
modelling.

partial model Environment
PortHeat ha;
extends EnvironmentProperties;
CelsiusTemperature T (start=30, min=30);
parameter Volume vol(start=1000, min=0);
algorithm
ha.T := T;
equation
vol * rho * shcap * der(T) = ha.qheat;
end Environment;

4. The model of the ladle
The considered input variable in the ladle is the
initial temperature T0 of the processed material. The
necessary phenomena to consider are related to time
variation of the temperature inside and outside of the
ladle and the variation of steel volume inside of the
ladle, when the casting process starts. It is supposed
that the steel is in liquid phase and no phase change
is performed in the ladle.
Two sub-models cover the ladle: the processed
material (steel) and the wall model. The transfer of
thermal energy from ladle to outside of ladle is
modelled by radiation phenomenon from the surface
of the ladle to environment. A valve, conducted by a
controller with proper drives, makes the control of
the steel debit.
For the considered phenomena the following
variables are necessary: temperature and heat flow
rate for thermal domain; pressure, temperature and
volume flow rate for fluid domain. The interfaces for
such phenomena can be defined as:
connector PortFluid
Pressure p;
flow VolFlowRate qvol;
end PortFluid;
connector PortHeat
CelsiusTemperature T;
flow HeatFlowRate qheat;
end PortHeat;
connector PortThermoFluid
Pressure p;
CelsiusTemperature T;
flow VolFlowRate qvol;
end PortThermoFluid;
The environment must be taken into consideration in
order to show the behaviour of the high temperature
The Modelica Association

In the EnvironmentProperties model the properties of
the medium related to density, rho, and to specific
heat capacity, shcap, are defined.
The phenomena from thermal domain are considered
now. It is about of two main phenomena: radiation
from the hot surface to another one with a lower
temperature; the conduction of heat, which is
specific to heat conduction in solid phases. The
models can be as:
model Conduction
PortHeat ha,hb;
ThermalConductivity thermalcond (start = 1e-5);
Thickness thick (start = 1);
Area transfer_area (start=1);
Real Rth(start=1, min=1E-6) "Thermal Res.";
algorithm
Rth := thick / thermalcond / transfer_area;
ha.qheat := (ha.T - hb.T) / Rth;
equation
ha.qheat + hb.qheat = 0;
// un-defined: thick, thermalcond, transfer_area;
end Conduction;
and
model Radiation
PortHeat ha,hb;
constant Real viewfactor = 0.1 "The view factor";
constant Real sigma(final
unit="W/(m2.K4)")=5.6704e-8 "Stefan-Boltzman";
Area transfer_area (start=1, min=0);
Real Rth(start=1, min=1E-6);
algorithm
Rth := 1 / sigma / transfer_area / viewfactor;
ha.qheat := (ha.T^4 - hb.T^4) / Rth;
equation
ha.qheat + hb.qheat =0;
// un-defined: transfer_area;
end Radiation;

134

Modelica 2005, March 7-8, 2005

Some Results on Neutral Modelling of the Steel Continuous Casting Process

The ladle model contains two sub-models: the wall
and the steel. The wall model is composed mainly
from a physical model, which defines the size and
the composition of the wall, and the steel model. The
wall model of the ladle can be as
model Wall
PortHeat ha, hb;
Conduction hcond;
Volume vol (start=1);
Density rho (start=1);
Real shcap (start=1);
CelsiusTemperature T (start=30, min=0)"In the
wall centre";
equation
connect(ha, hcond.ha);
connect(hb, hcond.hb);
vol * rho * shcap * der(T) = abs(ha.qheat);
//re-declare: vol, rho, shcap;
end Wall;
The model of the liquid steel is
model Steel
PortHeat ha;
PortThermoFluid tfb;
extends SteelProperties;
CelsiusTemperature T (start=1500);
Volume vol(start=1, min=0);
Area area (start=1, min=0.1);
Real hout(start=1, min=0)"Enthalpy out-flow";
algorithm
hout := tfb.qvol * shcap * rho * tfb.T;
tfb.p := 1 + vol * rho * 9.8 /101325 /area;
tfb.T := T; ha.T := T;
equation
der(vol) = tfb.qvol;
rho * vol * shcap * der(T) = hout + ha.qheat;
end Steel;
Now, the ladle model can be defined as
model Ladle
PortHeat ha;
// interaction with env. near the steel surface;
PortHeat hb;
// interaction with tundish;
PortThermoFluid tfc;
// phenomena models:
Wall wall;
Steel steel;
// inherits from:
extends LadleGeometry;
extends LadleMaterialProperties;
Real h(start=1)"Steel heigth inside ladle";
The Modelica Association

algorithm
h := steel.vol / ladle_area;
wall.hcond.transfer_area := ladle_lateral_area;
wall.hcond.thick := ladle_thick;
wall.hcond.thermalcond := ladle_kL;
wall.shcap := ladle_speccap;
wall.vol := ladle_vol;
wall.rho := ladle_rho;
steel.area := ladle_area;
equation
connect(wall.ha, ha);
connect(wall.hb, steel.ha);
connect(steel.ha, hb);
connect(steel.tfb, tfc);
end Ladle;
The valve is considered as linear and with a very
small resistance. The model is
model Valve "A model for valve"
PortThermoFluid tfa,tfb;
PortControl ca;
parameter Real res(start=0.1, min=1e-6);
Boolean off;
algorithm
off = ca.u < 0;
equation
tfa.qvol = if off then 0 else (tfa.p-tfb.p)/res;
tfa.qvol + tfb.qvol = 0; tfa.T = tfb.T;
end Valve;

5. The model of the tundish
The input variable in the tundish model is the
volume flow and the steel height inside of the
tundish is the controlled variable. The basic
phenomena are related to the flow of materials from
ladle to tundish. Because no phase transformations
are taking place, for the material model is necessary
to have only a model for the liquid phase. The
interaction with the environment is made by the
lateral surface of the tundish only.
The model and some submodels are presented in the
Fig. 3. The test model is composed from the tandem
ladle plus tundish, completed with material source,
(“source”), valves for events (“valve1”, “valve2”),
and a load model (“load”). Inside of the dot lines
polygons the sub-models of ladle and tundish were
presented. In the following the models will be
presented and discussed.
The ladle and the tundish have the same structure.
Both use a material model (steel) and a wall model.
135

Modelica 2005, March 7-8, 2005

D. Aiordachioaie, M. Munteanu, E. Ceanga

Figure 3: The test structure for the ladle-tundish tandem
The wall sustains the steel. The model of the
processed material is called Steel. It has two thermofluid ports and one heat port. The first two are
necessary to model the flow of the steel. The heat
port is necessary to model the interaction with the
wall.
The Steel model must be improved by adding a
ThermoFluid port to model the input and the output
flows of the material in tundish:
model Steel
PortThermoFluid tfa,tfb;
PortHeat ha;
// parameters from steel properties model;
parameter Density rho(start=1000);
parameter SpecificHeatCapacity shcap(start=1e-5);
CelsiusTemperature T (start=1500);
Volume vol(start=1, min=0.1, max =10);
Enthalpy hin(start=1, min=0)"Enthalpy in-flow";
Enthalpy hout(start=1, min=0)"Enthalpy out-flow";
Area press_area(start=1, min=0.1) "Area for grav.
pressure";
equation
hin = tfa.qvol * shcap * rho * tfa.T;

The Modelica Association

hout = tfb.qvol * shcap * rho * tfb.T;
der(vol) = tfa.qvol + tfb.qvol;
vol * rho * shcap *der(T) = hout + hin + ha.qheat;
T = tfb.T; ha.T =T;
// un-defined: press_area, tfa.p, tfb.p; (context
dependency!);
end Steel;
The steel model is considered with volumic and
material properties. The pressures on two ports will
be defined later when the geometry of the vessel that
sustains the steel is defined. It is about of context
details. The model of the wall must define the
geometry, the material properties and the heat
conduction phenomena, as:
model Wall
PortHeat ha, hb;
// parameters from wall material properties;
ThermalConductivity thermalcond (start=1e-5);
// parameters from geometrical wall model;
Thickness thick (start=1);
Area hcond_transfer_area (start=1);
Density rho(start=1);
Volume vol (start=1);

136

Modelica 2005, March 7-8, 2005

Some Results on Neutral Modelling of the Steel Continuous Casting Process

SpecificHeatCapacity shcap(start=1);
Real Rth(start=1, min=1E-6) "Thermal resistance";
CelsiusTemperature T (start=100);
equation
Rth = thick / thermalcond / hcond_transfer_area;
ha.qheat = (ha.T - hb.T) / Rth;
T = if ha.qheat > 0 then hb.T else ha.T;
vol * rho * shcap *der(T) = ha.qheat + hb.qheat;
//un-defined: vol, rho, shcap, thermalcond, thick,
hcond_transfer_area;
end Wall;
The tundish model says that the tundish (object) an
interaction between the wall and steel behaviour. The
declarative model can be as
model Tundish
PortThermoFluid tfa, tfb;
PortHeat ha;
// parameters from tundish geometry model:
parameter Height tundish_h (start=1);
parameter Thickness tundish_thick (start=0.5);
parameter Volume tundish_vol(start=5, min=0.1);
parameter Diameter tundish_d (start=1, min=0.1);
Area tundish_area (start=1, min=0.1)"Hor.Crosssection area";
Area tundish_lateral_area (start=1, min=0.1);
// parameters from tundish material properties:
parameter ThermalConductivity tundish_kL;
Real steelh(start=1)"Steel heigth inside tundish";
Wall wall;
Steel steel;
algorithm
tundish_area := tundish_vol / tundish_h;
tundish_lateral_area=3.14*tundish_d*tundish_h;
steelh := steel.vol / tundish_area;

wall.hcond_transfer_area := 3.14 * tundish_d
* steelh;
wall.thick := tundish_thick;
wall.thermalcond := tundish_kL;
wall.rho := 2000;
wall.vol := 1;
wall.shcap := 0.9;
steel.press_area := tundish_area;
equation
// context definition:
steel.tfb.p = steel.tfa.p + steel.vol * steel.rho * 9.8
/101325 / steel.press_area;
steel.tfa.p =1;
connect(wall.hb, ha);
connect(wall.ha, steel.ha);
connect(steel.tfa, tfa);
connect(steel.tfb, tfb);
end Tundish;

The Modelica Association

6. The cooling model
The phenomena running after tundish can be
considered as generated by a single type model: a
cooling model of the liquid material. From a
phenomenological point of view, it should model the
transfer of energy from the liquid and the solid phase
of the processed material to other material that acts
as receptor or loads of the thermal energy.
The difficulty of the modelling problem is from the
uncertainties generated by the material parameters,
by the phenomena interactions during the casting
process. More, all parameters are distributed and are
temperature dependent. Moreover there are many
material phase transformations such as:
•liquid-solid transformation of the processed
material;
•liquid-solid-gaseous bidirectional transformations
of the auxiliary materials, which allow the
lubrification of the processed material in the primary
cooling zone;
•liquid-gaseous phase transformations for the fluid
materials that take the thermal energy of the
solidified material and make the secondary cooling.
Taking in account such a complex set of phenomena,
a simplified model will be considered based on
balance energy. This approach is started also from
the reality that in the real installation the information
for control and monitoring purposes use global
variables, e.g. volume flow rates and temperatures of
the involved materials, and not local variables, like
densities and viscosities.
In Fig. 4 the structure of the cooling models is
presented. There are also represented the sources of
the materials and materials loads. The structure of
the cooling model is represented in the upper left
side of the Fig. 4. Three models are considered: two
of materials (Steel and Water) and a model for
separation (Wall).
On the upper right side the structure of the processed
material is presented, as interaction of two
submodels: material in liquid phase (Liquid Steel)
and material in solid phase (Solid Steel). For these
two phases interfaces were defined: tfla, tflb for
liquid phase and tfsa, tfsb for solid phase.
The processed materials have material interfaces (tfa,
tfb, tfc) and interfaces for changing of the thermal
energy (ha), as it is presented in the lower right side.

137

Modelica 2005, March 7-8, 2005

D. Aiordachioaie, M. Munteanu, E. Ceanga

Figure 4: The structure of the cooling model
for the continuous casting of the steel using water as cooling agent
The cooling model is designed with the same
structure in order to be able to use in both sides of
the cooling zones: primary and secondary. Setting
up the numerical values of input-output variables,
makes the selection of one of them. By example, for
the primary cooling zone zeros values are necessary
for the solid materials, because the material in
received from tundish with liquid phase only. In the
following the model of the processed material will be
described, as interaction between solid and liquid
phase. The model for the solid phase is
model SteelSolid “The SteelSolid model”
PortThermoFluid tfa,tfb, tfc;
PortHeat hb;
extends SteelSolidProperties;
CelsiusTemperature T (start=30);
Volume vol(start=1, min=0.1);
Enthalpy hin1(start=1"In-flow from source side";
Enthalpy hin2(start=1)"In-flow from liquid side";
Enthalpy hout(start=1)"Out-flow";
equation
hin1 = tfa.qvol * shcap * rho * tfa.T;
hin2 = tfc.qvol * shcap * rho * tfc.T;
hout = tfb.qvol * shcap * rho * tfb.T;
vol*rho*shcap*der(T)=hout+hin1+hin2+hb.qheat;
tfb.T = T;
The Modelica Association

hb.T = (tfa.T + tfb.T + tfc.T)/3;
// undefined: vol;
end SteelSolid;
The model for the liquid phase is
model SteelLiquid “The SteelLiquid model “
PortThermoFluid tfa,tfb, tfc;
Extends SteelLiquidProperties;
Temperature T (start=1500);
Volume vol(start=2, min=0.1);
Enthalpy hin(start=1)"In-flow from source side";
Enthalpy hout1(start=1)"Out-flow to next block";
Enthalpy hout2(start=1)"Out-flow to solid steel";
Enthalpy H(start=1) "Latent energy";
equation
hin = tfa.qvol * shcap * rho * tfa.T;
hout1 = tfb.qvol * shcap * rho * tfb.T;
hout2 = tfc.qvol * shcap * rho * tfc.T;
H = vol * rho * L;
der(vol)=if vol>0 then tfa.qvol+tfb.qvol+tfc.qvol
else 0;
vol*rho*shcap*der(T)=hin+hout1+hout2- der(H);
tfb.T = T;
end SteelLiquid;
The model for the processed (cooled) material is

138

Modelica 2005, March 7-8, 2005

Some Results on Neutral Modelling of the Steel Continuous Casting Process

model Steel “The Steel model”
PortThermoFluid tfla, tflb;
PortThermoFluid tfsa, tfsb;
PortHeat ha;
SteelLiquid sliquid;
SteelSolid ssolid;
Volume vol(start=3, min=0);
parameter Real K (start=1e-8) "L2Solid speed”;
algorithm
ssolid.tfc.qvol := K * sliquid.H;
equation
connect(tfla, sliquid.tfa);
connect(sliquid.tfb, tflb);
connect(ssolid.tfa, tfsa);
connect(ssolid.tfb, tfsb);
connect(sliquid.tfc, ssolid.tfc);
connect(ssolid.hb, ha);
sliquid.vol + ssolid.vol = vol;
ssolid.tfc.T = if sliquid.vol > 0 then sliquid.Ts else
ssolid.T;
// un-defined: vol; context dependent;
end Steel;
Finally, the cooling model considers the interaction
between the model of the processed material (steel)
and the material that takes the energy in order to be
able to transform the processed material from liquid
to solid phase. The cooling model is as
model Cooling
PortThermoFluid tfla, tflb "Steel Liquid";
PortThermoFluid tfsa, tfsb "Steel Solid";
PortThermoFluid tfwa, tfwb "Water";
// from geometry model;:
parameter Real Rfluid (start=1) “Thermal res”;
parameter Area area (start=1)“Heat Transfer area”;
Water water; Steel steel; Wall wall;
equation
connect(steel.tfla, tfla);
connect(steel.tflb, tflb);
connect(steel.tfsa, tfsa);
connect(steel.tfsb, tfsb);
connect(steel.ha, wall.ha);
connect(wall.hb, water.ha);
connect(water.tfa, tfwa);
connect(water.tfb, tfwb);
steel.vol = 3;
// real volume must be defined;
water.vol = 0.5; // real volume must be defined;
end Cooling;

7. The casting model
The casting model is composed from three main
submodels or modules: the ladle, the tundish, and the
The Modelica Association

cooling model. In the simulation scenario two other
models are necessary, i.e. the source of the steel,
which impose the events in changing the liquid
material on the input of the process, and, the second,
the load models which is responsible for the
reference of the casting speed. The declarative model
can be as
model TestCastingProcess
SourceSteel steel_S;
Ladle ladle; Tundish tundish;
Cooling cool;
WaterSource water_S;
WaterLoad water_L;
LoadSteel load_S;
equation
connect(steel_S.tfla, ladle.tfla);
connect(ladle.tflb, tundish.tfla);
connect(tundish.tflb, cool.tfla);
connect(water_S.tfa, cool.tfwa);
connect(cool.tfwb, water_L.tfa);
connect(cool.tflb, load_S.tfla);
connect(cool.tfsb, load_S.tfsa);
connect(cool.tfwb, water_L.tfa);
end TestCastingProcess;
Fig.5 presents the evolution of the steel temperatures
in ladle and tundish. The simulation scenario
supposes that from time to time, when the
temperature is increasing in steps, the ladle is filled
up with new liquid material.

Conclusions
The main goal of the work was to obtain a neutral
representation of the continuous casting process of
the steel. Considering all aspects of the process is out
of the scope and is quite difficult without a base
library of materials and phase transformation under
neutral format.
It was supposed that the neutral model is the start
point in the development of more sophisticated and
more accurate models and it is used as a first
description of the process. Some aspects of the
modelling methodology using Modelica language
were also presented.
The models for ladle, tundish and cooling zone were
presented. Simulation results are presented also in
order to check the right qualitative behaviour of the
obtained models, under an imposed scenario at the
input of the casting process. The results are accurate
regarding on the evolution of the temperature of the
steel inside the tundish.

139

Modelica 2005, March 7-8, 2005

D. Aiordachioaie, M. Munteanu, E. Ceanga

Figure 5: Temperature evolution of the steel in ladle and tundish

References
[1].Modelica
and
Modelica
http://www.modelica.org/, 2004.

Association,

[2].Michael Tiller, Introduction to Physical
Modelling with Modelica, Kluwer Academic
Publisher, 2001.
[3].Thomas, B.G. “Continuous Casting: Modelling,”
The Encyclopedia of Advanced Materials, (J.
Dantzig, A. Greenwell, J. Michalczyk, eds.)
Pergamon Elsevier Science Ltd., Oxford, UK,
Vol. 2, 2001, 8p., (Revision 3, Oct. 12, 1999).

[7].Thomas, B. G., X. Huang, et al., Simulation of
Argon Gas Flow effects in a Continuous Slab
Caster, Metallurgical Trans. 25B(4): 527-547,
1994.
[8].Thomas, B. G., A. Dennisov, et al., Behavior of
Argon Bubbles during Continuous Casting of
Steel. Steelmaking Conf. Proceedings, Chicago,
IL, ISS, Warrendale, PA. : 375-384, 1997.
[9]. Thomas, B.G and S.P. Vanka, Study of Transient
Flow Structures in the Continuous Casting of
Steel, University of Illinois at UrbanaChampaign,
Mechanical
and
Industrial
Engineering, Research Report,1999.

[4].Thomas, B. G., B. Ho, et al., Heat Flow Model of
the Continuous Slab Casting Mold, Interface,
and Shell. Alex McLean Symposium
Proceedings, Toronto, Warrendale, PA, Iron and
Steel Society: 177-193, 1998.

[10].Thomas, B.G., Continuous Casting of Steel,
Chap. 15. Modeling and Simulation for Casting
and Solidification: Theory and Applications.
Marcel Dekker, New York, 2000.

[5].D.T.Creech, Computational modelling of
multiphase turbulent fluid flow and heat transfer
in the continuous slab casting mold, Master of
Science in Mechanical engineering Thesis,
University of Illinois at Urbana-Champaign,
USA, 1997.

[11].B. Kiflie and D. Alemu, Thermal Analysis of
Continuous Casting Process, Faculty of
Technology, Addis Ababa University, Ethiopia,
ESME
5th
Annual
Conference
on
Manufacturing and Process Industry, September
2000.

[6].McDavid, R. and B. G. Thomas: “Flow and
Thermal Behavior of the Top-Surface Flux/
Powder Layers in Continuous Casting Molds.”
Metallurgical Trans. B 27B (4): 672-685, 1996.

[12].B.Koza and J. Dzierzawski, Continuous Casting
of Steel: Basic Principles, Research Article,
American Iron and Steel Institute, Learning
Center, http://www.steel.org, 2000.

The Modelica Association

140

Modelica 2005, March 7-8, 2005

Switched Capacitor Simulation with Modelica

Switched Capacitor Simulation with Modelica
Christoph Clauß1), Elisabeth Erler2)
1) Fraunhofer Institute Integated Circuits, Branch Lab Design Automation
Zeunerstraße 38, D-01069 Dresden, Germany
2) Berufliches Schulzentrum, Otto-Dix-Straße 2, D-01705 Freital
clauss@eas.iis.fhg.de

Abstract

which do not need currents explicitely no differentiation of the charge is necessary. In this case only
algebraic (linear or nonlinear) equations have to be
solved with the stepsize of the switching intervals. Typical devices possible at this switched-capacitor
simulation approach are ideal voltage sources, ideal
switches, capacitors, voltage-controlled voltage sources, operational amplifiers. Some special simulators
exploit this approach, e.g. TOSCA [2], SWITCAP [3],
AWEswit [4].

To simulate switched-capacitor circuits effectively special simulators use the charge-voltage system of
equations instead of the current-voltage system. Furthermore, the set of devices is limited. In this paper
possibilities are presented to follow this approach in
Modelica. An example switched-capacitor library is
implemented as well as example circuits.

1

Introduction

In this paper a possibility is studied to perform the SCsimulation with Modelica.

Switched-capacitor (SC) networks are often used for
the realization of filters, comparators, or integrators. As
a simple example of a switched-capacitor circuit c.f.
figure 1. Depending on the switching frequency resistors with varying resistance can be created. Integrated
SC circuits are often much cheaper than conventional
IC’s [1]. Since in such circuits the switching frequency
and the signal frequency often differ considerably, long
time simulations are necessary to investigate the circuit
behaviour. This is time consuming because small
switching intervals with high currents flowing cause
small step sizes during the simulation.

2

For the description and simulation of electrical circuits
usually relations between currents (i) and voltages (v)
are used. The combination of the equations of all devices in a circuit together with the KIRCHHOFF’s law
equations at nodes results in a current-voltage-system
which concsists of differential-algebraic equations
(DAE).
This DAE has to be used if the switching behaviour is
of interest. If from a more general point of view an abstraction from the switching behaviour is acceptable
the switches can be modelled more ideally. In this case
high current impulses occur which force the simulation
of the DAE to small time steps, and therefore to a poor
performance.

C=1
S
in
e
2

C1

1
S
C
=
c
lo
c
k

OpA mp

C
2
G5

G3

A way out is the change from the current-voltage-system to the charge-voltage-system. Provided that:
• the ideal switches are timed in an equidistant
scheme (stepsize s)
• the devices are restricted to capacitors and such
devices which can be described by algebraic relations between pin voltages only (e.g. ideal voltage
sources, voltage controlled voltage sources, ideal
operational amplifiers, ideal switches)
• capacitors are the only devices which combine pin
currents and pin voltages
• no currents themselves are of interest

G4

Figure 1: SC Integrator circuit
A simplification is possible if only the voltages at the
ends of switching intervals are of interest. In such cases
the calculation of the behaviour of currents can be
avoided. Provided that the exchange of charges is finished within the switching interval it is sufficient to
calculate the voltages for the total charge equalization
only. If furthermore only devices are in the circuit

The Modelica Association

Fundamentals

141

Modelica 2005, March 7-8, 2005

C. Clauß, E. Erler

Then the current-voltage DAE can be integrated over
each step interval of the size s. Since derivations with
respect to time occur in capacitors only capacitors are
outlined in detail:
The equation of a capacitor is:
i =

d
C(v)
dt

(2-1)

with i beeing the current and v the voltage over the capacitor. If [ta, tn] with s = tn – ta is the actual time
interval the integration of (2-1) with respect to time results into
q =

d
C ( v ) ( v ( tn ) – v ( ta ) )
dv

(2-2)

where q is the charge transported into the capacitor
within the interval. If the capacitance is constant the
formula is
q = C ⋅ ( v ( tn ) – v ( ta ) )

(2-3)

The device equations (2-2), (2-3) contain voltages and
charges only. Since according to our assumtion all other devices can be described by algebraic relations
between pin voltages, and KIRCHHOFF’s current
equations can be trivially integrated using
tn

q =

∫ i ( t ) dt

(2-4)

ta

the resulting system of equations is a linear or nonlinear algebraic charge-voltage system.
During simulation it has to be solved once at each time
interval at tn. Therefore a higer performance can be expected than solving the current-voltage-DAE. Further
optimizations are possible if the network topology is
exploited, which often changes between two cases
only.
If the restricted amount of devices is left since e.g. a resistor is needed, then the current needs to be calculated
by differentiating the charge variable q (2-4). In this
case a differential-algebraic system is constructed with
the loss of the above mentioned advantages.
There are some generalizations possible such as nonequidistant time grids, switching depending on voltage
values and others, which are not yet considered in this
paper. In the following the implementaion of a
switched-capacitor library is described which bases on
the charce-voltage-system of circuit equations.

The Modelica Association

3

Implementation

In contrast to usual electrical modelling the connectors
include the voltage, and the charge, which is transported via the pin in one switching intervall. The charge is
a flow value like the current in the current-voltage system since according to (2-4) the charge meets
KIRCHHOFF’s law. The connector definition is:
connector VoltageChargePin
Modelica.SIunits.Voltage v
"Potential at the pin";
flow Modelica.SIunits.Charge q
"Charge flowing into the pin";
end VoltageChargePin;

Using this connector models and partial models can be
created like in the Modelica.Electrical.Analog
package.
Basically, there are two groups of devices: Devices
which depend on the switching interval, like switches
and capacitances, and other devices which do not depend on the switching interval. Devices depending on
the switching interval must be „informed“ about the
events of switching. This could be achieved by further
connector, which is connected with a clock generator,
or a logic network. Since in this implementation the restriction is that each switch changes at equidistant
timesteps, each device depending on switching intervals has a clock parameter with clock = 2 ⋅ s . Via the
sample function
algorithm
when sample(0, clock/2.0) then ...

the calculations are controlled which have to be done at
switching time points. The advantage of this approach
is that no clock connections are necessary. Otherwise
the user has to care about the correct clock parameters
at each device. This is a disadvantage. In the examples
a central clock parameter is introduced. Each device
clock parameter is set equal to the central clock parameter by the user. The choice of clock = 2 ⋅ s instead
of clock = s seems to be practical: the clock parameter covers a complete on-off-interval.
Using this clock handling and equation (2-3), the implementation of the linear constant capacitor device is:
model Capacitor
extends Interfaces.OnePort;
parameter Modelica.SIunits.Capacitance C=1;
parameter Real clock=1;
Real vlast(start=0);
Real tlast(start=-1);
algorithm
when sample(0, clock/2) then
if (time > tlast) then
tlast := time;

142

Modelica 2005, March 7-8, 2005

Switched Capacitor Simulation with Modelica

vlast := pre(v);
end if;
end when;
equation
q = C*(v - vlast);
end Capacitor;

model VCV
extends
SwitchedCapacitor.Interfaces.TwoPort;
parameter Real gain=1;
equation
v2 = v1*gain;
q1 = 0;
end VCV;

In the algorithm section only once at a sample tlast and
vlast (which correspondend to ta and v(ta) in equation
(2-3)) are calculated. This is ensured by comparing the
time with the variable tlast. The equation (2-3) itself is
located in the equation section because it can be solved
manifold at a switching point during iterations.

model IdealOpAmp
SwitchedCapacitor.Interfaces.VoltageChargePin
in_p, in_n, out;
equation
in_p.v = in_n.v;
in_p.q = 0;
in_n.q = 0;
end IdealOpAmp;

The switches are modelled similarly. At switching samples the state of the switch is changed. The pin relations
are formulated in the equation section:

The device models are combined to a SC-library for
test and investigation purposes. It contains simple
models only. An extension towards more complicated
devices like operational amplifiers with parasitic capacitances and offset or nonlinear capacitance models
is possible.

model OpeningSwitch
extends SwitchedCapacitor.Interfaces.OnePort;
parameter Real clock=1;
Real s;
Boolean control(start=false);
Real tswitch(start=-1);
algorithm
when sample(0, clock/2.0) then
if (time > tswitch) then
tswitch := time;
control := not control;
end if;
end when;
equation
v = s*(if control then 1 else 0);
q = s*(if control then 0 else 1);
end OpeningSwitch;

4

The models of the SC-library are successfully testet at
a collection of about 20 circuits:
• simple resistors replaced by switched capacitors
• charging of one or more capacitances
• SC-integrators
• SC delay circuit
• Cauer-filter

If for voltage inputs the electrical models shall be used
a converter between the switched-capacitor and the
usual electrical domain is necessary. Since signals in
the switched-capacitor domain change at switching
time points only it is useful to sample the input voltage.
The converter model without any feedback into the current-voltage domain is:

In this section some of the examples are presented to
demonstrate that the SC-simulation works correctly.
All examples were simulated using the simulator
Dymola5.3a.

4.1

model ElectricalToSwitchedCapacitorVoltage
parameter Real clock=1;
Interfaces.VoltageChargePin pinSC;
Modelica.Electrical.Analog.Interfaces.Pin
pinElectrical;
algorithm
when sample(0, clock/2.0) then
pinSC.v :=pinElectrical.v;
end when;
equation
pinElectrical.i = 0;
end ElectricalToSwitchedCapacitorVoltage;

Constant charge flow

In this example a constant charge flow circuit (Fig. 2)
is simulated, which is compared with a constant current
flow through a resistor.
1
Q
S

V
Q
2
=
1

Devices which do not depend on the switching intervals are modelled like the counterparts in the currentvoltage-domain. Merely currents (i) are replaced by
charges (q). As examples the voltage controled voltage
model and the ideal opamp model are cited:

The Modelica Association

Examples

C
=
c
lo
c
..
.

G6

C
Q
1

G7

G8

Figure 2: Constant charge flow circuit

143

Modelica 2005, March 7-8, 2005

C. Clauß, E. Erler

V
=
1

E l2 S C

S

C
=
1

C
s

C
=
1
0

C

G

G_SC

Figure 5: Charging a capacitance

Figure 3: Constant charge flow result
In Fig. 3 the linearly growing line shows the analytical
calculated charge of a circuit like in Fig. 2 where the
switched capacitor with the value clock/2 is replaced by
an equivalent resistor of value R=2 in the current-voltage domain. After each clock period (=1 second) which
includes two switching periods (s=0.5 second) the
charge flowing into the switch is equal to the charge of
0.5 Coulomb flown in the actual clock interval.
In the following Fig. 4 the current of the SC-Circuit
like Fig. 2 is simulated in the current-voltage domain.
The current peaks depend on the parasitic resistance
value in the current-voltage switch model. A purely
ideal simulation is not possible in the current-voltage
domain.

Figure 6: Charging a capacitance: voltages
Furthermore, Fig. 7 shows the charges flowing through
the positive pins of both capacitances.

Figure 4: Current peaks in current-voltage
simulation

4.2

Charging a capacitance

The following circuit (Fig. 5) is a simple charging up of
a capacitance. In this example an electrical voltage
source is used. The voltage is converted into the SC domain with the charge-voltage system.

Figure 7: Charging a capacitance: charges

The pictures in Fig. 6 show the voltages of the capacitances C, and Cs. Depending on the state of the switch
the voltage Cs.p.v of Cs is 1V, if Cs is connected with
the voltage source, or it is equal to the voltage C.p.v of
C which is increasing with each charge equalization.

The charge flow through Cs.p is positive if Cs is
charged by the voltage source. Otherwise it is negative
in the case of the charge equalization between both capacitances. The velocity of charging depends on the
switching interval length clock.

The Modelica Association

144

Modelica 2005, March 7-8, 2005

Switched Capacitor Simulation with Modelica

4.3

SC-Integrators

4.4

The SC-Integrator [5] according to Fig. 1 integrates the
input voltage. The result which is inverted, can be seen
in Fig. 8.

Delay circuit

A clock-controlled delay example is the circuit in
Fig. 11 which combines two voltage amplifiers [6].
The result is delayed by one clock length. Fig. 12
shows the input signal and the delayed output at a clock
of 1.e-4.
C lo s e r

O p e ...
C= C

C2
S1
S
in
e

C1

C= C

S2

C= C

G4

G7

O P1
G1

S4

C4

C3
S3

G2
G3

G5

O P2

C=C

G6

Figure 11: Clock delay circuit

Figure 8: Inverting integration results with
clock=0.01 (above) and clock=0.1 (below)
With a slightly changed topology [5] according to
Fig. 9 a noninverting integration of the input signal is
possible. The results depend on the clock length. Already large clock switching intervals calculate
sufficient results (Fig. 10).

Figure 12: Sine input and delayed SC result

C=1

4.5

Cauer filter

G4 C

S1

V

G1

As a final and more complex example which demonstrates the possibilities of the SC package, the 5th order
cauer filter according to Fig. 14 is modelled [7]. For
purposes of test an unusual time scale is used. The
pulse response results of some of the opamp outputs
can be seen in Fig. 13.

Cs
C=clock

G2

S2

VCV

G3

G5

Figure 9: Noninverting SC-Integrator

Figure 13: Sine input and delayed SC result
Figure 10: Noninverting integration results

The Modelica Association

145

Modelica 2005, March 7-8, 2005

C. Clauß, E. Erler

V

Electri...

C1

1

S2

C14

6

C=1
C2

S1

OP1

C=7.23

4

C=1.5
C3
C=1....

S4

C4

S6

S5

C=1
C5

S8

S7

C=1

C=10...

C6

C16

S3

C=1....
C7

S9

7

C15

S10

8

C=1
C8

OP2

OP3

5

C=10...

3

C=1....

9

C9
C=2

S11

C17
OP4

S12

C=12...

11

C10
S13

C=1

S15

C11
C=2
C13

Cauer_OPV_QV

S14

S16

C=1

C=8.6...
OP5

2

C=9....
C12

S17

C18

10

S18

Figure 14: Cauer filter

4.6

Statistics

Each circuit is modelled both as current-voltage system
using the Modelica.Electrical.Analog package (with
default parameters of the switches) and as charge-voltage system using switched capacitor package. In the
following the systems are abbreviated with CU (current-voltage system) and CH (charge-voltage system).

To compare the performance between simulations of
the current-voltage system and the charge-voltage system of SC circuits the following test examples are used:
circuit
Integ

Integrator according to Fig. 1

Integnon

noninverting integrator according to Fig. 9

Delay

Delay circuit according to Fig. 11

CauerOP

Cauer filter according to Fig. 14

CauerVC

like CauerOP, using voltage-controlled voltage
sources instead of operational amplifiers

The Modelica Association

In the following table system related quantities calculated by Dymola are collected:
• unkn:
unknown variables before translation
• diff:
differented variabled befor translation
• tvar:
time varying variables after translation
• state:
continuous time states after translation

146

Modelica 2005, March 7-8, 2005

Switched Capacitor Simulation with Modelica

circuit
Integ

CU CU
unkn diff

CU CU CH CH
tvar state unkn diff

CH CH
tvar state

40

2

10

2

45

0

14

0

Integnon 61

2

18

2

65

0

24

0

Delay

4

35

4

123

0

53

0

CauerOP 382

18

135

14

410

0

209

0

CauerVC 412

18

177

14

440

0

219

0

111

than in the current-voltage system (Table 2, Table 3).
The reason is that the charge-voltage system of
equaions is an algebraic one (Table 1).
If otherwise the at least necessary number of steps is
calculated according to
in
tstop ⁄ ( clock ⁄ 2 )
Table 3 the resulting number is less than the number of
steps according to Table 2. That means that there are
further possibilities of optimization within the simulation algorithm.

5

Table 1: Translation related quantities
In the next
shown:
• steps:
• F:
• Jac:

Integ

The main result of this investigation is that switchedcapacitor simulation with Modelica and Dymola is possible. The switched-capacitor simulation using the
charge-voltage system and the restricted set of devices
is clearly faster than the simulation of the current-voltage system. The Cauer example shows that the package
can be applied for the simulation of more complex examples than simple test cases. An extension of the
package to devices including parasitic effects, nonlinearities etc. is desirable.

table simulation related quantities are
number of successful steps
number of F-evaluations
number of Jacobian-evaluations

CU
steps

CU
F

CU
Jac

22744

61244

10800

circuit

CH
steps

CH
F

CH
Jac

4700 8900 4200

Integnon 111387 295721 51654

20000 38000 18000

Delay

640

2613

9205

1173

Tasks for future research are more flexible controlling
of switches e.g. via logic networks and further optimization of the algorithm, especially in comparison with
switched-capacitor special simulators.

1200 560

CauerOP 19912

241201 15222

5030 9657 4627

CauerVC 23273

331305 20891

5030 9657 4627

Table 2: Simulation related quantities
In the following table the CPU-time is compared:
• tstop:
stop time
• CPU:
CPU-time for integration in seconds
circuit

tstop

CU
CPU

clock

6

References

[1]

Horowitz, P.; Hill, W.: The Art of Electronics.
Cambridge University Press, 1989
Liberali, V. et al.: TOSCA: A simulator for
switched-capacitor noise-shaping A/D converters. IEEE Tran. on Comp.-aided Design of
Integr. Circuits and Syst. 12(1993)9 1376-1386
SWITCAP - Simulator for ideal switched
capacitor networks. http://www.cisl.columbia.edu/projects/switcap
Trihy, R.; Rohrer, R. A.: A switched capacitor
circuit simulator: AWEswit. IEEE Journal of
Solid State Circuits 29(1994)3, 217-225
Tietze, U.; Schenk, Ch.: Halbleiter-Schaltungselektronik. Berlin, Heidelberg, New York,
Springer-Verlag, 1980
Civardi, L.; Gatti, U.; Torelli, G.: An AHDLbased methodology for computer simulation of
switched-capacitor filters. Elsevier Science
Microelectronics Journal, 27(1996)6, 485-497
Fehlauer, E.; Krauß,M.: Ein effektiver Algorithmus zur Zeitbereichsanalyse von SCOVSchaltungen. Wiss. Z. Techn. Univers. Dresden
35(1986)H.4, 159-163

[2]

CH
CPU

Integ

2

0.01

1.4

0.7

Integinv

10

0.01

5.8

2.0

Delay

0.002

0.0001

1.1

0.95

CauerOP 200000

1000

18.7

1.68

CauerVC 200000

1000

49.2

1.71

[3]

[4]

[5]

Table 3: CPU-time
[6]

The simulations run on a 800 MHz PC with 128 MB
RAM.
Although in the charge-voltage system the number of
time-varying variables after translation is higher than
in the current-voltage system (Table 1) the computational amount in the charge-voltage system is far less

The Modelica Association

Conclusion

[7]

147

Modelica 2005, March 7-8, 2005

The Modelica Association

148

Modelica 2005, March 7-8, 2005

Hydrological modeling in Modelica

Hydrological modeling in Modelica
Karin Berg Kaj Nyström
Linköping University
Linköping, Sweden
kb@lysator.liu.se kajny@ida.liu.se

Abstract
Hydrological modeling is an area where modeling has
been used for a very long time. Applications range
from forecasts for the hydro power industry, public safety, agriculture and environmental monitoring.
Still, to the best of our knowledge, Modelica has been
very little used in hydrological modeling so far. In this
paper, we aim to show that the Modelica language is
well suited for hydrological modeling and also to outline a possible future development of libraries in order
to further facilitate hydrological modeling and coupling of hydrological models to other types of models
in Modelica.
A Modelica implementation of the hydrological HBV
model is compared with the original Fortran model.
The main advantages of using Modelica as modeling
language are more readable and re-usable code and
better abstraction. The disadvantage is longer execution times compared to the Fortran model.
The HBV model is a quite simple model mathematically. It would be useful to investigate the behaviour
of more complex hydrological models as well in order
to see whether we can find the same advantages of using Modelica as modeling language in that respect as
we have in the case with the HBV model.
Keywords: hydrology, modeling, HBV, Modelica,
runoff simulation

1

Introduction

Even though specialised modeling languages have matured over the years, Modelica perhaps being one of
the best examples, most hydrological models are still
written in Fortran. This, we believe, hampers the
development of hydrological modeling. Especially
since considerable knowledge of computer science in
general and Fortran programming in particular is not
something that every hydrologist possess. Clearly, hydrological modeling needs better tools in order to facilThe Modelica Association

itate future model development. The goal of this paper
is to present Modelica as an alternative modeling language for hydrological applications and to investigate
if a direct translation to Modelica of a hydrological
model is actually easier to understand than the corresponding Fortran model.
Hydrological models used today have a wide range
of applications including decision support for different business purposes, for example energy trading
and farming, hydrological forecasts and warnings and
other public safety applications. In addition, they are
also often coupled with for example climatological,
meteorological, chemical and/or biological models.
As an example of a hydrological model we have chosen a version of the HBV model [4]. HBV is a widely
used model throughout the world primarily for hydrological forecasting and runoff simulation, for example
as a tool when designing dams for the hydro power industry, but the HBV model has been applied to many
other areas as well. Among recent applications are
modeling and simulation of nutrient transport in large
catchments and simulations of the potential effects of
climate change on water flows, water quality, particle
transport and biochemical processes in the water.

2

Model description

The HBV model was developed at the Swedish Meteorological and Hydrological Institute (SMHI) in the
1970’s [4]. HBV/PULSE, which is used in this study,
is a similar model developed from the HBV model in
the 1980’s as a consequence of the need to study acidification and substance transport. The two models have
very similar structure but the HBV/PULSE model is
slightly less complex when only hydrology is simulated. HBV and similar models are often described as
semi-distributed conceptual models. They have some
spatial resolution since they handle systems of catchments, lakes and rivers, but within catchments the spatial resolution is limited.

149

Modelica 2005, March 7-8, 2005

K. Berg, K. Nyström

It is conceptual in the sense that it does not use detailed
physical laws of nature in the calculations but rather
simple equations which are consistent with the current
hydrological knowledge. The model consists mainly
of three parts: snow, soil moisture and runoff response
functions. These steps are calculated for each land use
type in every catchment and there is also possibility to
divide the catchments further into sub-catchments. In
the HBV model, but not in the HBV/PULSE model,
it is also possible to divide the catchments and subcatchments into altitude zones.
There are also some routines for weighting and correction of input data and evaluation of model performance. Output data from the forest, field and lake
areas is weighted The present model is based on an
HBV/PULSE model [2] used for research purposes.
Driving variables in the model are daily temperature
and precipitation measurements and monthly averages
of potential evapotranspiration. The number of parameters in the model vary slightly depending on the current version and application area. The model used in
this project has 34 parameters. Both driving variables
and parameters are stored in text files.

3

Model implementation in Modelica

Existing libraries such as Fluid, Species, WasteWater
[5], HylibLight (light version of HyLib [1]), QSSFluidFlow [3] were considered for the implementation of
HBV, but we found them not very well suited for this
application. Since the existing hydraulics libraries are
developed for different engineering purposes they include for example pressure, conductance, geometry of
pipes and vessels and other parameters which are not
known and/or not meaningful to use on the scale on
which the HBV model is operating.

Catchment

Forest

Field

Lake

Interception
SnowPack

SnowPack

SoilMoisture

LakeStorage

SnowPack

SoilMoisture
Response
Response

Figure 1: Component hierarchy in the Modelica implementation of the HBV model: Catchments consists
of several land use components which in turn consists
of different basic HBV components.

3.1

General components and interfaces

In hydrological applications, water volume is sometimes expressed in the unit mm. Water in the HBV
model is entirely expressed in mm and conversion to
other units is only performed when all calculations
have been made. This may seem strange but is a consequence of precipitation measurements in dm3 /m2 ,
which can be reduced to simply mm. Because of this,
a HydrologyVol unit, connectors and storages for volumes expressed in mm have been created (figure 2).
A snow storage was also created, which stores water
in both frozen and liquid form. Connectors, icons and
variables for stored volumes are declared in the general components.

Instead, we have created some very simple general
components for water storage and transport where the
only variable is the water volume itself. There are both
some general base classes and HBV specific components and file reading functions.

Discrete variables have been used since the first aim
was to make a quick translation of the HBV model
from Fortran to Modelica and this was most easily accomplished using discrete variables rather than continuous.

The HBV model components can be divided into three
levels as shown in figure 1. It was possible to transfer
some parts of the model to equation form but the main
part is written as algorithm statements due to special
cases such as if-statements without any else-clause or
with different number of assignments in different parts
of the statement.

Finally, there are base classes for sources and an infinite sink model. The sink model is not storing anything at the moment, but it can easily be modified to
do so. Sources are available with outlets of one or two
types. In this application they are used for sources with
both snow and water outlets, providing input for the
snow storages described above.

The Modelica Association

150

Modelica 2005, March 7-8, 2005

Hydrological modeling in Modelica

package Units
type HydrologyVol =
R e a l ( f i n a l q u a n t i t y =” H y d r o l o g y V o l ” ,
f i n a l u n i t =”mm” ) ;
end U n i t s ;
package I n t e r f a c e
c o n n e c t o r H y d r o l og y F lo w
import H y d r o l o g y ;
Hydrology . U n i t s . HydrologyVol q ;
end H y d r o l og y F lo w ;
c o n n e c t o r QoutD =
d i s c r e t e o u t p u t Hy d r o l o g y F l o w ;
c o n n e c t o r QinD =
d i s c r e t e i n p u t H yd r o lo g y F l o w ;
end I n t e r f a c e ;
p a c k a g e Components
p a r t i a l model S t o r a g e
import H y d r o l o g y . U n i t s . H y d r o l o g y V o l ;
import H y d r o l o g y . I n t e r f a c e . QinD ;
import H y d r o l o g y . I n t e r f a c e . QoutD ;
d i s c r e t e H y d r o l o g y V o l w( min = 0 ) ;
QinD q I n 1 ;
QoutD qOut1 ;
end S t o r a g e ;
p a r t i a l model S n o w S t o r a g e
import H y d r o l o g y . U n i t s . H y d r o l o g y V o l ;
import H y d r o l o g y . I n t e r f a c e . QinD ;
import H y d r o l o g y . I n t e r f a c e . QoutD ;
I n t e r f a c e . QoutD qOut1 ;
I n t e r f a c e . QinD q I n 1 ;
I n t e r f a c e . QinD q I n 2 ;
d i s c r e t e H y d r o l o g y V o l s ( min = 0 ) ;
d i s c r e t e H y d r o l o g y V o l w( min = 0 ) ;
end S n o w S t o r a g e ;
end Components ;

hold a limited amount of water or snow. There is also
a limitation on relative water content in the snow, but
SoilMoisture and Response have no such limits.
model R e s p o n s e
import H y d r o l o g y ;
e x t e n d s H y d r o l o g y . Components . S t o r a g e ;
o u t e r parameter R e a l k ;
o u t e r parameter R e a l a l f a ;
equation
when s a m p l e ( 0 , 1 ) t h e n
w = p r e (w) + q I n 1 . q − qOut1 . q ;
qOut1 . q = 0 . 0 0 1 ∗ k ∗wˆ ( 1 + a l f a ) ;
end when ;
end R e s p o n s e ;

Figure 3: Modelica code for the HBV response function

3.3

HBV land use components

Features common for the three types of land use class
in HBV - the icon type and a snow pack variable which
need to be accessed from several basic components are declared in the partial class LandUse. Forest, Field
and Lake are extensions of LandUse. Forest is the land
use model which contains most parts and equations.
It consists of four model parts: Interception, SnowPack, SoilMoisture and Response, and also one sink
for containing evaporated water. Field has the same
structure as Forest but without Interception since field
is defined in the HBV model as land area with no interception. Lake models consists of only two parts Figure 2: Unit declaration and examples of connectors SnowPack and LakeStorage. Contributions from the
different land use types are added and given a weight
and storages using mm as volume unit
proportional to their area. Calculations for the land use
components are only performed if the area is greater
3.2 HBV basic components
than zero.
Most of the HBV model equations are found in the
basic HBV components Interception, SnowPack, SoilMoisture, Response and LakeStorage. One difference versus the Fortran model is that Interception and
SnowPack are separated instead of treated together in
a common snow routine. This makes the model structure more clear and it also made it possible to use fewer
parameters. All basic components except Response
are implemented using algorithm statements. The Response model is much smaller than the others and there
were no problems with expressing it entirely in equation form (figure 3).
There are limitations on storage of water and snow intercepted in for example trees, since the trees only can
The Modelica Association

3.4

HBV catchment component

The largest component in the HBV model is the catchment. Each Catchment consists of one precipitation
source P and the three land use components described
above. As mentioned in the previous section, there is
also a component for adding and weighting the outflow from the three land use components. Since flows
are weighted based on the relative area of the land use
class, this type of catchment component can be used
even if the catchment for example has no lake or consists only of one big lake.
Reading of driving variables and parameters is accomplished using external C functions which are called

151

Modelica 2005, March 7-8, 2005

K. Berg, K. Nyström

from Catchment. Parameters in the model can also be
altered by the user between simulations. In order to
manage the parameters in an efficient way, all parameters are stored as inner parameters in Catchment. All
models inside Catchment consequently have the parameters which are common for the whole catchment,
which is almost all parameters, declared as outer.
Daily temperature and monthly maximum evapotranspiration are calculated in the Catchment component
and accessed as outer parameters from the catchment
parts. Precipitation has its own component P, a source
with three snow outlets and three rain outlets which
provides input to the land use components. Catchment
also keeps track of which day and month it is in order
to assure that the right data is delivered to the other
model components.

4

Simulation

When setting up an HBV model for a specific area,
Catchments are declared with the appropriate parameter files, PTQW files (driving variables and measured
flow and lake water levels) and initial values. They are
connected to each other directly or through AddFlows
components depending on the geography of the area.
The test simulation setup in this study consisted of two
catchments connected as shown in figure 4. Since the
test areas are small (0.44 and 0.43 km2 respectively),
the AddFlows component adds the two outflows without any weighting or distribution of the flows over
time. The model was run for 1475 time steps, which
corresponds to a time period of a little more than four
years. An Euler solver with fixed step was used since
calculations only need to be performed once every
time step.
A rough estimation of execution times was made in
order to make sure that the Modelica model performed reasonably well compared to the Fortran version. Without any optimisations, the Modelica model
has approximately five to ten times longer execution
time than the Fortran model. The model described
in this paper does not have very long execution time
in either case, so in this application it is not the most
important factor to consider when choosing modeling
language.
The added outflow from the two catchments, Qout
(figure 5), was compared with the corresponding output from the Fortran model. Qout is the runoff response to precipitation which is used for hydrological
forecasts and warnings. Some other important model
variables, for example the soil moisture storage which
The Modelica Association

is used for estimating the risk of forest fires, were also
compared with Fortran results. The comparisons show
that the Modelica model produces the same results as
the Fortran version.

5

Experiences and conclusions

The translation from sequential Fortran code to an object oriented approach was rather easy but it was difficult to also translate the code to equations. The
greatest use for Modelica is probably in designing
new models and making additions to existing models. Some restructuring of the model was done in this
project but more needs to be done in order to take full
advantage of the Modelica language.
The main benefit of translating the model into Modelica is more readable and reusable code, which facilitates future model development. Modelica has proven
quite easy to work with for a non computer scientist with some background in programming. Debugging, though, could be improved since many of the
errors that can be encountered are radically different
from those encountered in ’normal’ imperative programming in for example C.
The test example in this study was quite small, with
only two catchments. In most cases the model is run
over a larger number of catchment. It would therefore
be useful to test the HBV implementation on a larger
scale as well.
Since hydrological modeling is performed with many
different techniques, further development of general
hydrological base classes and components is needed
including components for for example physically
based modeling. It would also be useful to investigate
the behaviour of more complex hydrological models
as well in order to see whether we can find the same
advantages of using Modelica as modeling language
in that respect as we have in the case with the HBV
model.

152

Modelica 2005, March 7-8, 2005

Hydrological modeling in Modelica

model HBV
import H y d r o l o g y ;
H y d r o l o g y .HBV. Components . S i m p l e C a t c h m e n t S i m p l e C a t c h m e n t 1
( Forest1 (
SnowPack1 ( s ( s t a r t = 0 . 0 ) ,w( s t a r t = 0 . 0 ) ) ,
S o i l M o i s t u r e 1 (w( s t a r t = 1 0 0 . 0 ) ) ,
R e s p o n s e 1 (w( s t a r t = 1 0 . 0 ) ) ) ,
Field1 (
SnowPack1 ( s ( s t a r t = 0 . 0 ) ,w( s t a r t = 0 . 0 ) ) ,
S o i l M o i s t u r e 1 (w( s t a r t = 1 0 0 . 0 ) ) ,
R e s p o n s e 1 (w( s t a r t = 1 0 . 0 ) ) ) ) ;
H y d r o l o g y .HBV. Components . S t a r t C a t c h m e n t S t a r t C a t c h m e n t 1
( Forest1 (
SnowPack1 ( s ( s t a r t = 0 . 0 ) ,w( s t a r t = 0 . 0 ) ) ,
S o i l M o i s t u r e 1 (w( s t a r t = 5 5 . 0 ) ) ,
R e s p o n s e 1 (w( s t a r t = 1 0 . 0 ) ) ) ,
Field1 (
SnowPack1 ( s ( s t a r t = 0 . 0 ) ,w( s t a r t = 0 . 0 ) ) ,
S o i l M o i s t u r e 1 (w( s t a r t = 5 5 . 0 ) ) ,
R e s p o n s e 1 (w( s t a r t = 1 0 . 0 ) ) ) ) ;
H y d r o l o g y . Components . T e s t S o u r c e T e s t S o u r c e 1 ;
H y d r o l o g y . Components . S i n k S i n k 1 ;
H y d r o l o g y .HBV. Components . Add2Flows Add2Flows1 ;
equation
c o n n e c t ( T e s t S o u r c e 1 . qOut1 , S i m p l e C a t c h m e n t 1 . q I n 1 ) ;
c o n n e c t ( Add2Flows1 . qOut1 , S i n k 1 . q I n 1 ) ;
c o n n e c t ( S i m p l e C a t c h m e n t 1 . qOut1 , Add2Flows1 . q I n 2 ) ;
c o n n e c t ( S t a r t C a t c h m e n t 1 . qOut1 , Add2Flows1 . q I n 1 ) ;
end HBV;

Figure 4: Modelica code for declaration and connection of the HBV model parts

Figure 5: HBV runoff response simulated in Modelica

References
[1] P. Beater. Modeling and digital simulation of hydraulic systems in design and engineering. educaThe Modelica Association

153

tion using modelica and hylib. In M. Otter, editor,
Modelica workshop 2000 proceedings, pages 33–
44. The Modelica Association, 2000.

Modelica 2005, March 7-8, 2005

K. Berg, K. Nyström

[2] B. Carlsson, S. Bergström, M. Brandt, and
G. Lindström. PULS-modellen - struktur och
tillämpningar (the PULSE model - structure and
applications, in Swedish), 1987. SMHI Reports
Hydrology No.8.
[3] S.M.O. Fabricius and E. Badreddin. Modelica library for hybrid simulation of mass flow in process plants. In The Modelica Association, editor,
2nd International Modelica Conference proceedings, pages 225–234. The Modelica Association,
2002.
[4] G. Lindström, B. Johansson, M. Persson,
M. Gardelin, and S. Bergström. Development and
test of the distributed hbv-96 hydrological model.
Journal of Hydrology, 201:272–288, 1997.
[5] G. Reichl. Wastewater a library for modelling
and simulation of wastewater treatment plants in
Modelica. In P. Fritzson, editor, Proceedings of
the 3rd International Modelica Conference, pages
171–178. The Modelica Association, 2003.

The Modelica Association

154

Modelica 2005, March 7-8, 2005

Visualisation of Model Transformation Algorithms for a Modelica Translator

Visualisation of Model Transformation Algorithms for a Modelica
Translator
Peter Harman, Ricardo UK Ltd., Peter.Harman@ricardo.com

Abstract
A software component has been developed to
visualise the bipartite graph representing the model
structure of a Modelica model. The visualisation is a
window on the underlying graph, and thereforethe
graph transformations appear animated.
This work forms part of research being carried out
into improved strategies for simulation of highly
discontinuous systems. The primary use is to allow
the structure of an equation system to be studied
with the aim of categorising the equations according
to the type of discontinuity.

representing each equation or unknown, and edges to
show relationships between them. The tool described
here extends this concept to include the hybrid
features of a Modelica model, adding vertices to
represent conditional expressions and edges to relate
these to variables and equations. All variables,
including constants, parameters, discrete and
continuous states and derivatives, are represented as
vertices. This allows all actions to be taken, such as
the evaluation of constants, to be represented as
transformations of the underlying graph.
Edges in the graph can be undirected or directed.
Undirected edges relate a variable with an equation,
where the variable can be either on the left-hand-side
or the right-hand-side of the equation. Directed
edges are used to show a variable that is required by,
or is the result of, an algorithm, a function-call or a
conditional expression.

This tool has other applications such as debugging
or clustering tools. Different layouts and animation
methods have been used to maximise the clarity of
the visualisation, however large models produce
graphs which are too large to view.

2 Visualisation of a Model
1 Introduction

Figure 1 shows the model
Modelica.Mechanics.Rotational.Examp
les.CoupledClutches in Dymola.

The Modelica specification [1] and existing
Modelica tools such as Dymola [2] and
OpenSourceModelica [3], make use of graphtheoretical model transformations. The mixture of
differential equations and constraint equations lead
to a Differential-Algebraic-Equation (DAE) system
of unknown index.
Current model transformations [4] have the
following objectives:
• Exploit the sparsity of the system of equations
and sort the equations into small systems of
linear or non-linear equations, this is done in
current tools using the Tarjan algorithm [5]
• Ensure the system is of DAE-index 0 or 1, which
can be solved by a standard solver, this is done
in current tools using the Pantelides algorithm
[6,7]
• Aim to reduce the size of any systems of linear
or non-linear equations by use of tearing [8] or
relaxing [9]
Central to the model transformation algorithms is the
concept of representing the system of equations and
unknowns as a bipartite graph, with vertices
The Modelica Association

Figure 1: CoupledClutches model schematic
The system of variables, equations and conditional
expressions is shown in Figure 2. This seemingly
small model has 100 equations and hence the graph
is large. In the left-hand column each vertex
represents a variable, with the colour representing
the variability of the variable. Constants are shown
magenta, Parameters blue and time-varying variables
are red. In the middle column each vertex represents
an equation. In the right-hand column each vertex
represents a condition expression, such as time <
sin2.startTime. The vertices are joined by
edges, those with arrows are directed edges with the
arrow showing the direction.

155

Modelica 2005, March 7-8, 2005

P. Harman

conditional expressions and the variables on which
the conditions depend. This allows the
categorisation of discontinuities into Local and
Global. Local discontinuities affect only a small part
of the system when they occur, whereas Global
discontinuities affect the entire system. This
categorisation is performed by calculating a measure
of the size of the system that is directly connected to
the variable in which the discontinuity occurs, i.e.
the number of equations and conditional expressions
which depend on the variable.
Further categorisation is performed determining
whether the discontinuity occurs to a state variable
or one of it’s derivatives.

Figure 2: CoupledClutches model equation system

4 Other Applications
Although this tool has been developed to study the
relationships between discontinuous equations and
the variables on which they depend, there are other
applications during the translation process for which
visualisation of the equation structure would be
advantageous.
4.1 Model Debugging
Figure 3: Zoomed-in view of Figure 2

3 Categorisation of Discontinuous
Equations
The main application of this work is the
development of improved strategies for simulating
highly discontinuous systems. It has been shown [4]
that an efficient method of simulating a hybrid
system is to use a multi-step DAE solver for the
smooth continuous parts of the simulation, and to
stop and restart the simulation at each discontinuity
or event. However, for large highly discontinuous
models this is not necessarily efficient. A concept
developed is that of event-density, the frequency at
which discontinuities occur in the model. Eventdensity rises exponentially with the size of the
model. As the time between discontinuities reduces
towards the time-step of the simulation, the
simulation performance is seriously compromised.
Strategies are being developed to allow the
simulation to handle events differently depending on
the source and type of event. To achieve this aim
discontinuous equations must firstly be categorised.
Visualisation of the structure of the system is being
used to study interconnection between equations,
The Modelica Association

Recent work into debugging for equation-based
modelling systems [10] has made use of
visualisations of graphs to show which part of the
model is over or under constrained. A visualisation
tool such as this could be used as part of an
interactive debugging tool. Many models are too
large to visualise in this manner, however a
subsection of the model can be shown.
4.2 Assessment of Model Transformation
Algorithm Efficiency
By visualising the graph, aspects of a particular
model can be shown, such as algebraic loops. Figure
4 shows a visualisation of a small model with a
clearly identifiable algebraic loop. In this
visualisation, the dark vertices represent equations
and the light coloured vertices represent variables.
The efficiency of tearing algorithms can be
interpreted from the resulting visualisation, as the
loop becomes a 'tree' with branches, each branch
representing a system of equations to be solved
numerically. This is analogous to the sizes of blocks
shown in a sparsity plot of the model Jacobian.
The effect of the technique of ‘inline integration’
[11] on the model structure can also be visualised.
This technique inserts equations for integration

156

Modelica 2005, March 7-8, 2005

Visualisation of Model Transformation Algorithms for a Modelica Translator

algorithms into the equation set before the equations
are sorted.

virtual connection graph and the resulting spanning
trees would allow the user to identify and correct the
source of any problem, such as altering the priority
of potential root nodes to control which are selected
during translation.

5 ModeliCode
This visualisation tool forms part of an objectoriented framework created for the development of a
Modelica to simulation code translator, called
ModeliCode. This is written in Java [14]. The graph
manipulation and visualisation package uses the Java
Universal Network and Graph (JUNG) library [15].
ModeliCode also includes a symbolic computation
library to rearrange and differentiate equations,
developed using JScheme [16], which allows the
mixing of Scheme code and Java classes.
A flexible template-based code-generator is included
which allows code to be output in a number of
languages.

Figure 4: Small model with algebraic loop
4.3 Clustering

Currently ModeliCode only translates from flattened
models. These can be read from .mof files output
from Dymola, or can be read via a Corba interface
with the OpenModelica Modeq program.

Clustering algorithms have been used [12] to divide
the Modelica model up into subsystems which can
be executed on separate processors in a cluster. This
is done after the model equations have been sorted,
and requires analysis of the graph to select the
subsystems.

6 Development Issues
6.1 Layout

An interactive visualization tool could be used at
this stage, allowing the user to influence the output
by selecting the edges which become points of
communication between the processors in the
cluster.
4.4 Visualisation of Virtual Connection Graph
for Debugging Overdetermined Systems
The technique for translating overdetermined DAE’s
used by the Modelica MultiBody library, introduced
in [13], makes use of a Virtual Connection Graph.
Each overdetermined type in the model is a vertex in
the graph. This vertex can be a root of a spanning
tree, a potential root which the system will decide
whether it is a root or not, or an ordinary node.
There are two types of edge in the graph, breakable
or non-breakable, which are defined by connect or
Connections.branch statements.
The translator aims to break the virtual connection
graph into spanning trees each with one root. This
may not be possible, due to the number of root
vertices or non-breakable edges. Visualisation of the
The Modelica Association

The layout defines the locations of each vertex.
JUNG provides a number of classes for defining the
layout. Initial studies used a class called
SpringLayout, which is analogous to having a spring
acting between each vertex. Figure 4 was generated
using this layout, showing how it is very good at
illustrating an algebraic loop for a very small model.
However, as the model size increases this layout
makes the graph very hard to read. A new layout
class was written to place the vertices in columns
according to the object they represent. This matches
graphs shown in similar work [10].
6.2 Animation
Clarity is improved by animating the graph. As
vertices are removed, such as during the evaluation
of constants and parameters, or the removal of alias
equations, the vertices in the same column are
moved up to fill their spaces. As equations and
variables are sorted, the vertices are moved into their
new order.

157

Modelica 2005, March 7-8, 2005

P. Harman

7 Conclusions
By visualizing the model in this way, understanding
can be gained of the internal structure of the model.
This understanding can be used to develop model
transformation algorithms and assess their
efficiency, to find errors within the model, or to
apply specialized algorithms such as clustering.
A relatively small model can produce graphs that are
very large and difficult to read, therefore simple
layouts and features such as animation must be used
in the viewer to improve clarity.

8 Acknowledgements
Thanks to Professor Seamus Garvey and Dr Atanas
Popov at Nottingham University for supervising this
project, and to Michael Tiller at Ford Motor
Company; Peter Bunus, Kaj Nyström, Håkan
Lundvall and Peter Aronsson at Linköping
University for useful discussions.
In memory of Dr Pete Lockett, Coventry University.

9. Otter M., Elmqvist H., and Cellier F.E. (1996),
“Relaxing - A Symbolic Sparse Matrix Method
Exploiting the Model Structure in Generating
Efficient Simulation Code”, Keynote Address,
CESA’96 IMACS Multiconference, Symposium
on Modelling, Analysis and Simulation
10. Bunus P, (2002), “Debugging and Structural
Analysis of Declarative Equation-Based
Languages” (Licenciate thesis), Department of
Computer and Information Science, Linköping
University
11. Elmqvist H., Otter M., and Cellier F.E. (1995),
“Inline Integration: A New Mixed
Symbolic/Numeric Approach for Solving
Differential-Algebraic Equation Systems”,
Keynote Address, Proceedings ESM'95,
European Simulation Multiconference
12. Aronsson P., Fritzson P., (2002),
“Multiprocessor Scheduling of Simulation Code
from Modelica Models”, Proceedings Modelica
2002
13. Otter M., Elmqvist H., Mattsson S.E., (2003),
”The New Modelica MultiBody Library”,
Proceedings Modelica 2003
14. JUNG, http://jung.sf.net
15. Java, http://java.sun.com
16. JScheme, http://jscheme.sf.net

References
1. Modelica specification,
http://www.modelica.org/documents/ModelicaS
pec21.pdf
2. Dynasim Dymola, http://www.dynasim.se
3. Fritzson P., Aronsson P., Bunus P., Engelson V.,
Saldamli L., Johansson H., Karström A., (2002),
“The Open Source Modelica Project”,
Proceedings Modelica 2002
4. Mattsson SE, Otter M, Elmqvist H, (1999),
“Modelica Hybrid Modelling and Efficient
Simulation”, 38th IEEE Conference on Decision
and Control
5. Duff I.S., Erismann A.M., and Reid J.K. (1986),
“Direct Methods for Sparse Matrices”, Oxford
Science Publications
6. Cellier F.E., and Elmqvist H. (1993),
”Automated formula manipulation supports
object-oriented continuous-system modelling”,
IEEE Control System Magazine, 13(2)
7. Mattsson S.E., and Söderlind G. (1993), “Index
Reduction in Differential-Algebraic Equations
Using Dummy Derivatives”, SIAM Journal on
Scientific Computing. Vol. 14
8. Elmqvist H., and Otter M. (1994), “Methods for
Tearing Systems of Equations in ObjectOriented Modelling”, Proceedings ESM'94
European Simulation Multiconference
The Modelica Association

158

Modelica 2005, March 7-8, 2005

Modeling of Interactive Virtual Laboratories with Modelica

Modeling of Interactive Virtual Laboratories with Modelica
Carla Martin Alfonso Urquia Sebastian Dormido
Departamento de Informatica y Automatica, E.T.S. de Ingenieria Informatica, UNED
Juan del Rosal 16, 28040 Madrid, Spain

Abstract
The implementation of virtual-labs supporting runtime
and batch interactivity is discussed and it is illustrated
by means of several case studies. The virtual-lab models have been programmed using Modelica language
and translated using Dymola. The virtual-lab views
(i.e., the user-to-model interfaces) have been implemented using Ejs and Sysquake. This software combination approach allows us to take advantage of the
best features of each tool. Ejs and Sysquake capability for building interactive user interfaces composed
of graphical elements, whose properties are linked to
the model variables. Modelica capability for physical modeling and Dymola capability for simulating
hybrid-DAE models.
In order to implement this approach, the following
tasks have been completed: (1) a novel modeling
methodology, adequate for runtime interactive simulation using Ejs, Simulink and Modelica/Dymola, has
been proposed; and (2) a Sysquake to Dymosim interface has been programmed: a set of functions in LME,
intended to be used by the Sysquake applications.

tional flow of information between the view and the
model. Any change of a model variable value is automatically displayed by the view. Reciprocally, any
user interaction with the view automatically modifies
the value of the corresponding model variable.
Two alternative types of interactivity can be implemented:
– Runtime interactivity. The user is allowed to perform actions on the model during the simulation
run. He can change the value of the model inputs, parameters and state variables, perceiving
instantly how these changes affect to the model
dynamic. An arbitrary number of actions can be
made on the model during a given simulation run.
– Batch interactivity. The user’s action triggers the
start of the simulation, which is run to completion. During the simulation run, the user is not
allowed to interact with the model. Once the simulation run is finished, the results are displayed
and a new user’s action on the model is allowed.

1.1 Contributions of this paper

1

Introduction

A virtual-lab is a distributed environment of simulation and animation tools, intended to perform the interactive simulation of a mathematical model. Virtuallabs provide a flexible and user-friendly method to define the experiments performed on the model. In particular, interactive virtual-labs are effective pedagogical resources, well suited for web-based and distance
education [1].
Typically, the virtual-lab definition includes the following two parts: the model and the view. The view
is the user-to-model interface. It is intended to provide
a visual representation of the model dynamic behavior and to facilitate the user’s interactive actions on the
model. The graphical properties of the view elements
are linked to the model variables, producing a bidirecThe Modelica Association

The implementation of interactive virtual-labs is discussed in this manuscript. Runtime and batch interactivity are considered. In both cases, the models are
programmed using Modelica language and translated
using Dymola [2]. The view of the virtual-labs supporting runtime interactivity has been implemented
using Easy Java Simulations [3] (abbreviated: Ejs.
http://fem.um.es/Ejs/). The view of the virtual-labs
supporting batch interactivity has been programmed
using Sysquake (http://www.calerga.com/).
This software combination approach allow us to take
advantage of the best features of each tool. Ejs
and Sysquake capability for building interactive userinterfaces composed of graphical elements, whose
properties are linked to the model variables. Modelica
capability for physical modeling, and finally Dymola
capability for simulating hybrid-DAE models.

159

Modelica 2005, March 7-8, 2005

C. Martin,A. Urquı́a, S. Dormido

The tasks completed to successfully implement this the Java source code of the virtual-lab program, compiles the program, packs the resulting object files into
approach are discussed. In particular:
a compressed file, and generates HTML pages con– Runtime interactive simulation. The communi- taining the virtual-lab as an applet. Then, the user can
cation between the virtual-lab view (programmed readily run the virtual-lab and/or publish it on the Inusing Ejs) and the virtual-lab model (C-code gen- ternet.
erated by Dymola) is accomplished by using The view definition is a strong point of Ejs. Ejs inthe Ejs-Simulink and the Dymola-Simulink in- cludes a set of ready-to-use visual elements, that the
terfaces. The C-code generated by Dymola for modeller can use to compose a sophisticated view in a
the Modelica model can be embedded within a simple, drag-and-drop way. The properties of the view
Simulink block [2]. On the other hand, Ejs allows elements can be linked to the model variables.
the model to be partially or completely devel- On the contrary, the model definition and simulation
oped using Simulink block diagrams. As a conse- is a weak point of Ejs. Ejs provides its own procequence, virtual-labs supporting runtime interac- dure to define the model, which must be formulated
tivity can be implemented by combining the use by the user as a sorted sequence of algorithm clauses
of Ejs, Matlab/Simulink and Modelica/Dymola. (i.e., assignment statements). Ejs implements some
standard ODE solvers. However, it implements neiThe Modelica model needs to be adequately forther algorithms for symbolic formula manipulation nor
mulated in order to be: (1) useful as a Simulink
algebraic-loop solvers.
block; (2) able to accept information from the
Ejs version 3.3 (release 2004) provides a Ejs to Matvirtual-lab view; and (3) able to return inforlab/Simulink interface. Therefore, Ejs 3.3 supports
mation to the virtual-lab view. As a consethe option of describing and simulating the model usquence, a modeling methodology has been proing Matlab/Simulink: (1) Matlab code and calls to
posed. It states how a Modelica model can be
any Matlab function can be used at any point in the
formulated to suit runtime interactive simulaEjs model; and (2) the Ejs model can be partially or
tion. This methodology has been successfully apcompletely developed using Simulink block diagrams.
plied to program a set of virtual-labs for chemiThis significantly improves the Ejs capabilities for
cal process control. One of them is discussed in
model description and numerical solution. However,
this manuscript: the virtual-lab of a double-pipe
Simulink modeling paradigm (i.e., graphical blockheat exchanger. Other virtual-labs are discussed
diagram modeling) exhibits some limitations [7]. It rein [4, 5, 6].
quires explicit state models (ODE) and that the blocks
– Batch interactive simulation. A set of Sysquake have a unidirectional data flow from inputs to outfunctions has been programmed to facilitate data puts. These restrictions strongly condition the modexchange between the view and the model of the eling task, which requires a considerable effort from
virtual-lab. These functions synchronizes the ex- the modeller.
ecution of the dymosim.exe file (generated by Dy- The use of Modelica language is an attractive alternamola) and the Sysquake application. The com- tive to Simulink, because it reduces considerably the
bined use of Sysquake and Modelica/Dymola for modeling effort and permits better reuse of the modvirtual-lab programming is illustrated by means els. The combined application of Modelica/Dymola
and Ejs to the implementation of virtual-labs in disof two case studies.
cussed next.

2

Runtime interactive simulation, by 2.1 Combined use of Ejs, Matlab/Simulink
and Modelica/Dymola
combining the use of Ejs, Simulink
Dymola 5.0 interface to Simulink 3.0 can be found
and Modelica/Dymola

Easy Java Simulations (Ejs) is a open source, Javabased software tool intended to implement virtuallabs. It can be freely downloaded from the website http://fem.um.es/Ejs/. Ejs guides the user in the
process of creating the model and the view, generates
The Modelica Association

in Simulink’s library browser: DymolaBlock block
[2]. This block is an interface to the C-code generated by Dymola for the Modelica code. DymolaBlock
block can be connected to other Simulink blocks, and
also to other DymolaBlocks blocks, in the Simulink’s
workspace window. Simulink synchronizes the nu-

160

Modelica 2005, March 7-8, 2005

Modeling of Interactive Virtual Laboratories with Modelica

merical solution of the complete model, performing
the numerical integration of the DymolaBlock blocks
together with the other blocks.
In order to make the Modelica model useful as a DymolaBlock block, the computational causality of the
Modelica model interface needs to be explicitly set [2].
The input variables are supposed to be calculated from
other Simulink blocks, while the output variables are
calculated from the Modelica model.
Ejs 3.3 supports the option of describing and simulating the virtual-lab model using Simulink. In this case,
the data exchange between the virtual-lab view (composed using Ejs) and the model (Simulink block diagram) is accomplished through the Matlab workspace.
The properties of the Ejs’ view elements are linked to
variables of the Matlab workspace, which can be written and read from the Simulink block diagram.
The Modelica model needs to be built to allow the
communication with the virtual-lab view. It needs to
support the discontinuous changes in the value of its
state variables, parameters and input variables which
are the result of the user interaction. In some cases,
several choices of the state variables need to be supported simultaneously in the model, in order to provide the user with alternative ways of describing the
state changes. A design methodology for the Modelica model is described in Section 2.2. Further details
can be found in [4, 6].

2.2

Modeling methodology

The model of a perfect gas is shown in Figure 1. The
input flow of gas (F), of heat (Q) and the input temperature (Tin ) are input variables. The gas volume (V )
and the heat capacities (CP ,CV ) are time-independent
properties of the physical system.
In general, different choices of the model statevariables are possible. Possible choices in the model
shown in Figure 1 include: e1 = {p, T }, e2 = {n, T }
and e3 = {n, p}; where ei represents one particular
choice of the state variables. If the user wants to
change interactively p and T , the appropriate choice
is e1 = {p, T }. This is also the right choice if the
user wants to change p and to keep constant T , or of
he wants to change T and to keep constant p. Likewise, the appropriate choice is e2 if the user wants:
(1) to modify interactively n and T ; or (2) to modify
n and to maintain constant T ; or (3) to modify T and
to maintain constant n. An analogous reasoning is applied to e3 . In general, an interactive model is required
to support state changes that correspond with different
choices of the state variables.
The Modelica Association

In addition, interactive changes of the model parameters can have different effects depending on the state
variable choice. Consider an instantaneous change in
the gas volume (V ) of the model shown in Figure 1. If
the state variables are e1 = {p, T }, then the change in
V produces an instantaneous change in the number of
moles (n), while the pressure (p) and the temperature
(T ) remain constant. On the contrary, if the state variables are e2 = {n, T }, then the change of volume produces a change of pressure. In this case, the number
of moles (n) and the temperature remain constant. As
a consequence, the interactive model needs to support
different choices of the state variables simultaneously.
An approach to implement this capability is the following. Building the interactive model as composed of
several instantiations of the physical model, each one
with a different choice of the state variables. When
describing an interactive action on the model, the user
selects the adequate state-variable choice according to
his preference. This information is transmitted from
the virtual-lab view to the model. Then, the interactive model uses the adequate physical-model instantiation (that with the chosen state selection) for executing the instantaneous change in the parameters and
state variables, and for solving the re-start problem.
Finally, these calculated values are used to re-initialize
the other physical-model instantiations. This action
guarantees that all physical-model instantiations describe the same trajectory.
Modelica capability for state-selection control allows
easy implementation of this approach [8]. Three instantiations of the perfect-gas model (i.e., perfectGas)
have been defined (see Figure 2): (1) perfectGasSS1,
with e = {p, T }; (2) perfectGasSS2, with e = {n, T };
and (3) perfectGasSS3, with e = {n, p}. The Appendix A provides the Modelica code for the perfect-gas
model.
Two input variables to the DymolaBlock block are
used to carry out the interactive changes in the state:
Istate[:] and CKstate[:] (see Figure 2).
The array Istate[:] contains the values used to reinitialize the model state. In the perfect-gas model:
Istate [:] = {n, p, T }.
The array CKstate[:] is used to trigger the state reinitialization events, which are performed using the
Modelica operator reinit. Each variable of the array
CKstate[:] is used to trigger the events in a different instantiation of the physical model. The perfectgas model contains three instantiations of the physicalmodel: perfectGasSS1, perfectGasSS2 and perfectGasSS3. Consequently, the array CKstate[:] has three

161

Modelica 2005, March 7-8, 2005

C. Martin,A. Urquı́a, S. Dormido

n: Number of moles
p: Absolute pressure
V : Volume of the gas
T : Absolute temperature
U: Internal energy
CP ,CV : Heat capacities
F: Input flow of gas
Tin : Input temperature
Q: Input flow of heat
R: Perfect gas constant

p ·V = n · R · T

0 empty
dn
dt =
F not empty

0
empty

dU
F
·C
·
T
+
Q
not empty and F > 0
=
P
in
dt

F ·CP · T + Q not empty and F ≤ 0

       
	  	 
  
 >




 <  −

U = n ·CV · T

 


CP − CV = R

Figure 1: Model of a perfect gas

456789:;:9< O5@P MEjsN

(Iparam[:], Ivar[:]) containing the new values, and
two arrays (CKparam[:], CKvar[:]) for triggering the
re-initialization events.
The output-variable array of the DymolaBlock block,
O[:] (see Figure 2), contains the variables linked to the
properties of the virtual-lab view. Ejs uses the value of
this output array (O[:]) to refresh the simulation view.
The value of the input array Enabled[:] is set by Ejs,
and it selects which output is connected to the output
signal O[:]. The output array in the perfect-gas model
is the following: O [:] = {n, p, T,V,CP , Tin , F, Q}.

456789:;:9< =>?@:ABCDEFGHFEIJ <:>KL MSimulinkN
model perfectGasInteractive

 !"#$
% "#$
&' !"#$
&'% "#$
())*"#$
&'())*"#$

(Modelica)

model perfectGasSS1
model perfectGasI
model perfectGas
e={p,T}
when change(CKparam[1]) then
reinit({V,Cp},Iparam[:]);
end when;
when change(CKvar[1]) then
reinit({F,Tin,Q},Ivar[:]);
end when;
when change(CKstate[1]) then
reinit(p,Istate[2]);
reinit(T,Istate[3]);
end when;

The Simulink model of the perfect-gas is shown in
Figure 3a. The Modelica model (perfectGasInterac..
..
.
.
tive) is embedded within the DymolaBlock block. The
model perfectGasSS3
blocks connected to the DymolaBlock inputs (“MATmodel perfectGasI
model perfectGas
LAB Fcn” blocks) transmit the value of the input
e={n,p}
when change(CKparam[3]) then
variables from the Matlab workspace to the Simulink
reinit({V,Cp},Iparam[:]);
end when;
when change(CKvar[3]) then
block-diagram window. The blocks connected to the
reinit({F,Tin,Q},Ivar[:]);
end when;
DymolaBlock outputs (“To Workspace” blocks) transwhen change(CKstate[3]) then
reinit(n,Istate[1]);
mit the value of the output variables from the Simulink
reinit(p,Istate[2]);
end when;
/012*3"#$
block-diagram window to the Matlab workspace. Ejs
reads the value of these output variables from the Matlab workspace and writes the value of the input variFigure 2: Schematic description of the perfect-gas ables in the Matlab workspace.
virtual-lab
The view of the virtual-lab is shown in Figure 3b. The
main window (on the left side) contains the schematic
diagram of the process (above) and the control buttons
components. CKstate[1] triggers the change in the (below). Both of them allow the user to experiment
state-variables of perfectGasSS1. CKstate[2] and CK- with the model. The vessel volume, represented in
state[3] trigger the change in the state-variables of per- the schematic diagram, is linked to the V variable. Its
fectGasSS2 and perfectGasSS3 respectively (see Fig- value can be interactively changed by clicking on the
ure 2).
hand picture and dragging the mouse. Three radio butThe interactive parameters (V , CP ) and the input tons allow choosing the state variables ({p, T }, {n, T }
variables (F, Tin ,Q) are defined as constant state- or {n, p}). Text fields allow the user set the value of
variables (i.e., with zero time-derivative) in the phys- the state variables (n, p, T ), the input variables (F, Tin ,
ical model [4]. Their values are changed by using Q) and the parameters (V , CP ). The window placed on
the reinit operator. Four input variables to the Dy- the right side of the virtual-lab view contains graphic
molaBlock block are used (see Figure 2): two arrays plots of the model variables.
The Modelica Association

+,-.

162

Modelica 2005, March 7-8, 2005

Modeling of Interactive Virtual Laboratories with Modelica



 

Figure 3: Perfect-gas virtual-lab: a) Simulink model; b) View







Figure 4: Heat exchanger virtual-lab: a) Physical model; b) Simulink model; c) View
The Modelica Association

163

Modelica 2005, March 7-8, 2005

C. Martin,A. Urquı́a, S. Dormido

2.3

Case study I: heat exchanger

text field to modify the input variables (i.e., liquid and
gas flows, liquid and gas input temperatures, and molar fraction of CO2 and SO2 in the gas mixture); and
(4) checkboxes to show and hide three secondary windows: “Geometry Parameters”, “Modify State” and
“Characteristics”.
The “Geometry Parameters” window contains text
fields that can be used to modify the pipe length
and diameters. The controls placed in the “Modify
State” window allow changing the temperature of the
medium inside each control volume (i.e., the cooling
liquid, the gas mixture or the metal wall). Finally,
“Characteristics” is a window with several plots of the
model variables.

The interactive simulation of a heat exchanger has
been implemented, by the combined use of Ejs, Matlab/Simulink and Modelica/Dymola. A mixture of carbon dioxide and sulfur dioxide is cooled by water in a
double-pipe heat exchanger [9]. Two modes of operation are allowed: cocurrent or parallel flow and countercurrent flow. The convective heat transfer on both
the tube and shell sides are calculated from the DittusBoelter correlation [9]. The center heat exchanger tube
is made of copper with a constant thermal conductivity, and the exterior of the steel pipe shell is very well
insulated.
The physical model of the heat exchanger has been
composed using JARA. The model diagram is shown
in Figure 4a. JARA is a set of libraries of some funda3 Batch interactive simulation, by
mental physical-chemical principles. JARA was origicombining the use of Sysquake and
nally written in Dymola language [10, 11]. Later on, it
was translated into Modelica language. The methodModelica/Dymola
ology discussed in Section 2.2 was applied in order to
make JARA useful for interactive simulation [5].
Sysquake is a commercial tool intended to develop
JARA is composed of seven model libraries, including interactive applications [12]. It is based on LME,
models of:
an interpreter specialized for numerical computation.
LME is mostly compatible with the language of MAT– Control volumes containing: (1) an ideal mixture
LAB(R) 4.x and it includes many features of MATof an arbitrary number of semi-perfect gases; or
LAB 5 to 7. It implements graphic functions specific
(2) a homogeneous liquid mixture composed of
to dynamic systems (such as step responses and frean arbitrary number of components; or a homoquency responses) and general purpose functions used
geneous solid. The liquid and gaseous control
for displaying any kind of data.
volumes are considered open systems (i.e., they
Typically, a Sysquake application contains several
can exchange mass and heat with their environinteractive graphics, which are displayed simultanement) and chemical reactions can take place inously. These graphics contain elements that can be
side them. The solid control volumes are conmanipulated using the mouse. While one of these elsidered closed systems (i.e., they only exchanges
ements is being manipulated, the other graphics are
energy, not mass, with their environment).
automatically updated to reflect this change. The con– Mass transport due to the pressure and concen- tent represented by each graphic, and its dependence
tration gradient, the gravitational acceleration, with respect to the content of the other graphics, is prochemical reactions, liquid-vapor phase changes, grammed using LME.
etc.
The main goal of Sysquake is the interactive manipulation of graphics. The user can define functions, called
– Heat transport by conduction and convection.
handlers, intended to perform different tasks managed
The Simulink model is shown in Figure 4b. The by Sysquake. These tasks include the model initializainteractive model of the heat exchanger, written in tion, manipulation of figures and selection of menus.
Modelica language, has been embedded within the As input and output, the handlers use variables as well
DymolaBlock block. Observe that the structure of as values managed directly by Sysquake, such as the
this Simulink model is completely analogous to the position of the mouse. Therefore, only the code necessary for displaying the figures and processing manipuperfect-gas model, shown in Figure 3a.
The view of the virtual-lab is shown in Figure 4c. The lations from the user is required. This results in small
main window (on the left side) contains: (1) a diagram scripts, developed quickly and easy to maintain.
of the heat exchanger; (2) buttons to control the simu- LME can be extended by libraries, composed of relation run (i.e., pause, reset and play); (3) sliders and a lated functions written in LME, or by extensions deThe Modelica Association

164

Modelica 2005, March 7-8, 2005

Modeling of Interactive Virtual Laboratories with Modelica
%)*+%	
  , - /  
1&
'-	34 &516(



.
 . 0 2

4 , 4





,


. 9

# $ :%;<

dsin.txt

%7 8	
  4



dslin.txt


   

!

"

4 ,




the names of the model variables (i.e., inputs, outputs, parameters, states) and their default values
from dsin.txt file, and saves them as variables to
the Sysquake workspace.

,

dsin1.txt

dymosim.exe

	
 


	

 




# $ %  	
& 


– SetValues(txtFile, pN, p, x0N, x0). The name and
the value of the model parameters and state variables are written to the txtFile text file (dsin1.txt
by default).

	
 


	

 


dsres.txt

– dymosim(iFile, oFile). This function executes the
following command: dymosim -d dsin.txt iFile
oFile. The default file name for iFile and oFile
is dsin1.txt and dsres.txt respectively.

'( 
# $ % 	

 



Figure 5: Sysquake-Dymosim interface functions

Combined use of Sysquake and Modelica/Dymola

– linearize(iFile, oFile). This function obtains the
linearized model by executing the command: dymosim -l iFile oFile. The default file name for
iFile and oFile is dsin1.txt and dslin.txt respectively.

A Sysquake interface to Dymosim (i.e., the executable
file generated by Dymola [2]) has been programmed.
This interface is a set of functions in LME, intended to
be used by the Sysquake applications. These functions
perform the following tasks:

– [N,s] = tload(oFile). This function reads the result file, oFile (default file name: dsres.txt), and
stores the signal names and the simulation results
into N (text matrix) and s (numeric matrix) respectively.

– The setExperiment and setValues functions write
the experiment description to a text file. This
text file is intended to be the input file for dymosim.exe.

– [A,B,C,D,xN,uN,yN] = tloadlin(txtfile). It loads
the linear model generated by dymosim from the
txtfile result file (default file name: dslin.txt) into
the Sysquake workspace.

veloped with standard compilers.

3.1

– The dymosim and linearize functions execute the Next, two case studies are provided to illustrate the use
dymosim.exe file in order to simulate and lin- of this Sysquake-Dymosim interface.
earize the Modelica model respectively.
– The tload and tloadlin functions: (1) read the output file generated by dymosim.exe after a model
simulation or linearization respectively; and (2)
save these results as variables to the Sysquake
workspace. These variables can be used by
Sysquake applications.
Next, a brief description of each function is provided
(see Figure 5):
– setExperiment(txtFile, StartTime, StopTime, Increment, nInterval, Tolerance, MaxFixedStep, Algorithm). It writes to the txtFile text file (default
file name: dsin1.txt) the simulation parameters.
– [p, x0, pN, x0N, InputN, outputN] = getinfo. This
function executes the dymosim.exe file (command
dymosim -i) in order to generate the Dymosim input file (dsin.txt). In addition, this function reads
The Modelica Association

3.2 Case study II: control loop
The interactive simulation of the control loop shown
in Figure 6 is implemented by combining the use of
Sysquake and Modelica/Dymola. The constitutive relation of the hysteresis-based controller in shown in
Figure 7. The setpoint is the composition of two
signals: a piecewise linear function and a sine function. The model of the control loop has been programmed using Modelica language and translated using Dymola. The execution of the dymosim.exe file
generated by Dymola is controlled by the Sysquake
application (i.e., the virtual-lab view).
The view of the virtual-lab is the Sysquake application
shown in Figure 8. It is composed of four graphics.
Three of them are interactive:

165

– “Constitutive relation” plot (graphic on the upper
left). The position of the {a, b, c, d, e, f } points of
Modelica 2005, March 7-8, 2005

C. Martin,A. Urquı́a, S. Dormido

r

u

e

u

+-

e

 
x=Ax+Bu
y=Cx

y

Figure 6: Control loop
u

d

u(e) = - u(-e)

c

f

e
s4

s3

s2
s1
0

a

b

Figure 9: View of the heat exchanger virtual-lab
e

Figure 7: Constitutive relation of the controller

3.3 Case study III: heat exchanger

The heat exchanger virtual-lab described in Section
2.3 supports runtime interactivity. It was implemented using Ejs, Simulink and Modelica/Dymola.
In this section, the heat exchanger model is revisited,
and a virtual-lab supporting batch interactivity is programmed by combining the use of Sysquake and Modelica/Dymola.
The view of the virtual-lab is the Sysquake application
shown in Figure 9. The sliders placed on the upper
left side allow modifying some model parameters: the
pipe length and diameters, and the thermal parameters
of the center heat-exchanger tube.
The graphic on the upper right corner is interactive.
It represents the time-evolution of the inlet temperature of the water. The shape of this curve can be
Figure 8: View of the control loop virtual-lab
changed by clicking on one of the points and dragging
the mouse.
The graphics on the lower side of Figure 9 show the
the controller constitutive relation can be changed
time-evolution of the temperature at certain positions
by dragging the mouse.
of the tube and the shell.
– “Roots” plot (graphic on the lower left). The
4 Conclusions
plant zeros and poles can be changed by clicking on the circles and crosses and dragging the The feasibility of combining Modelica/Dymola with
mouse.
Ejs and Sysquake, for implementing runtime and batch
interactive simulations respectively, has been demonstrated. Ejs and Sysquake are software tools intended
– “Reference” plot (graphic on the lower right).
to develop interactive applications. Their strong point
The shape of the piecewise linear function and
is the programming of the virtual-lab view. Workthe amplitude and frequency of the sine function
ing together with Modelica/Dymola significantly imcan be modified by clicking on the lines and cirproves the Ejs and Sysquake capabilities for model
cles that appear in the graphic and dragging the
description and simulation. The use of Modelica lanmouse.
guage reduces considerably the modeling effort.
In order to implement this software combination apThe Modelica Association

166

Modelica 2005, March 7-8, 2005

Modeling of Interactive Virtual Laboratories with Modelica

proach, a modeling methodology has been proposed [9]
and a Sysquake-Dymosim interface has been programmed. Several case studies of virtual-labs supporting runtime and batch interactivity have been dis[10]
cussed.

Acknowledgements

Cutlip M.B, Shacham M. Problem Solving in
Chemical Engineering with Numerical Methods.
Prentice-Hall, 1999.
Urquia A. Modelado Orientado a Objetos y Simulación de Sistemas Hı́bridos en el Ámbito del
Control de Procesos Quı́micos. PhD. Thesis.
Dept. Informática y Automática, UNED, Madrid,
Spain, 2000.

The authors wish to thank Dr. Yves Piguet (Calerga
[11] Urquia A, Dormido S. Object-Oriented Design
Sarl, Lausanne, CH) for his constructive comments.
of Reusable Model Libraries of Hybrid Dynamic
This work has been supported by the Spanish CICYT,
Systems. Mathematical and Computer Modelling
under DPI2001-1012 and DPI2004-1804 grants.
of Dynamical Systems, 9(1), pp. 65–118, 2003.

References

[12] Calerga Sarl. Sysquake 3. User’s Manual. Calerga Sarl. Lausanne, Switzerland.

[1] Dormido S. Control learning: Present and Future. In: Annual Reviews in Control, vol. 28, pp.
115–136, 2004.
[2] Dynasim AB. Dymola. User’s Manual. Version
5.0a. Dynasim AB. Lund, Sweden.
[3] Esquembre F. Easy Java Simulations: a Software
Tool to Create Scientific Simulations in Java. In:
Computer Physics Communications, vol. 156,
pp. 199–204, 2004.
[4] Martin C, Urquia A, Sanchez J, Dormido S, Esquembre F, Guzman J.L, Berenguel M. Interactive Simulation of Object-Oriented Hybrid Models, by Combined use of Ejs, Matlab/Simulink
and Modelica/Dymola. In: Proc. 18th European
Simulation Multiconference, pp. 210–215, 2004.
[5] Martin C, Urquia A, Dormido S. JARA 2i - A
Modelica Library for Interactive Simulation of
Physical-Chemical Processes. In: Proc. European Simulation and Modelling Conference, pp.
128–132, 2004.
[6] Martin C, Urquia A, Dormido S. Object-Oriented
Modeling of Virtual Laboratories for Control
Education. 16th IFAC World Congress, Praha,
Czech Republic, July 2005. Accepted.
[7] Astrom K.J, Elmqvist H, Mattsson S.E. Evolution of Continuous-Time Modeling and Simulation. In: Proc. of the 12th European Simulation
Multiconference, Manchester, UK, 1998.
[8] Otter M, Olsson H. New features in Modelica
2.0. In: Proc. 2nd International Modelica Conference, pp. 7.1–7.12, 2002.
The Modelica Association

APPENDIX A: Modelica code for the
perfect-gas model
model perfectGas
parameter Boolean nIsState, pIsState, TIsState;
Real n (unit="mol", start=20,
stateSelect = if nIsState
then StateSelect.always
else StateSelect.default);
Real p (unit="N.m-2", start=1e5,
stateSelect = if pIsState
then StateSelect.always
else StateSelect.default);
Real T
(unit="K", start=300,
stateSelect = if TIsState
then StateSelect.always
else StateSelect.default);
Real V
(unit="m3", start=1);
Real Cp (unit="J/(Kg.K)", start=5*R/2);
Real Cv (unit="J/(Kg.K)");
Real F
(unit="mol.s-1");
Real Tin (unit="K");
Real Q
(unit="J.s-1");
parameter Real R (unit="J/(mol.K)") = 8.31;
protected
Real U (unit="J", stateSelect = StateSelect.never);
Boolean empty (start=false);
equation
// Interactive parameters
der(V) = 0;
der(Cp) = 0;
// Input variables
der(F)
= 0;
der(Tin) = 0;
der(Q)
= 0;
// State equation
p * V = n * R * T;
// Mol balance
der(n) = if empty then 0 else F;
// Energy balance
der(U) = if empty then 0
else if F>0 then F*Cp*Tin+Q else F*Cp*T+Q;
// Internal energy
U = n * Cv * T;
// Mayer law
Cp - Cv = R;
// Empty-vessel condition

167

Modelica 2005, March 7-8, 2005

C. Martin,A. Urquı́a, S. Dormido

when F > 0 and
pre(empty) or
n < 1e-5 and not pre(empty) then
empty = not pre(empty);
end when;
end perfectGas;
model perfectGasI
extends perfectGas;
Modelica.Blocks.Interfaces.InPort Iparam (n=2);
Modelica.Blocks.Interfaces.InPort Ivar
(n=3);
Modelica.Blocks.Interfaces.InPort Istate (n=3);
Real CKparam;
Real CKvar;
Real CKstate;
Modelica.Blocks.Interfaces.OutPort O
(n=8);
protected
Boolean CKparamIs0 (start = true, fixed=true);
Boolean CKvarIs0
(start = true, fixed=true);
Boolean CKstateIs0 (start = true, fixed=true);
equation
// Interactive change of the parameters
when CKparam>0.5 and
pre(CKparamIs0) or
CKparam<0.5 and not pre(CKparamIs0) then
CKparamIs0 = CKparam < 0.5;
reinit(V,
Iparam.signal[1]);
reinit(Cp, Iparam.signal[2]);
end when;
// Interactive change of the input variables
when CKvar>0.5 and
pre(CKvarIs0) or
CKvar<0.5 and not pre(CKvarIs0) then
CKvarIs0 = CKvar < 0.5;
reinit(F,
Ivar.signal[1]);
reinit(Tin, Ivar.signal[2]);
reinit(Q,
Ivar.signal[3]);
end when;
// Output signal
O.signal = { n, p, T, V, Cp, Tin, F, Q };
end perfectGasI;
model perfectGasSS1
extends perfectGasI (nIsState=false,
pIsState=true,
TIsState=true);
equation
// Interactive change of the state variables
when CKstate>0.5 and
pre(CKstateIs0) or
CKstate<0.5 and not pre(CKstateIs0) then
CKstateIs0 = CKstate < 0.5;
reinit(p, Istate.signal[2]);
reinit(T, Istate.signal[3]);
end when;
end perfectGasSS1;

when CKstate>0.5 and
pre(CKstateIs0) or
CKstate<0.5 and not pre(CKstateIs0) then
CKstateIs0 = CKstate < 0.5;
reinit(n, Istate.signal[1]);
reinit(p, Istate.signal[2]);
end when;
end perfectGasSS3;
model perfectGasInteractive
Modelica.Blocks.Interfaces.InPort Iparam (n=2);
Modelica.Blocks.Interfaces.InPort Ivar
(n=3);
Modelica.Blocks.Interfaces.InPort Istate (n=3);
Modelica.Blocks.Interfaces.InPort CKparam (n=3);
Modelica.Blocks.Interfaces.InPort CKvar
(n=3);
Modelica.Blocks.Interfaces.InPort CKstate (n=3);
Modelica.Blocks.Interfaces.InPort Enabled (n=3);
Modelica.Blocks.Interfaces.OutPort O
(n=8);
Modelica.Blocks.Interfaces.OutPort Release(n=1);
perfectGasSS1 SS1 (CKparam = CKparam.signal[1],
CKvar
=
CKvar.signal[1],
CKstate = CKstate.signal[1]);
perfectGasSS2 SS2 (CKparam = CKparam.signal[2],
CKvar
=
CKvar.signal[2],
CKstate = CKstate.signal[2]);
perfectGasSS3 SS3 (CKparam = CKparam.signal[3],
CKvar
=
CKvar.signal[3],
CKstate = CKstate.signal[3]);
equation
connect(Iparam, SS1.Iparam);
connect(Istate, SS1.Istate);
connect(Ivar,
SS1.Ivar);
connect(Iparam, SS2.Iparam);
connect(Istate, SS2.Istate);
connect(Ivar,
SS2.Ivar);
connect(Iparam, SS3.Iparam);
connect(Istate, SS3.Istate);
connect(Ivar,
SS3.Ivar);
Release.signal = {4.0};
O.signal = if Enabled.signal[1] > 0.5
then SS1.O.signal
else if Enabled.signal[2] > 0.5
then SS2.O.signal
else if Enabled.signal[3] > 0.5
then SS3.O.signal
else zeros(size(O.signal, 1));
end perfectGasInteractive;

model perfectGasSS2
extends perfectGasI (nIsState=true,
pIsState=false,
TIsState=true);
equation
// Interactive change of the state variables
when CKstate>0.5 and
pre(CKstateIs0) or
CKstate<0.5 and not pre(CKstateIs0) then
CKstateIs0 = CKstate < 0.5;
reinit(n, Istate.signal[1]);
reinit(T, Istate.signal[3]);
end when;
end perfectGasSS2;
model perfectGasSS3
extends perfectGasI (nIsState=true,
pIsState=true,
TIsState=false);
equation
// Interactive change of the state variables

The Modelica Association

168

Modelica 2005, March 7-8, 2005

Parallelization in Modelica

Parallelization in Modelica
Kaj Nyström Peter Aronsson Peter Fritzson
Linköping University, Sweden
{kajny,petar,petfr}@ida.liu.se

Abstract

complex applications, the use of modeling and simulation is promoted.
The better the computer, the larger and more precise There are four different ways which a user can go
simulations can be carried out, and the more benef- about in order to faster be able to simulate a more comicent modeling can be. It is well known that faster plex physical structure:
computers enable more precise and computationally
1. Buy a faster computer
expensive simulations to be carried out, which allow
more pre-cise mathematical models. This paper gives
2. Optimize the model for faster simulation
an overview of certain methods for expanding the limits of what can be done in the area of simulation by
3. Optimize the compiler
parallelizing simulations based on Modelica [18, 16]
4. Parallelize the model, distributing simulation
models. This is an efficient and less expensive way of
across many processors.
achieving better simula-tion performance.
In the following, we will restrict ourselves to deWhile option one can sometimes be a viable alternascribing various ways of parallelizing a simulation in
tive, it is so only up to a certain point. There is a limit
Modelica, ranging from coarse grained high level parto how fast computers are available, even if you have
allelization to fine grained task merging at a very low
the financial resources to update your computer every
level. It is very difficult to say which approach is
month.
the most successful or promising since little research
Option two might very well be the issue for a whole
has been done in most of the subareas of parallelizing
series of articles all by itself. Still, experience show
Mode-lica models. Task merging seems to be the most
that there is a limit to the performance gain which can
developed approach and does give significant perforbe obtained also from model optimization.
mance increases [1] but the other areas are largely
Option three is an interesting item as it can potentially
unexplored. We can therefore only guess that based
boost performance of every model compiled with that
on parallelization research in other areas, there is litcompiler. The amount of performance gain which can
tle to gain for a normal user in parallelizing a small
be obtained by compiler optimization is however also
simulation. Larger, more complex simulations on the
quite limited.
other hand can benefit greatly from parallelization, esThis paper will focus on item four, parallelization of
pecially if it can be done automatically.
the model. The model is assumed to be written in
Keywords: Modelica, parallelization, task merging, Modelica and to be of a size and complexity which
transmission line modeling, weak connectors
makes it nontrivial to simulate within reasonable time

1

on a single powerful computer. Apart from this, we
make no assumptions whatsoever on the model structure, composition or domain.

Introduction

Since the advent of computers, there has always existed a need for more computational power. In fact,
the peak performance of a computer system effectively
sets a limit to what the user can actually do. For a
Modelica user, the amount of computational power
available at simulation time is what determines what
can be simulated. Obviously, if we can simulate more

The Modelica Association

2 Parallelization in General
Parallelization of computational problems has been
an issue for as long as there has been computers.
Regardless of how fast current computers are, there
has always been applications where this is simply not

169

Modelica 2005, March 7-8, 2005

K. Nyström, P. Aronsson, P. Fritzson

enough. Parallelization of the problem is then the only
viable solution. The problem is to get good performance while distributing the computation across several CPUs. Communication between jobs can, even if
carefully implemented cause severe delays in the computation because the necessary data may not be available when it is needed. Also, simple program branches
such as if-statements which decide which statement
should be executed and not must be treated with great
care so that the right program path is taken. These,
and several other issues must always be taken into account when trying to parallelize an application. This is
even more important when trying to parallelize a general class of applications, such as Modelica models.

3

Parallelization in Modelica

4.1 The Transmission Line Modeling Method

We will in this paper try to summarize past, present
and future research advances within the area of parallelization of models expressed in the Modelica language. We have divided the subject into three parts or
levels, depending on where the parallelization is applied. The high level parallelization tries to partition
the model on the Modelica source code level. The
medium level deals with the numerical solvers while
the low level parallelization deals with the solver generated code.
Before we begin, we would like to make one observation which makes the task of parallelizing Modelica
even more challenging than with other languages, for
example C or Fortran. Modelica developers are normally not experts in parallel programming. In fact,
they are usually not computer scientists at all, but
instead domain experts within one or many specific
fields using physical modeling. This demands a lot
of the parallelization framework since the user (that
is, the Modelica modeler) can not really take an active
part in the parallelization. This means that the parallelization must be automatically performed, without
user interaction to a great extent. If this is not possible
then at least the user interaction must be minimized
and formulated in a way that makes sense even to a
user with no experience whatsoever in parallel computing.

4

High Level Parallelization

High level parallelization, as stated previously deals
with the problem of parallelizing models at the Modelica source code level. In general, this means that
the Modelica language itself is extended or modified

The Modelica Association

in some way in order to allow the user to provide
the compiler with directions on how to parallelize the
simulation. In comparison with other high level languages, the Modelica language has some interesting
properties which can be used to our advantage when
trying to parallelize Modelica simulations.
The most interesting property is probably the connection construct. A Modelica model almost always consists of a multitude of components with connections
between them. The connections define an explicit
interface between components which is quite useful
when considering how to best partition the model. Indeed, both of the two high level parallelization methods we know about use connections in one way or another.

The transmission line modeling (TLM) method [6] is
derived from two ideas. First, that many models can be
viewed as a continuous transmission line which propagates information. Second, that the information being
propagated in time step t − 1 in many cases does not
differ much from the information propagated in step
time step t. This means that we can reuse information
received in time step t − 1 in the calculations for time
t, thus reducing the amount of communication needed
between partitions in the model. While we do introduce an error in the model by reusing values from earlier time step, this error is mathematically decidable
and it is possible to reduce the amount of value reuse
and thus reduce the error introduced. The transmission
line modeling method is not yet implemented in any
Modelica implementation that we know of although an
implementation of the TLM method has been planned
in the GridModelica project [5] for 2005.

4.2 The Weak Connectors Method
Introduced by [7] this somewhat less explored method
also deals with connections. By introducing the concept of weak connections, the model can be partitioned
in two or more parts. The idea is to separate fast subsystems from slow so that different solver step size,
or even different solvers can be used when solving the
system. The difficult part here is to find good places
to insert the weak connection, instead of a normal connection. Such places frequently occur between domain
boundaries and while these could quite easily be identified by a domain expert, it is not so easy to find them
automatically, which is of course the desirable method.
One way of doing this could be to exploit the package

170

Modelica 2005, March 7-8, 2005

Parallelization in Modelica

structure of Modelica which roughly divides compo- cobian calculation is sometimes necessary when using
nents into different domains.
an implicit ODE solver and its calculation is side effect
free which makes the amount of interCPU communi4.3 Other high level parallelization methods cation small. Related to this, it is possible to achieve
some degree of parallelism in the calculation of the
There are a some high level parallelization tech- states in an ODE or a DAE, meaning function f in the
niques in traditional parallel programming that could ODE system 1 and functions f , g in the DAE system
be adapted to Modelica. One such technique is matrix 2.
operation partitioning. Matrixes and vectors represent
large data chunks upon which operations are executed.
Ẋ = f (X ,t)
(1)
One example operation could be to add one to each
f (Ẋ, X ,Y,t) = 0, g(X ,Y, Z) = 0
(2)
element in the matrix. Such an operation could quite
easily be distributed across several CPUs as the individual operations of adding one to element m[i][ j] is
independent from the operation of adding one to element m[k][l].
In the same way, parts of normal loop parallelization techniques could probably be employed to achieve
parallelization in Modelica. For example High Performance Fortran (HPF)[11] has the forall, pure and independent keywords which gives the compiler directions on how to parallelize loops in the program. Even
though these constructs could quite easily be introduced in the Modelica language, it is unsure whether
they will provide the same performance boost as they
do in HPF due to Modelicas radically different execution model.

5

Medium level parallelization

The next level of parallelization is at the equation system and numerical solver level. Parallel solvers have
in the past had problems with numerical stability in
comparison with other state-of-the-art solvers. Thus,
limiting the usage of such solvers to specific domains
where the requirement on the numerical stability of the
solver is not too demanding. Parallelizing numerical
solvers is in itself a very complex task and while an
interesting way to achieve additional parallelism, for
example with algorithms such as [12, 13] it is not really Modelica specific. We shall therefore in this paper
concentrate on other ways of equation parallelization.
Another interesting solver related technique is the
mixed mode integration technique presented in [4]. It
is a compromise between explicit and implicit integration, done by splitting fast and slow subsystems in a
model and to apply implicit discretization only to the
fast part. Results presented in [4] indicates performance increases ranging from four to sixteen times.
One task that could be parallelized without too much
effort be parallelized is the Jacobian calculation. Ja-

The Modelica Association

It might also be possible to conduct parallelize solving of equation system in some cases, as done in [14].
Even though it is common that subcomponents in an
equation system depend upon each other in a linear
fashion, it does not have to be so. What has to be done
is to build a task dependency graph and determine if
subsystems can be solved simultaneously and pass this
to a task scheduler which then distributes the tasks.
Scheduling and partitioning algorithms as described in
[2] also belongs on this level. In that paper only static
scheduling algorithms are described and while these
work very well for continuous systems, they will not
work with hybrid models, meaning models that contain both continuous and discrete parts. In such hybrid
systems, discrete events can radically change the behavior of the system so in that case, we need to use
dynamic scheduling instead.

6 Low level parallelization
While the difference between medium an low level
parallelization might be hard to define, we have in this
paper drawn the line at the data level at which the
parallelization algorithms work. With low level parallelization, the object is to parallelize the compiler
generated simulation code. We will refrain from describing low level parallelization here since it is already thorouwghly described in [3].

7 Discussion
Parallelization in Modelica is still very much underdeveloped, with the possible exceptions of the low
level parallelization and solver integration. This is perhaps somewhat surprising since physical modeling and
simulation is one of the areas with the strongest demand for more computational power. While there exist some parameter study applications [10, 9, 8], real

171

Modelica 2005, March 7-8, 2005

K. Nyström, P. Aronsson, P. Fritzson

parallelization of Modelica models is still to a great [7] Casella F. , Maffezzoni C. : ”Exploiting Weak
extent a an open issue to be explored.
Interactions in Object Oriented Modeling”, EUROSIM Simulation News Europe, Mar. 1998, pp.
While the above mentioned techniques can probably
8-10.
be applied separately with good results, even better results can be expected if they are combined together.
For instance, parallelization of the model with the [8] Nyström K, Aronsson P, Fritzson P. GridModelica - A modeling and simulation framework
TLM method can be combined with task merging in
for the grid Proceedings of SIMS conference,
the lower layer to achieve a coarse grained parallelizaCopenhagen, Denmark 2004.
tion at Modelica source level while achieving a more
fine grained parallelization at lower level.
[9] Engelson V, Fritzson P. A Distributed Simulation
To conclude, we think that while a modeling language
Environment Proceedings of SIMS 2002 conferperhaps not does not live or die with its parallelization
ence.
abilities, it is still important to develop parallelization
in order to make the Modelica language a serious com- [10] Joos H-D, Looye G, Moormann D. Design of
Robust Inversion Control Laws using Multipetitor to Fortran, C and C++ also when it comes to
Objective Optimization AIAA Guidance and
simulation of computationally demanding models.
Control Conference, Montreal, Canada, 2001.

8

Acknowledgement

[11] High Performance Fortran Forum High Performance Fortran Language Specification, version
This work was sponsored by Vinnova[19] via the
1.0 Houston, Texas, 1993
GridModelica[5] project.
[12] Yi-Ling F. Chiang, Ji-Suing Ma, Kuo-Lin Hu and
Chia-Yo Chang Parallel multischeme computation Journal of scientific computing, 3(3):289References
306, 1988
[1] Aronsson P., Fritzson P. , Task Merging and
Replication using Graph Rewriting, Tenth In- [13] Gilbert C. Sih and Edward A. Lee Declustering: A new multiprocessor scheduling technique
ternational Workshop on Compilers for Parallel
IEEE Transactions on Parallel and Distributed
Computers, Amsterdam, the Netherlands, Jan 8Systems, 4(6):625-637, June 1993
10, 2003
[2] Aronsson P., Fritzson P. Clustering and Schedul- [14] Andersson Niklas Compilation of Mathematical Models to Parallel code Licenciate thesis,
ing of Simulation Code Generated from EquaLinköping University, 1996
tion Based Simulation Languages 9th Workshop
on Compilers for Parallel Computers, CPC 2001, [15] The
OpenModelica
project.
June 27-29, Edinburgh, Scotland, UK
http://www.ida.liu.se/
pelab/
modelica/OpenModelica.html
[3] Aronsson P. Fritzson P. A Task Merging Technique for Parallelization of Modelica Models [16] The
Modelica
Association.
Modelica conference 2005, Hamburg, Germany
http://www.modelica.org.
2005.
[17] Fritzson P, Aronsson O, Bunus P, Engelson V, Jo[4] Schiela A. Olsson H. Mixed-mode Integration for
hansson H, Karström A, Saldamli L. The Open
Real-time Simulation Proceedings of the ModelSource Modelica Project. In Proceedings of the
ica Workshop 2000, pp 69-75.
2nd International Modelica Conference, Munich
Germany, 18-19 2002.
[5] The
GridModelica
project,
http://www.ida.liu.se/labs/pelab/modelica/
[18] Fritzson P. Principles of Object-Oriented ModGridModelica.html, accessed 2004-12-06.
eling and Simulation with Modelica 2.1. WileyIEEE Press, 2004.
[6] Christopoulos C. , The Transmission Line Modeling Method, EEE/OUP Series on Electromag- [19] Vinnova http://www.vinnova.se
netic Wave Theory, 1995

The Modelica Association

172

Modelica 2005, March 7-8, 2005

A Simulation Management Enviroment for Dymola

A Simulation Management Environment for Dymola
Sven-Erik Pohl∗ Jörg Ungethüm†
German Aerospace Center (DLR), Institute of Vehicle Concepts
Pfaffenwaldring 38-40, 70569 Stuttgart

Abstract

necessary to apply versioning not only to the Modelica libraries but also to any auxiliary files like pre- and
postprocessing scripts, which are necessary to run the
simulation. The ability for recovering the model and
rerun the simulation is sensible against the completeness and version-correctness of these auxiliary files.
Multiple simulation projects must be supported, even
if libraries or scripts are used and developed concurrently. Another objective is a clear and informative
simulation report which includes version information
as well as simulation results.

Building Modelica libraries is a steady process of
adding and refining models. There is rarely a final
version of a library. This leads to the fact that simulation results are difficult to reproduce due to changes
in sub-models. However, reproducible simulation results have to be provided for solid project work and
scientific research. Using Matlab as a platform a simulation management environment, called SiME, was
developed. This environment includes general simulation handling, as well as tools for pre- and postprocessing. A HTML-based simulation history contain3 Design
ing parameters and results is included.
Keywords: Modelica tools, simulation management,
The simulation management environment tends to beMatlab, CVS
come a very complex system, as various different
components are needed to reproduce simulation results. Besides the core model code, parameter lists,
1 Introduction
measured data, experiment scripts, documentation and
Developing Modelica libraries while at the same time other auxiliary files must be stored and recreated. Formaintaining several complex models can make back- mat, size or number of these auxiliary files is not
ward compatibility difficult. Moreover, keeping spe- known in advance. Nonetheless, reliability is major
cific library versions is especially important if simula- concern for the simulation management environment.
tion results were published in research reports or sci- However, a substantial ambition in the design process
entific publications. A common practice in software was a straight and simple realization. Therefore, the
engineering, a version control system appears to be an Concurrent Versions System (CVS) [1] was employed
adequate solution to manage the code evolution. How- as base layer. CVS uses a client/server architecture,
ever, if several libraries are involved in the simulation which makes it easy to install and maintain. SiME itkeeping track of the files becomes tedious. Addition- self consists only of client side scripts and does not really, linking the versions with the results has to be done quire any additional server software. Therefore SiME
can be used with any CVS server. Due to the use of a
manually.
standard version control system, any file within SiME
is accessible using standard tools. Furthermore, con2 Objectives
current access using SiME and standard CVS clients
is seamlessly possible. The following code fragment
A simulation management environment was outlined shows the Matlab call of the CVS client.
to overcome this shortages. The central idea is to automate and standardize the versioning process. It is syscmd=[cvsbin_name,’ ’,cvsopt_str,’ ’,...
∗ sven.pohl@dlr.de
† joerg.ungethuem@dlr.de

The Modelica Association

cvscmd, ’ ’,cmdopt_str,’ ’];
for i = 1:length(cmdargv)
cmdarg_str = deblank(cmdargv{i});

173

Modelica 2005, March 7-8, 2005

S.E. Pohl, J. Ungethüm

Figure 1: Automatically created simulation overview html-page

step the complete simulation run can be repeated simply using the simulation ID.

cmdlen=length(syscmd)+length(cmdarg_str);
[rcc,mesg]=system([syscmd,cmdarg_str]);
end

4.1
The CVS command part is defined by syscmd while
the files to processed are bundled in cmdargv.
The core of SiME consists of a few scripts written in
Matlab. Dymola’s simulation results are easily accessible within Matlab. Matlab’s numerical capabilities
are outstanding and within SiME all of its features,
e.g. the data visualization tools are applicable. However, Matlab is not optimal for string processing and
system command execution. Dedicated scripting languages like python and Perl are much more comfortable in this context.

Initialization

During initialization a unique simulation ID is generated and a complete list of all files which are relevant
for the simulation is built. Matlab script dependencies
are collected automatically. However, Modelica and
auxiliary files must be added manually. SiME forces
any file on the list under version control if this was not
done before:
for element=1:counter
[err,errmsg]= fkcvsadd(’’,...
cmdopt,notinrepository(counter));
end;

Afterwards the files are checked in and tagged using
the simulation ID. In that way all files involved in the
simulation process are marked with the simulation ID
The basic concept of SiME is to organize arbitrary and can be retrieved securely. This code fragment ilsimulation tasks in projects. Each project consists of lustrates the process of committing and tagging:
a history of completely reproducible simulation runs. for i=1:filenum
For example, a project named ”hybridcar” is a Mod% commit files
cmdopt.m = [’automated commit’];
elica library development of a hybrid electric vehi[err.commit(i),errmsg.commit{i,1}]=...
cle. The developer uses SiME to protocol the developfkcvscommit(’’,cmdopt, ...
ing process and to document the evolution steps. It’s
remainder(startpos(i):endpos(i)));
not only possible to directly compare the results but
% tag files
[err.tag(i),errmsg.tag{i,1}]=...
also to retrieve the complete simulation code, to make
fkcvstag(tag,’’,’’, ...
changes if necessary and to re-run the simulation.
remainder(startpos(i):endpos(i)));
The Simulation Management Environment splits each end;
simulation process into four steps. The initialization
part sets up the simulation run and calls the CVS rou4.2 Preprocessing
tines. Preprocessing, simulation and postprocessing
mainly contain code to handle the simulation applica- The initialization routine calls the main simulation
tion (e.g. Dymola) and its results. In a possible fifth script. From this Matlab script the external simulation

4

Features

The Modelica Association

174

Modelica 2005, March 7-8, 2005

A Simulation Management Enviroment for Dymola

Figure 2: Automatically created simulation report html-page

sim.model,ex,sim.modelname);
application is started. Generally, any application using
the Dynamic Data Exchange (DDE) interface can be end;
called remotely. In this case Dymola is used. In the % Close Dymola
dymoexit;
preprocessing part the Dymola model and the model
parameters are defined. For parameter studies an array
of values for each parameter can be provided. A parameter matrix is then built from the parameter arrays. 4.4 Postprocessing

Subsequent to the simulation process arbitrary Matlab
scripts can be run to further process the results, e.g. to
Dynasim provides Matlab functions to start Dymola generate plots.
and execute commands via DDE interface. These A standardized protocol in HTML is generated includfunctions are used to establish an interaction between ing the history of simulation tasks. An example of
Matlab and Dymola. The self explanatory code is this simulation overview is shown in Figure 1. For evshown below:
ery simulation task a link to a HTML report is given.

4.3

Simulation

% Set up experiment
ex=dymoexperiment; % default values ex
ex.StopTime = 0.1; % set StopTime
% Start Dymola
res.start = dymostart(sim.dymolabinpath);
% Load Package
res.load = dymoload(sim.package);
% Check Model
res.check = dymocheck(sim.model);
% Translate Model
res.translate = dymotranslate(sim.model);
for num = 1:sim.parmatrixsize
% Set parameter(s)
dymosetpar(sim,num);
% Simulate Model
res.simulate = dymosimulate(...

The Modelica Association

The HTML report (Figure 2) includes in detail all the
parameters used within initialization, preprocessing,
simulation process and hyperlinks to the saved plots.
Additionally, a summary of all error messages and
comments occurred during the runtime is given.

4.5

Re-Run Simulations

To retrieve the complete set of simulation files only the
simulation ID is needed. A MATLAB function will
retrieve the files from the repository. The files are now
ready for manipulation and a new simulation run can
be started.
175

Modelica 2005, March 7-8, 2005

S.E. Pohl, J. Ungethüm

Figure 3: The SiME graphical user interface

5

Graphical User Interface

Some additional Dymola scripting language commands would be desirable, e.g. retrieving a list of all
To coordinate the projects and their history a graphi- Modelica files which are referenced by a model or gencal user interface is added. Figure 3 shows the main erating a screen-shot of the current diagram window.
interface window. Projects can be loaded, created and
managed. General information, e.g. directories and
project details, can be edited. The simulation his- 7 Conclusions
tory of projects can be browsed and simulation reA simulation management environment (SiME) was
sults displayed. New simulation runs can be tested or
developed to provide easy and efficient access to earlaunched. Dymola result files can be browsed using
lier simulation runs. SiME ensures the reproducibility
the Matlab GUI provided by Dynasim.
of simulation results, even if the models involved are
still in development. This facilitates the documentation, avoids redundant work and is an important con6 Limitations
tribution for quality assurance.
SiME inherits the limitations of the CVS system. E.g. SiME uses Matlab as scripting language, since Matlab
the handling of binary files like pictures is not optimal is used frequently already for pre- and postprocessing.
and reordering of directory structures is difficult and As backbone server for SiME the Concurrent Versions
error prone.
System (CVS) was selected, since it is freely available
Most of the CVS limitations are overcome by its suc- and extremely reliable. The use of the models outside
cessor, the Subversion [2] system. Subversion reached of the simulation management is not restricted, so that
release 1.0 in March 2004. Currently little practical the normal, CVS supported model development is not
experiences with Subversion are present. However, as disturbed.
Subversion is downwards compatible to CVS, switching to Subversion should be possible.
Absolute directory path references might be included References
in the model code, like script references in Dymola’s
[1] Version Management with CVS. Per Cederqvist.
annotations. These path references become staled
https://www.cvshome.org/docs/manual/
links in the recreated files which cannot be fixed easily.
The Matlab–Dymola communication uses Dymola as [2] Version Control with Subversion. Ben CollinsSussmann, Brian W. Fitzpatrick, C. Michael
DDE server which is available on MS Windows only.
Pilato. http://svnbook.red-bean.com/en/1.1/svnThis prevents the SiME client currently from working
book.pdf
on any other operation system.
The Modelica Association

176

Modelica 2005, March 7-8, 2005

Meta-modelling of Mechanical Systems with Transmission Line Joints in Modelica

Meta-modelling of Mechanical Systems with Transmission Line
Joints in Modelica
Alexander Siemers Iakov Nakhimovski Dag Fritzson
Linköping University, Linköping, Sweden
SKF, Göteborg, Sweden

Abstract
A framework for meta-modelling with Transmission
Line (TLM) joints is presented. The framework is intended to support transient simulations of mechanical
systems using co-simulation of different tools. The expressive power of the Modelica language is used to
describe the meta-model in an easy to understand, object oriented way. A ModelicaXML based translator is
used to convert Modelica code to an XML document
which is accepted as input by the co-simulation engine. The framework prototype for SKF’s BEAST and
MSC.ADAMS is presented here. It is designed to be
general, so that support for other simulation tools can
be easily added. The main focus is on modelling of
co-simulation Meta-Models taking advantage of Modelicas graphical and object-oriented modelling capabilities.
Keywords:
simulation; co-simulation; metamodelling; multibody; TLM; XML

1

Motivation

In the area of modelling and simulation of mechanical systems one can identify many different classes of
models and corresponding tools. The specialization
leads to different focus for different tools. One might
say that every tool is optimized for a certain kind of
problems. In terms of meta-modelling every tool can
be seen as a black-box handling a particular component. A component is a model defined in some specific language together with some modelling and simulation tool that can perform a transient simulation of
it. The examples of such components are equationbased multi-physics Modelica models, general multibody models in MSC.ADAMS, models with detailed
contact definitions in SKF’s BEAST, flexible components as modelled in FE tools, etc. .
In reality the different components are dependent on
each other. Two components that are in physical inThe Modelica Association

teraction form boundary conditions for each other and
some interface can often be defined.
Unfortunately it is often the case that the different
classes of tools are used independently. Every class of
tools is using approximations of the components it has
interface with, that is, simplified models of the boundary conditions. Several time consuming iterations are
often necessary to make the components converge to
similar values on on the common interface. The limitations on the modelling accuracy are thus fundamental.
The need to bring different components into a complete more tightly coupled simulation is therefore justified. This allows higher accuracy and preserve the
investments in the components.
Different co-simulation systems have appeared on the
market during the last years. Most of them are focused
on co-simulation of control systems and corresponding mechanical component. The coupled simulations
this paper is focusing on are different. All components in our framework are mechanical and they have
forces and motion in the interfaces. What is more important from numerical point of view, the sub-models
are likely to use different differential equation solvers
with variable time step. Numerical stability, which is
not an issue for discrete time simulations, becomes an
important consideration.
One method that was earlier used to enable closer interaction between such sub-models in a coupled simulation is transmission lines modelling (TLM). The
TLM uses physically motivated time delays to separate the components in time and enable efficient cosimulation. The technique has proven to be stable and
was implemented for coupling of hydraulical and mechanical sub-systems [1], [2].
However, no attempt to design a general coupled simulations framework was done. In this paper a general
approach to meta-modelling of mechanical systems
using TLM is presented. Modelica language is used
to make such models easy to manage and the frame-

177

Modelica 2005, March 7-8, 2005

A. Siemers, I. Nakhimovski, D. Fritzson

c2
v1

3 Simulation Framework
v2

F1

F2
c1

Figure 1: Delay line with the passing wave variables
c1 and c2 and velocity variables v1 and v2 .

work is designed to enable simple extension with new
simulation tools.

2

Transmission Line Modelling

TLM method, also called Bilateral Delay Line
Method, exploits the fact that all physical interactions
in nature have finite propagation speed. The properties
of the delay lines were studied in [7]. The method is
briefly described below.
A basic one-dimensional transmission line is shown in
Figure 1. For the mechanical case the line is basically a
long spring with force waves c1 and c2 going between
it ends. The input disturbances are velocities v 1 and v2
and the reaction forces from the transmission line F1
and F2 .
Note that the spring in our implementation is assumed
to be iso-elastic. That is no cross-term waves are generated when working in 2D and 3D. See [2] for further
discussions.
If the line delay is set to T and its impedance to Zc
then the govering equations are:
c1 (t) = F2 (t − T ) + Zc v2 (t − T )
c2 (t) = F1 (t − T ) + Zc v1 (t − T )

The design goals for the simulation part of the framework were portability, simplicity to incorporate new
simulation tools, computational efficiency. The design goals were realized by defining following concepts and interfaces:
TLM interface. A named point on a mechanical object where position and velocity can be evaluated and
reaction force applied.
TLM manager. The central simulation engine. It is a
stand alone program that reads in a XML definition of
the coupled simulation. It then starts Simulation components and provides the communication bridge between the running simulations. That is the components
only communicate with the TLM manager which acts
as a broker marshalling information between the components as required by TLM theory. TLM manager
sees every simulation component as a black box having one or several TLM interfaces. The information
is then forwarded between TLM interfaces belonging
different components.
TLM plug-in. A small C + + library having a single
abstract class representing TLM interface for a specific simulation tool. The TLM plug-in can be seen by
a simulation component as an external force that depends on position, velocity and time. The implementation of the plug-in handles the necessary communications with TLM manager.
Simulation component. Any simulation program that
has incorporated TLM plug-in as a part of its model.
A small script that takes the general parameters as input and starts the specific component is an additional
requirement. This intermediate step is necessary since
TLM manager needs a common way to start all the
components and each tool might have some specific
start procedures.

(1)
F1 (t) = Zc v1 (t) + c1 (t)
F2 (t) = Zc v2 (t) + c2 (t)

4 Modelica as Meta-Model Language

The equations show that the two simulation systems
are decoupled with the delay time T . Simulation
framework can utilize this decoupling to enable efficient communications during co-simulation.
The transmission line introduces a parasitic mass
mtlm = Zc T and stiffness ktlm = Zc/T . Since it is often necessary to have a relatively large delay time (to
enable larger communication intervals) while keeping
the stiffness value, the user needs to be aware of the
large parasitic mass.
The Modelica Association

Simulations of complete systems where components
are modeled and simulated in different simulation
packages are called co-simulations. The model of a
co-simulation including all system components and its
inter connections we call a meta-model.
The extended markup language (XML) has its strength
in textual data representation and conversion. It is often the language of choice for communicating information between different tools. Those were the reasons behind the decision to use it as the input to the
simulation engine.

178

Modelica 2005, March 7-8, 2005

Meta-modelling of Mechanical Systems with Transmission Line Joints in Modelica

Readability and edit-ability, on the other hand, are not
the strengths of XML. Design of co-simulation metamodels requires thus a more powerful modelling language or graphical modelling environment. The following requirements were defined for meta-model definitions:
• Meta-Models should be based on a standard language.
• A graphical model editor should be available for
ease of use.
Modelica with its object oriented modelling capabilities and its standardized graphical notations is thus
perfectly suited. The fact that the Modelica standard
defines graphical notations results in the availability
of graphical model editors, i.e., MathModelica [5] and
Dymola [4]. These editors typically allow easy connection modelling and user interface driven class design.
It should be mentioned that only Modelicas modelling
capabilities are of interest here. Meaning that there is
no need for Modelica based simulations. The use of
Modelica as meta-modelling language might as well
simplify the integration of Modelica simulations into Figure 2: The basic TLM Meta-Model class library.
meta-model based co-simulations. This, however, is
not within the scope of this work.
They add a certain number of TLM interfaces to each
component. TLM connections define data exchange
and synchronization between these components dur4.1 Meta-Model Class Library
ing co-simulation. Connections are created between
A meta-model Modelica package for component and two TLM interfaces of two TLM components. TLM
TLM connection modelling, using Modelicas object interfaces are therefore defined as connectors.
oriented features, has been designed.
Several base classes define common model parameters
Three packages plus a base model class were defined: needed by the TLM manager or for correct XML translation. Specialized child classes modify these paramThe Components package contains classes for the eters to their needs. BEAST Components for example
different simulation components. These are cur- modify the start-method as follows:
rently BEAST and MSC.Adams components.
The Connections package contains the TLM connection or joint. Different TLM specific parameters can be specified for each connection.

model BaseComponent
parameter String Description;
parameter String SimulationFiles;
parameter String StartMethod;
.
.
end BaseComponent;

The Interfaces package contains the corresponding
TLM interface. Each TLM component contains
at least one TLM interface.
model BeastComponent

extends BaseComponent

The BaseMetaModel class is the base class for each (StartMethod="beast --serial");
Meta-Model. It contains Meta-Model specific pa.
rameters.
.
end BeastComponent;

Different TLM components are defined in the components package which are inherited from the sim- Both component and interface classes contain a type
ulation tool specific components, see also Figure 2. specifier which is TLM for TLM components and TLM
The Modelica Association

179

Modelica 2005, March 7-8, 2005

A. Siemers, I. Nakhimovski, D. Fritzson

interfaces. This allows for additional type checking
during model translation and guarantees that TLM interfaces are connected with TLM connections. But is
also useful for future extensions with new connection
types.

4.2

added. This allows for other extensions as well, e.g.,
selecting appropriate component icons for more intuitive modelling, see Figure 3. New components should
be added to the UserComponents package in the MetaModel library. This is needed for the XML translator
to work properly.

Component Modelling
4.3 Meta Modelling

Component modelling is divided into two steps:
• Component modelling in the specialized environment. Each component of the multi-scale simulation is modeled in its specific environment. Users
define the TLM interfaces to the model.

Meta-Models are created using a graphical Modelica
editor, see Figure 4, where components are dragged
into the model. Every Meta-Model must extend the
BaseMetaModel class that contains Meta-Model
and co-simulation specific parameters. TLM compo• Component modelling in the multi-scale environnents and connections are added to the model and conment. The component needs to be integrated into
nections are drawn between the TLM interfaces.
the multi-scale environment. Startup methods,
interfaces, and communication parameters must
be specified.

Co-simulation components are modelled in the modelling environment of the specific simulation tool. To
participate in a TLM co-simulation each simulation
program needs to integrate an TLM plug-in and a way
to model TLM interfaces. In MSC.ADAMS for example external forces are connected to a TLM interface,
and BEAST defines so called TLM-ties. The TLM
interfaces are thus part of the simulation model expressed in the modelling language of the specific program.
Simulation components are integrated into the metamodel by selecting a matching component from the
Modelica Meta-model library. Component type and
number of TLM interfaces have to match.
Figure 4: A simple BEAST-MSC.ADAMS MetaModel.

Figure 3: A MSC.ADAMS car simulation component
in the Modelica environment with four TLM interfaces
at the front tire.
Alternatively can the base components, i.e., BeastComponent and AdamsComponent, be extended (inherited) and a certain number of TLM interfaces be
The Modelica Association

Several parameters need to be specified for the different parts of the model. They are needed by the TLM
manager for correct simulation execution. BEAST and
MSC.ADAMS components, for example, need a simulation file to be specified, see Figure 5, and TLM connections require correct TLM parameters.
The meta-model description is kept general and works
with any simulation tool that supports TLM connections. New components can be created by extending the BaseComponent class or any of the predefined
component classes. Only the start-method for the simulation tool needs to be specified for new components.
Predefined components can be extended if more TLM
interfaces are required. The number of required TLM
interfaces is application and simulation-model dependent.

180

Modelica 2005, March 7-8, 2005

Meta-modelling of Mechanical Systems with Transmission Line Joints in Modelica

Figure 5: The BEAST component parameter dialog.

4.4

Meta-Model Translation

The meta-model is translated into XML code to run
in the co-simulation framework. A Modelica to XML
translator has been designed for this purpose. The Figure 6: Modelica Meta-Model detailed BEAST hub
translator makes use of ModelicaXML [3] plus some unit integrated into a MSC.ADAMS racing-car model.
co-simulation specific translations. The translation is
done in two steps:
1. Translation from Modelica to ModelicaXML
2. Translation from ModelicaXML to the MetaModel XML representation
To simplify parsing of the Modelica Meta-Model it is
first translated into a Modelica-XML representation
using the ModelicaXML [3] translator. This representation can be parsed and translated with a standard
XML-parser. The libXML2 [6] standard library has
been used to convert the ModelicaXML Meta-Model
into the XML representation required by the TLM
manager.

4.5

Meta-Model Example

An typical example of a BEAST-MSC.ADAMS MetaModel is shown in Figure 6. A front wheel bearing hub-unit is connected to the race-car with four
flanges each of which is modelled as a TLM connection. The components have to be prepared in BEAST
and MSC.ADAMS to contain the TLM interfaces. Afterwards they are integrated into the meta-model environment by creating component classes with appropriate icons and TLM interfaces in the Modelica package.
Each Meta-Model needs to extend the BaseMetaModel
Modelica class to inherit the global co-simulation parameters. TLM connections are added between the
TLM interfaces according to the hub-unit flanges. The
complete Modelica model looks like this:
The Modelica Association

model BeastHubInAdamsCar
extends MetaModel.BaseMetaModel;
MetaModel.UserComponents.BeastCarCorner
BeastHubUnit(
Description=
"A complete Beast hub-unit",
SimulationFiles="CarCorner.in",
StartMethod="start-beast");
MetaModel.UserComponents.AdamsCarModel
AdamsCar(
Description="A MSC.ADAMS car model",
SimulationFiles="racing_car.cmd");
MetaModel.Connections.TLMConnection TLM1;
MetaModel.Connections.TLMConnection TLM2;
MetaModel.Connections.TLMConnection TLM3;
MetaModel.Connections.TLMConnection TLM4;
equation
connect(AdamsCar.p1,
TLMConnection1.p1);
connect(AdamsCar.p2,
TLMConnection2.p1);
connect(AdamsCar.p3,
TLMConnection3.p1);
connect(TLMConnection1.p2,
BeastHubUnit.p1);
connect(TLMConnection2.p2,
BeastHubUnit.p2);
connect(TLMConnection3.p2,
BeastHubUnit.p3);
connect(TLMConnection4.p2,
BeastHubUnit.p4);
connect(AdamsCar.p4,
TLMConnection4.p1);
end BeastHubInAdamsCar;

181

Modelica 2005, March 7-8, 2005

A. Siemers, I. Nakhimovski, D. Fritzson

Finally the model is converted into the XML repre- 5 Conclusion
sentation required by the TLM manager by first converting it into ModelicaXML and then into the XML A framework for meta-modelling and simulation of
Meta-Model representation. The XML model looks mechanical systems using transmission lines for coulike this:
pling components was presented. The main features of
the framework are:
<?xml version="1.0"?>
<Model name="BeastHubInAdamsCar"
StartTime="0"
EndTime="1"
TLMDelay="0.001">
<SubModels>
<SubModel Name="BeastHubUnit"
Description=
"A complete Beast hub-unit"
SimulationFiles="CarCorner.in"
StartMethod="start-beast">
<InterfacePoint Name="p1"
iType="TLM"/>
<InterfacePoint Name="p2"
iType="TLM"/>
<InterfacePoint Name="p3"
iType="TLM"/>
<InterfacePoint Name="p4"
iType="TLM"/>
</SubModel>
<SubModel Name="AdamsCar"
Description=
"A MSC.ADAMS car model"
SimulationFiles="racing_car.cmd"
StartMethod="start-adams">
<InterfacePoint Name="p1"
iType="TLM"/>
<InterfacePoint Name="p2"
iType="TLM"/>
<InterfacePoint Name="p3"
iType="TLM"/>
<InterfacePoint Name="p4"
iType="TLM"/>
</SubModel>
</SubModels>

• General object-oriented meta-modelling utilizing
the strengths of Modelica
• Stability by applying minimalist approach to the
program design resulting in small portable code
• Extensibility of the framework thanks to the
portable and easy to incorporate software plugin.
The framework currently targets SKF’s BEAST simulation tool and MSC.ADAMS.

References

[2] Krus P. Modelling of Mechanical Systems Using Rigid Bodies and Transmission Line Joints.
Transactions of ASME, Journal of Dynamic Systems Measurement and Control. Dec 1999
[3] Pop A., Fritzson P. ModelicaXML:A Modelica
XML Representation with Applications, Modelica 2003 Conference
[4] Dymola, http://www.dymola.com, Dynasim AB
[5] MathModelica,
http://www.mathcore.com/products/mathmodelica
Mathcore AB
[6] The XML C parser and toolkit of Gnome,
http://www.xmlsoft.org/

<Connections>
<Connection From="AdamsCar.p1"
To="BeastHubUnit.p1"
iType="TLM" alpha="0" Zf="0"/>
<Connection From="AdamsCar.p2"
To="BeastHubUnit.p2"
iType="TLM" alpha="0" Zf="0"/>
<Connection From="AdamsCar.p3"
To="BeastHubUnit.p3"
iType="TLM" alpha="0" Zf="0"/>
<Connection From="BeastHubUnit.p4"
To="AdamsCar.p4"
iType="TLM" alpha="0" Zf="0"/>
</Connections>
</Model>

The Modelica Association

[1] Krus P., Jansson A. Distributed Simulation of
Hydromechanical Systems ’Third Bath International Fluid Power Workshop’, Bath, UK 1990

[7] Larsson, J. Interoperability in Modelling and
Simulation, PhD thesis, Linköping University,
Linköping, Sweden, 2003

182

Modelica 2005, March 7-8, 2005

Session 3a
Automotive Simulation I

The Modelica Association

183

Modelica 2005, March 7-8, 2005

The Modelica Association

184

Modelica 2005, March 7-8, 2005

AirConditioning - a Modelica Library for Dynamic Simulation of AC Systems

AirConditioning –
a Modelica Library for Dynamic Simulation of AC Systems
Hubertus Tummescheit†

Jonas Eborn†

Katrin Prölß‡

† Modelon AB, Ideon Science Park, SE-223 70 Lund, Sweden
‡ TU Hamburg–Harburg, Department of Thermodynamics, Denickestr. 17, D-21073 Hamburg, Germany

Abstract

Temperature:

350

Ref Wall Air

Quality

1

The AirConditioning library is a new, commercial
Modelica library for the steady-state and transient
simulation of air conditioning systems using modern, compact heat exchangers that use microchannel
tubes instead of the bulkier fin-and-tube type heat ex0
changers. Currently it is mostly used by automotive 320
OEMs and suppliers that need high-accuracy system
level models to ensure both passenger comfort and en- Figure 1: Examples of dynamic diagrams: spatial
ergy efficiency of systems developed under the pres- plot of condenser temperatures and ph-diagram for a
sure of reduced design cycle times. The AirCondi- R134a cycle.
tioning library contains basic correlations for heat and
mass transfer and pressure drop, components for condynamic and steady-state design computations,
trol volumes and flow resistances and advanced readyeliminating the need for multiple platforms and
to-use models for all relevant components of automomodels. Significant improvements to the steadytive air conditioning systems like condenser, evaporastate solvers in Dymola combined with model imtor, compressor, expansion devices and accumulator.
provements have resulted in reliable steady-state
initializations that can be used for design optimization.
1 Introduction
The AirConditioning library has been derived from the Re-designed user interface The user interface improvements make full use of recent Dymola feaModelica library ThermoFluid [1, 2] and the ACLib litures: structured dialogs using hierachy, tabs
brary [11], with considerable enhancements in particand groups where appropriate, illustrations linked
ular of the useability and robustness. Most of the funinto the dialogs for explanation of the parameter
damental design ideas outlined in [1, 2] are still valid,
meaning and use of interactive elements for direct
but a number of useability-oriented design improveuser feedback during simulation runs.
ments have been made also with respect to the specializations for AC-cycles described in [11]. Compared to
ThermoFluid, also simplifications of the library struc- Dynamic process diagrams The UserInteraction library by Dynasim has been used to create dyture have been made due to the reduced spectrum of
namic interface elements for AC applications:
applications. The most important differences are:
spatial plots of temperatures or heat transfer coefSteady-state capabilities Traditionally, AC system
ficents and instantaneous corner points of the relevel models are only used as steady-state modfrigerant cycle ph-diagram, as shown in Figure 1.
els, with the exception of very simplistic, often
linear models for control design. ThermoFluid New two-phase dynamic state model The
inteprovided accurate dynamic models, but could
grated mean-density model has been introduced
not be used for steady-state tasks. AirCondifor two-phase flow and greatly reduces the risk
tioning bridges that gap and is suited both for
of discretization-triggered flow oscillations.
The Modelica Association

185

Modelica 2005, March 7-8, 2005

J. Eborn, H. Tummescheit, K. Prölß

Apart from the robustness benefit it is also
a reduced-order dynamic model that doesn’t
sacrifice accuracy, but rather allows the same or
better accuracy with fewer dynamic states.
Many AC component models A number of new,
specialized AC-component models have been
added, e.g. internal heat exchanger, condenser
with integrated receiver, short orifice tube, and
many more.
Compressor models Two formulations for the compressor efficiencies have been developed: one is
for the case of full-load measurement data only,
reported in [4], the other computes also efficiencies for varying swash-plate angle inputs [3].
Optional model encryption Dynasim has developed
a novel approach to model encryption that makes
use of symbolic pre-processing of the model code
before the actual encryption, called “scrambling”.
Most critical data is irretrievably removed from
the model code even before proper encryption by
evaluating all given parameters. The new method
allows to selectively hide or reveal model features, giving the user full control over available
model parameters and outputs. The symbolic
evaluation of parameter expressions before code
generation masks geometry information in a way
that it is impossible to retrieve it even from the
generated C-code.

1.1 Standard for model exchange
Dymola and the AirConditioning library was chosen
by a group of German OEMs after a benchmark comparing it with other potential tools. During 2004, the
tool was tested by the OEMs [9] and many of their suppliers, and then chosen as a common tool for model
exchange between suppliers and OEMs. The benchmark and testing process has contributed to continued
improvements of the library regarding the componentoriented requirements from suppliers and the systemoriented requirements of OEMs.

2

Heat exchanger models

In automotive refrigeration cycles heat is absorbed at
the low temperature level of the cabin air or at ambient temperature and rejected at the discharge level of
the ambient. For heat transfer between air and working fluid a condenser/gas cooler on the high pressure
The Modelica Association

level and an evaporator on the low pressure level are
used, exploiting the low heat transfer resistance of the
two-phase refrigerant. In some, mainly R744, applications, an internal refrigerant-to-refrigerant heat exchanger which transfers heat from one pressure level
to the other enhances the performance of the cycle.
Most heat exchanger types currently used in automotive air conditioning systems are represented by the library models or they can be developed from subcomponents.

2.1

Refrigerant side models

The fluid flow on the refrigerant side is based on
dynamic control volume models that are different
than the standard finite volume model found in ThermoFluid [1, 2]. The AirConditioning library uses from
version 1.1 a new control volume that is similar to the
one used in the ThermoPower library [5]. The main
difference is that it is based on the computation of the
mean density, ρ̄, found by integrating over enthalpy
along the flow, assuming constant pressure and taking
into account the location of the phase boundaries (h pb ),
ρ̄ =

Z h2
h1

ρ(p, h)dh =

Z h pb
h1

ρ(h)dh +

Z h2
h pb

ρ(h)dh (1)

With different inlet and outlet conditions and over the
two boundaries, hliq and hvap , the integral splits up into
9 different cases, for which the analytic solution can be
derived. In the one-phase region a regular mean value
is used. Within the two-phase region the integral is
rewritten using the expressions for quality x and volumity, ν = 1/ρ, which are linear in enthalpy.
h − hliq
ν = x · νvap + (1 − x)νliq
hvap − hliq
Z h2
Z
hvap − hliq ν2
hvap − hliq ν2 1
dν =
ln
ρ(h)dh =
νvap − νliq ν1 ν
νvap − νliq ν1
h1
x=

The expressions are such that they are continuously
differentiable even across the phase boundaries. The
analytic derivatives of the mean density w.r.t. the inputs of the fluid property calculation have also been
derived and validated using the new automatic differentiation feature of Dymola [6].
Due to the magnitudes of temperature gradients and
pressure drops, a different parameterization than chosen by [5] has to be implemented for air conditioning systems: pressure drops have a larger influence
on the driving temperature difference and can not be
neglected. Another important feature of the refrigerant side models is to fully make use of the fact that

186

Modelica 2005, March 7-8, 2005

AirConditioning - a Modelica Library for Dynamic Simulation of AC Systems
Mean density [kg/m3]

9800

1200

800

Heat Flow Rate in W

1000
d_mean[1]
d_mean[2]
d_mean[3]
d_mean[4]
d_mean[5]
d_mean[6]

600
400
200
0

25

50

75

Tw o-phase fraction

1.2
tw oPhase[1]
tw oPhase[2]
tw oPhase[3]
tw oPhase[4]
tw oPhase[5]
tw oPhase[6]
tw oPhase_m

0.8

0.4

9600
9400
9200
9000
8800
analytic solution
finite volume method

8600
0

5

10

15

20

25

30

Number of Segments

0.0
0

25

50

Figure 3: Influence of air side discretization on total
transferred heat in a refrigerant condenser

75

Time [s]

Figure 2: Mean density and two-phase fraction in
a six segment pipe with R134a during a rapid transient starting in all liquid phase. Both properties are
smooth throughout the simulation, with the exception of dmean [1] and the overall two-phase fraction,
twoPhasem , that jump when the inlet enthalpy changes
at t=30s.
the phase boundary location is resolved continuously
within each finite volume and not just discretely for
each volume. Using the two-phase length fraction for
interpolation of all phase dependent correlations and
properties improves calculation accuracy vastly. An
added benefit is that the interpolation also makes variables such as heat transfer coefficient change continuously with time when the phase boundary moves from
one finite volume to the next.
The smooth results of the mean density model is illustrated in Figure 2 where the calculated mean density
and two-phase fraction of a refrigerant pipe is shown.
Heat transfer properties are interpolated with the individual two-phase fraction of each volume, while the
pressure loss model can use the overall two-phase fraction of the pipe. The pipe model with n = 6 will then
only have one dynamic pressure state but six enthalpy
states. This model is normally used for the refrigerant
side of a heat exchanger, where a six pass evaporator
with n = 3 will have six pressure states and eighteen
enthalpy states.

• discontinuous phenomena depending on condensing/ non-condensing conditions on cold surfaces and
• very short residence times of an air particle inside
the heat exchanger.
To accommodate for these features, two different models have been developed for the air side of compact automotive heat exchangers. One is a discretized finite
volume based model with steady-state mass- and energy balances for each volume, the other is a symbolic
solution of the outflow temperature found by applying
constant medium properties along the flow path. In
both cases the correlation for convective heat transfer
is used,
Q̇ = αA(Twall − T )

where Q̇ is the heat flow rate, α is the coefficient of
heat transfer, A is the surface area, T and Twall are
the temperature in the bulk flow and at the wall surface, respectively. The heat connector variables Q̇ and
Twall provide an interface to wall models. The computational burden of dynamic balances with an increased
number of dynamic states is avoided by using steadystate balances, which is justified by the short residence
time of the fluid.
Due to the sharp gradients and/or discontinuities on the
air side, the finite volume method requires a relatively
high discretization. If high accuracy is required, typically 10 – 15 elements are needed for the air passage1
2.2 Air side models
Figure 3 shows simulation results for the steady-state
Air side models in compact heat exchangers of air con- heat flow rate of a compact flat tube condenser of 2
ditioning systems are characterized by three features:
• sharp gradients along short flow paths,
The Modelica Association

1 For multi-layered heat exchangers this includes the sum of
elements for all layers, (air segments/layer)∗(number of layers).

187

Modelica 2005, March 7-8, 2005

J. Eborn, H. Tummescheit, K. Prölß

cm depth comparing the finite volume and the analytical approach. Air temperatures at inlet and outlet were
320 K and around 336 K, respectively.
A symbolic solution for the outlet state can only be
found if the water content of the air remains constant
along the flow path, which is only the case for very low
or zero inlet humidities or air heating. In the finite volume model, when the wall surface temperature drops
below the saturation temperature of the bulk flow, the
amount of condensing humidity will be determined by
applying a heat and mass transfer analogy approach.
Assuming a similarity in the shape of the temperature
boundary layer of a convective fluid flow and that of
the respective concentration boundary layer, the mass
transfer coefficient β can be determined from
β=

Le(m−1) α
ρc p

where Le is the Lewis number, α the coefficient of
heat transfer and with m = 1/3 valid for most applications [12]. The driving potential of water condensation is then formed by the water content in the bulk
flow X and that for saturation at surface temperature
Xsat (Twall ). Assuming the ideal gas law applies, the
condensate flow rate ṁw is computed from
ṁw = βρA(X − Xsat (Twall ))
with ρ as the bulk flow density. The model allows outlet humidities below 100% and water condensation at
the same time. The correct determination of the latent
heat is important, as it can make up around 50% of the
total transferred heat.
Heat transfer and pressure drop correlations for air side
specific geometries from the literature are part of the
library. Additional user correlations can be incorporated on the component top level by using replaceable
classes.

2.3 Air-refrigerant heat exchangers
Condensers/gas coolers and evaporators in automotive
refrigeration cycles are mostly of cross, cross-co or
cross-counter flow type and consist of louvered fins
and extruded microchannel flat tubes, both made of
aluminium, as schematically shown in Figure 4a).
The models in the library are composed of refrigerant and air cross flow elements with walls between the
two media [11]. Heat conduction in the solid material
in fluid flow direction is neglected. The dynamic behavior of the component is mainly influenced by the
amount and distribution of the solid wall material and
The Modelica Association

Figure 4: a) cross flow of air and refrigerant, b) 4pass condenser with horizontal refrigerant flow and a
refrigerant side discretization of 3 per pass
associated heat capacity. On both sides of the wall,
several parallel flow channels are lumped into one homogeneous flow for efficiency reasons. The refrigerant path through the component is treated as one pipe
flow with variable cross section and one air element
associated with each flow segment. Each air element
is further discretized or symbolically integrated along
its flow. Automatic coupling of air elements is made
according to the parameter-specified and component
type dependent 3D orientation, e.g. as the evaporator
shown in Figure 6 and to the user defined segmentation
of the refrigerant flow. Both parameters are merged
into a 3D-matrix, which defines the position of each
refrigerant segment with respect to a fixed coordinate
system. The condenser in Figure 4b) would yield a 2
by 2 by 3 matrix which is used for conditional connect statements of air inlets and outlets in the component. This approach allows for a wide variety of flow
paths and a 2D-interface for inhomogeneous air inlet.
However, the interface resolution is directly coupled
to the number of refrigerant passes through the heat
exchanger and their segmentation.

2.4

Internal heat exchangers

For systems using the refrigerant R744 (CO2 ) as the
cycle fluid, it is quite common to have an internal heat
exchanger between the high pressure side, after the

188

Modelica 2005, March 7-8, 2005

AirConditioning - a Modelica Library for Dynamic Simulation of AC Systems

Do_outer
Di_outer

d_fin

In the definitions above, p is the pressure, T temperature, V displacement volume, ρ density, h specific enthalpy, P power, ṁ mass flow and M the torque of the
compressor. In the subscripts d refers to the discharge
side, s to the suction side, is to isentropic conditions
and e f f to effective values.
In order to simplify the situation in early development
stages, the efficiency functions are factored into two
Di_inner
parts: one that captures the influence of the pressure
Do_inner
ratio and rotational speed, f (π, n) and another one that
takes into account the control of the swash plate anFigure 5: Cross section of tube-in-tube internal heat gle and rotational speed, g(x, n). Measurements of the
influence of the swash plate angle are not always availexchanger.
able, and due to this separation it is still possible to derive efficiencies for the full load case. A typical form
gascooler, and the low pressure side, between the ac- of the efficiency functions is given below.
cumulator and the compressor. The base classes for


 

the internal heat exchanger are identical to those for
pd /ps 2 x − x0
λe f f = π0 −
a2 n2 x + a1 nx + a0
the refrigerant side of flat tube heat exchangers.
π0 − 1
1 − x0
Currently used internal heat exchangers come in a
wide variety of geometries. Tube-in-tube type interηis = f (π, n) · g(x, n)
nal heat exchangers as in Figure 5 can be parametrized


directly from the geometrical data. For other types of
π0 − π
1 π0 − 1 π
− ab
f (π, n) = a
internal heat exchangers, the user has to compute paπ0
b π0
!

k
rameters like the hydraulic diameter and the heat transx−1
fer areas by hand.
g(x, n) =
1−
(c + 1 − b) x
x0 − 1

3

a = a(n) = a1 n + a0

Swash plate compressor model

b = b(n) = b3 n3 + b2 n2 + b1 n + b0

The compressor is modeled as a steady-state map that
relates suction- and discharge states and mass flow.
Due to the wide variety of mechanical constructions,
a simple parameterization of a swash-plate or swashring compressor has to be based on an extensive set of
measurements. The measurements are used to adapt
the free parameters of efficiency functions that are
chosen to have physically reasonable asymptotics for
high pressure ratios and low rotational speed. The
form of the functions is similar to the one presented in
[4], and varies slightly for different compressor types.
The compressor model uses three functions to characterize the compressor efficiencies, the volumetric efficiency λe f f , the effective isentropic efficiency ηe f f
and the isentropic efficiency ηis . The efficiencies are
defined as
λe f f
ηe f f
ηis

ṁe f f
=
V nρ(ps , Ts )
(hd,is − hs )ṁe f f
Pis
=
=
Pe f f
2π|M|n
hd,is − hs
=
hd − hs

The Modelica Association

c = c(n) = c1 n + c0
k = k(n) = k1 n + k0
The effective isentropic efficiency has the same functional form as the isentropic efficiency. Two of the
constants have physical significance, π0 is the upper
limit of the pressure ratio at which the discharge mass
flow decreases to 0. Similarly, x0 is the lower limit
of the relative displacement control signal where the
compressor does not discharge any more. The parameters ai , bi , ci and ki are free parameters that have to be
adapted to measurement data.

4

Expansion devices and valves

The library includes simple orifice and thermostatic
expansion valve (TXV) models. Several models of
these short flow restrictions are based on the computation of mass flow of compressible fluids as described
in DIN EN 60543-2-1, computing a flow coefficient Kv
in m3 /h. The model takes into account the choking of
flow above the critical pressure ratio. Simpler models

189

Modelica 2005, March 7-8, 2005

J. Eborn, H. Tummescheit, K. Prölß

with a constant ζ-parameter,
∆p =

350

|ṁ|ṁζ
2A2 ρ

and with quadratic scaling based on nominal parameters are also available. The TXV is based on the DIN
valve model, with a PI-controller with a suitable time
constant representing the bulb dynamics.

4.1

Short orifice tube
320

A geometrical model of a short orifice tube is also included according to the correlation in [7]. The orifice
tube model has been validated against measured data
from the reference with good results over a wide range
of operating conditions. The mass flow error is less
than 5-10% in all but extreme cases. For sub-cooled
conditions the liquid flow equation 2 is used, and for
fully choked flow equations 3-4 are used. Inbetween
these extremes the mass flow is interpolated based on
upstream quality.
q
2
ṁl = C1 Dtube
2ρl (p1 − p f )
(2)
r
π
M2κ
2
ṁc =
p1 Dtube
(3)
4
RT
Ltube
1 − M2 κ + 1
M 2 (κ + 1)
λ
=
+
log
(4)
Dtube
κM 2
2κ
2(1 + κ−1
)
2M 2

Figure 6: Parameter dialog for specifying evaporator
geometry parameters. Illustrations and explanations
provide help for the input fields and different parameters are grouped under tabs; General, Flat tube geometry and Louvered fin geometry.

example models using the library UserInteraction. Dynamic components include value displays showing e.g.
instantaneous temperature and transferred heat, spatial
plots showing temperatures, quality or other properties
along the refrigerant flow direction and ph-diagrams
In the equations above λ is the friction coefficent, κ
that illustrate the full refrigerant cycle behavior. Exis the ratio of specific heats and p1 is upstream presamples of dynamic diagrams are shown in Figure 1.
sure. The adjusted downstream pressure, p f , depends
on subcooling temperature, critical pressure and tube
dimensions [8]. Note that Equation 4 is an implicit
equation for the Mach number M. It is used exactly as 6 Initialization
quoted in the orifice tube model.
Robust steady-state initialization is critical for using
dynamic AC models also for steady-state applications
5 User interface
and system design optimization. From a tool and liThe library makes full use of recent Dymola features brary implementation viewpoint all of the pieces beto make the models easy to use. Component param- low are important to allow robust initialization.
eter dialogs are structured using tabs and grouping,
• Reduce the number of required input parameters
with appropriate text and graphical explanations. All
for initialization for distributed parameter sysnon-numerical input values can be selected from droptems, but still achieve convergence for reasonable
down menus and the lists of choices for correlation
input values. This has to be done in the library demodels and geometry records are automatically upsign, and it often requires that template 2 models
dated using the annotation choicesAllMatching. As an
are provided that reduce inputs for specific conexample, the geometry parameter dialog for a flat tube
figurations, including the boundary conditions.
evaporator is shown in Figure 6.
2 These are example models tailored for different applications
To further enable an easy understanding of simulation
results, dynamic diagrams have been integrated into in AirConditioning.
The Modelica Association

190

Modelica 2005, March 7-8, 2005

AirConditioning - a Modelica Library for Dynamic Simulation of AC Systems

n ref
total variables
dynamic states
iteration vars
Init time [s]

2
11132
38
301
3.3

4
21992
74
601
13.8

6
32852
110
901
34.4

10
54572
182
1501
113

require additional input parameters or outputs, these
have to be propagated explicitly to the top level by the
owner that exports the model and makes it available.
The method Encrypted save total consists of two distinct phases:
1. First, the model is pre-processed in a step called
scrambling, which flattens the model (removes
the composition hierarchy), evaluates all expressions in the model that can be evaluated,
and changes all variable names in the model
to generic ones. The evaluation of parameters
removes most sensitive parameters completely
from the model.

Table 1: Steady-state initialization times for different
discretizations of a six pass evaporator testbench from
AirConditioning 1.0 using Dymola 5.3b.
The remaining parameters should be those that
are typically measured for the device.
• Improvements of solver robustness in the simulation tool. Dymola recently introduced two new
features: a global homotopy method for the solution of large systems and much improved handling for scalar systems. Due to the tearing technique, scalar systems are much more frequent
than would be expected otherwise.

2. In a second step, the scrambled model is also
encrypted. In the user interface, the encrypted
model shows only the information needed to use
and run the model; connectors and public, toplevel parameters.

The unique advantage of the new encryption method
• Be aware of particular problem cases in the model is that sensitive information is irretrievably removed
equations and avoid them or rewrite them in a from the model in many cases. Consider e.g. the comway that is numerically easier to handle.
putation of a volume from parameters width, length
Using all these techniques, initialization problems and height: V = w ∗ l ∗ h. After scrambling, only the
with thousands of iteration variables are possible to value for V remains in the scrambled code. Obviously
solve with the current Dymola version. Results from it is impossible to back-calculate the original paramea computation benchmark are shown in Table 1.3 An ters from this information.
open point for even larger equation systems is to use
sparse methods also after symbolically tearing and reducing the size of initial equation systems.

7

Model encryption

To securely exchange accurate first principle based
simulation models without revealing proprietary data
to third party users, a careful balance has to be found
between two conflicting requirements:
• If the model information is completely hidden,
the model is similar to a black-box model and will
often not be of much use to the end user.
• If too many model details are revealed, many others can be reconstructed with little effort.

8

Transient simulation of automotive
systems

In the past, the influence of AC-systems on fuel consumption has been neglected by legislative bodies and
automotive manufacturers. This situation is currently
changing, and accurate fuel consumption estimates are
needed also for the case of a running AC unit. Figure 7 shows some of the key system parameters when
running a New European Driving Cycle (NEDC) that
contains an urban as well as an extra-urban section.
In [9], more results from simulating driving cycles using the AirConditioning library are presented. Models
from AirConditioning can be coupled directly to the
PowerTrain Modelica library [10] for fuel consumption calculation.

Encrypted save total models in Dymola keep only
the connector variables, top-level parameters and out9 Summary
puts visible to a user. By default, the new encryption
method hides as much data as is possible. If users AirConditioning is a comprehensive Modelica library
3 The benchmark was performed on a 3.2 GHz Pentium 4 with for the simulation of automotive air conditioning systems. AirConditioning contains models for current,
512 MB memory.
The Modelica Association

191

Modelica 2005, March 7-8, 2005

J. Eborn, H. Tummescheit, K. Prölß

of Functions in Modelica, In Proceedings of the 4th
International Modelica Conference, Hamburg, 2005.

7
6
5

[7] Singh, G.M., Hrnjak, P.S. and Bullard, C.W. Flow of
Refrigerant R134a through Orifice Tubes, HVAC &
Refrigeration Research, 7:3, pp. 245–262, July 2001.

4
Compressor Power [kW]
Evaporator Power [kW]
Condenser Power [kW]

3
2

[8] Kim, Y. and O’Neal, D.L. A Semi-Empirical Model
of Two-Phase Flow of Refrigerant-134a through
Short Orifice Tubes, Experimental & Thermal Fluid
Science, 9:4, pp. 426–435, 1994.

1
0
0

5

10

15

20

Figure 7: AC-system key parameters during NEDC
driving cycle. Condenser power is the top line, compressor power the bottom line.

[9] Limperich, D., Braun, M., Schmitz, G. and Prölß, K.
System Simulation of Automotive Refrigeration Cycles, In Proceedings of the 4th International Modelica
Conference, Hamburg, 2005.

R134a based systems as well as systems under development using R744. It has been chosen by a group of
automotive OEM and suppliers as a standardized tool
for exchanging models for automotive AC-systems.
Dynasim AB has added a new encryption method to
accommodate the exchange of models containing proprietary data. The refrigerant and air side models have
been adapted to cover the accuracy needed for component simulation and the flexibility and speed needed
for system simulation. AC components and systems
can be simulated in steady-state and dynamic conditions, and the models can be coupled to other Modelica
libraries, e.g. for powertrain models.

[10] Dynasim AB, http://www.dynasim.se/models.htm,
Accessed January 2005.
[11] Pfafferott, T., Dynamische Simulation von CO2
Kälteprozessen, Ph.D. thesis, Department of Thermodynamics, TU Hamburg-Harburg. In Berichte aus der
Thermodynamik, Shaker-Verlag, Aachen, 2005.
[12] Incropera, F.P. and DeWitt, D.P. Fundamentals of
Heat and Mass Transfer, Wiley & Sons, 5th ed., New
York, 2002.

References
[1] Eborn, J. On Model Libraries for Thermo-hydraulic
Applications. Ph.D. thesis TFRT–1061–SE, Dept of
Automatic Control, Lund Inst. of Technology, Lund,
Sweden, 2001.
[2] Tummescheit, H. Design and Implementation of
Object-Oriented Model Libraries using Modelica.
Ph.D. thesis TFRT–1063–SE, Dept of Automatic
Control, Lund Inst. of Technology, Lund, Sweden,
2002.
[3] Försterling, S. Personal communication, 2004.
[4] Försterling, S. Vergleichende Untersuchung von CO2 Verdichtern in Hinblick auf den Einsatz in mobilen
Anwendungen, Ph.D. thesis, TU Braunschweig, 2004.
[5] Casella, F. and Leva, A. Modelica open library for
power plant simulation: design and experimental validation, In Proc. of 3rd International Modelica Conference, Linköping, Sweden, 2003.
[6] Olsson, H., Elmqvist, H. and Tummescheit, H. Using Automatic Differentiation for Partial Derivatives

The Modelica Association

192

Modelica 2005, March 7-8, 2005

System Simulation of Automotive Refrigeration Cycles

System Simulation of Automotive Refrigeration Cycles
Dirk Limperich, Marco Braun, DaimlerChrysler AG
Katrin Prölß, Gerhard Schmitz, Hamburg University of Technology, Dept. of Thermodynamics
Dirk.Limperich@DaimlerChrysler.com, k.proelss@tu-harburg.de

1

Introduction

Numerical simulation in the automotive design
process is gaining increasing significance. This also
applies for thermodynamic and thermohydraulic
systems i.e. also for the air conditioning system
(HVAC) of an automotive vehicle. In order to
optimize the efficiency of HVAC-systems and to
obtain a better understanding of the complex
transient system behaviour of automotive
refrigeration cycles a Modelica library named ACLib
was developed in a joint research project by
DaimlerChrysler AG, Airbus Deutschland GmbH
and TUHH. It was based on the thermohydraulic
models of the free ThermoFluid library [2] and was
applied to automotive refrigeration cycles running on
the refrigerants R134a and carbon dioxide in an early
development stage, when only limited experimental
data was available [1, 5].
In order to share development costs and to combine
the system knowledge and expertise on vehicle
boundary conditions on one hand and the detailed
component knowledge of the supplier on the other
hand, a standardization process for a refrigeration
cycle
simulation
tool
was
initiated
by
DaimlerChrysler. Modelica/Dymola was chosen by a
pool of several OEM’s and suppliers for this task,
after several tools had been extensively investigated.
A new Modelica library, named AirConditioning
Library, which meets the requirements of industrial
application, and partly based on the former ACLib is
currently developed by Modelon AB. Due to its
user’s group as mentioned above, special emphasis is
placed on decoupling of physical equations and
possibly confidential and encrypted component data
as well as on high model flexibility.

2

Automotive Refrigeration Cycle

A Heating Ventilation and Cooling system (HVAC)
is the primary element in controlling environmental
temperatures of an enclosed automotive cabin. The

The Modelica Association

HVAC systems also provide fresh outdoor air and
adjust the temperatures and humidity to improve
comfort and increase efficiency (e.g. increase cabin
air circulation). Figure 2.1 shows the design of a
common automotive HVAC system. The design of
the AC-System (e.g. R134a refrigeration cycle) is
important for the cooling performance and demands
a high attention. A common R134a refrigeration
cycle consists of a compressor, condenser, high
pressure receiver, expansion device evaporator and
several hoses and tubes.
Expansion Device
Receiver/Drier

Cooling Unit/
Condenser

Compressor

Evaporator

Climate Control Unit

Fig. 2.1: Design of an automotive HVAC-Unit
As shown in figure 2.2, the R134a refrigeration cycle
is a subcritical vapor process. The process path in the
ph-Diagram is represented by the numbers 1-2-3-4
and shows the compression (1-2), isobaric heat
rejection at the condenser (2-3), adiabatic expansion
(3-4) and the isobaric evaporation (4-1). In steady
state the high pressure receiver is also represented by
number 3. In most cases the receiver is totally filled
with liquid R134a, assumed the refrigeration plant is
sufficiently charged.
The refrigerant mass is an important factor of a
vapor cycle and is one motivation for a complete
transient simulation. During different boundary
conditions (e.g. changing air temperature, air
massflow through heat exchanger) conditions the
refrigerant mass is moving to different parts of the
system and must be observed. The task is to find out

193

Modelica 2005, March 7-8, 2005

D. Limperich, M. Braun, G. Schmitz, K. Prölß

the optimal charge of the system and the changing
process behavior during any variation of the
compressor speed, air massflow and temperature.

3

2

condenser

expansion
device
4

model from the AirConditioning library is suitable
for a wide range of applications without requiring
experimental input data. It can be used for the
evaporator on the low pressure as well as for the
condenser / gas cooler in the high pressure side. Due
to the object oriented approach of the used Modelica
language and a standardized interface the heat
exchanger component can be used in variable cycle
positions and also as multiple instances with
different parameterization, i.e. as two evaporators
operated in parallel.

compressor
evaporator

1

The component specific parameterization, geometry
data, heat transfer and pressure drop correlations, is
decoupled from the physical equations and therefore
allows storage of confidential and encrypted
component data in a separate location.
3.1

Modelling approach

Fig. 2.2: Ideal case of R134a vapor cycle

3

Heat Exchangers

In order to capture the transient as well as the steadystate behaviour of the complete automotive
refrigeration cycle, detailed models of both main
heat exchangers, condenser/gas cooler and
evaporator, are required. They need to reproduce
correctly the heat transfer between refrigerant and air
flow and their respective property changes under
given boundary conditions. Commonly used in
automotive applications are compact cross flow heat
exchangers that use finned flat tubes with internal
microchannels as shown in Figure 3.1. Cross-co as
well as cross-counter flow versions are also widely
used for evaporators.

The fluid component models in the AirConditioning
library are based on fluid flow models realized in the
free Modelica library ThermoFluid [2][3]. This
approach applies a finite volume method (FVM)
allowing a numerically robust simulation of thermohydraulic systems including flow reversal. Mass and
energy balances on one and the momentum balance
on the other hand are solved on a staggered grid with
upwind property propagation.
The dynamic formulation of energy and mass
balances allows a representation of the transient
system behaviour. However, the major contribution
to transient component response rather originates
from heat capacities of the solid wall material.
medium transport

air

refrigerant

wall

refrigerant

heat transport

Due to the additional fuel consumption which is
about 100 liter gasoline [7] per year an exact and
realistic simulation is necessary for efficiency
optimization.

...
...
...
1

flat tube

refrigerant

louvered
fin

2

3

n

n = number of passes * discretization/pass

medium transport

flat tube
air

air

Fig. 3.1: Schematic of fluid flow in compact cross
flow air-refrigerant heat exchangers
Based on physical parameters and heat transfer
correlations from the literature, the heat exchanger

The Modelica Association

Fig. 3.2: Object diagram of heat exchanger
composition from air, wall and refrigerant
submodels.
The heat exchanger model is composed from two
fluid objects (air and refrigerant) and one wall
element. The wall mass is determined from detailed

194

Modelica 2005, March 7-8, 2005

System Simulation of Automotive Refrigeration Cycles

geometry input data and therefore reflects distributed
capacities. Heat conduction in the solid material is
modelled one-dimensional and perpendicular to both
fluids, longitudinal conduction is neglected for
efficiency reasons and because no significant loss in
accuracy is expected [4]. Heat is transferred between
wall and fluid using a heat connector class (Fig. 3.2).
Further information on the heat exchanger
composition approach can also be found in [5].
Heat transfer correlations for both fluids from the
literature, e.g. by Chang et. al. [6] for airflow
through louvered fins, are part of the library and used
as replaceable classes in the component. They are
easily replaced by correlations determined from
experimental data. In the same way pressure drop
correlations, geometry data or model switches as e.g.
air humidity condensation can be set by the user in a
top level dialog.
vertical refrigerant flow
z

horizontal refrigerant flow
z

y

x

Air

x: layers
y: pass segmentation
z: tube passes

gravity

gravity

x

and enthalpy at the heat exchanger inlet and a sink
generating a defined pressure at the outlet. The
source and sink were used to set the boundary
conditions resulting from data measured at the
component. The following comparison was made for
a cross-counterflow evaporator from an automotive
R134a-system built at Chrysler (Michigan, USA).
The heat exchanger is shown in Figure 3.4. The
geometric parameters of the component are all
known. In Table 3.1 the measured data and the
results of the simulations at steady state are shown.
The comparison of experimental data and simulation
results show very good correspondence in transferred
heat. The calculation of the refrigerant side pressure
drop and the air side water condensing (drainage) has
to be revised.

y

Air

Fig.3.4: R134a-Evaporator, cross counter flow

x: layers
y: tube passes
z: pass segmentation

Fig. 3.3: Orientation of component triple in 3D-space
A single pipe approach combines all parallel
refrigerant flows through the component in a single
flow with variable cross section, resulting in an array
of cross flow elements. They have to be formed into
a 3D structure to support different flow schemes.
Using a defined coordinate system with respect to air
flow and gravity (fig. 3.3), the generic heat
exchanger model can handle arbitrary flow patterns.
It also allows a defined interface for inhomogeneous
air inlet, which can be coupled with external 2D
data. However, resulting from the one-dimensional
flow approach in favour for numerical efficiency, the
air inlet (and outlet) resolution is restricted by flow
discretization (separated by dotted lines in figure 3.3)
and the number of refrigerant passes (separated by
solid lines in figure 3) in the component.
3.2

Fig. 3.5: Object diagram of test configuration

Validation of evaporator model

Simulations in a test configuration have been run
with the described models. The test configuration
(fig. 3.5) consisted of a source providing mass flow

The Modelica Association

195

Modelica 2005, March 7-8, 2005

Revolution 1/s

D. Limperich, M. Braun, G. Schmitz, K. Prölß

Boundary conditions for the evaporator from measured data

Compressor Speed

pR

TR,in

hR,in

TAir,in

r.H.Air_in

[kg/s]

[kg/s]

[MPa]

[K]

[kJ/kg]

[K]

[%]

0.132

0.043

0.633

296.5

289.6

330.3

19.2

0.132

0.048

0.434

281.8

271.2

316.5

18.9

0.132

0.054

0.439

281.3

272.7

316.5

19.1

0

Airmassflow kg/s

&R
m

Simulation

250

&
Q
R

r.H.Air_in

hR,out

TAir,out

&
Q
R

r.H.Air_in

[kJ/kg]

[K]

[kW]

[%]

[kJ/kg]

[kJ/kg]

[kW]

[%]

410.7

296.7

5.19

82.5

411.3

298.6

5.2

89.9

401.4

283.7

6.25

79.7

385.6

283.6

5.5

89.8

400.2

282.7

6.84

70.8

380.3

282.8

5.78

89.1

New European Driving Cycle

The New European Driving Cycle (NEDC) consists
of defined vehicle speeds in an urban as well as an
extra-urban section (fig 4.1). The NEDC is part of
the emission test EURO 4 and is also widely used as
a standard for fuel and energy consumption
experiments and evaluation.

1000

750

1000

0.0
250

500

Condenser

Time s

Evaporator

310
0

250

500

Time s

Fig. 4.2: Boundary conditions for the refrigeration
cycle during the NEDC
The Modelica object diagram of the model used for
the NEDC-cycle simulation is shown in figure 4.3.
The refrigeration cycle consists of an external
controlled compressor, a condenser, a receiver (with
integrated drier), thermostatic expansion valve,
evaporator and several pipes. The total volume and
the ratio of the high pressure side and suction side
volume are equal to the real refrigeration cycle. Also
the refrigerant charge of the simulation model is
equal to the real system.
Condenser...

Cond_tair
pT

EUDC = 1170 s

Con...

duration=...

100
Cond_phi

.
m

condenser

T

.
mT
k={0.4}

AirIn2

In

w ...

subc...

40

Evap_phi

rece...

CompressorS...

Evap_mair

pipe3

20

k={0.4}
Evap_tair

duration=...

1200

.
T

AirSi...

m T

Tp

AirIn1

Fig. 4.1: Driving speed during NEDC

evaporat...

SetPoin...

duratio...

pipe1

The resulting compressor speed and air velocity are
in the following used as boundary conditions in a
complete cycle simulation of a defined passenger car
(fig 4.2). The air inlet temperature for the evaporator
is constant at 310 K and the air massflow is constant
0.166 kg/s. The boundary condition for the
condenser is also shown in figure 4.2, the air
temperature is constant at 320 K and the air
massflow depends on driving speed.

The Modelica Association

w

duration=...

PI

1000

LimPI1

800

.
m

600
Time s

rps

suctio...

400

exp...

200

discha...

60

compr...

80
Velocity km/h

750

Evaporator

320

120

0
0

1000

330

Table 3.1: Comparison of measured data at the
evaporator with the simulation results in steady state

UDC = 780 s

Time s

750

0.4

Air Inlet Temperature 1/s

TAir,out

500

Condenser

0.8

0

hR,out

4

20

0

& Air
m

Measured data

40

Kv_of_pT1
w ...

Tempe...

T

Press...

super...

function
M

Fig. 4.3: Object diagram of complete R134a
refrigeration cycle

196

Modelica 2005, March 7-8, 2005

System Simulation of Automotive Refrigeration Cycles

In the following part, two simulation runs will be
discussed. The refrigeration cycle shown in figure
4.3 provides a basis for the two experiments. For
both experiment the described NEDC boundary
conditions were used. Only two different
compressors were used during the simulation runs.
They are referred to as compressor A and B in the
following. Compressor A has a 6 percent higher
displacement and one more cylinder, so that the
characteristic diagrams of both compressors are also
different.
The results of the simulation runs are shown in the
figures 4.4 -4.6. Three characteristic values of the
refrigeration cycles are shown and compared: the air
temperature behind the evaporator, the cooling
capacity and the required compressor power.
When using compressor B in the cycle the air
temperature behind the evaporator during UDC part
is mostly 1K higher than using the compressor A.

Only during the EUDC part there is nearly no
difference between the temperatures (fig. 4.4).
The comparison of the cooling capacity and the
compressor power shows the same behavior (fig. 4.5
and fig. 4.6). The total energy consumption for type
A is 733 Wh and for type B 720 Wh. Interesting is,
that during the EUDC the smaller compressor needs
less power for equal cooling capacity.
The solution of that experiment is that a 6% smaller
compressor could perform nearly the same cooling
capacity.
It is concluded, that the simulation tool is able to
predict the change of cycle behavior when the
accuracy of the component models is high enough.

Air Temperature at Evaporator Outlet - Type A
Temperature K

310
Compressor A

300
290
280
0

250

500

Time s

750

1000

Air Temperature at Evaporator Outlet - Type B
Temperature K

310
Compressor B

300
290
280
0

250

500

Time s

750

1000

Temperature K

Air Temperature Difference Type B - Type A
1
0
-1
0

250

500

Time s

750

1000

Fig. 4.4: Air Temperature behind evaporator - reference temperature for controlling T=283.15K

The Modelica Association

197

Modelica 2005, March 7-8, 2005

D. Limperich, M. Braun, G. Schmitz, K. Prölß

Cooling Capacity W

Cooling Capacity Type A
8000
Compressor A

6000
4000
2000
0

250

500

Time s

750

1000

Cooling Capacity W

Cooling Capacity Type B
8000
Compressor B

6000
4000
2000
0

250

500

Time s

750

1000

Cooling Capacity W

Cooling Capacity Difference Type B - A
1000
500
0
-500

-1000
0

250

500

Time s

750

1000

Fig. 4.5: Comparison of cooling capacity using compressor A and B
Compressor Pow er Type A
5000
Compressor A

Pow er W

4000
3000
2000
1000
0

250

500

Time s

750

1000

Compressor Pow er Type B
5000
Compressor B

Pow er W

4000
3000
2000
1000
0

250

500

Time s

750

1000

Compressor Pow er Difference Type B - A

Pow er W

400
0

-400
0

250

500

Time s

750

1000

Fig 4.6: Comparison of Compressor power for compressor A and B

The Modelica Association

198

Modelica 2005, March 7-8, 2005

System Simulation of Automotive Refrigeration Cycles

5

Common Simulation Tool
German Automotive Industry

in References
[1]

In Germany, a working group with members of
Audi, BMW, DaimlerChrysler and Volkswagen have
compared different simulation tools in order to
standardize the simulation of refrigeration cycles.
The advantages of standardization are mainly the
ability to integrate the supplier into the simulation
process. This makes it possible to simulate
components of different suppliers on one simulation
platform. After a benchmark test the group decided
to use Dymola Modelica for simulating refrigeration
cycles.
In the future models of refrigeration cycle
components are needed during the development
process. If the supplier is not able to create such a
model, detailed information of the geometry in
combination with measured data has to be provided
during the offer phase.

[2]

[3]

[4]

[5]

[6]

6

Conclusions

The dynamic simulation of an automotive
refrigeration cycle with Dymola/Modelica as part of
the design process is described in the paper. In a
cooperative effort between Hamburg University of
Technology (TUHH) and DaimlerChrysler AG, a
model library for modeling refrigeration cycles has
been developed based on the AirConditioning
library. Based on geometrical data, the single
components can be modeled and composed to an
entire cycle.
The validation of the evaporator is one example for
the component simulation and the results are in good
accordance with the experimental data.
The simulation of the NEDC has shown that a
prediction of the process behavior is possible, so that
the simulation is able to support the design of
refrigeration cycles for automotive applications.
At last the standardization has the advantage or the
chance that the component supplier’s expertise as
well as the automotive manufacturer’s knowledge of
vehicle parameters can be combined in a reliable
simulation.

The Modelica Association

199

[7]

Limperich D., Pfafferott T. and G. Schmitz:
Numerical Simulation of Refrigerant Cycles
with New Methods. Proceedings of
International Congress of Refrigeration,
Washington D.C., 2002.
Tummescheit,
H.:
Design
and
Implementation of Object-Oriented Model
Libraries Using Modelica. PhD Thesis,
Department of Automatic Control, Lund
Institute of Technology, Sweden, 2002.
Eborn, J.; On Model Libraries for Thermohydraulic
Applications,
PhD-Thesis,
Department of Automatic Control, Lund
Institute of Technology, Sweden, 2001
Asinari P., Cecchinato L. and E. Fornasieri:
Effects
of
thermal
conduction
in
microchannel gas coolers for carbon dioxide.
Int J Refrigeration 2004 27: 577-58.
Pafferott, T.: Dynamische Simulation von
CO2-Kälteprozessen für mobile Anwendungen. PhD thesis, Hamburg University of
Technology, Shaker Verlag, Aachen 2005
Chang Y.J, Wang CC: A generalized heat
transfer correlation for louver fin geometry.
Int J Heat Mass Transfer 1997; 40(3): 533544
Schwarz, W.: Prognose der R134aEmissionen aus Fahrzeug-Klimaanlagen bis
2010/20. Öko-Recherche, Büro für Umweltforschung, Frankfurt/M
http://www.oekorecherche.de

Modelica 2005, March 7-8, 2005

The Modelica Association

200

Modelica 2005, March 7-8, 2005

First Results in Cluster Simulation of Alternative Automotive Drive Trains

First Results in Cluster Simulation of Alternative Automotive Drive
Trains
Mathias Hommel
Brieffach 1778
Volkswagen AG
D-38436 Wolfsburg, Germany

Abstract
Control software plays an important role in the development of alternative drive trains. Energy management intervenes with the control of the combustion engine, the transmission or an additional electrical machine in different ways. In order to develop
the energy management before or parallel to the vehicle construction phase, a complex software development process is required that equally supports
modeling, simulation and implementation.
In the R&D of Volkswagen cluster simulation
was established to simulate the drive train of a vehicle as well as to develop algorithms for the relevant
electronic control units (ECU).
The methodology of cluster simulation will be
represented in the following article.

1

Introduction

For more than 20 years now Volkswagens deals with
alternative concepts for automotive drive trains. First
there were the electric vehicles with a comparatively
simple control that converted the driver’s wish into a
driving torque. Today, however, as combustion engine and electrical machine can be connected with
each other in multiple ways, one needs a complex
control in order to influence the torque distribution
depending on the driving conditions. The intention in
this case is to positively influence comfort and driving capability.
The control of the different components of the
drive train plays a central role in this context. The
so-called energy management coordinates the
torques of the drive train. The electrical energy storage capacitor is controlled by the so-called battery
management and so forth. For example, energy management and battery management influence each
other in a complex way.

The simulation of the drive train plays an essential role during the specification of the components
as well as during modeling the control algorithms.
The objective of this drive train simulation is a fast
and manageable process for developing controller
algorithms resulting in an automatic code generation
within a software-in-the-loop (SIL) process. Manageable in this context means that the developer can
react in a quick way to altering structures of the drive
train. The simulation time should be faster than real
time in order to be able to carry out parameter variations and code development fast. Therefore a cluster
computer was built for the drive train simulation
consisting of ten dual processor computers. The individual computers themselves are connected with
each other with a Myrinet1 network, which is an optical network.
Within the project SUVA (Surplus Value Hybrid
Vehicle) that was supported through the European
Community [1] Volkswagen built up a Volkswagen
Bora Hybrid with a hybrid drive train (Figure 1).

Internal Combustion Engine

Fuel Tank

Power Electronics
Clutch 2
Transmission

Electrical Machine

Battery

Clutch 1

Figure 1: Structure of the Volkswagen Bora Hybrid
The drive train of the Volkswagen Bora Hybrid consists of a combustion engine (1.4 liters, 55 kW,
3 cylinders, turbo diesel), an electrical machine
1

Myrinet is a registered trademark of Myricom, Inc., USA,
http://www.myricom.com

The Modelica Association

201

Modelica 2005, March 7-8, 2005

M. Hommel

(asynchronous machine, 25 kW peak), a clutch between the combustion engine and the electrical motor (clutch No. 2 in Figure 1), the automatic transmission (a dual clutch transmission, named by
Volkswagen DSG®2, [2]) and an energy storage
(6 Ah NiMH-battery, 288V).
The transmission concept is such that the transmission is provided with a dual clutch on the gearbox input side (see Fig. 6 in chapter 2.1 as well).
This clutch is represented in Figure 1 as being outside of the transmission for the sake of simplification
(designated as clutch 1 in Fig. 1).
Due to this arrangement this specific drive train
is called a parallel hybrid drive train since both combustion engine and electrical machine simultaneously or separately supply torque to the entire driving torque of the vehicle - acceleration to the strategy
that is worked out in the above mentioned energy
management ECU. For the classification of the different hybrid vehicles please refer to the relevant
literature [3].

On the other hand Modelica5/Dymola is used for
modeling the plant that is the closed loop controlled
system vehicle. Furthermore, executable files of
ECU algorithms in the form of a DLL (dynamic link
library) are incorporated into the simulation
(see Fig. 2). As it is shown in Figure 2 in the cluster
simulation the essential algorithms of the relevant
ECUs are simulated in Matlab/Simulink such as:
• the internal combustion engine ECU (ICE
Controller6),
• the ABS/ASC-system (Brake Controller),
• ECU of the gearbox (Gearbox Controller) as
well as
• the ECU of the electric machine (E-Machine
Controller).
Model of Drive Train
Driving
Cycle

Vehicle and Component Simulation using Modelica/Dymola

ICE
Controller

2

Simulation Model

E-Machine
Controller

Energy Management Controller as Simulink Model

ECU code generation via
Matlab/RTW embedded coder

BMS-DLL

BMS ECU code via compiling
with Target-Compiler

Figure 2: Structure of the drive train model of the
cluster simulation
Furthermore, the controller of the energy management ECU which is modeled in Matlab/Simulink is
integrated as well as the DLL of the controller of the
battery management ECU (BMS, battery management system).
The plant was modeled in Modelica/Dymola as
already described above and can be linked to the
cluster simulation either as a Dymosim.exe or as a
Dymola model.
Executable files (so-called executables or exe)
were generated from all models since it is to be expected that through the detailed modeling the performance of the cluster simulation is lowered due to
simulation of uncompiled models.

DSG is a registered trademark of Volkswagen AG, Germany

3

Matlab und Simulink are registered trademarks of The Mathworks, Inc., USA

4

Gearbox
Controller

Driver

The differences of the block-oriented or causal modeling using for example Matlab/Simulink3 and the
acausal modeling using for example Dymola4 were
described sufficiently [4].
While in the development of ECU algorithms
the causal, graphical, signal-based modeling become
more and more accepted in prototyping, acausal
modeling has its advantages in the description of
physical systems. The physical structure is maintained and the description corresponds to the local
physical equations of the components that are independent of their environment, as well as their coupling to the entire system of equations.
For this reason the cluster simulation is realized
by a simulator link-up: On the one hand Matlab/Simulink is used for modeling the ECU algorithms, the driver model (which generates the accelerator and brake pedal) and the driving cycle (which
generates the reference vehicle speed value, height,
air pressure and so on).

2

Brake
Controller

Dymola is a registered trademark of Dynasim AB, Sweden

The Modelica Association

5

Modelica is a registered trademark of the Modelica
Association
6

The term controller synonymously stands for a closed loop
control algorithm that is the functional software of an ECU
(electronic control unit).

202

Modelica 2005, March 7-8, 2005

First Results in Cluster Simulation of Alternative Automotive Drive Trains

The cluster simulation is a so-called forward
simulation in contrast to the so-called backward
simulation. Starting from a driving cycle the comparison of the actual value of the vehicle velocity
with the reference value is done by the driver model
which then generates the accelerator or brake pedal
command. The strategy of the energy management
then controls the components of the drive train to
generate the necessary driving torques in order to
follow the reference value of the vehicle velocity of
the driving cycle. The actual value of the vehicle
velocity is traced back to the driver model.
In the following, the individual, modeled systems are shortly described as well as the structured
components library in Dymola and the simulator
coupling.
2.1

Model of the Plant

The vehicle is structured on the highest modeling
level into the three large blocks: chassis (CHS),
power train (PTR) and auxiliaries (AUX) (Figure 3).

Figure 4: Model of the chassis (CHS)
Furthermore it incorporates a simple hydraulic model
for the excitation of the brakes (BRE, which stands
for brake model).
The model of the auxiliaries (AUX) consists of
the modeled electrical consumers of the vehicle electrics (14V).
The model power train (PTR) represents the relevant components such as the internal combustion,
ICE, engine (VKM, German: Verbrennungskraftmaschine), the fuel reservoir (TNK, German: Tank),
the clutch between ICE and electrical machine,
called separating-clutch (TRK, German: Trennkupplung; clutch 2 in Figure 1), the gearbox (GTR,
German: Getriebe), the high voltage battery (BAT)
and the electrical machine (Figure 5).

Figure 3: Structure of the vehicle model
The block EXITE_BLOCK represents the simulator
coupling described in the chapter 2.4.
The model of the chassis (CHS) incorporates a
vehicle model (BOD i.e. body) without lateral dynamics considering all relevant driving resistances as
well as a model of the contact of the tire with the
street (Figure 4).
Figure 5: Model of the power train (PTR)
In the upper part of Figure 5 the shared-memory
data-link is displayed which is described in
chapter 3.1.

The Modelica Association

203

Modelica 2005, March 7-8, 2005

M. Hommel

Only the internal combustion engine was modeled based on maps (efficiency maps). All other
components are equation-based models and are described shortly.
The model of the fuel tank is a simple model of
the flow of the fuel.
The model of the separating-clutch is a complex
mechatronic model of the clutch and the flywheel.
Even the hydraulic actuator and the mechanics of the
separating-clutch were modeled.
The induction motor was modeled as an electromechanical drive in α−β stator coordinates based
on the well known equations [5].
The NiMH battery was modeled with electrical
and thermal characteristics including ventilation.
The model of the automatic transmission is a
complex mechanical and hydraulic representation of
the DSG® (Figure 6).

Figure 7: Structure of the Dymola library VML

Figure 6: Section of the DSG

2.2

The Vehicle Modeling Library – VML

Dymola supports object-oriented modeling. Class
libraries can be created in so-called packages. Since
with the aid of the cluster simulation different drive
train configurations can be examined, from the start
the emphasis was put on a hierarchically structured
component library (Figure 7).

The Modelica Association

This library handles the components and the component structure as well as the variants of components.
In the following, attention is shortly being paid to the
construction of the component-library VML.
There are basically four levels of hierarchy: the
UCL - classes of the models of complete units, the
ACL - classes of the aggregate models, the CCL the classes of the components and their parts – the
PCL. In order to structure the system vehicle into
manageable subsystems the vehicle is structured into
the abovementioned subsystems chassis, powertrain
and auxiliaries which were named units. The main
parts of a unit are referred to as aggregates, such as
the ICE or the gearbox of the unit powertrain. Parts
of aggregates are referred to as components such as
the converter or the electrical drive itself of the aggregate electrical machine. So-called parts are elements of components such as different sensors or the
voltage conversion of the component converter.
This structure results from the principle of decomposition assuming the following: units consist of
aggregates, aggregates consist of components and
components consist of parts. The structure is displayed by the structure of packages in Dymola. The
packages by themselves are subdirectories on the
hard disk.

204

Modelica 2005, March 7-8, 2005

First Results in Cluster Simulation of Alternative Automotive Drive Trains

Classes of units (UCL) and aggregates (ACL)
furthermore can contain packages of connectors
(Pac_CON_...) and models (Pac_UTP_... and
Pac_ATP_... resp.; TP stands for a special type or
model). Archived models of particular aggregates or
units are stored in the type package. Parameterizing
is supported by using records.
2.3

Modeling of the Controller

The difficulty of the simulation of the drive train is
not mainly modeling the physical system; it can be
modeled with sufficient accuracy with more or less
effort.
The problem rather is the modeling of the control algorithm of the components that represents the
control characteristic. So the functionality of the ICE
control, the transmission control, the electrical machine control and the ABS/ASC control was modeled with relatively large effort. All models in Matlabt/Simulink were modeled discrete (for instance
fixed step size 10 ms).
The algorithm of the battery management system (BMS, that is the ECU that controls the battery
with respect to its boundaries) could be directly inserted into the cluster simulation as a DLL since the
algorithm was developed by the author himself. And
the complete algorithm of the energy management
ECU (Vehicle Management Unit, VMU), which was
developed in Matlab/Simulink, could be inserted too.
For these two last-mentioned ECU algorithms there
is a software development process with which one
can generate the flash code directly out of the simulation by means of automatic code generation or
compilation with the target compiler for the ECU
(see Figure 2). In case of the BMS this process is a C
programming language software development process and for the VMU a Matlab/Simulink/Real-TimeWorkshop (RTW) software development process.
Both processes were used in this way within the
above-mentioned SUVA project.
2.4

Master Model

In the so-called master model which was modeled in
Matlab/Simulink the interface data of all submodels
are exchanged via a network of the representatives of
all submodels which is fed back on itself (Figure 8).

Figure 8: Feedback structure of the representatives of
the submodels (the output is fed back without delay
onto the input)
As already mentioned in chapter 2.1, the simulator
coupling is carried out by the tool EXITE of the
company Extessy AG, Germany [6]. EXITE realizes
a simulator coupling on the basis of a client-serverlinkage. The server is the representative of a submodel which only provides the interfaces according
to the regarding submodel. The client is the submodel itself.
The Extessy AG provides a simulator coupling for
different simulation tools for example for Matlab/Simulink, ASCET-SD7, Saber8 and Dymola.
Several methods for data communication between
the client and server are supported such as the simple
sequential communication and the full-duplex communication. EXITE relies on the ISO-OSI layer
model of communication. So the communication
protocols TCP/IP and MPI are supported too. The
Master Model handles all interface data of all submodels, therefore it reflects the so-called communication matrix which shows which submodel exchanges which data with which submodel in what
sample time. In this cluster simulation over 900 signals are exchanged mainly because of the emulation
of the CAN bus (Controller Area Network – a commonly used network in the automotive context). 500
of these signals are relevant stimulation inputs for
the simulation.
The VMU and the BMS are stimulated in this
way with all signals available in reality. Thus this
7
ASCET-SD is a registered trademark of
Germany
8

The Modelica Association

205

ETAS GmbH,

Saber is a registered trademark of Synopsys, Inc., USA

Modelica 2005, March 7-8, 2005

M. Hommel

simulation represents a real SIL simulation concerning these two ECU algorithms. The relevant signals
are considered for the other ECU.

eral parts and to simulate them separately in case of
simulation overload.

3

As described in chapter 2.4, different combinations
of the communication protocols and of the communication methods are possible.
All benchmarks of cluster simulation were carried out with the full-duplex communication method
with the protocol MPI/GM9 via Myrinet, the optical
network.
The Matlab/Simulink models were modeled discrete. For the Dymola drive train model the integration algorithm lsodar (a multi-step-solver with a
variable step size for continuous and discreet systems) has proved to be very robust.
In Table 1 the results of several benchmarks are
listed. The third column contains the ratio of simulation time to simulated time (RT/tsim).

3.1

First Results
Shared-Memory-Coupling

The control of the electrical machine was realized
with the switching frequency of the converter which
is 8kHz. The model coupling of the electrical machine in Dymola and its control in Matlab/Simulink
would slow down the simulation extremely. For this
reason, a shared-memory data-link was created so
that two processes access the same storage area. The
processes are controlled so that both are processed
on different processors of a dual processor computer.
Thus the vehicle model is carried out on one processor as a Dymosim.exe. On the other processor the
electrical machine control is processed as a Matlab/Simulink/RTW-executable. The shared memory
block is represented in the upper part of the Dymola
model in Figure 5.
3.2

3.3

Table 1: Results of the performance measurements
Sim.
No.

Partitioning

The distribution of the submodels on the individual
computers was done according to performance aspects, because the slowest simulation determines the
overall performance of the cluster. For this reason
the partitioning shown in Figure 9 was carried out.
PC 1
Driver Model,
Driving Cycle
and HumanMachine-Interface
PC 9
Vehicle Modell
and Control of
Electrical Machine
PC 7+8
not yet used

PC 2
Brake Control and
DC/DC-Converter
Control
PC 0
Master Modell
(Communication
Matrix)
PC 6
ICE Control

Configuration

RT/tsim

(1)

all models as dummies – i.e. empty models

67.1

(2)

all ECUs as RTW-exe, except gearbox ECU; vehicle as
dummy models

8.9

(3)

all ECUs as RTW-exe, except VMU-ECU; vehicle as dummy
models

5.9

(4)

vehicle model as Dymosim.exe, all ECUs as RTW-exe, EMA
control with 8 kHz shared-memory data-link

1/390

(5)

as (4), EMA control with 4 kHz shared-memory data-link

1/216

(6)

vehicle model split into the electrical high voltage part,
modeled in Matlab/Simulink and compiled to an exectuable
and the remainder as Dymosim.exe; all ECUs as RTW-exe

1/15 10

PC 3
Energy
Management
PC 4
Battery
Management
System
PC 5
Gearbox Control

Figure 9: Distribution of the submodels on the
individual simulation PC
It was expected that the vehicle model determines
the performance of the overall system due to the detailed modeling of the components. For this reason
two more computers were reserved (PC 7 and 8 in
Figure 9) in order to split the vehicle model into sev-

The Modelica Association

Benchmarks

To examine the influence of the Matlab/Simulink
ECU models on the performance of the cluster simulation in simulation No. (2) and (3) of table 1 the
gearbox controller and the VMU controller, respectively, were replaced by empty models (so-called
dummies). As mentioned above, all other Matlab/Simulink models were RTW-executables. Even
the Dymola plant was simulated by a dummy. The
simulations were 8.9 and 5.9 times faster than real
time. This means that because of the complexity of
the model of the gearbox controller the performance
of the cluster simulation will be more influenced by
the gearbox controller than by the energy management controller. Furthermore it is obvious that even
9

GM is a registered trademark of Myricom, Inc., USA

10

Estimated value based on simulation of the vehicle model
without shared memory data-link and without control of
electrical machine

206

Modelica 2005, March 7-8, 2005

First Results in Cluster Simulation of Alternative Automotive Drive Trains

if the plant could be simulated faster as the gearbox
controller, the cluster simulation would be only a
maximum of 5.9 times faster than real time when
performing SIL-simulation for VMU controller algorithm development.
For the sake of comparison, the simulated time for
a complete empty-cluster simulation is given in
simulation No. (1). Only dummy models were simulated. It follows that the pure communication of
empty models is 67.1 times faster than real time. Per
simulation step (10ms fixed step), approximately
150µs is required (operating system and Matlab/Simulink overhead).
In simulation No. (4), all dummy models were
replaced by their respective models. The vehicle
model was compiled by Dymola into the executable
Dymosim.exe. All Matlab/Simulink models were
compiled by Matlab/RTW into executable files. The
simulation of the control of the electrical machine
(fixed step size) and therefore the data exchange via
shared-memory data-link between the electrical machine in Dymola (variable step size) and the control
of the electrical machine in Matlab/Simulink was
carried out with a 8kHz switching frequency of the
converter of the electric drive. As a result the simulation was 390 times slower than real time. Of course
this result is caused by the communication step size
of 125µs. As mentioned above, the integration algorithm used in Dymola was lsodar with a tolerance of
1E-5. (The model did not run by a tolerance of 1E4.) The data exchange between vehicle model and
the control of the electrical machine organized by
EXITE every 10ms activates an event in Dymola. As
a consequence additional CPU time is required
through reinitialization during solving the differential equations and thus the performance of the system
slows down.
Reducing the switching frequency and in this
way the frequency of the data exchange between
Dymola and Matlab to 4kHz still leads to a simulation which is 260 times slower than real time. Moreover, with this lower switching frequency at maximum rotational speed of the electrical motor no effective mechanical torques can be generated.
The transition of modeling the electrical machine
in α−β stator coordinates to d-q field coordinates
and, hence, the loss of the universal description of
the machine for the benefit of the symmetrical machine would reduce the simulated time and the effort
due to data exchange in such a way that the simulation rate would be moved into manageable proximity. The data exchange via shared-memory then
could be done in 10ms steps. Only one disadvantage
would arise: the harmonic pattern and consequently
The Modelica Association

the torque ripple of the electrical machine would be
simulated no more. However, the torque ripple supplies an insignificant contribution with regard to its
effects onto the torque characteristics of the drive
shaft during the software development of the energy
management algorithms and so it could be neglected.
Keeping this in mind, the high voltage electric
part of the drive train is presently removed out of the
Dymola vehicle model onto a Matlab/Simulink
model which also includes the controller of the electrical machine (estimated simulation time see simulation No. (6) in Table 1). Thus the performance of the
drive train simulation could be increased at least to
15 times slower than real time.

4

Alternatives for Increasing the Performance

It has been shown that the influence of the modeling
of a complex controlled system on the performance
of the entire simulation is quite important. To put it
precisely: in the present cluster simulation the Dymola model determines the overall performance. For
this reason possible alternatives for improving the
performance of the cluster simulation will be described in this chapter.
4.1

Simplification of the Modeled Plant

The vehicle model must be redesigned in such a way
that models with only small influence on the entire
simulation or those with a vague description are reduced to simple constants or low-pass filters of first
order.
The auxiliaries model for example: a constant
efficiency and a constant load at the 14V power supply can be accepted. The effect on the development
of the energy management algorithm is minimal and
the error can be accepted.
4.2

Elimination of Stiffness

The stiffness values of the system have an essential
influence on the performance of the cluster simulation. These must be identified and eliminated. Since
that was not done until now, a further increase in
performance can be expected.
4.3

Calculating Vehicular Submodels Separately

As it was shown in chapter 3.3 it is possible to
shorten the simulated time by splitting the vehicle

207

Modelica 2005, March 7-8, 2005

M. Hommel

model into several parts. A further alternative for
increasing the performance therefore is the identification of effects with large time constants and submodels which can be calculated separately. So a second or a third Dymola session could be opened and
for example the simulation of the auxiliaries could be
calculated separately.
4.4

Usage of more Efficient Solvers

The simulation slows down due to events (10ms data
exchange via EXITE, discontinuities in modeling)
and because of the variable step size and the solver
used in Dymola.
The most efficient way for speeding-up the
simulation is the use of a single step solver for continuous systems with variable step size and state
event handling. The usage of Dynasim’s GODESS
library (GODESS stands for generic ODE solving
system) that incorporates such solvers is presently
proved.
4.5

Replacing
Modeled
its ECU-DLLs

Controller

by

If the real ECU code of a controller is available,
complex modeling can be avoided. Furthermore, the
ECU code is often more efficient. Thus, the BMS
code could be included into the cluster simulation. In
the same manner the DSG®-ECU code could be
linked to the cluster simulation. By doing so and together with all other herein mentioned possibilities
for increasing the performance of this simulation
there could be an increase in simulation time which
would result to a 9 times faster performance than real
time (see simulation No. (2) in Table 1).

5

such complex simulation is the level of detail of the
submodels and the solver used.
With Modelica/Dymola as an object-oriented,
multi-domain modelling tool it is possible to alter
plant structures in a fast way.
One next step has to be the validation of the
simulation. For this purpose, an approximately
300 km long driving cycle has already been measured.
In future more ECU algorithms will be linked as
DLL into the cluster simulation which makes the
control characteristics more realistic and reduces the
amount of work necessary for modeling control algorithms.
For the development of controller algorithms
and for the specification of components, an automated simulation will be designed; with it, parameters can be changed within their boundaries by predefined scripts or Monte-Carlo analysis, allowing
massive parameter variations to be carried out automatically.
In order to obtain a manageable SIL, the cluster
simulation has to be redesigned to be faster than real
time.

6

Acknowledgements

This work was done within a project of Volkswagen
R&D in cooperation with various partners. For this
reason the author would like to thank the respective
colleagues of the Audi Electronics Venture GmbH,
of the Extessy AG as well as of the Lineas Automotive GmbH and there in particular Wolfgang Borgs
and Vadim Bulakhov for their assistance in modeling
and puting the cluster simulation into operation.

Conclusions and Future Work

A complex mechatronic simulation was presented in
a heterogeneous cluster of simulators used for hybrid
drive train simulation in the automotive industry.
The objective was to clarify whether or not it is possible to set up a manageable SIL process with extensive computational aid. As a result it can be said that
on principle ECU algorithms can be developed with
the aid of the presented method. An advantage of
SIL compared to traditional applications in the vehicle is that the control algorithms can be developed
robust in respect of fluctuations in components and
environmental data and in a reproducible manner.
Effects of the communication between the ECUs can
also be examined. Decisive for the manageability of

The Modelica Association

References

208

[1]

[2]

[3]

J.-W. Biermann, C. Bunz, M. Crampen, S.
Köhle, D. Mesiti: Drei OEM, ein gemeinsames Antriebskonzept – Drei neue Hybridfahrzeuge, entwickelt im EU-Projekt SUVA,
13. Aachener Kolloquium Fahrzeug- und
Motorentechnik, Aachen, 2004
Timo Götte, Thomas Pape: DSG – Das Direktschaltgetriebe von Volkswagen, VDITagung “Getriebe in Fahrzeugen 2004”,
Friedrichtshafen, 22.-23. Juni 2004
Roland Kube, Michael Böckl, Mathias
Hommel, Siegfried Köhle: Energy Management Strategies for Hybrid Drive Train Sys-

Modelica 2005, March 7-8, 2005

First Results in Cluster Simulation of Alternative Automotive Drive Trains

[4]

[5]
[6]

tems Using Infrastructure Information, EURmotor New Advances in Electronics Engineering, Energy Management – Today and
tomorrow, 23.-24.9.2004, Aachen
M. Tiller, D. Linzen: A Comparison of Different Methods for Battery and Supercapacitor Modelling, SAE 2003-01-2290, 2003
Werner Leonhard: Control if Electric Drives,
Springer Verlag, 2. edition, 2000
EXITE Handbuch Version 1.3.0, EXTESSY
AG, Wolfsburg, 2004

The Modelica Association

209

Modelica 2005, March 7-8, 2005

The Modelica Association

210

Modelica 2005, March 7-8, 2005

Session 3b
Thermodynamic Systems II

The Modelica Association

211

Modelica 2005, March 7-8, 2005

The Modelica Association

212

Modelica 2005, March 7-8, 2005

Simulation of a thermal model of a surface cooled squirrel cage induction machine by means of the
SimpleFlow-library

Simulation of a thermal model of a surface cooled
squirrel cage induction machine by means of the
SimpleFlow-library
C. Kral, A. Haumer, M. Plainer
Arsenal Research, Faradaygasse 3, 1030 Vienna, Austria

Abstract

• Mixing of media flows obeying mixing rule
can be realized easily.

SimpleFlow -library was created to model heat and
coolant flows of simple thermal equivalent circuits.
The main components of this library and their applications are presented in this paper. Furthermore, a thermal model of a surface cooled squirrel
cage induction machine is introduced. The simulated temperatures are compared with measuring
results which were obtained in the laboratory.

1

Introduction

Typical cooling models consist of a thermal network model and a cooling circuit of a device
(e.g. an electrical machine) which is going to
be cooled. The mechanism of coolant flow is
different from heat conduction [1], described by
the thermal network model. Therefore in the
second section the SimpleFlow -library is introduced. Basic equations and components of the
cooling model are presented, as well as the structure of the library. The third section introduces
a complete thermal network model of a surface
cooled squirrel cage induction machine (totally
enclosed fan cooled), using the elements from
Modelica.Thermal.HeatTransfer. The simulation is presented in the fourth section, whereas
the measurement is described in the fifth section.
The sixth section compares simulation and measurement results.

• Reversing the direction of flow is possible.
• No complex media properties are needed.
• The medium is considered to be incompressible.
• Mixtures of different media are not taken into
account. Each individual cooling circuit has
to have a designated medium.
• Medium properties are considered to be constant.
• Pressure changes are only caused by pressure
drops (due to friction of the coolant flow at
solid surfaces).

The library design has been restricted to simple
media as coolants, only taking basic thermodynamic effects into account, such as the transport
of heat by a flowing medium. These prerequisites
allow a very easy handling of the library and are
sufficient for a wide range of applications, including the cooling of devices. Cooling of electrical
machines is an important topic, because the forecast of machine temperature increases allows to
improve the machine design as well as to reduce
the machine size and mass, which ends up in competitive advantages. In these applications temperature rise of the coolant as well as pressure drop
of the coolant flow are rather small, so the abovementioned conditions are fulfilled satisfactorily.
Other applications not fulfilling the above2 SimpleFlow Library
mentioned conditions like complex thermodyThe description of coolant flows due to forced con- namic processes have to be modelled using
vection is difficult. The developed SimpleFlow - Modelica.Media and Modelica.Fluid, which are
library was designed to model such coolant flows currently under development. So the SimpleFlow library is not designed to compete with these high
under the following conditions:
sophisticated thermodynamic libraries but to ease
the modelling of simpler applications.
• Splitting of media flows is simple.
The Modelica Association

213

Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer, M. Plainer

2.1

Equations

SimpleFlow -library has to take simple thermodynamic equations in to account. The following
quantities have been chosen to describe the state
of a coolant flow:
• pressure (p) and temperature (T) as potentials
• mass flow (mflow) and simple energy flow
(sEflow) as flow quantities
The naming of simple energy flow is chosen to keep
in mind that only the heat transported by the media’s thermal capacity is taken into account, avoiding mix-up with thermodynamic energetic quantities like enthalpy.
The basic equations of a flow element are collected
in partial models, placed in subpackages named
Partials and Friction [2], [3], [4], [5]:

to out and b is assigned to in. This means, that
there are two sets of equations used depending on
the actual flow direction of the medium. The handling of these two sets of equations is supported
by the Modelica statement semiLinear [6].
Modelica ensures the correct summation of mass
flows and energy flows as well as equity of potentials pressure and temperature of connected ports.
Since the mixing rule is applied at the inlet port of
an element according to the actual flow direction,
the temperature of the port where the mass flow
leaves the preceding element does not necessarely
show the medium’s temperature but the (possible) mixing temperature of the following element.
The medium’s temperature is represented by the
internal state T.
Besides the definition of common media (air and
water) and appropriate sensors for pressure and
pressure drop, temperature and temperature drop,
mass flow and energy flow the library puts the
following components at the user’s disposal.

• Pressure drop is a function of mass flow: linear dependency is assumed to a limit where
laminar flow is effective, and quadratic de- 2.2 Sources
pendency is modelled for higher mass flows
• Infinite ambient with constant or prescribed
approximating turbulent effects.
temperature and pressure which is not influ• Mass flow balance:
enced by ingoing or outcoming flows.
flowPort in.mflow +
• An element which allows to define pressure
flowPort out.mflow = 0;
level in a closed circuit, since flow elements
• energy flow balance:
only define pressure drops.
flowPort in.sEflow +
• Simple fans (neglecting the media mass
flowPort out.sEflow + Q flow =
within the fan) and pumps (taking the mem * cp * der(T);
dia’s thermal capacity into account), allowing
where Q flow is the energy flow exchanged
to define either pressure drop or mass flow.
with the environment outside the medium, m
is the medium’s mass, cp represents specific
heat capacity of the medium and T is the 2.3 Components
medium temperature within the element.
• Isolated pipes with and without consideration
• Energy flow at the port where the mass flow
of medium mass
leaves the element:
• Pipes (with and without medium’s mass)
flowPort out.sEflow =
with a thermal connector where heat is exflowPort out.mflow * cp * T;
changed with a thermal network.
• Mixing rule at the port where the mass flow
• A predefined simple cooler, containing a vecenters the element:
tor of cooler elements, each consisting of a
flowPort in.sEflow =
pair of pipes, coupled with a thermal conducflowPort in.mflow * cp * flowPort.T;
tor.
The actual connectors of any component are
flowPort a and flowPort b. If the medium flows The usage of the library is demonstrated with
from a to b, a is assigned to in and b is assigned to a couple of simple examples. These elements
out. For the opposite flow directions a is assigned together with Modelica.Thermal.HeatTransfer
The Modelica Association

214

Modelica 2005, March 7-8, 2005

Simulation of a thermal model of a surface cooled squirrel cage induction machine by means of the
SimpleFlow-library

allow the modelling of complex applications like
the cooling of an electric machine.

3


	









Thermal Equivalent Circuit

The components of a thermal equivalent
circuit
can
be
imported
from
Modelica.Thermal.HeatTransfer. The thermal
networks are designed in the style of electrical
components and circuits. The components of
such a network are:








!





 
#
"











&
'

%
%
$ 
$
 
 

'
)
(  
 

&
)
( 


 



Figure 1: Thermal equivalent circuit of a surface
• Nodes are regions of constant temperature. cooled squirrel cage induction machine
The potential of a node represents the absolute temperature of that node. The SI unit
FGHIJ
of the absolute temperature is K.
• A loss source in the thermal circuit is equivalent to a current source in an electric circuit.
There are loss sources where the precalculated losses have to be corrected by the actual
temperature of the corresponding node in order to consider copper losses correctly. Other
loss sources such as iron losses do not need
a temperature dependent correction. The SI
unit of the heat flow is W.

LMNOP

77897>?
,-/778:;=
9
7789<BC

FGQKR

*21
**+77897A?*01

7A?97>?

LMNOS

7789:;< ,-.
7A?9<BC

.56
@A?9<BC
@789<BC
BEB
43/ @78D@= 3*+ 301 @78D@< 43.
9
9
@789@A?
@A?9@>?
@789@>?
321

FGQKT

FGKIJ
• Thermal resistors represent regions of heat
conduction. For technical application such as
electric machines, heat transfer is mainly heat
Figure 2: Thermal network of the active part
conduction and convection. Heat radiation is
usually not considered. The SI unit of a thermal conductance is K / W. A thermal conductor is the reciprocal of a thermal resistor. To achieve reusability, the active part – which is
the same for many types of cooling – is modelled as
Its SI unit is W / K.
a separate submodel with appropriate connectors
• Thermal capacitors represent the ability of (see fig. 2)
storing heat energy in a certain region. The The losses of the induction machine have to be
separated in accordance to the introduced model.
SI unit of a thermal capacitor is Ws / K.
Stator copper losses have to be divided into slot
The utilized thermal equivalent circuit is shown in losses (LSSL) and the losses with respect to the
fig. 1. With respect to the thermal heat conduc- winding heads (LWHA and LWHB) of each side. The
tion paths the induction machine is divided into ratio of these losses is directly proportional to the
three axial sections. The outer sections are the respective coil length within these sections. Rotor
drive end (A-side) and the non-drive end (B-side). heat losses have to be divided into rotor slot losses
End-rings (ERA and ERB), end cap air (AIA and (or bar losses; LRSL), and the losses with respect to
AIB), winding heads (WHA and WHB), housing (HOA the end rings of each side (LSRA and LEAB). Stator
and HOB) and cooling ribs (RIA and RIB) refer to and rotor iron losses have to be determined with
either of these sides. The middle section consists respect to yoke and teeth (LSYO, LSTO, LRYO and
of the rotor yoke (RYO), rotor slots (RSL), rotor LRTO). Copper losses are precalculated and have
teeth (RTO), the air gap (AGP), stator slots (SSL) to have temperature correction in order to model
and stator teeth (STO), stator yoke (SYO), housing the actual losses accurately.
(HOM) and cooling ribs (RIM).
Therefore, there exist four types of nodes:

The Modelica Association

215

Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer, M. Plainer

This allows to define thermal conductance
dependent on actual machine speed.
Y[Va_[`bVc\\\
UVWXYZ[X\\\

It is advantageous if loss components are directly
available from machine design software. Otherwise, these components have to be estimated with
respect to the current density or flux density and
the mass of these sections.

]
UVWX]W^W_`X\\\

Figure 3: Node with constant losses

4

Simulation

The geometric design data of the induction machine were available by courtesy of the machine
manufacturer. The electromagnetic quantities
hjepnjoqerkkk
such as magnetomotive forces (mmf), flux densidefghijgkkk
ties, current densities etc. were determined by motor design software ASYN. The output data of the
motor design software deal as input parameters for
l
the determination of the relevant thermal paradefglfmfnogkkk
meters of the machine. These parameters are the
thermal conductances and capacitances as shown
Figure 4: Node with temperature dependent losses in fig. 1 and have been calculated as follows [2],
[3].
• Node without any properties, such as end cap
air (AIA and AIB)
• Node with thermal capacity, such as the parts
of the housing (HOA, HOB, HOM)
• Node with thermal capacity and losses (without temperature dependent correction), such
as the stator yoke (SYO); see fig. 3
• Node with thermal capacity and losses (with
temperature dependent correction), such as
the stator slots (SSL); see fig. 4
Temperature dependent correction is done by the
following formula:
Losses (T ) = Losses (T0 ) [1 + α (T − T0 )]

(1)

where T0 designates the reference temperature at
which the temperature dependent copper losses
have been calculated.
Two types of thermal conductances have been
used:

• Thermal conductances in a homogenous region:
1
A
=λ
(2)
Rth
l
where λ designates the material specific thermal conductivity, A is the cross section and l
is the length of heat conduction.
• Thermal conductances of heat transfer at a
surface between solid and coolant flow:
1
= αA
Rth

(3)

where α designates the heat transfer coefficient which is dependent on coolant properties as well as the velocity of coolant flow and
A is the surface area.
• Thermal capacity:
C = mc

(4)

where m is the mass of the considered region
and c is the material specific heat capacity.

• Modelica.Thermal.HeatTransfer.ThermalConductor with constant thermal
Heat transfer between cooling ribs and air flow
conductance
was also modelled in three axial sections, using the
elements of the SimpleFlow -library to describe the
• Modelica.Thermal.HeatTransfer.Convection where the actual thermal con- air flow. Air flow rate is adjusted proportional to
ductance is prescribed by a signal input. the actual machine speed.
The Modelica Association

216

Modelica 2005, March 7-8, 2005

Simulation of a thermal model of a surface cooled squirrel cage induction machine by means of the
SimpleFlow-library
uvs









uss
ys
xs
 
 
 
 

ws
vs

s

ts

uss
z{|} ~|{ 





uts





vss

Figure 5: 18.5 kW squirrel cage induction machine Figure 6: Simulated (S) and measured (M) stator
with nickel-chromium-nickel temperature sensors slot (SSL) and stator tooth (STO) temperature
and temperature recorder


5

Measurement

¯®
­¬
¦©
¥ª«
©¦
¨§
¥¦

Measurements were carried out for a four pole,
18.5 kW squirrel cage induction machine with surface cooling. The machine is shown in fig. 5. The
stationary parts of the machine were equipped
with nickel-chromium-nickel temperature sensors:

°±²
°» ²
°±²
°» ²



³´µ´¶· ¸¶¹º
³´µ´¶· ¸¶¹º
¼¶½³¾¿À Á
¼¶½³¾¿À Á
















 ¡ ¢ £ ¤
• one sensor in the stator slot (two additional
PT-100 sensor were already available in this
machine)
Figure 7: Simulated (S) and measured (M) stator yoke (SYO) and stator housing, A-side (HOA)
• one sensor in a stator tooth
temperature

• three sensors in the winding head of each side
of the machine in order to average the measured temperature in these areas

6

Simulation and Measurement
Results

• one sensor in the stator yoke

Some results of computer simulation (S) and measuring (M) are compared in fig. 6–10. The investi• one sensor on each side of the end cap air (A- gations refer to continuous duty with intermittent
side and B-side)
periodic loading (duty cycle S6). The motor was
loaded with 140% of nominal load for four minutes
• three sensors in the housing (A-side, middle, and no-load for six minutes.
B-side)
Simulations and measurements match both qualitatively and in quantity.
• one sensor for ambient temperature

7

Conclusions

• one sensor for the air temperature in the cooling ribs at the B-side (blow-in)
A detailed thermal equivalent circuit of
an asynchronous induction machine with
• one sensor for the air temperature in the cool- squirrel cage was persented.
The machine
ing ribs at the A-side (blow-out)
model was built using components from
The Modelica Association

217

Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer, M. Plainer

Modelica.Thermal.HeatTransfer.
This
package does not cover the mechanisms of heat
transport through a coolant flow, though. ThereÄÂÂ
ÚÙ
fore, SimpleFlow -library was developed, which
Ø×
is intended to handle applications like cooling of
ÑÔ ÈÂ
electric machines in a simple way. Other appliÖ
ÐÕ
ÔÑ ÇÂ
cations which do not fulfill the assumptions of
ÓÒ
SimpleFlow -library have to use the more complex
ÐÑ
ÛÜÝ
Þßàáßàâ
ãäåá
æ
Modelica.Fluid and Modelica.Media libraries.
ÆÂ
Ûç Ý Þßàáßàâ ãäåá æ
Since the application presented in the example
meets the assumptions of SimpleFlow -library
ÅÂ
Â
ÃÂ
ÄÂÂ
ÄÃÂ
ÅÂÂ
very well, the simulation results match with
ÉÊËÌ ÍËÊÎ Ï
measurements.
The SimpleFlow -library is also suitable for other
Figure 8: Simulated (S) and measured (M) temcooling types of electrical machines. Models for
peratures of winding head, A-side (WHA)
such cooling circuits (e.g. open circuit ventilated)
are under test. The determination of the relevant
parameters is going to be performed with a speêëè
cific precalculation software which is currently developed.
êèè
Models simulating the temperature rise of electriÿ
cal machines are a very important application beþý
cause they lead to design optimizations and com÷ú îè
petitive advantages.
öûü
ÄÅÂ

ú÷
ùø
ö÷

íè

ëè

References

   	
 
   	
 

ìè
è

éè

êèè
ïðñò óñðô õ

êéè

[1] G. Rippar and B. Zechmeister, “Simulation of
networks of heat sources (in German),” ElinZeitschrift, vol. 1, no. Heft 1, 1971.

ëèè

Figure 9: Simulated (S) and measured (M) tem- [2] VDI-Gesellschaft für Verfahrenstechnik und
Chemieingenieurswesen,
VDI-Wärmeatlas.
peratures of winding head, B-side (WHB)
Berlin: Verlag Springer, 2002.


&%
$#

"

!






[3] Dubbel Interaktiv 2.0. Verlag Springer electronic media, 2002.

'( ) *+,-./ .01 2
'3 ) *+,-./ .01 2



[4] G. Merker and C. Eiglmeier, Fluid- und
Wärmetransport
–
Wärmeübertragung.
Stuttgart, Leipzig: B.G. Teubner, 1999.



[5] G. Merker and C. Baumgarten, Fluid- und
Wärmetransport – Strömungslehre. Stuttgart,
Leipzig, Wiesbaden: B.G. Teubner, 2000.










   



[6] H. Elmqvist, H. Tummescheit, and M. Otter,
“Object-oriented modeling of thermo-fluid systems,” Modelica Conference, 2003.



Figure 10: Simulated (S) and measured (M) temperatures of end cap, A-side (AIA)

The Modelica Association

218

Modelica 2005, March 7-8, 2005

Modelling Heat Exchangers by the Finite Element Method with Grid Adaption in Modelica

Modelling Heat Exchangers by the Finite Element Method with
Grid Adaption in Modelica
Stefano Micheletti∗, Simona Perotto∗, Francesco Schiavo†
Politecnico di Milano,
P.zza Leonardo da Vinci 32
20133 Milano, Italy

Abstract

PDEs discretization, adopting either a finite volume
method (FVM) or a finite element method (FEM), with
In this paper we present a new Modelica model for different strategies for single-phase or two-phase fluid
heat exchangers, to be used within the ThermoPower flow [5]. Furthermore, a moving-boundary evaporator
library. The novelty of this work is a combined em- model has been recently added to the library.
ployment of finite elements with grid adaption.
The modelling of a generic single-phase 1-D heat exchanger is discussed, along with its approximation via In this paper we present a new model for single-phase
the Stabilized Galerkin/Least-Squares method. The HEs, based on the use of the finite element method
grid adaption procedure is first introduced from a gen- with grid adaption. The objectives of this work are
eral viewpoint and then within the Modelica frame- twofold: to develop a new HE model with high accuracy and reduced computational complexity and to
work. Finally, some preliminary results are shown.
show how complex mathematical techniques can be
successfully used in Modelica for the modelling of
distributed-parameters physical systems.
1 Introduction
Heat exchangers (HEs) play a relevant role in many
power-production processes, so that their accurate
modelling, at least for control-oriented analysis, is a
key task for any simulation suite [13].
Accurate modelling of such devices is usually a complex task, the reason being that the control-relevant
phenomena are associated with thermal dynamics described by Partial Differential Equations (PDEs). On
the other hand, different complexity levels of representation may be necessary, depending on the specific
simulation experiment to be performed.
Within this framework, the power-plant modelling library ThermoPower [5] exploits the Modelica language modularity features, offering to the users several interchangeable component models, with varying
levels of detail.
As for the HEs, the models currently provided are differentiated by the numerical scheme employed for the

The proposed model is an improvement of the actual
FEM model [6], obtained by a grid adaption technique: the grid nodes (i.e., the points where the solution is computed) change their positions so as to adapt
dynamically to the solution variations. Such model
can significantly improve the modelling accuracy, by
removing the non-physical solution oscillations observed for the actual FEM model, whilst using fewer
nodes and containing the computational burden.

The paper is organized as follows: in Section 2.1 we
recall the modelling of a generic single-phase 1-D heat
exchanger, while in Section 2.2 we discuss its approximation via the Stabilized Galerkin/Least-Squares
method. In the third section the grid adaption problem
is introduced from a general viewpoint, while in Section 4 we address the moving mesh method on which
the Modelica implementation, analyzed in Section 5,
∗ MOX,
Dipartimento di Matematica “F. Brioschi”, is based. Some preliminary numerical results are pro{stefano.micheletti,simona.perotto}@mate.poli
vided in Section 6. Finally, the last section draws
mi.it
† Corresponding author, Dipartimento di Elettronica e Infor- some conclusions and outlines possible future developments.
mazione, francesco.schiavo@elet.polimi.it
The Modelica Association

219

Modelica 2005, March 7-8, 2005

S. Micheletti, S. Perotto, F. Schiavo

2 The Heat Exchanger Model

momentum and energy can be formulated as follows:

In the context of object-oriented modelling, it is convenient to split the model of a generic heat exchanger
(HE) into several interacting parts, belonging to three
different classes [5]: the model of the fluid within a
given volume, the model of the metal walls enclosing
the fluid and the model of the heat transfer between the
fluid and the metal, or between the metal and the outer
world. In this paper, we focus on the modelling of the
first class. We improve the framework proposed in [6]
by introducing suitable grid adaption techniques.
The model presented in this paper can represent singlephase HEs, which constitute a significative part of the
industrial applications (e.g., the primary side of a Pressurized Water Reactor nuclear power plant [3]). However, also two-phase flows could be handled as well.

2.1 The Fluid Model
Let us deal with a compressible fluid within a pipeshaped volume V with a rigid boundary wall, exchanging mass and energy through the inlet and outlet
flanges, and thermal energy through the lateral surface.
We assume that

∂ρ ∂w
+
= 0,
∂t ∂x
1 ∂w ∂p
dz C f ω
w|w| = 0 ,
+ + ρg +
A ∂t ∂x
dx 2 ρA3
∂h w ∂h 1 ∂p ω
+
=
+
φe ,
∂t ρA ∂x ρ ∂t ρA

A

(1)
(2)
(3)

where A is the pipe cross-sectional area, ρ the fluid
density, w the mass flow-rate, p the fluid pressure, g
the acceleration of gravity, z the pipe height, C f the
Fanning friction factor, ω the wet perimeter, h the specific enthalpy, φe the heat flux entering the pipe across
the lateral surface. The fluid velocity can be defined
as u = w/(ρA). Notice that in (2) and (3) we have neglected the kinetic and the diffusion term, respectively.
In the case of water-steam flows it is convenient to
choose the pressure and the specific enthalpy as the
thermodynamic state variables, so that the expressions
of the balance equations have the same form for singlephase and two-phase flows [12]: thus all the fluid properties, such as the temperature T , the density ρ and the
partial derivatives ∂ρ/∂h and ∂ρ/∂p can be computed
as functions of p and h.

• the longitudinal dimension x is far more relevant 2.2 The Approximation Procedure
than the other two;
In view of power generation plant modelling, the most
relevant phenomenon is described by equation (3), so
• the volume V is “sufficiently” regular (i.e., the that the focus for the present paper is the approximacross-sectional area is uniform and V is such that tion of this latter by FEM and grid adaption. Actuthe fluid motion along x is not interrupted);
ally, the mass and momentum equations (1) and (2) describe the fast pressure and flow rate dynamics, while
• there are no phase-changes (that is the fluid is al- the energy one (3) describes the slower dynamics of
ways either single-phase or two-phase);
heat transport by the fluid velocity. These faster modes
are typically not taken into account in HEs modelling
• the Reynolds number Re is such that turbulent [6]. In particular, note that, assuming the pressure p
flow conditions are assured along all the pipe, uniform along x (with possible jumps at the HE boundwhich in turn guarantees almost uniform veloc- ary) and neglecting the inertial term ∂w/∂t in (2), the
ity and thermodynamic state of the fluid across integration of the mass and momentum balance equations (1) and (2) is reduced to
the radial direction.
Notice that, when water or steam is assumed as the
working fluid, the last hypothesis does not hold at
very low flow rates (laminar flow regime). However,
in practice, most industrial processes never operate in
such conditions.
Under the hypotheses above it is possible to define all
the thermodynamic intensive variables as functions of
the longitudinal abscissa x and time t. Within this
framework, the dynamic balance equations for mass,
The Modelica Association

win − wout = A
pin − pout

Z L
∂ρ

dx ,
∂t
= ∆pF + ∆pH ,

(4)

0

(5)

where win , wout , pin , and pout are the mass flow-rate
and pressure at the HE inlet and outlet, while ∆pF and
∆pH are the pressure drops due to friction and fluid
head, respectively. For further details on the approximation for equation (1) and (2) we refer to [6].

220

Modelica 2005, March 7-8, 2005

Modelling Heat Exchangers by the Finite Element Method with Grid Adaption in Modelica

dependent. This unavoidably leads to an increase of
the number of unknowns since the displacement of the
grid nodes is to be determined as well.
As for the test functions involved in the GALS method,
they are defined by
ψi (x,t) = ϕi (x,t) ±

Figure 1: Some typical hat functions
Equation (3) is discretized with the stabilized PetrovGalerkin method GALS (Galerkin/Least-Squares), using suitable Dirichlet weak boundary conditions at the
inflow [11].
We refer to [6] for further details about the application
of the GALS method to heat exchangers.
In the following we provide some details about the approximation procedure by means of piecewise linear
finite elements of equation (3), while referring to [16]
for an exhaustive coverage of the finite element approximation theory.
We remark that we generalize the standard GALS
method to the case of time-dependent shape and test
functions, since, using the grid adaption strategy, the
length of each mesh element varies in time.
Let the spatial domain [0, L] be subdivided into N − 1
elements identified by N (≥ 3) nodes. The length of
the i-th element is denoted as `i (t), while the abscissa
of the i-th node is indicated in the sequel with δi (t).
On this partition we introduce the space of the piecewise linear functions, whose typical basis (hat) functions are shown in Fig. 1.
Their analytical expressions are the following:
ϕ1 (x,t)


 δ2 (t) − x
=
 `1 (t)
0

ϕi (x,t)

where α (0 ≤ α ≤ 1) is a stabilization coefficient. Notice that for α = 0 the standard (i.e., non-stabilized)
method is obtained.
For the reader’s ease, we provide also the expression of
the time derivative ϕ̇i = ∂ϕi (x,t)/∂t of the basis function ϕi , namely

− δ̇i−1 − (x − δi−1 ) `˙i−1





`2i−1

ϕ̇i (x,t) =
δ̇i+1 − (δi+1 − x) `˙i




`2i


0

δi < x ≤ δi+1 ,
otherwise .
(9)

N

h(x,t) = ∑ hi (t)ϕi (x,t) = h(t)T ϕ(x,t), h = [h1 · · · hN ]T ,
i=1
N

ρ(x,t) = ∑ ρi (t)ϕi (x,t) = ρ(t)T ϕ(x,t), ρ = [ρ1 · · · ρN ]T ,
i=1
N

w(x,t) = ∑ wi (t)ϕi (x,t) = w(t)T ϕ(x,t), w = [w1 · · · wN ]T ,
i=1
N

i=1

(10)

otherwise ,

with ϕ̄(x,t) = [ϕ1 (x,t), · · · , ϕN (x,t)]T .
Applying the GALS finite element method to (3) leads
to the following set of N ODEs:
N

Z L

δi−1 (t) < x ≤ δi (t) ,

∑ ḣi ϕi

0

δi (t) < x ≤ δi+1 (t) ,

with i = 2, · · · , N − 1 and where
i−1

∑ ` j (t) , for i = 1 . . . N .

(7)

∂Ωin

ṗ

0

∑Ni=1 ρi ϕi

Z

Notice that, in view of the grid adaption procedure, the
basis functions defined in (6) are both space and time
221

Z L

∂Ωin

0

N

∑ hi ϕ̇i

!
ψ j dx+

i=1

!
dϕi
∑ hi dx ψ j dx+
i=1
!

∑Ni=1 wi ϕi
A ∑Ni=1 ρi ϕi

Z L

j=1

ψ j dx +

∑Ni=1 wi ϕi
A ∑Ni=1 ρi ϕi

0

otherwise ,

!

i=1

Z L

(6)

The Modelica Association

δi−1 < x ≤ δi ,

Let us expand the quantities h, ρ , w, φe in terms of the
basis functions ϕi as:

Z

δi (t) =

(8)

φe (x,t) = ∑ φi (t)ϕi (x,t) = φ(t)T ϕ(x,t), φ = [φ1 · · · φN ]T ,

0 ≤ x ≤ `1 (t) ,


 x − δN−1 (t)
δN−1 (t) < x ≤ L ,
ϕN (x,t) =
 `N−1 (t)
0
otherwise ,

x − δi−1 (t)




 `i−1 (t)
δi (t) − x
=



`i (t)


0

α ∂ϕi (x,t)
,
2
∂x

N

N

∑ hi ϕi

ψ j dx =

Z L

ω ∑Ni=1 φi ϕi

0

A ∑Ni=1 ρi ϕi

i=1

ψ j dx +

!
∑Ni=1 wi ϕi
hin ψ j dx,
A ∑Ni=1 ρi ϕi

!
ψ j dx+

∀ψ j with j = 1, · · · , N ,
(11)

Modelica 2005, March 7-8, 2005

S. Micheletti, S. Perotto, F. Schiavo

where hin is the fluid specific enthalpy at the inflow of FEM, can be cast into the framework of model reboundary ∂Ωin . Such set of ODEs can be represented duction, i.e., the approximation by a finite dimensional
by the following compact matrix notation:
model of a conceptually infinite dimensional one. Several parameters (e.g., the mesh spacing, the degree of
1
1
ω
1
M h˙ + MD h + F h + C h = R ṗ + Y φ + K w , (12) the polynomial finite elements, tuning parameters reA
A
A
A
lated to the discretization procedure) govern the acwhere M, MD , F, C, R, Y , K are defined as follows:
curacy of the approximation. As an effective tool
to assess such approximation property, some estimaZ L
Z L
tors/indicators, as the local cell residual, are typically
M ji =
ϕi ψ j dx , MD ji =
ϕ̇i ψ j dx ,
employed [1, 9, 18]. Once the error indicator has been
0
0
computed on a given mesh, the information that it conZ L N
∑k=1 wk ϕk dϕi
tains can be used to generate a better mesh that gives
Fji =
ψ j dx ,
N
0 ∑k=1 ρk ϕk dx
more accuracy. This is the basis of adaptive error conZ
trol.
∑Nk=1 wk ϕk
C ji =
ϕi ψ j dx ,
N
Many engineering problems are characterized by solu∂Ωin ∑k=1 ρk ϕk
tions exhibiting a complex structure, e.g., singularities
Z L
Z L
ϕi
ψj
near corners, boundary layers or shocks. In such cases,
dx
,
Y
=
ψ
dx
,
Rj =
ji
j
N
N
0 ∑k=1 ρk ϕk
0 ∑k=1 ρk ϕk
the idea is to distribute the mesh spacings according
Z
hin
to local features of the solution, that is to concentrate
ϕi ψ j dx .
K ji =
N
in
the elements in the regions where the solution changes
∂Ω ∑k=1 ρk ϕk
(13) rapidly and, vice versa, to coarsen them where the solution is smoother, with the aim of obtaining a solution
The matrices C and K, which enforce the boundary sufficiently accurate and with a reasonable computaconditions into equation (12), depend on the inflow tional load.
boundary ∂Ωin . It can be noted that, as we are consid- Typically an adaptive error control procedure consists
ering the 1-D case, the inflow boundary is constituted,
of a discretization method combined with an adaptive
at most, by the points x = 0 and x = L, depending on
the sign of w = win . Thus the only test functions that algorithm. There are three main types of adaptive techare non-zero at the inflow are ψ1 and ψN and the only niques for FEM: i) the h-method: the mesh is refined
and coarsened locally according to certain error esnon-vanishing entries of the matrices C and K are
timators; ii) the p-method: the polynomial degree is

!

w
α
1

chosen in each element according to some smoothness
1−
w|x=0 > 0 ,
C11 =
ρ1
2
indicator; iii) the r-method: the element vertices are


0
otherwise ,
relocated to concentrate them in desired regions on the
basis of a monitor function.

!

α
 wN
In the following we focus on this last philosophy
1+
w|x=L > 0 ,
CNN =
ρN
2
which is usually referred to as moving mesh method


0
otherwise ,
[7, 10, 14, 15, 17]. In this method, a mesh equation in
!
(14)
volving the nodes speed is solved to compute the mesh

α
 hin |x=0
1−
w|x=0 > 0 ,
points location together with the solution of the differK11 =
ρ1
2


ential equation at hand. In principle, starting from a
0
otherwise ,
given mesh, the idea is to move the mesh nodes, while

!
keeping their number fixed, towards regions of rapid

α
 hin |x=L
1+
w|x=L > 0 ,
solution variations, e.g., steep wave fronts and shocks.
KNN =
ρN
2



0

otherwise .

3.1

Grid Adaption as a Control Problem

The matrices C and K are consequently diagonal.

An interesting point of view to tackle the grid adaption procedure is to state it as a control problem. As a
matter of fact, the grid adaption is based on a feedback
3 The Grid Adaption Philosophy
mechanism that can be represented as in Fig. 2.
The discretization of complex phenomena described Within this framework, the process is represented by
by systems of partial differential equations by means the N ODES obtained from GALS discretization, the
The Modelica Association

222

Modelica 2005, March 7-8, 2005

Modelling Heat Exchangers by the Finite Element Method with Grid Adaption in Modelica

Figure 3: The spring model for grid adaption
Figure 2: Grid adaption as a control problem
sensor is represented by some estimate of the discretization error and the controller is defined by the
grid adaption strategy. The time-varying boundary
values for the HE (hin and win ) and the heat flux entering its lateral surface (φe ) are, from the point of view
of feedback grid adaption, process disturbances, while
the length of the elements (`i ) can be regarded as the
(vectorial) control variable `.
The aim of the control system is to minimize the estimated error. In this paper we adopt the equidistribution principle [2] to design the controller (i.e., the
mesh adaption strategy): the aim is to dynamically obtain an equidistributed error over the elements.

4

The Moving Mesh Method in Modelica

The application of the GALS method to equation (3)
leads to a set of N ODEs whose unknowns are the
nodal values for the fluid specific enthalpy. Moreover, due to the grid adaption strategy, we have to include other N − 1 unknowns, i.e., the lengths `i of the
elements. The coupled equations yield the so-called
DAE-system.
The mesh point positions have to be calculated in such
a way that

to correct such values so that the constitutive and completeness constraints are satisfied.
On the other hand, when dealing with a declarative
language such as Modelica, a different approach has
to be taken: the constitutive and completeness constraints have to be intrinsically fulfilled. Such result
can be easily obtained using a physical approach for
the implementation of the adaption procedure.
Let us consider Fig. 3: each element can be identified
with a spring of length `i and specific elastic constant
ki , with the first and the last spring fixed to the domain
boundaries x = 0 and x = L, respectively.
Let Fi, j be the force that the i-th spring exerts on the
j-th one. Usually it is assumed that
Fi, j = 0 ∀ j 6= i − 1, i + 1 ,

(15)

that means that each spring interacts only with the two
adjacent ones. Furthermore, the force that two adjacent springs exert on each other can be expressed as
Fi,i+1 = ki `i

Fi+1,i = ki+1 `i+1 .

(16)

Supposing that the spring constants ki are nonnegative, an effective choice for the unknowns `i in
terms of the ki is:
`i =

ki
L,
N−1
∑ j=1 k j

∀i = 1···N −1 .

(17)

This automatically guarantees the completeness constraint as

1) the length of each element is strictly positive (constitutive constraint: `i > 0 ∀ i = 1 · · · N − 1 , ∀t ≥ 0 );

N−1

N−1

ki
L
N−1
i=1 ∑ j=1 k j

∑ `i = ∑

i=1

= L.

(18)

2) the total length of the elements is equal to L (com- Moreover, if all the spring constants are positive, then
pleteness constraint: ∑N−1
the constitutive constraint is fulfilled as well. It is imi=1 `i = L , ∀t ≥ 0 ).
portant to notice that such strategy is independent of
These constraints can be easily fulfilled when dealing the particular grid adaption procedure at hand.
with imperative languages (i.e., algorithm oriented). To make effective the chosen adaption procedure it is
In such a case, a specific grid adaption procedure is necessary to relate the elastic constants ki to the local
first allowed to yield a mesh characterized by values monitor function εi , as
for the lengths `i “illegal” with respect to the criteria
1) and 2). Then a suitable refinement algorithm is used
The Modelica Association

223

ki =

1
, ∀i = 1, · · · , N − 1 .
`i εi

(19)

Modelica 2005, March 7-8, 2005

S. Micheletti, S. Perotto, F. Schiavo

The strategy we adopt aims at concentrating the grid
points in the domain regions where the monitor function ε is larger. This can be justified by analyzing equations (19) and (17): the larger the monitor function,
the smaller the associated spring constant and, consequently, the smaller the length of the corresponding
element.
The monitor εi is usually defined as a function of a
“residual”, identified in the sequel with the symbol ζi ,
directly related to the approximate solution obtained
with the GALS method.
The monitor function εi = εi (ζi ) can be chosen arbitrarily, provided that it is definite positive, though it is
much more effective when it monotonous as well.
One of the most used monitor function sharing these
properties is the so-called arclength [4], given by

4.1

Definition of the Residual

The residual definition is a key choice in the grid adaption framework. When using the arclength monitor
function, a common choice for the residual is the approximate gradient:
ζi =

hi+1 − hi ∂h
≈ ,
`i
∂x

∀i = 1, · · · , N − 1 .

(22)

This choice aims at concentrating the grid points within
the regions where large solution variations occur. This
implicitly assumes that the discretization error is large
in such areas.
However, in case of problems with a “sharp-but-notsteep” solution, it has been shown that the arclength
monitor function with approximate gradient given by
(22) performes poorly (see [10]). In such a case, a better approximation can be obtained using the curvature
q
2
εi = 1 + µ ζi ,
(20) monitor function (21) with a second order approximation of the 2nd order spatial derivative:
where µ is a positive coefficient used to “tune” the grid
hi+1 − 2hi + hi−1 ∂2 h
adaption.
≈ 2 , ∀i = 1, · · · , N − 1 , (23)
ζi =
∂x
`2i
In [7] it is shown that this choice yields good results
when applied to transport equations.
where it is understood that h0 = hin .
Another example of monitor function, successfully
used in [10], is the curvature monitor function, given In [14], it is shown that, for problems involving more
than one moving front in the solution, the use of the
by
q
curvature monitor function can lead to better results
(21)
εi = 4 1 + µ ζ2i .
than the use of the arclength one.
In this paper we show results obtained with grid adapUsing the arclength or the curvature monitor function, tion based on these two residual definitions and moniparticular care has to be taken in the choice of the tor functions.
parameter µ, since it is a sort of “gain” of the mesh
controller: the larger µ, the faster the grid adaption
becomes (see Fig. 2). The value of such parameter 5 Modelica Implementation
can either be fixed or tuned by the user. In this latter
case, lower and upper bounds for µ should be provided, The developed model has been implemented in a Modsince a low value can make the adaption mechanism elica component called Flow1DfemAdapt which is
too weak and then useless, while a too large value can going to be included within the library ThermoPower
negatively affect the numerical stability of the adap- [5]. The component is perfectly interchangeable with
the actual library components for 1-D HEs, since it
tion algorithm.
The tuning of the parameter µ becomes even more crit- uses the same connectors: two flanges for fluid flow
ical when using a fixed time-step explicit method to and a terminal for heat flux (Fig. 4).
solve the resulting non-linear DAE system, which is
often the case when simulating industrial plants in connection with the control system [3]. Such sensitivity
depends on the fact that, somehow, the parameter µ
regulates how “fast” the grid adaption is: a large value
makes the adaption too fast, thus introducing dynamics with time constants significantly smaller compared
with the fixed time step, resulting in a numerical instability.
The last step to complete the grid adaption scheme is
the definition of the residual ζi over the elements.
The Modelica Association

224

Figure 4: Component Icon
Modelica 2005, March 7-8, 2005

Modelling Heat Exchangers by the Finite Element Method with Grid Adaption in Modelica

The Modelica implementation is quite close to the one
presented in [6] with some difference in the energy
equation and completed with the equations for the grid
adaption.
The discretized energy equation contains a new term:

which is followed by a valve and by an ideal pressure sink. An ideal heat-flux source is connected to
the HE distributed heat-flux terminal. Such setup has
been selected in order to highlight the differences of
the approximation schemes on the HE outlet specific
enthalpy.
M*der(h)+(MD+F/A)*h+C/A*h=R*der(p)+
Y*omega/A*phi+K/A*w;
The HE internal pressure is held constant since the
mass flow-rate and the valve opening are set to a fixed
where the additional tridiagonal matrix MD is coded
value and the sink pressure is constant as well. Thus,
with nested “for” loops as shown in [6].
The selection of the residual and of the corresponding supposing the specific enthalpy of the fluid within the
monitor function depends by the user via the integer HE does not vary substantially, it is possible to assume
parameter Residual:
that the fluid density is almost constant.
In case the heat-flux is set to zero as well, it is possible
if Residual==1 then
for i in 1:N - 1 loop
to show that the analytical solution for the transport
res[i] = (h[i+1] - h[i])/l[i];
equation (3) is a ramp-wave travelling along the HE
err[i] = sqrt(1+mu*res[i]ˆ2);
with constant velocity u. It is then possible to evalend for;
else
uate the model approximation performances with an
res[1]=(h[i + 1] - 2*h[i]+hin)/l[i]ˆ2;
a-posteriori error indicator, evaluating the square deerr[1] = (1+mu*res[1]ˆ2)ˆ0.25;
for i in 2:N - 1 loop
viation
res[i] = (h[i+1]-2*h[i]+h[i-1])/l[i]ˆ2;
err[i] = (1+mu*res[i]ˆ2)ˆ0.25;
end for;
end if;

Z t

E(x) =

2
ĥ(x,t) − h(x,t) dt ,

(24)

0

Finally, the length of the elements is obtained solving
of the approximate solution h from the analytical one
the following N − 1 algebraic equations:
ĥ.
for i in 1:(N - 1) loop
The indicator E is spatially distributed, so we extract
k[i] = 1/(err[i]*l[i]);
from it two different indicators:
l[i] = k[i]/sum(k)*L;
end for;

Z L

IE =

E(x) dx ,
0

6

(25)

OE = E(x)|x=L ,

Simulations

In this section we show simulation results in order to
evaluate the different performances of the grid adaption strategies. All the simulations have been performed within the Dymola [8] simulation environment.

denoting the integral error (IE) and the output error
(OE).
For the sake of approximation, as we compute the
square deviation E(x) at the grid points only, the indicator IE is evaluated via a linear piecewise interpolation.
The numerical data employed for the HEs modelling
are the length L = 10 m and the cross-sectional area
A = 3.14 · 10−4 m2 . The heat-flux φe is set to zero. The
fluid entering the HE is liquid water at pressure p =
105 Pa, with initial specific enthalpy hin = 105 J/Kg
and flow rate win = 1 Kg/s. Thus, the transit time turns
out to be 31.25 s.
The time-integration of the system is performed with
a fourth order Runge-Kutta scheme with a fixed time
step Ts = 0.1 s. The chosen time step turns out to be adequate for the simulations of the dynamics represented
Figure 5: Reference Simulation Layout
by (3) [3].
The first test case aims at checking the effectiveness of
The reference simulation layout is shown in Fig. 5, the grid adaption strategy when abrupt changes of the
consisting in an ideal flow source connected to a HE solution are involved.
The Modelica Association

225

Modelica 2005, March 7-8, 2005

S. Micheletti, S. Perotto, F. Schiavo

Table 1 clearly shows that, for the case at hand, the solution obtained with the proposed grid adaption strategy with relatively few nodes (N = 10) is a far better
approximation of the exact solution (at least in term
of the indicators IE and OE) than the ones obtained
with FVM and FEM with a number of nodes N = 20
or N = 50. However, the computational overhead due
to grid adaption is not negligible, as highlighted by the
CPU time column.
The results show that the use of the proposed grid
adaption strategy is convenient when the demand on
the accuracy of the solution is relatively strong. This
can be obtained by a small number of mesh nodes
though the CPU time can increase. Alternatively, standard FVM or FEM can be employed but a higher number of nodes is required to obtain the same level of acFigure 6: Approximate enthalpy provided by three differ- curacy.
ent numerical schemes and exact enthalpy

The time interval of the simulation is chosen as
[0, 60] s. The inflow enthalpy hin is described by a
ramp function with a rising time of 1 s starting at 1 s.
The corresponding increment of the enthalpy is of the
5% of the initial value.
In Fig. 6 the HE outlet specific enthalpy associated
with three different numerical schemes is compared
with the exact solution (blue line). In particular the
cyan, the red and the green lines correspond to the
finite volumes (20 nodes), finite elements (20 nodes)
and finite elements with grid adaption based on the arclength monitor function (10 nodes). The “gain” of the
mesh controller has been set to the value µ = 3.5 · 10−4
after several simulations as a trade-off between accuracy and numerical stability.
Fig. 6 shows that grid adaption with arclength monitor function can significantly improve the quality of
the approximation. On the other hand, to thoroughly
compare the three proposed algorithms, their computational effort has to be taken into account as well, since
the grid adaption procedure is not cost-free. A full
comparison of the various methods is summarized in
Table 1.
Method
FVM
FEM
FEM
FEM+GA
FEM+GA

N
20
20
50
10
15

CPU time
0.302 s
0.356 s
1.06 s
0.579 s
1.109 s

OE
3.59 · 107
7.50 · 106
2.61 · 106
4.64 · 105
4.37 · 105

The second test case shows that the good results obtained with grid adaption using the arclength monitor
function do not hold when the curvature monitor function is used, as can be seen by the curves in Fig. 7. The
simulation time interval is now chosen as [0, 80] s. The
inflow enthalpy hin is represented by a function characterized by three stages: a raising ramp from t = 1 s
to t = 2 s, a plateau during 18 seconds, a decreasing
ramp from t = 20 s to t = 21 s. The net increment of
the enthalpy is the 5% of the initial value, while the final value coincides with the initial one. The “gain” of
the mesh controller has been chosen equal to 3.5· 10−4
and 3.5· 10−8 for the arclength and the curvature monitor function, respectively. Larger values of µ for the
curvature choice lead to numerical instabilities.

IE
6.98 · 107
1.71 · 107
1.65 · 107
8.39 · 106
2.43 · 106

Figure 7: Approximate enthalpy provided by four different
Table 1: CPU time, output and integral error
The Modelica Association

numerical schemes and exact enthalpy

226

Modelica 2005, March 7-8, 2005

Modelling Heat Exchangers by the Finite Element Method with Grid Adaption in Modelica

The CPU time and the values of IE and OE are gathered in Table 2.
While for the arclength monitor function similar considerations as in the previous test case hold, we note
that the technique based on the curvature monitor
function does not introduce significant benefits, concerning both the CPU time and the accuracy (compared, for instance, with the FEM case with N = 20).
Method
FVM
FEM
FEM+GA∗
FEM+GA†
∗
†

N
20
20
10
10

CPU time
0.515 s
0.546 s
0.622 s
0.719 s

OE
7.55 · 107
1.51 · 107
2.72 · 106
2.54 · 107

IE
1.41 · 108
7.97 · 107
3.44 · 107
1.79 · 108

Arclength monitor function
Curvature monitor function

Table 2: CPU time, output and integral error
In the last test case we study the effect of the grid adaption on the approximate solution under a sudden cooling of the lateral surface of the HE. The time interval is
[0, 120] s. The inflow enthalpy hin is the same as in the
first case, while at t = 60 s the heat-flux is decreased
with a step variation to φe = −795W /m2 , i.e. 500W
are lost through the lateral surface of the HE.
Assuming that the fluid density is approximatively
constant, the exact solution for the outlet enthalpy is
the delayed inlet increasing ramp followed by a decreasing ramp starting at t = 60 s.

It turns out that grid adaption significantly improves
the quality of the solution with respect to FEM or FVM
when abrupt changes are involved, while the difference is less evident where the solution is smooth.

7

Conclusions and Future Work

In this paper we present a new model for 1-D singlephase heat exchangers in Modelica. The model, fully
compatible with the ones already available within the
library ThermoPower, is based on an approximation
of the energy balance equation by the GALS finite element method with grid adaption.
The mathematical model and its approximation have
been addressed in detail, as well as the grid adaption
strategy within the a-causal framework Modelica.
The effectiveness of the proposed technique has been
assessed on some test cases and compared with the
standard FV and FE methods. The main conclusion is
that grid adaption turns out to be effective when high
accuracy is required. In more detail, even if the “placement” of each mesh node is more expansive in terms
of CPU time, a smaller number of nodes is required to
guarantee a certain level of accuracy, compared with
FVM and FEM.
Future work will be devoted to a more theoretically
sound selection of the optimal value for the “gain” µ
of the mesh controller. Moreover, the employment of
a dynamical residual will be further investigated.

References
[1] R. Becker and R. Rannacher. An optimal control approach to a posteriori error estimation in
finite element methods. Acta Numerica, 10:1–
102, 2001.
[2] C. Boor. Good Approximation by splines with
variable knots. Springer Lecture Notes Series
363. Springer Verlag, 1973.

clength monitor function)

[3] A. Cammi, F. Casella, M.E. Ricotti, F. Schiavo,
and G.D. Storrick. Object-oriented simulation
for the control of the IRIS nuclear power plant.
In 16th IFAC world congress, Prague, Czech Republic, July 4-8, 2005.

In Fig. 8 the approximate solution of the three schemes
FVM (N = 20), FEM (N = 20), FEM+GA (N = 10,
arclength monitor function with µ = 3.5 · 10−4 ) is provided together with the exact HE outlet enthalpy.

[4] W. Cao, W. Huang, and R.D. Russel. An radaptive finite element method based upon moving mesh PDEs. Journal of Computational
Physics, 149(2):221–244, March 1999.

Figure 8: Effect of a heat-flux decrease (adaption with ar-

The Modelica Association

227

Modelica 2005, March 7-8, 2005

S. Micheletti, S. Perotto, F. Schiavo

[5] F. Casella and A. Leva.
Modelica open [17] C. Sereno, A. Rodrigues, and J. Villadsen. The
moving finite element method with polynomial
library for power plant simulation: Design
rd
approximation of any degree. Computers &
and experimental validation. In 3 ModelChemical Engineering, 15(1):25–33, 1991.
ica Conference, Linköping, Sweden, November
3-4, 2003. http://sourceforge.net/
[18] R. Verfürth. A review of a posteriori error
projects/thermopower.
estimation and adaptive mesh-refinement tech[6] F. Casella and F. Schiavo. Modelling and simuniques. B.G. Teubner, 1996.
lation of heat exchangers in Modelica with Finite
Element Methods. In 3rd Modelica Conference,
Linköping, Sweden, November 3-4, 2003.
[7] E.A. Dorfi and L.O.’C. Drury. Simple adaptive
grids for 1-D initial value problems. Journal of
Computational Physics, 69:175–195, 1987.
[8] Dymola. Dynamic Modelling Laboratory. Dynasim AB, Lund, Sweden.
[9] K. Eriksson, D. Estep, P. Hansbo, and C. Johnson. Introduction to adaptive methods for differential equations. Acta Numerica, pages 105–158,
1995.
[10] W. Huang, Y. Ren, and R.D. Russell. Moving
mesh methods based on moving mesh partial differential equations. Journal of Computational
Physics, 113:279–290, 1994.
[11] T.J.R. Hughes, L.P. Franca, and G.H. Hulbert.
A new finite element formulation for computational fluid dynamics: VIII. The Galerkin/LeastSquares method for advective-diffusive equations. Computer Methods in Applied Mechanics
and Engineering, 73(2):173–189, 1989.
[12] F.P. Incropera and D.P. DeWitt. Fundamentals
of Heat and Mass Transfer. John Wiley & Sons,
1985.
[13] A. Leva and C. Maffezzoni. Modelling of power
plants. In D. Flynn, editor, Thermal Power Plant
Simulation and Control, pages 17–60, London,
2003. IEE.
[14] Y. Liu. On Model Order Reduction of Distributed
Parameters Models. Licentiate Thesis, Royal Institute of Technology, Stockholm, 2002.
[15] K.K. Miller and R.N. Miller. Moving finite elements, I & II. SIAM Journal on Numerical Analysis, 18(6):1019–1032, 1033–1057, 1981.
[16] A. Quarteroni and A. Valli. Numerical Approximation of Partial Differential Equations.
Springer Verlag, 1997.
The Modelica Association

228

Modelica 2005, March 7-8, 2005

Calculation of Thermophysical Properties in the Modelica Library TechThermo

Calculation of Thermophysical Properties in the Modelica Library
TechThermo

1

PowerPlantTT

Detailed models of
power plant components

models

SolarTT

Solar energy systems

thermal storage systems

models

models

StorageTT

Wolf-Dieter Steinmann
German Aerospace Center
Institute of Technical Thermodynamics
Pfaffenwaldring 38-40, 70569 Stuttgart
wolf.steinmann@dlr.de>
−
Experienced Modelica users should
Abstract
profit from TechThermo primarily by
extending the models provided by the
Many physical models describing thermodynamic
library thus minimizing the extent of
systems require correlations for thermophysical
work spent on implementation of trivial
properties to complete the set of equations. A Modeequations needed for describing a
lica library like TechThermo which is intended for
physical process.
general application in technical thermodynamics
−
by standardization of interfaces the comust include also a set of models for calculation of
operation between model-developers is
thermophysical properties. Since the total number of
improved.
models in TechThermo should be limited, the range
of application for selected model must be as wide as
possible. The models for calculation of thermophysical properties in TechThermo are based on general
concepts which allow the introduction of new working media by modification of a few model paramemodels
ters. Models for calculation of multiphase or multicomponent media are composed of models representing single phase behaviour and mixing models.
Keywords: thermodynamic system; thermophysical
properties;
TechThermo

The TechThermo library

Base library for engineering thermodynamics

1.1

Aims of TechThermo

TechThermo is a basic library for engineering applications in thermodynamics. This basic library provides components which are relevant for the bulk of
applications in this area. TechThermo is complemented by problem-specific libraries which include
components relevant only for a limited scope of application (Figure1). There are different aspects how
TechThermo can improve the efficiency of modelling activities:
−
the library should allow a fast implementation of a model describing the
simulation problem without generation
of additional source code the detailing
of the system may be limited, but this
approach allows fast results and demands only limited knowledge of Modelica or numerical principles

The Modelica Association

Figure 1: Application of basic library TechThermo in combination with problem-specific
libraries
Although it would be comfortable to have a universal thermodynamic library which allows the
modelling of any system by mere composition of
basic models without input of further model equations, this approach was not chosen for TechThermo since the implementation of such a library
seems not to be feasible in practice. Instead, the
aim of TechThermo is to minimize the effort for
supplementary models for a wide range of application.

229

Modelica 2005, March 7-8, 2005

W. Steinmann

1.2

heat exchangers and models representing simplified systems like solar collectors or fuel cells. These two packages
can be regarded as infrastructure for
modelling technical systems.

Structure of TechThermo

Modelica-infrastructure:
Interface
- definition of model interfaces
Source
- models for imposing boundary
conditions
Fundamentals of engineering thermodynamics:
Medium
thermophysical correlations for
working media
Basis
descriptions of fundamental
physical processes
Fundamentals of technical systems:
Component
- models of basic technical units
Subsystem
- simplified models of technical systems
Tab1: The structure of TechThermo
The models of TechThermo are organized in six
main packages and an additional folder with examples. These six packages can be attributed to one of
three different groups:
−

−

−

package Interface and package Source
include the models which are needed for
the exchange of information between
connected models and models for imposing boundary conditions. These two
packages can be regarded as the infrastructure needed in any Modelica simulation
package Medium and package Basis
comprise models describing fundamental processes in thermodynamics and
correlations for thermophysical properties of working media. These two packages can be regarded as the infrastructure needed for modelling thermodynamic processes.
package Component and package Subsystem contain models describing basic
technical components like turbines and

The Modelica Association

The six main packages are stored in separate files; a
subset of packages can be selected provided the hierarchy is regarded (Tab. 1): while package Interface
demands no models from the other five packages,
package Source demands package Interface, Medium
demands Source and Interface and so on.

2
2.1

Models including correlations for
thermophysical properties
Relevance of correlations between variables
describing thermodynamic systems

Thermodynamic systems can be described by various
variables. The most common state variables for technical systems are
−
spec. enthalpy
−
pressure
−
density
−
spec. entropy
−
temperature
−
spec. internal energy
−
steam quality
−
vector with mass fractions
The minimal number of independent variables
needed to define the state of a system depends on the
number of phases and components, for a pure substance only two variables are needed. Depending on
the physical process various combinations of variables may be used in a model. Mathematical correlations between state variables are needed if different
sets of variables are used. These correlations must
ensure that all sets of variables define the identical
thermal state.

2.2

Representation of thermal state information in TechThermo

The connectors in the TechThermo library transfer
information between models as energy flows. Three
different kinds of energy flows are defined:
−
combined heat and mass transfer

230

Modelica 2005, March 7-8, 2005

Calculation of Thermophysical Properties in the Modelica Library TechThermo

−

heat transfer (without mass transfer),
defined by heat flow rate q_dot and
temperature t
−
pure exergy, defined by exergy flow
rate exergy_dot
While the selection of connector variables defining
heat transfer and pure exergy flow is obvious, various sets of variables listed in section 2.1 can be used.
The connector for combined heat and mass transfer
in TechThermo is defined by
mass flow rate m_dot

−

pressure p

−

spec. enthalpy h

Outlet

2tconst
p_out

polytropic compression

pressure

−

property models the compressor can be adapted to
other working fluids. AirCompressor also includes two models NotUsedVariables; these
models are used to define the remaining variables of
the thermal state connectors by parameters to complete the set of equations.

−
composition vector x_i[n_comp]
Pressure and spec. enthalpy represent a minimal set
of state variables. If models include physical processes described by other variables, these variables
must be calculated from pressure and spec. enthalpy.
One basic concept of TechThermo is the separation
of models including correlations for thermophysical
properties from the other parts of a model. A fourth
connector for thermal state information is defined
including all variables listed in section 2.1. This concept should be demonstrated here by the model
AirCompressor representing an adiabatic compressor for air. The physical process is shown in Figure 2. Assuming an isentropic efficiency eta_isentrop
the spec. enthalpy h_out at the outlet is
h_out=h_in+(State2.h-h_in) /
eta_isentrop

isentropic compression

p_in
Inlet

spec. Volume

Figure 2: p-v diagram of adiabatic compression

Variable State2.h is the spec. enthalpy after an
isentropic compression form pressure p_in to pressure p_out. The entropy after the isentropic compression is identical to the entropy for inlet enthalpy
h_in and pressure p_in. The models demands two
thermophysical correlations:
1.
spec. entropy s_in at inlet enthalpy h_in
and pressure p_in
2.

spec. enthalpy State2.h for entropy
s_in and pressure p_out.

Figure 3 shows the diagram layer of AirCompressor. The model CompressorNoProp1 represents
the compressor model without specification of the
working fluid. By addition of two models AirPerfectGasCaloric including the thermophysical
property correlations for air the model is completed.
Thermal state connectors are used to link CompressorNoProp1 and the two AirPerfectGasCaloric models. By exchanging the

The Modelica Association

Figure 3: Diagram layer of the compressor model AirCompressor including two models for calculation of
thermophysical properties of the working fluid.

231

Modelica 2005, March 7-8, 2005

W. Steinmann

3
3.1

The main package Medium in
TechThermo

gas property routines does not provide different
results
the accuracy of the property model should correspond to the accuracy of the other physical models; e.g. in two phase flow the results provided
by models for pressure loss or heat transfer coefficients often show errors within the range of 3050%, using complex models for calculating the
density of the medium is not efficient in combination with models of limited accuracy.
in dynamic simulations the assumption of thermal equilibrium in the working fluid may be not
valid; the application of high accuracy property
routines describing steady state systems does not
improve the quality of the model compared to
the real world.

-

Selection of model describing property data

TechThermo is intended as a basis library for applications in technical thermodynamics. The models
included should be used in a wide range of applications. Concerning the models for thermophysical
correlations included in the main package Medium
of TechThermo there are two basic aspects:
−
only models based on general concepts
are contained; these models can be
adapted to various media by modification of a small number of parameters
−
TechThermo does not include large
multiparameter equations of state which
are only available for a limited number
of media.
The accuracy of general models usually is limited; if
the models offered by TechThermo don’t fulfil the
demands, additional models are provided by problem-specific model libraries.

-

Using high precision property routines does not necessarily improve the quality of simulation results; on
the other side, the complex high precision property
routine make the finding of a solution more difficult
from a numerical point of view. The choice of the
adequate level of complexity of property routines is
essential for effective modelling and simulation.
5

The selection of the property models strongly influences the behaviour of the model. The choice should
always be adapted to the specific simulation problem. Aspects that should be considered are
the extend of variation for a state variable within
a model; if the variation is limited, the application of simple linear property models may be
sufficient without introducing significant errors;
e.g. if a simulation deals with a gas at room temperature at ambient pressure the application of
the ideal gas law is often sufficient, using real

The Modelica Association

1bar
0
10 bar
Error Gas Density [%]

Mathematical models for thermodynamic property
data are available within a wide range of complexity
and accuracy. Criteria for selection of algorithms can
be
−
accuracy compared to reference values
−
consistency; especially interesting near
to phase transitions
−
dependence on selected variables; many
multiparameter equations of state can’t
be inverted and demand iterative solution if the set of independent variables
changes
−
numerical aspects like stability and required calculation time

−5
100 bar

−10

−15
Redlich Kwong
Ideal Gas Law

−20

−25

−30
100

150

200

250
300
350
Temperature [°C]

400

450

500

Figure 4: Accuracy of the results for density of
steam provided by the Ideal Gas model and the
Redlich-Kwong equation of different pressure levels.
Figure 4 shows the deviation from the reference values for the density of superheated steam provided by
the Ideal Gas law and the Redlich Kwong correlation. Depending on temperature and pressure range
the difference in accuracy changes significantly: at
low temperatures, the simple Ideal Gas law model
shows almost the same quality like the RedlichKwong equation. For applications at high pressure
levels the differences become significant, using the
Ideal Gas law here probably is not acceptable.

232

Modelica 2005, March 7-8, 2005

Calculation of Thermophysical Properties in the Modelica Library TechThermo

3.2

model IdealGasVolumetricNoProp "p/rho=RT"

Organisation of property models

extends TTInterface.ThermalState.PropertyPort;

The main package Medium includes six subpackages with property models:
−
−
−
−
−

Gas
Liquid
Solid
MultiPhase
MultiComponent

replaceable TTMedium.MediumSpecificData.
Data.MediumThermoFundamentalConstants
SpecificConstants "record with medium specific
constants";
SIunits.SpecificHeatCapacity r_gas
"spec. gas constant";

Two additional sub-packages (MediumSpecificData, MathTool) supply fundamental constants for various substances and mathematical tools
like cubic equation solvers.
Property model can be separated into two groups:
−
single phase models for pure substances
−
multiphase and/or multicomponent
models

parameter Boolean switch_r_gas_const=true
"if switch_r_gas_const==true then specific gas
constant r_gas is defined by
parameter molar mass SpecificConstants.m_mol";
equation
if switch_r_gas_const==true then
r_gas = GeneralConstants.R/SpecificConstants.m_mol;
end if;

StateCut.p = r_gas*(StateCut.t + 273.15)*
StateCut.rho;

In TechThermo, models describing a multiphase /
multicomponent system are composed of basic single
phase models for pure substances. Depending on the
variables included in the models, these basic models
can be divided into three groups:
−
volumetric properties including pressure, temperature and density
−
caloric properties including spec. enthalpy, heat of evaporation, spec. entropy and spec. internal energy
−
transport properties like viscosity and
heat conductivity

3.3

Basic concepts for Implementation of property models

end IdealGasVolumetricNoProp;

The medium is defined by the spec. gas constant
which is calculated from the molar mass m_mol and
the general gas constant. R. If the molar mass remains
constant
during
the
simulation
(switch_r_gas_const is true) the value for the molar
mass is taken from the record SpecificConstants which includes the fundamental constants
of a medium. SpecificConstants is a record
of type MediumThermoFundamentalConstants:
record MediumThermoFundamentalConstants
"record defining reference state for
thermophyscial properties TTcode:CfD1"

3.3.1 Definition of substances by record with
fundamental constants

parameter SIunits.MolarMass m_mol "molar mass";
parameter SIunits.
ThermodynamicTemperature t_critical
"critical temperature";
parameter SIunits.Pressure p_critical
"critical pressure";
parameter SIunits.Density rho_critical
"critical density";
parameter SIunits.SpecificHeatCapacity
r_gas=GeneralConstants.R/m_mol "specific gas constant";
parameter Real omega_acentric "acentric
factor";
end MediumThermoFundamentalConstants;

The Ideal Gas correlation is implemented in the
model IdealGasVolumetricNoProp:

This record contains the molar mass and the state
variables in the critical point. These constants are
easily available for many substances. In the Tech-

Basic concepts for the implementation of property
models should be demonstrated here by the example
of the perfect gas law. The perfect gas is described
by the ideal gas correlation between density rho,
temperature t and pressure p and a correlation between the caloric variables spec. enthalpy, spec. internal energy and entropy assuming a constant spec.
heat capacity.

The Modelica Association

233

Modelica 2005, March 7-8, 2005

W. Steinmann

Thermo library models are preferred which require
only these fundamental constants for the specification of the substance.
The model model AirIdealGasVolumetric
calculates the volumetric properties of dry air assuming the ideal gas law:
model AirIdealGasVolumetric
"p/rho=RT for Air TTcode:Ca1"
extends TTMedium.Gas.Support.
IdealGasVolumetricNoProp
(redeclare TTMedium.
MediumSpecficData.Data.
AirThermoFundamentalConstants
SpecificConstants);

Gas
Liquid
Solid

AirIdealGasVolumetric extends the general
model IdealGasVolumetricNoProp and defines
the
medium
by
the
record
AirThermoFundamentalConstants.
3.3.2

Flexible choice of used state variables

The correlations between the caloric variables are
provided by the model
PerfectGasCaloricNoProp.
assuming a constant specific heat.
There are various correlations for spec. enthalpy h
and spec. internal energy u:
1 h = cp * (t-t0) + h0
u = cv *(t-t0) + u0
2 h = u + p / rho
There are also different options for the calculation of
the spec. entropy:
1 s = cv * log(T / T0) + R_gas * log(rho0
/.rho) + s0
2 s = cp * log T / T0) + R_gas * log(p /.p0) +
s0
Depending on the application, different formulation
might be advantageous. The user can select options
by structural parameters. Many property models in
TechThermo offer alternative formulations for the
calculation of material properties.

3.3.3

filled with
medium specific color :
corelation for
caloric state variables
u, h, s

filled with
medium specific color :
corelation for
volumetric state variables
p, v, t

Thermal State connector

Figure 5: Icon used for models containing thermophysical property correlations.
Figure 6 shows the icon of the AirPerfectGasCalVol.
This model is composed of IdealGasVolumetric and a model PerfectGasCaloric as shown
in Figure 7

Figure 6: Icon for AirPerfectGasCalVol providing correlations for both caloric and volumetric
state variables of dry air

Icon representation of property models

The icons of the property model should provide first
information about the included correlations. The basic icon is shown in Figure 5. The range of validity,
the included variables and the substance is indicated
in the corresponding areas of the icon.

The Modelica Association

234

Modelica 2005, March 7-8, 2005

Calculation of Thermophysical Properties in the Modelica Library TechThermo

Figure 7: Diagram layer of AirPerfectGasCalVol; combination of model IdealGasVolumetric and model PerfectGasCaloric
3.3.4

Composed models

AirPerfectGasCalVol represents a simple
form of a composed model; two basic models are
joined to offer the complete set of state variables.
The concept of composed models becomes especially interesting for multiphase models which a
composed of models representing the separate
phases. For wet steam with steam quality x the thermal state variables can be calculated from the properties of the liquid and the gas phase:
−
−
−
−

h = h’ + x * (h”-h’)
u = u’ + x * (u”-u’)
s = s’ + x * (s”-s’)
rho = 1/rho’ + x * (1/rho” – 1/rho’)

h’, u’, s’, rho’ are the properties of the saturated liquid, h”, u”, s”, rho” are the properties of the saturated
steam. Additional correlations are:
−
−
−

−

TSatPSatAntoineNoProp
provides the correlation between saturation
temperature and saturation pressure

−

HeatVaporizationNoProp calculates the heat of vaporization dependent
on the saturation temperature

−

VariableRhoCalVolNoProp calculates the properties for the liquid
phase for saturation pressure and saturation temperature

−

IdealGasVolumetricNoProp
calculates the properties for the gas
phase assuming saturation pressure and
saturation temperature

−

TwoPhaseMix calculates the properties of wet steam from the information
provided by the other four models

WetSteamV01NoProp can be specified for any
substance provided the following constants for the
substance are available:
−
state variables in the critical point
−
two constants needed for the Antoine
correlation for saturation pressure
/saturation temperature
−
a single value for the heat of vaporization dependent on saturation temperature
The modular approach is advantageous regarding the
consistancy at the transition between different regions. Since the properties of the two phases of the
wet steam are calculated using single phase property
models there are no discontinuities at the transitions
between the two phase region and the single phase
regions.

∆h = h” – h’
s” – s’ = ∆h / (tsat + 273.15)
h = u + p / rho

with heat of vaporization ∆h and tsat saturation temperature. Model WetSteamV01NoProp is composed of five models to calculate the properties of
wet steam:

The Modelica Association

235

Modelica 2005, March 7-8, 2005

W. Steinmann

The user can select one of these three options by a
structural parameter. For options 2 and 3 a cubic
equation solver is used.

Conclusions and Outlook

Figure 9: Diagram layer of
WetSteamV01NoProp for calculation of properties of wet steam.

The TechThermo library includes a basic set of models with correlations for thermophysical properties.
These models have been selected considering the
range of application, so only models which can be
used for many different substances are included. The
property models in TechThermo should allow complete descriptions of a thermodynamic system in the
initial phase of model developing. Since property
models are separated from the other parts of a model
by a thermal state connector, a quick exchange of
property models is possible.
Further development aims at implementing property
models which are more efficient regarding numerical
aspects. These models should offer flexibility in the
selection of the dependent variable and should optimize the calculation time / accuracy ratio. One approach here includes the transformation of state variables and the application of cubic equation solvers.

3.3.5 Alternative formulation for non-linear
correlations

References

The convergence behaviour of a model is influenced
by the formulation of non-linear property correlations. Which variable is chosen as dependent might
affect the numerical performance of a model. If possible, TechThermo offers for the non-linear property
model various formulations. One example is the
Redlich-Kwong equation for the volumetric properties of gases:

p=

[1]
Reid, R.C., Prausnitz, J.M., Poling, B.E. : "The
Properties of Gases & Liquids", 4th edition, McGraw-Hill
Book Company, 1988

a
RT
−
1
1 ⎛ 1
⎞
− b T 0,5
+ b⎟
⎜
rho
rho ⎝ rho
⎠

coefficients a and b are calculated from values for
the critical state.
As already shown in Figure 4, this cubic algorithm
provides better results as linear correlations like the
ideal gas law. The model RealGasVolumetricNoProp offers three different options:
1 acausal formulation
2 temperature t as function of pressure p and
density rho
3 density rho as function of pressure p and
temperature t
The Modelica Association

236

Modelica 2005, March 7-8, 2005

Development of a Simplified Transmission Hydraulics Library based on Modelica.Fluid

Development of a Simplified Transmission Hydraulics Library based
on Modelica.Fluid
Michael M. Tiller
Research and Advanced Engineering, Ford Motor Company
mtiller@ford.com

Abstract
Modeling of hydraulic systems often leads to
systems of equations that are stiff and difficult to
solve. In many cases, stiffness of these systems can
be traced to orifices and relatively small volumes
within the model. Frequently, such volumes and
orifices are only present to facilitate explicit statespace formulations of the underlying conservation
principles.
In an effort to create more efficient models and
to eliminate the need for insignificant or nonphysical contributions from such components, the
new Modelica.Fluid library [1] introduces a
structured set of base classes (leveraging new features in the Modelica language) from which fluid
component models can be built. These base classes
allow for a wider range of component configurations
by eliminating the need for extraneous volumes and
orifices in hydraulic schematics.
Using the Modelica.Fluid library as a
foundation, another library has been developed that
includes hydraulic components for hydraulic transmission modeling. The models are aimed at addressing lingering performance and robustness issues with
hydraulic circuits in transmission models and include
several useful simplifications. Because these component models use a first-principles formulation (i.e.
conservation of mass and energy), it is possible to
mix simplified or idealized components with models
that include complex dynamics. As such, model developers can focus on the dynamics of interest (e.g.
dynamics associated with the design of a specific
spool valve in a transmission) while still capturing
the basic functional behavior for the other components in the system. The result of this approach is a
practical continuum between functional and predictive modeling.

1

Goals

Models for transmission hydraulics usually have
one of two purposes. The first purpose is to be a
functional reproduction of an existing or proposed
transmission design. In this case, the response of the
model is only intended to reproduce the functional
behavior of the actual transmission hydraulics. Such
models would naturally include delays, approximate
rates of response, etc.
The other purpose is to be a predictive model of
a particular transmission design. Such a model is
referred to as a design-oriented model because it can
be used to conduct “what if?” studies on potential
design candidates. The key requirement for this kind
of model is that it should not only be sensitive to the
relationship (both transient and steady-state) between
the inputs to the model and the outputs but it should
also properly predict the hydraulic response as a result of changes to the design parameters (orifice
sizes, volumes, diameters, etc). This latter possibility requires considerable physical detail and a solid,
first-principles understanding of component behavior.
The goal of the component library described in
this paper is to provide a path to move between these
two types of representations easily. In this way, a
single model of the hydraulic system can be developed that can be selectively refined to serve both
purposes. In some cases, it is useful to consider both
purposes in the same model. For example, as part of
the design process for a particular valve a designoriented model of that valve can be used in conjunction with functional models of the remaining components. This not only brings the potential for faster
simulations to speed up the design process but also
integrates nicely the cascading nature of system engineering based development processes.

Keywords: Transmission, VMA, hydraulics, DAEs

The Modelica Association

237

Modelica 2005, March 7-8, 2005

M. Tiller

2
2.1

Functional vs. Predictive

2.2

Background

The simplest way to demonstrate the differences between the formulation and performance of
functional and predictive models is to look at an example in detail. However, even basic hydraulic circuits are a little difficult to understand without some
background. For this reason, we will first explain
how a basic hydraulic regulator valve works before
moving on to a complete circuit model. For simplicity, we consider the single solenoid value, shown in
Figure 1.

Functional Model

The model shown in Figure 2 represents an
example of a pressure control circuit for an automatic transmission.

Figure 2: Sample Pressure Control Circuit

Figure 1: Sample Regulator Valve

A common characteristic of a regulator valve
is that an axial force is applied to both sides of the
valve. In most cases, the force is the result of a pressure applied by a fluid over the exposed area on that
side of the valve. But the force can be generated by
other means as well (e.g. in the case of a solenoid
valve, an electro-magnetic force is applied to one
side). The “output” port of the valve (shown in
Figure 1, at the top of the valve) can be fed from two
potential sources (indicated in Figure 1 by the ports
on the bottom of the valve) depending on the position of the valve. In the case of all valves shown in
this paper, the larger the force on the left side of the
valve, the more flow will come from the bottom right
input port. Conversely, the larger the force on the
right side of the valve, the more flow will come from
the bottom left input port. In simple terms, the output pressure will be biased toward the pressure in the
input port on the opposite side of the larger force.
To tune the performance of the valve, an “offset”
force can be generated using a preloaded spring inside the valve body.

The Modelica Association

Using the background provided in Section 2.1,
we can now explain the circuit shown in Figure 2
and deduce the following functional behavior:
• A force command signal (upper left) is sent
to an electric coil in the solenoid. This coil
applies the commanded force to the left side
of the solenoid valve.
• Because the output pressure of the solenoid
is also the pressure applied on the right side,
the solenoid valve will seek a position that
balances the electric coil force with the
“output pressure” of the valve. In this way
(and with a gain that depends on the areas
involved), the output pressure of the solenoid valve is controlled.
• The solenoid output pressure is applied to
the left sides of both the regulator and the
boost valve. The boost valve (bottom valve)
is designed with a preload such that it does
not open until a critical pressure has been
reached. Above that critical pressure, its
output pressure starts dropping to the sump
pressure. Otherwise, its output pressure follows the regulator valve pressure.
• Before the critical pressure of the boost
valve is reached, the regulator valve functions much like the solenoid valve because
its output pressure is effectively the balancing force on the right side. Again, given the
areas involved a certain gain is achieved.

238

Modelica 2005, March 7-8, 2005

Development of a Simplified Transmission Hydraulics Library based on Modelica.Fluid

•

2.3

However, once the boost valve starts to
open, the pressure on the right side of the
regulator quickly drops giving the pressure
on the left a greater mechanical advantage
(and thus increasing the gain significantly).
Finally, the regulator valve output is applied
to the clutch. The clutch plates do not come
into contact with each other until a critical
pressure is reached. Prior to this, the flow
into the clutch fills the gap that forms as the
plates moves. This filling effect results in a
delay between the regulator output pressure
and the applied clutch pressure.
Detailed Model

The functional description in Section 2.2 describes how the circuit is supposed to function.
However, the functional description assumes a
steady-state response with no dynamic effects. In
reality, there are many dynamic effects.
For example, each valve includes a small volume
on each end that fills and empties as the force balance changes. In addition, the flow is regulated by
orifices which open and close as the valve moves.
The behavior of the orifices is non-linear and very
sensitive to the machining of the spool itself. Furthermore, these circuits are designed to provide large
flow rates which means the fluid itself can build up a
significant amount of momentum. Finally, the compressibility of the transmission fluid (transmission
fluid often includes a significant amount of trapped
gas) combined with the small mass of the spool can
result in high-frequency oscillatory responses.
While the dynamics described in this section are
on a much smaller time scale than the functional dynamics described previously, they can have a very
significant effect on noise and vibration in the mechanical system. As such, these kinds of detailed
models (and the staggering amount of geometric
component data they require) are very useful in the
design of the pressure control circuits.
2.4

Structural Differences

The biggest difference between the functional
and predictive models is the presence of dynamic
terms. For example, the momentum balance on the
regulator valve spool can be expressed as1:

F = p L AL − p R AR − mx − kx = 0
1

For simplicity, so-called “flow forces” (i.e. reaction
forces from changing the fluid momentum) are neglected.

The Modelica Association

where p L is the pressure on the left side, AL is the
area on the left side, p R is the pressure on the right
side, AR is the area on the right side, m is the mass
of the spool and x is the position of the spool.
Similarly, the mass balance for the volume on
the left side of the valve can be expressed as:

Qi − Qo − ρA( x − x0 ) − ρAx = 0
where Qi is the mass flow rate into the volume, Qo
is the mass flow rate out of the volume, ρ is the
density, A is the cross-sectional area and x is the
position of the valve.
The inclusion of the capacitive elements makes
the formulation of the problem simpler because
most, if not all, of the equations can be written as
explicit differential equations, e.g.,

x=v
p L AL − p R AR − kx
m
Q − Qo + ρAv
ρ= i
A( x − x0 )

v=

However, as we will discuss later the simpler formulation is actually much more expensive to solve because of the high frequency dynamics in the system.
Because many of these capacitive elements contribute nothing to the overall functional behavior, one
simplification is to eliminate them. Rather than deleting them from the model, they can be “logically”
deleted by setting their capacitances (e.g. m and A )
to zero. As we can see from the differential equations, if we continue to rely on the explicit differential equations, such an approach would lead to a singular system of equations because the denominators
would go to zero. However, if we reconsider the
structure of the problem given that these capacitive
terms are zero and allow purely algebraic constraints
to appear in the problem formulation (effectively
turning the problem into a system of differentialalgebraic equations), then we get the relatively simple system:

p L AL − p R AR
k
Qi = 0
x=

While many traditional dynamic system analysis
tools are based on the notion that the dynamics must
be characterized in terms of ordinary differential
equations (ODEs), Modelica specifically broadens
the general problem definition to support differential-algebraic equations (DAEs) [2]. This broader

239

Modelica 2005, March 7-8, 2005

M. Tiller

3

Comparisons

In this section we will quantify many of the differences in structure and performance between these
two types of models. We start with the functional
model and then include the higher-order dynamic
effects. In addition to comparing the simulation results, we will also consider how these effects change
the overall structure of the problem and what impact
this has on simulation time.
3.1

Functional Validation

Before we compare the structure and performance of these two types of models, we should first
perform a basic validation of the model. Note that
while the example in this paper was chosen to provide a “real-world” context to the issues, the model
itself was created specifically for this paper and is
not a validated automatic transmission circuit.
There are two main characteristics of interest in
this circuit. The first is to confirm the effect of the
boost valve. This should create a “knee” in the pres-

The Modelica Association

sure response of the circuit. The other effect is the
filling of the clutch volume as the clutch is stroked.
Figure 3 shows the functional validation of the
circuit by plotting regulator valve output pressure
and clutch pressure as a function of coil force. When
the coil force reaches 35 Newtons, we can see the
knee in the output pressure. In addition, the difference between the clutch pressure and the regulator
valve output pressure is caused by the need to fill the
gap formed as the clutch is moved into position.
Regulator Output Pressure

Clutch Pressure

8
7
6

Pressure [bar]

problem definition combined with sufficient symbolic manipulation [3] (as in Dymola, [4]) means
that such simplifications are a practical means of
formulating simplified systems of equations using
exactly the same component models.
The equations in this section touch on only a few
of the structural differences between functional and
predictive models. Modelica also provides features
for expressing more complex behavior like parametric behavior formulations (often used to describe diodes or clutches [5]) and piecewise linear expressions (used to describe convected property balances
in Modelica.Fluid). All of this means that
many of the limitations that exist when forced to cast
component behavior in terms of explicit differential
equations can be completely eliminated. As a result,
alternative formulations that are more natural, flexible and computationally efficient, like the ones used
for the components in this paper, become possible.
It is worth noting that useful behavioral descriptions are typically sufficiently complex that the resulting algebraic equations are both non-linear and
coupled. As a result, after symbolic manipulation
simultaneous non-linear systems of algebraic equations (i.e. “algebraic loops”) often emerge from the
explicit differential equations. However, the cost of
the non-linear iterations is often much less than the
cost of resolving the fine details associated with
higher-order dynamics.

5
4
3
2
1
0
0

10

20

30

40

Coil Force [N]

Figure 3: Functional Validation

3.2

Adding Predictive Details

To demonstrate the impact of including predictive details in the model, we will modify the functional model to include 3 important physical effects:
spool dynamics, valve orifices and valve volumes.
These are just a few typical examples of complexities that are required to truly predict the response of
the hydraulic systems. Other effects are also significant (e.g. fluid inertia, mechanical limits, compressible media) but for simplicity they will be neglected.
For the functional model, the spool mass is assumed to be zero. As a result, the position of the
spool in the functional model is determined by the
steady state force balance on the spool. However, in
the case where the spool has non-zero mass, the balance of the axial forces determines the acceleration
of the spool2.
To simplify the calculation of the valve output
pressure, the functional model prescribes the output
pressure by blending the two input pressures continuously as a function of the spool position. The
appropriate mass flow rates to achieve this are computed implicitly. This is not particularly physical
2

In addition to the spool mass, some damping must be
introduced as well.

240

Modelica 2005, March 7-8, 2005

Development of a Simplified Transmission Hydraulics Library based on Modelica.Fluid

Regulator Output Pressure

ing conditions. Figure 5 shows what a typical solenoid command might look like. The square pulse at
the start is used to fill the clutch volume. At the end
of the square pulse, the friction materials in the
clutch should just be coming into contact. At approximately 0.4 seconds, the solenoid force drops to
allow the clutch to engage smoothly. The force is
then slowly ramped up to increase the capacity of the
clutch. Once the clutch is locked, the coil force
jumps up to keep the clutch firmly engaged.
Coil Force
45
40
35
30
25

Force [N]

because it assumes that the valve can flow any
amount of mass. In reality, such flow rates are limited by the sizes of the various orifices. For the predictive model, the flow through each path in the
valve is computed explicitly based on the pressure
drops between the ports. While the equilibrium position of the valve will be identical in each case, the
presence of orifices results in constraints on how
quickly the control circuit can respond. In addition,
the nature of the orifice equation typically results in
some numerical issues.
The final detail is the filling and mixing associated with the volumes at the ends of the valves. In
the functional model, the volumes at the ends of the
valves are neglected (i.e. no mass or energy capacitance). For the detailed model not only is this volume included, but is varies with spool position.
While these dynamics complicate the response
of the circuit, they do not change the overall functional behavior. Figure 4 shows the response of the
circuit with these physical details included. The
conditions are nearly identical to those used to generate Figure 3.

20
15
10
5
0
-5
0.0

Clutch Pressure

0.2

0.4

1.0

The functional model response is shown in
Figure 6. Note that the clutch pressure does not respond until after the clutch volume is filled. Once
the volume is filled, the response of the clutch pressure closely follows the force command profile
shown in Figure 5.

6
5

Pressure [bar]

0.8

Figure 5: Solenoid Force Command

7

4
3
2

Regulator Output Pressure

Clutch Pressure

8

1

7

0

6

-1
0

10

20

30

40
Pressure [bar]

Coil Force [N]

Figure 4: Detailed Model Validation

It should be noted that the conditions chosen
for validation in Figure 4 are such that the dynamics
have little impact. The biggest feature is the
“smoothing” of the edges. However, because the
progression of coil force proceeded on a quasi-steady
time scale, the dynamics are not visible. The main
purpose of Figure 4 is simply to show that with the
physical details included, the circuit is still functionally equivalent.
3.3

0.6
Time [s]

8

Transient Response

To highlight the implications that the various
physical details have on the transient response, we
need to drive the circuit under more realistic operat-

The Modelica Association

5
4
3
2
1
0
0.0

0.2

0.4

0.6

0.8

1.0

Time [s]

Figure 6: Functional Model Response

By comparison, Figure 7 shows how the
more detailed model responds. Rather than responding cleanly to the coil force command, the regulator
valve output pressure fluctuates as the spool settles
into a quiescent state. In particular, the spool oscillates significantly in response to step changes in the

241

Modelica 2005, March 7-8, 2005

M. Tiller

coil force. Most of these oscillations occur before
the clutch starts to engage, but some of them can
clearly be seen in the clutch pressure response. Another interesting effect shown in Figure 7 is the delay
in the engagement of the clutch. This is due to the
fact that the regulator output pressure does not drop
immediately to a pressure that is in proportion to the
coil force. Instead, the clutch pressure drops lower
than it did in the functional model which causes the
clutch volume to briefly empty before recovering.
These dynamics introduce an additional delay before
the friction materials come in contact.
Regulator Output Pressure

Another way to visualize the differences in the
dynamics of the two models it to visualize the poles
in each model. In this way, the range of time constants and natural frequencies can be quickly assessed. Figure 8 shows a map of the two poles present in the functional model. One of the poles has a
time constant of 1 millisecond and corresponds to a
specific first order response introduced in the filling
model. The other pole has a natural frequency of
0.08 Hz and corresponds to the mechanical response
of the clutch-inertia system shown at the bottom of
Figure 2.

Clutch Pressure

8
7
6

Pressure [bar]

5
4
3
2
1
0
-1
0.0

0.2

0.4

0.6

0.8

1.0

Time [s]

Figure 8: Poles in the Functional Model

Figure 7: Detailed Model Response

3.4

Structure and Performance

Table 1 highlights some of the structural and
performance differences between the simulations
shown in Figure 6 and Figure 7. Because the functional model is approximately 5 times faster than the
predictive models, it is useful for proving out control
strategies or for performing hardware-in-the-loop
testing. The performance differences between these
types of models could become even more significant
as additional physical details are added or as the
overall complexity of the circuit increases.

# of states
Linear
system sizes
Nonlinear
system sizes
CPU time

Functional
Model
6
{6, 2, 11}

Detailed Model

{8, 9, 6}

{3, 13}

0.09 [s]

0.46 [s]

For comparison, the poles of the predictive
model are shown in Figure 9. An important difference between the poles shown in this figure and the
ones shown in Figure 8 is that the dynamics in the
predictive model are non-linear. As a result, the positions of the poles vary as a function of the states in
the predictive model. For this reason, Figure 9 overlays the values of the poles (computed via linearization) at various times during the predictive model
response shown in Figure 7 to demonstrate the range
of the dynamics.

20
{6, 10, 4, 13}

Table 1: Quantitative Comparison

The Modelica Association

Figure 9: Poles in the Predictive Model

242

Modelica 2005, March 7-8, 2005

Development of a Simplified Transmission Hydraulics Library based on Modelica.Fluid

The lowest natural frequency shown in Figure 9
has a value of 18.7 Hz and it exists prior to the first
change in solenoid pressure. The highest natural
frequency in the system is 90.7 Hz and it appears
during the drop in solenoid pressure at approximately 0.41 seconds.
A more intangible quality to these models is the
underlying robustness. While Table 1 compares the
performance of simulations that were run using these
two models, what it does not show is the fact that the
detailed model is less robust numerically than the
functional model. Singularities associated with vanishing volumes, ill-posed Jacobians, etc. can not only
have an even greater detrimental impact on the simulation time, they can prevent the simulation from
completing at all.

4

Acknowledgments
The central idea for this paper came after reviewing various models used within Ford to model
transmission hydraulics. As such, I would like to
thank Chad Griffin and James McCallum for their
willingness to share and discuss their models. I
would also like to thank James for the time he graciously spent explaining many of the nuances of hydraulic control circuits. Greg Pietron, Bill Tobler
and James McCallum also provided valuable feedback while reviewing this paper. Finally, I would
also like to thank Bill Tobler and Steve Frait for taking the time to discuss and explain the behavior of
specific components discussed in this paper.

References

Conclusions

[1]

A common issue in modeling applications is including the appropriate level of detail for the task at
hand. During the initial design phase of a circuit like
the one shown in Figure 2, it is important to quickly
verify the functional performance of the circuit
and/or the control strategy behind it. Simple models
can quickly confirm the steady state clutch pressure
achieved for a given solenoid force. Then, as the
design process focuses on finer details (orifice diameters, spool masses, etc) additional geometric information can be added that allows additional dynamics to be considered.
This paper highlights several advantages of using Modelica for hydraulic system modeling. The
first advantage is the ability to leverage the Modelica.Fluid and Modelica.Media libraries.
Careful thought has gone into the formulation of
these libraries to leverage as much of the potential of
the Modelica language as possible while still providing a relatively straightforward framework for developing components. These libraries can now serve as
the foundation for the development and exchange of
hydraulic component models.
The other advantage of using Modelica for hydraulic systems is the ability to express idealizations
that fall outside the typical formulations. It is no
longer necessary to build models from alternating
“flow-volume” pairs or to consider only behavioral
models that lead to explicit differential equations.
Instead, Modelica allows the expression of a broader
class of behavioral models which, through symbolic
manipulation, can be simplified down to relatively
simple and efficient algebraic relationships.

The Modelica Association

243

[2]

[3]

[4]

[5]

Elmqvist H., Tummescheit H., and Otter M.,
“Object-Oriented Modeling of Thermo-Fluid
Systems”, Proceedings of the 3rd International Modelica Conference, Linköping,
Sweden, 2003.
“Modelica – A Unified Object-Oriented Language for Physical Systems Modeling”, Version 2.1, January 30th, 2004. Modelica Association,
http://www.modelica.org/documents/Modelic
aSpec21.pdf
Mattsson, S. E. and Söderlind G., “Index Reduction in Differential-Algebraic Equations
Using Dummy Derivatives”, SIAM J. Sci.,
Comput., 14(3):677-692, May 1993.
Brück D., Elmqvist H., Olsson H., Mattsson
S.E., “Dymola for Multi-Engineering Modeling and Simulation”, Proceedings of the 2nd
International
Modelica
Conference,
Oberpfaffenhofen, Germany, 2002.
Tiller M. M., “Introduction to Physical Modeling with Modelica”, Kluwer Academic
Publishers, 2001. ISBN 0-7923-7367-7.

Modelica 2005, March 7-8, 2005

The Modelica Association

244

Modelica 2005, March 7-8, 2005

Session 3c
Methods II

The Modelica Association

245

Modelica 2005, March 7-8, 2005

The Modelica Association

246

Modelica 2005, March 7-8, 2005

Probabilistic Analysis and Design Optimization of Modelica Models

Probabilistic Analysis and Design Optimization of Modelica Models
Björn Johansson
Petter Krus
Department of Mechanical Engineering
Linköping University, Sweden

Abstract
In this paper, the system simulation model is discussed from an engineering design perspective. Special emphasis will be given Modelica models, and it
is exemplified how computational design methods
operate on the simulation model in order to evaluate
different concepts. Model based design optimization
and probabilistic analysis are discussed as examples
of such computational methods.
An XML-based information system for representation and management of design data for use together
with the Modelica model is further proposed in order
to simplify the use of computational design methods.
Finally, an example is presented, where probabilistic
analysis is carried out on a Modelica model of an
aircraft actuation system using the proposed and implemented tools and methods.

1

Introduction

In the area of engineering design, a substantial part
of the process consists of manual design work involving the inspiration and creativity of the designer.
However, a large part of the design process can be
formalized, and by applying formal design methods,
these can be implemented in computer software as
computational design methods. By employing computational methods in early stages of the design
process, it is possible to acquire valuable informa-

tion. Such methods could for example include model
based design optimization or probabilistic analysis.
These computational methods will be described in
more detail throughout the paper, but common for
the methods is that they operate on simulation models in an automatic, iterative way. This implies new
requirements on the simulation tools as well as on
the representation and management of data related to
the computational methods.

2

Computational design methods

As indicated in the introduction, a computational
design method the uses the simulation model as the
primary source of information.
The principal similarities between different computational design methods and how they operate on the
simulation model are illustrated in Figure 1. With
this view, the computational methods either operate
on the inputs to the model (design synthesis), or on
the outputs from the model (design evaluation). Both
probabilistic analysis and design optimization can be
seen as automatic methods that repeatedly execute
and evaluate the simulation model.
This way of automatic execution adds specific demands to the simulation environment. From the design perspective, it is not of interest exactly how the
model is executed, but it must be valid and must not
‘fail’ or get ‘stuck’. It also calls for separation between the actual simulation model and information
related to perform a design task using computational

Computational
Computational design
design method
method
Design
Design inputs
inputs
-- Concept
Concept (model)
(model)
-- Design
Design variables
variables
-- Uncertainties
Uncertainties
-- Objectives
Objectives
-- Constraints
Constraints

Design synthesis

Design evaluation

•Monte-Carlo
•Optimizer
•Etc.

•Statistical analysis
•Objective function
•Etc

Design
Design outputs
outputs
-- Feasible?
Feasible?
-- Optimal?
Optimal?
-- Robust?
Robust?

Simulation model
Model parameters

Simulation results

Figure 1. Computational design methods operating on a system simulation model.

The Modelica Association

247

Modelica 2005, March 7-8, 2005

B. Johansson, P. Krus

methods. This is because the same simulation model
could be used in a wide range of design tasks.
2.1

Model based design optimization

A typical example of a computational design method
is design optimization based on system simulation, as
described by Krus et al. [4].
By formulating requirements and desirables as a
mathematical objective function, design optimization
can be employed. Parameterized simulation models
of the system enable an optimization algorithm to be
used to find the system parameters that maximize the
objective function while meeting the constraints. The
optimization algorithm repeatedly modifies specific
design variables (model parameters), executes the
model, and evaluates an objective function, see
Figure 2.
Design
Design optimization
optimization

x
x 3
x1 2
Design variables
Constraints
C4
C3
C2
C1

Optimization
algorithm
Simulation
model

Evaluation

Objective function

Figure 2. Process for model based design optimization.

A non-gradient method is specifically appropriate for
optimization of simulation models since the objective function is defined from simulation results and
derivatives of the objective function can not be defined. One example is the Complex optimization algorithm, presented by Box [6], which has been used
very successfully over a wide range of problems and
is characterized by simplicity and robustness.
2.2

For example, by taking uncertainty into account, the
following information can be extracted:
• The probability of meeting a set of constraints
and achieving a technically feasible design with
in the ranges of the design variables, the probability of feasibility.
• How much it will be necessary to relax a specific
constraint in order to have a sufficiently high
probability of feasibility.
• The effect of uncertainty in system parameter
values, i.e. the robustness of the design
The information above can not be achieved using
deterministic simulation models with fixed parameter values. Therefore, it is necessary to use probability distributions to represent uncertain values on
model parameters.
A feasible design is defined as a design that satisfies
all imposed technical constraints [5]. The examination of the concept’s feasibility could be seen as a
probabilistic methodology where the probability of
finding feasible design alternatives within the design
space is investigated. This so-called probability of
feasibility, Pfeas, is an important figure of merit in the
early phases of design since it indicates whether the
concept is promising for further analysis such as design optimization.
Figure 3 illustrates the process of concept feasibility
assessment. By assigning normal distributions for the
design variables and using a sampling-based method
such as the Monte Carlo simulation together with the
simulation model, the Pfeas can be calculated given
the settings of the design variables and the constraints.
Determine
Determine Concept
Concept Feasibility
Feasibility
x
x2 3

x1

MonteCarlo

Model based probabilistic analysis
p1

Other important examples of computational design
methods are based on probabilistic analysis. These
methods are used not only to assure a technically
feasible concept, but also to find a robust design
point by including uncertainty in the models.
In all stages of the engineering design process, and
especially in early stages, most available information
suffers from uncertainty. By using methods for probabilistic analysis, this uncertainty is brought into the
design process through the use of simulation models.
This is highly desired since important knowledge
about the uncertainty is otherwise omitted.

The Modelica Association

Design space
exploration

Design variables

Uncertainties

Simulation
model
C4

Constraints

C3

Evaluation

C2
C1

Relax
Relax active
active
constraints
constraints ifif possible
possible

N

Y
P(feas)>ε
P(feas)>ε

Figure 3. The process of concept feasibility assessment
[5]. The model code is evaluated repeatedly where the
design variables are varied within the design range using a
sampling based method such as Monte-Carlo simulation.

248

Modelica 2005, March 7-8, 2005

Probabilistic Analysis and Design Optimization of Modelica Models

If the total probability of feasibility is too low, the
constraints must be investigated individually and
either the active constraints relaxed or the concept
modified, for example by infusing new technologies
to the concept and thereby improving its characteristics. Mathematically, the probability of feasibility
Pfeas for a system with m constraints is defined as [5]:
m

Pfeas = ∏ Pi

(1)

Pi = P(Ci ≤ 0)

(2)

i =1

where Pi is the probability that one specific constraint Ci is met. For another formulation using information content as the figure of merit, see the theory of Axiomatic Design [8]
The Monte-Carlo simulation used to simulate uncertainty or variability is a rather simple algorithm that
randomly samples values according to a probability
distribution. However, more sophisticated methods
with improved search efficiency can be used as well
such as Adaptive Importance Sampling (AIS) as described by Wu in [11].
2.3

Computational design data

As indicated in the previous sections, computational
design methods include a wide range of data that is
not primarily associated the model of the system. As
can be concluded from Figure 2 and Figure 3, a wide
range of design related data is required such as
• Design variables – A subset of the system parameters that are modified during the design iteration.
• Uncertainties – Many model parameters are uncertain, which must be handled.
• Constraints – Measures that must be met in order for the design to be feasible.
• Objective functions – A mathematical function
used by an optimization algorithm in order to define a figure of merit.
• Process model – In order to accomplish full system simulation and optimization involving several types of models and codes, it is necessary to
be able to represent and execute a computational
sequence.
The data above is normally not possible to represent
inside simulation models. It is also the fact that a
computational design task often includes more than
one model represented using one specific approach.
In order to accomplish for example system optimization, it is often necessary to include several types of
models, such as CAD, CFD, financial models, etc.

The Modelica Association

Typical is also that integration of already existing,
so-called legacy codes is necessary.

3

Modelica and computational data

The Modelica modelling language is developed in an
international effort by the Modelica Association [6]
consisting of members from both industry and the
academic world with the intention of establishing a
de-facto standard for system simulation. The Modelica language contains a large number of features
with extensive support for advanced modelling of
systems from different engineering domains. The
modelling principle is object-oriented and equation
based where different types of equations are supported. Modelica also enables representation of general data as so-called annotations.
It has been shown several times that Modelica is
very well suited for modelling of physical systems.
However, representation of design related data as
exemplified in previous section is not directly supported. Even if it would be possible to represent design data as annotations this is not an attractive solution since it still not would be generally supported in
tools available for Modelica.
One important argument why a separate representation of design data would be necessary is:
A design project often contains several models, and
several types of models. In order to fully assess the
properties of a certain design, this could include both
technical domains and others, such as financial models. A general representation of design data that is
simple to use together with different model implementations is therefore necessary.
The approach taken in this work is to represent the
data as XML outside the simulation model as illustrated in Figure 4. This approach will be further described in the next section of this paper.
Equations

Variables

Design variables
Uncertainties

Components

Parameters

System interfaces

Constraints

Objective functions
Process model

System model
representation

Design project
representation

¾Modelica

¾XML

Figure 4. The system simulation model is represented in
Modelica, while data regarding the design task is represented in XML.

249

Modelica 2005, March 7-8, 2005

B. Johansson, P. Krus

3.1

XML-based data repository

In order to facilitate the use of computational design
methods using models implemented for example as
Modelica, a design data repository has been created
where the system data can be represented in a general way using XML. An XML document is however
not very usable without an accompanying XML
schema [10]. Just as the XML can effectively describe data, the XML schema defines the structure of
the XML document. It defines each allowed element
in a document, the allowed attributes and possibly
the acceptable attribute values for each element. It
also defines the occurrences, sequence, and nesting
of each element.
The information model developed for this purpose
has a hierarchical and object-oriented structure in
order to organize the data in a way that is close to the
physical system. In order for the information model
to be as general as possible, generic elements are
defined such as system, subsystem, variables and
native data. A top level structure of the data can be
seen in Figure 5, and the different parts of the data
model are described in more detail below.

Figure 5. An object oriented and hierarchical structure in
order to organize the design data.

The variable element is the important building block
in the repository. This element is used as a neutral
representation of both system parameters and design
variables, see Figure 6. Besides name and default
value, which are required attributes, the variable contains optional information such as unit, description,
and data type. With a variable type attribute, it is
also possible to define whether the variable is controllable, non controllable, or a so-called technology
factor (described in more detail in [3]). As illustrated
in Figure 6, the variable element also has subelements that contain additional information such as
probability distribution and settings if the variable is
generated by a design algorithm such as Design of
Experiment (DOE) or is a design variable in an optimization algorithm. It is possible to attach these
sub-elements to all variables in a generic way.

The Modelica Association

Figure 6. XML Schema representation of the variable
element used to represent various kinds of system parameters with extensive information such as probability distributions.

The idea is that probability distributions are defined
and stored parametrically. It is possible to select
from typical standard distributions such as uniform
distribution, normal distribution, triangular distribution, etc. Custom distributions could also be defined
as interval values or single values. This means that
no mathematical functions for the distributions are
stored in the repository. For example, in the case of a
normal distribution, the mean value and the standard
deviation are stored and not the mathematical function describing the relation between these metrics
and the probability density function, PDF.
In Figure 7, some example XML code is visualized
as represented using the XML editor XML Spy. For
visualization of the actual XML code, see the example in section 5.

Figure 7. Design variable visualized in the XML editor
XMLSpy.

4

Integration framework

A software prototype for collaborative system simulation and computational design has been developed

250

Modelica 2005, March 7-8, 2005

Probabilistic Analysis and Design Optimization of Modelica Models

in projects prior to the work presented in this paper;
see for example [2].
The framework is based on a Service Oriented Architecture [7] which means that models and methods
communicate using so-called web service standards
such as SOAP and WSDL, see [9]. The standards are
used to define interfaces between the models and to
represent the data being exchanged between the
models, methods and users clients. The framework
enables different kinds of models to be encapsulated
as simulation modules without exposing the actual
content of the model. Only a published interface is
visible to the outside. The models can also be executed in a distributed fashion which enables models
and methods to be executed from their original location. With this approach, both models and methods
are managed as generic simulation modules which
are integrated and executed as illustrated in Figure 8.
Excel
Excel spreadsheet
spreadsheet

used to dynamically create and parse the input and
output files to and from the Modelica simulation directly. This is a very flexible approach which has
been implemented in previous projects, see [3].
Important to note is that this for model integration is
not intended for high-speed data exchange between
tightly coupled models. Rather, it is intended for
automation of sequential (or parallel) computational
design tasks involving several distributed model. An
XML-based process model has also been developed
which can be automatically executed by a so-called
sequencer. Further details about this framework are
presented in [2].

5

Example – Probabilistic analysis of
aircraft actuation system

In this section an example will be presented where a
probabilistic analysis is carried out using the presented framework and a simulation model developed
in Modelica.

Simulation module

Computational
Computational
methods
methods

Sequencer

5.1

Electro-hydrostatic actuation system

SOAP
messages
Design
Design data
data
repository
repository

Figure 8. Integration framework where a simulation
model implemented in Modelica is integrated with computational methods and a design data repository. Inputs and
outputs are here managed using an Excel spreadsheet.

The system is an electro-hydraulic system, principally illustrated in Figure 10. The intention is to
mount the system inside the aircraft wing in order to
move the control surfaces of the aircraft.
xpref

A wrapper is created around the simulation model in
order to publish the model as a simulation module as
illustrated in Figure 9.
model EHA
DCmotor motor;
HydraulicPump pump;
HydraulicPiston piston;
equation
connect(motor.shaft,pump.shaft);
connect(pump.port2,piston.port1);
connect(piston.port2,pump.port1);
end EHA;

Executable code
•Dymosim.exe

•Web server
•SOAP engine

Wrapper

Executable code
•Dymosim.exe

Figure 9. The Modelica system model is translated and
compiled using Dymola. The executable code is wrapped
as web service simulation module.
In the work presented here, a prototype has been implemented where Matlab constitutes the wrapper that
communicates with both the simulation model, and
the web service interface. A more permanent solution is however intended where XML technology is

The Modelica Association

Power
electronics

DCM

HP
Load

Power 270 V
DC-bus

Figure 10. A schematic model of an electro-hydrostatic
Actuation system (EHA) implemented in Modelica.

Web
Web enabled
enabled simulation
simulation module
module
SOAP
messages

xp

Due to the compact design of the system and the
high power density, the system generates heat that
can lead to high temperatures and cause damage to
the system. It is therefore of interest to analyze the
thermal behaviour of the system during missions of
the aircraft. In order to accomplish this, a model of
both the dynamic performance and the thermal properties of the EHA as well as load forces from authentic missions have been modelled in the Modelica
language.
5.2

Simulation model in Modelica

There are different aspects that are of interest when
studying actuation systems such as dynamic per-

251

Modelica 2005, March 7-8, 2005

B. Johansson, P. Krus

formance, how the system responds to a control signal, or how sensitive the system is to disturbances.
The models of the system were designed in an object-oriented way where all the components were
modelled using the Modelica modelling language. In
each component, equations for both dynamic behaviour and thermal properties are included and thermal
properties such as temperature and heat flow are represented in the connectors.
The electric motor and the power electronics are also
designed to include dynamic as well as thermal
properties. Both hydraulic and electric components
have equations for thermal properties. Pure thermal
components have also been added to the model. In
Figure 11, a graphical representation of the model as
implemented in Dymola is visualized.

5.3

The uncertainties

From a design point of view, the system includes
several uncertain parameters that could affect the
thermal properties in the components. In order to
keep the example simple, only three parameters in
the model is selected to illustrate uncertainties in the
system.
Normal distributions are selected for the resistance in
the DC motor and in the power electronics. A normal
distribution is also set for at speed dependent thermal
parameter in the motor.
Table 1. Definition of uncertain parameters.
System parameter
Mean
value
0.35
Inverter resistance [Ω]
Speed dependent thermal
0.5
constant [rad-1]
2.5
Motor resistance [Ω]

Standard
dev
0.1
0.1
0.25

As an example, the representation of the motor resistance is visualized below. Both graphically, and as
XML code.
P

DCM.Ra
1.75

Figure 11. The simulation model as implemented in the
Dymola simulation tool.

The system has been simulated in mission of 50
minutes. In Figure 12, results from simulation can be
seen. The system was simulated with load and control signals from authentic mission data. The simulation show that high temperatures will occur both in
the hydraulic fluid as well as in the motor windings
during a so-called extreme mission.

2.5

3.25

Figure 13. A normal probability distribution defines the
resistance of the electric DC motor.
<Variable name="DCM.Ra" info="DC motor resistance"
variableType="NonControllable"
variabilityType="NormalDistribution">
<Value>2.5</Value>
<Distribution>
<Normal mean="2.5" stdDev="0.25"/>
</Distribution>
</Variable>

5.4

The constraints

A few example constraints are here presented regarding the temperatures in different parts of the system.
• The temperature of the hydraulic oil should not
exceed 90°C,
o
•

The temperature of the DC motor windings
should not exceed 100°C
o

Figure 12. Temperatures [K] in the system during a heavy
mission. Simulation of the Modelica model using Dymola.
The mission is simulated for 50 minutes (3000 sec).

The Modelica Association

C1 = Oil.Ti ≤ 90°C

C 2 = DCM.Ti ≤ 100°C

The constraints are evaluated in each simulation in
order to evaluate the probability of feasibility described below.

252

Modelica 2005, March 7-8, 2005

Probabilistic Analysis and Design Optimization of Modelica Models

5.5

Evaluating probability of feasibility

In the application example, probabilistic analysis is
employed on the system in order to investigate the
probabilities of meeting the constraints.
The framework illustrated in Figure 8 is here used
for the simulations. The simulations are controlled
from an Excel document, where inputs to the model
can be entered as well as results from the model
monitored.
In each execution of the model, the max temperature
in the different parts of the system at each simulation
is stored. By modifying the inputs according to the
probability distributions of the uncertain parameters,
variability in the responses is obtained as well.
The results are investigated by computing a Cumulative Density Function (CDF) for the response of interest. By fitting a standard distribution to the values
of the responses, the probability of achieving responses that meet the constraints can be computed,
see Figure 14.
Constraints

Simulation
Simulation
response
response
values
values

Probability

100%

Probabilistic
analysis
0%

Value

Constraint value

Figure 14. The simulation results are extracted from the
XML repository for analysis.

Below, the results for the temperatures of the hydraulic fluid as well as the DC motor temperature are
visualized.
1.000

500

.750

375

.500

250

P (Oil.Ti ≤ 90) = 48%

.250

For the uncertainties and constraints used in this example, the results are the following probabilities:
• The temperature of the hydraulic oil should not
exceed 90°C,
o
•

P(C1 ) = 48%

The temperature of the DC motor windings
should not exceed 100°C
o

P (C 2 ) = 8%

This implies that the total probability of meeting the
constraints (probability of feasibility) is:

P (feas) = P{(Oil.Ti ≤ 90) U (DCM.Ti ≤ 100)}
= 4%
It is obvious that this is too low probability for the
system to be robust and we must investigate if the
constraint can be relaxed or else we make some
change to our design. For the purpose of this example, we now assume that the constraints cannot be
relaxed.
Now assume that we infuse technologies to our concept that increases the ventilation of the EHA mounting area and the increases the transportation of heat
from the EHA surface. This means that we can assume a technology factor that should affect the probability of meeting the constraints.
By modifying our model we can now re-evaluate the
probabilistic analysis in the same way as above.
The results in Figure 16 show that the probability of
meeting the constraints has increased.
1.000

500

.750

375

.500

250

P (Oil.Ti ≤ 90) = 93%

.250

125

125

.000

.000

0
53.91
70

58.43
80

62.96
90

67.48
100

58.43
65

62.96
75

67.48
85

72.01
105

72.01
110

1.000

500

.750

375

.500

250

P (DCM.Ti ≤ 100) = 8%

.250

0
53.91
55

1.000

500

.750

375

.500

250

P (DCM.Ti ≤ 100) = 87%

.250

125

125
.000

.000

0
53.91
90

58.43
100

62.96
110

67.48
120

58.43
80

62.96
90

67.48
100

72.01
110

72.01
130

Figure 15. The probability of meeting constraints on oil
temperature and DC motor temperature with uncertainty
in some system parameters.

The Modelica Association

0
53.91
70

Figure 16. The probability of meeting constraints on oil
temperature and DC motor temperature with a modified
concept.

253

Modelica 2005, March 7-8, 2005

B. Johansson, P. Krus

The total probability if feasibility for the modified
concept is now:

References

P (feas) = P{(Oil.Ti ≤ 90) U (DCM.Ti ≤ 100)}

[1]

= 81%
We can now accept the current concept and move on
to the next step in the design process, which includes
further simulation and optimization to achieve an
optimal design point with respect to both performance and robustness. This is however beyond the
scope of this paper.

6

Discussion and conclusions

It is important to realize that in a computational design task, the system simulation model is not the toplevel integrator that accesses and integrates different
types of data. It is rather a component that is being
accessed from a design framework at a higher level
including some computational method. The information that the simulation model delivers is then evaluated and integrated with results from several types of
models.
Simulation models in industry exists in a wide range
of representations ranging from old legacy codes
represented in Fortran code to modern objectoriented modelling languages such as the Modelica
language implemented in simulation tools such as
Dymola. It is important that the computational design methods can interact with the models regardless
of implementation. With a design data repository
implemented in a format that is simple to access by a
wide range of tools, this interaction is highly facilitated.
The approach presented in this paper uses XML for
representation of the design data in a format that is
general and not associated with existing representations of system simulation models. The advantage is
that XML is widely supported by a wide range of
software tools, and that it is simple to access and
manage the XML data.
The example presented in this paper is only one simple illustration of how the simulation model can be
used in a computational design task. Increased demands for the product developing industry regarding
faster time to market will make design automation
more and more important. It is therefore very important to continue to define interfaces between the area
of engineering design and the area of system modelling and simulation.

The Modelica Association

254

[2]

BOX M. J., “A new method of constrained optimization and a comparison with other methods,”
Computer Journal, 8:42-52, 1965.
JOHANSSON B. AND KRUS P., “A Web Service
Approach for Model Integration in Computational
Design”, in Proceedings of ASME Computers and
Information in Engineering Conference, Chicago,
USA, September 2-6, 2003.

[3]

JOHANSSON B., DELAURENTIS D. A. AND MAVRIS
D. N., “Managing Design Data for Probabilistic
Evaluation of Aircraft Concepts”, in Proceedings
of International Conference on Engineering Design, ICED'03, Stockholm, Sweden, August 1921, 2003.
[4] KRUS P., JANSSON A. AND PALMBERG J-O, “Optimisation for Concept Selection in Hydraulic
Systems”, in Proceedings of 4th Bath International Fluid Power Workshop, Bath, UK, 1991.
[5] MAVRIS D. N. AND DELAURENTIS D. A., “A probabilistic approach for examining aircraft concept
feasibility and viability”, Aircraft Design, 3
pp.79-101, 2000.
[6] MODELICA ASSOCIATION, “Modelica A Unified
Object-Oriented Language for Physical Systems
Modeling,
Language
Specification,
http://www.modelica.org, 1999.
[7] PAPAZOGLOU, M.P.: “Service-Oriented Computing: Concepts, Characteristics and Directions” in
Proceedings of the 4th International Conference
on Web Information Systems Engineering (WISE
2003), December 10-12, 2003
[8] SUH N. P., Axiomatic Design: Advances and Applications, Oxford University Press, New York;
Oxford, 2001.
[9] TSALGATIDOU A. AND PILIOURA T., "An Overview of Standards and Related Technology in
Web Services," Distributed and Parallel Databases, 12, pp. 135-162, 2002.
[10] WORLD WIDE WEB CONSORTIUM,
http://www.w3c.org.
[11] WU Y.-T., “Computational methods for efficient
structural reliability and reliability sensistivity
analysis” AIAA Journal, Vol. 32(8), pp 1717-23,
1994.

Modelica 2005, March 7-8, 2005

Optimization for Design and Parameter Estimation

Optimization for Design and Parameter Estimation
Hilding Elmqvist1, Hans Olsson1, Sven Erik Mattsson1, Dag Brück1,
Christian Schweiger2, Dieter Joos2, Martin Otter2
1

Dynasim AB, Lund, Sweden ({Elmqvist, Hans.Olsson, SvenErik, Dag}@Dynasim.se)
2
DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany
(Christian.Schweiger@DLR.de, Dieter.Joos@DLR.de, Martin.Otter@DLR.de )

•

Abstract
This paper describes new features of the Modelica
environment Dymola to perform integrated computer
experiments with Modelica models, in particular for
model calibration, design optimization and
robustness or sensitivity assessment based on
multiple criteria and multiple simulation runs. The
environment and especially the problem setup are
demonstrated by several application examples.

1

Introduction

Recently, new features have been added to the
Modelica simulation environment Dymola [2] to
simplify experimentation with Modelica models significantly. Some basic ideas are from the optimization environment MOPS [3]. The central part is a
Modelica model of a physical system with Modelica
parameters that are not yet fixed. Several problem
classes can now be conveniently solved:
• Model Calibration (Parameter Estimation):
Some Modelica parameters of the model are not
known. Several simulation runs are performed
and compared with measurement data that is
available from equivalent dynamic behavior of
the real device. Via optimization, the selected
unknown parameters and initial conditions are
determined such that the simulations and the
measurement data are in good agreement. Also
standard tasks such as fitting of functions to
measurement data is supported.
• Design Optimization
(Parameter Optimization):
Selected Modelica parameters of the model are
tuned to improve the system dynamics, e.g., by
changing the parameters of a controller or some
parameters of the physical device. This is performed by multi-criteria parameter optimization
using one or several simulation runs to compute
the desired criteria.

The Modelica Association

Assessment (Parameter Variation):
Selected Modelica parameters of the model are
systematically changed within a given grid and
for every fixed set of parameters, simulations are
performed. This might be used, e.g., to evaluate
a finished design by varying the operating
points. For Monte Carlo simulations, the parameter values are chosen statistically. Simulations with small variations to the parameters can
be used to determine how sensitive a design is.
All these experiment tasks utilize the same basic
functionality that is defined once:
• Tuner Parameters:
Modelica parameters that remain constant for a
particular simulation but are varied by the experimentation environment to search for satisfactory solutions are called “tuners”. E.g. via parameter estimation or optimization the tuners
shall be determined such that criteria are minimized.
• Criteria:
Criteria are used to compute quantitative values
of achieved performance of a simulation run.
Criteria are assumed to be positive and smaller
values reflect better performance. Usually, several criteria are needed to express the desired behavior. For example, typical criteria of a system
step response are over-shoot or settling time. By
weighting each criterion individually by a fixed
demand value (criterion_i/demand_i), where the
demand value expresses the designer’s notion of
expected system performance, a clear preference
list of the criteria is defined. For example, the
demand value for the settling time might be 0.1
s, indicating that a value of 0.1 s is satisfactory
from a users point of view.
To solve the multi-criteria problem by means of
standard numerical optimization an overall criterion to be minimized has to be formulated. This
so called aggregation function is by default the
maximum function, yielding a min-max optimization problem over the weighted criteria (= the

255

Modelica 2005, March 7-8, 2005

H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M. Otter

largest weighted criterion is minimized). Of
course the maximum weighted criterion may
change during optimization depending on the
tuner values found. Note that an aggregation
function value less than 1 implies that all criteria
satisfy the demands.
There is an option to choose other aggregation
function types like weighted sum. In any case the
weights are formed by the reciprocal demand
values.
• Constraints:
Design specifications are often given as constraints such as actuator limits. If a certain level
of compliance is achieved for a criterion, this
level must be kept, and smaller (better) criterion
values are not necessary. Constraints are formulated as criteria, which are requested to be
smaller than the demand value. Optimization
procedures account for constraints in their optimization strategy explicitly.
• Indicator plots:
A criteria value results in one number to express
the performance. This is necessary in order that
an optimizer can be used. A human would like to
evaluate a design by visual comparison of result
plots of different designs, e.g., by viewing a
whole step response curve and not only the overshoot value. Indicator plots for a model can be
defined once and then reused, e.g., for online
visualization of the optimization or parameter
estimation process.
• Model Cases:
In many applications, several simulation runs are
necessary to evaluate a design or to estimate parameters. In the Dymola environment, several
simulation runs are collected together to model
cases: Exactly the same tuners, criteria and indicator plots are used for each model case. The
model cases are distinguished only by a set of
fixed Modelica parameters that define the different simulation runs. Often, these case parameters
describe different operating conditions, e.g., different road or load conditions of a vehicle.
The paper shows for two application examples how
to define the problem setup of tuners, criteria, cases
and indicator plots by means of the graphical user
interface. The defined problem setups are used to
solve the calibration task of an under-actuated two
joint Furuta Pendulum and then the parameter optimization for robot control laws. The solution of the
multi-criteria optimization problem is discussed
briefly in Section 4.

The Modelica Association

2

Application Examples

In this section, details of the experimentation environment are described elaborately by several examples.
2.1

Parameter Estimation of an under-actuated
two joint Furuta Pendulum

Consider the Furuta pendulum demonstration of the
Department of Automatic Control, Lund Institute of
Technology, Lund, Sweden. The
pendulum, consisting of 2 revolute joints and 2 moving bodies,
is shown in the figure. Only the
first joint (vertical axis) is driven
by a DC motor. Experiments and
controller have been designed
and evaluated in [1].

Within Dymola, a model of the Furuta pendulum is
easily constructed by dragging, dropping and connecting body and joint components from the MultiBody library. However, it is also necessary to set
physical parameters in the model. Some of these parameters such as the length of the arm or the length
of the pendulum are easily measured on the system.
Direct measurements of the weights of the parts
would require the system to be dismounted (in other
cases it is easy to measure the mass or determine it
from a CAD system). Moreover, it is not simple to
measure the inertia of the parts or the friction characteristics of the two joints.
The new Dymola experimentation environment has
been used for parameter identification. For this, the
movement of the 2 body pendulum has been recorded by sensors in the joints. The same movements
are performed with a simulation model and the friction parameters are optimized such that the measured
and the simulated movements closely agree.

256

Modelica 2005, March 7-8, 2005

Optimization for Design and Parameter Estimation

Selection of parameters to be tuned
When estimating parameters from measurements, a
basic question is “Which parameters can be estimated from the measurements?” Changing a parameter to be estimated must of course influence the
output. However, this is not enough if several parameters are to be estimated. Consider the arm of the
Furuta pendulum. It rotates around a vertical axis.
The model of the arm uses
Modelica.MultiBody.Parts.BodyShape
It has the following parameters: mass, position of
center of mass and inertia tensor with respect to
center of mass. Since the arm is rotating around a fix
axis, it is only the inertia with respect to this axis that
influences the behavior of the system. Inertia with
respect to an axis being orthogonal to the vertical
axis does not influence the motion at all. The criterion is independent of its value. We will discuss a
more general case. Let Jc denote the inertia with respect to a vertical axis through the center of mass.
Let m denote the mass of the arm and rc denote the
distance between the point of rotation and the center
of mass. The inertia of the arm with respect to the
point of rotation, Ja, is then
J a = J c + m ⋅ rc 2

It is this inertia that is of importance for the rotation
of the arm. It is this parameter that can be estimated
from measurements. It is not possible to estimate m,
Jc or rc uniquely from measurements of positions or
velocities.
What will happen if we try to estimate Jc and m? In
the best case we will get a good estimate of Ja, but Jc
and m may be really different from the their real
physical values. One approach to investigate if we
are about to estimate too many parameters is to make
estimation experiments on the model. First one could
use the model with its nominal parameter values to
produce simulated “measurement data”. Then one
would set the model parameters that are going to be
estimated to other values, and run the calibration
procedure using the previously produced “measurement data”. If the estimated parameters give the
same simulation results but are significantly different
from the “true” nominal ones, then this indicates
overparametrization, because the nominal behavior
can be reproduced by other parameter values than the
nominal ones used to produce the “measurement
data”.
Assume rc = 0.1225 and being known. Assume the
nominal values Jc= 0.0014 and m = 0.165. Assume
the criterion to be the integrated squared error of the
pendulum angle and arm angle. Let the pendulum
start in horizontal position and use the simulation
The Modelica Association

time 5 s. It is illustrative to plot the criterion versus Jc
and m as shown below.

We see a valley where the criterion is unchanged.
Along the valley the effective inertia, Ja, is unchanged with peaks on either side where it has been
changed. The error is not symmetric with respect to
large variations in Ja and the error increases more
when Ja decreases.
To compute this map we used a gridding function
that takes the calibration task (as described below)
and additionally the gridding parameters as inputs,
i.e. we do not have to define the calibration task
twice.
A further possibility is to investigate the sensitivity
of the criterion with respect to the parameters estimated. In particular we can calculate the sensitivity
matrix (the Hessian of the minimization problem).
Dymola calculates the sensitivity matrix by simulating for disturbed parameters and taking differences
of the resulting criterion values obtained. The sensitivity matrix was found to be
[431064, 6456.3;
6456.3, 97.0671],
The eigenvalues being 431161 and 0.37 are very different in magnitudes. Considering the numerical accuracy, the small eigenvalue may be considered as
being zero. The eigenvector having the large eigenvalue is {0.99989, 0.01498}. It means a large sensitivity in the direction
{0.99989, 0.01498}*{Jc, m}
Recall Ja = Jc + 0.01501*m which shows that the
criterion is sensitive for variations in Ja. The second
eigenvector {-0.01498, 0.99989} is orthogonal. (For
a symmetric matrix, all eigenvalues are real and eigenvectors are orthogonal.) The small eigenvalue,
being very close to zero, indicates that the measured
behavior is insensitive to variations in the direction
of the second eigenvector as is also shown in plot
above.
Since the optimization problem is a non-linear leastf i2 ( p) , we can alternative comsquares problem,

257

∑

Modelica 2005, March 7-8, 2005

H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M. Otter

pute the insensitive direction (in a more numerically
robust way) as the approximate null-space of
∂f i ( p ) / ∂p .

∑

It may be remarked that for the case where the criterion is independent of a parameter, there will be a
valley parallel to the axis representing the parameter
and the sensitivity matrix the vector in the direction
of the parameter will be an eigenvector with zero
eigenvalue.
Thus for the arm we set rc = 0 and interpret the estimated inertia as being Ja. It means that we introduce
a top-level parameter I_arm and set arm.r_CM to
{0,0,0}, and arm.I_22 to I_arm.
The pendulum consists of a cylinder having a small
mass at the end. It is natural to assume its inertia
with respect to all axes perpendicular to its length
axis to be equal, call it I_pendulum. Set pendulum.I_11 = I_pendulum and set pendulum.I_33 =
I_pendulum. The inertia sensed by the rotating arm
depends on the angle of the pendulum, which means
that for the pendulum, we can estimate also mass
(pendulum.m) and position of the center of mass,
r_CM_pendulum. We set pendulum.r_CM to {0,
r_CM_pendulum, 0}.
Parameters in the friction model for the joints can
also be estimated. We assume Coulomb friction with
a linear dependence on velocity. For the arm joint we
introduce tau11 and tau12 and set frictionR1.tau_pos
to [0, tau11; 1, tau12] and similarly for the pendulum
joint.
Setting up the calibration task
To set up the calibration task, select CalibrateModel
from optimization package. Click the right mouse
button. Select Call Function. A dialog is shown:

model). This allows easy reference to parameters
when selecting tuners as described below.
To specify which parameters to tune, click on the
tunerParameters and the right pane of the dialog
shows

Clicking on Select gives a browser for simple
selection where we tick the parameters as decided.

Clicking OK fills the tunerParameter dialog as
shown in the following image.

It shows that the calibrate function has one
argument, setup. Clicking on the “+” opens it and
shows that it is a record with five elements, which
describes various aspects of the calibartion task
including which parameters to tune, criterion and
which measurement data to use. We will discuss the
specification of these elements in turn. The calibrate
function assumes the current model (last translated

The Modelica Association

258

Modelica 2005, March 7-8, 2005

Optimization for Design and Parameter Estimation

Estimating initial conditions
The initial conditions will be different for different
experiments, for example, if we let the pendulum
start at different angles. To get good fits it is advisable to estimate the initial conditions. We can give
reasonable guesses, because we try to start the system in a well-defined state. For some experiments
the initial conditions are known accurately and they
should then be given as part of the setup of the calibration cases, but this is not the case here.
The joint models allow specification of initial conditions in terms of parameters. These parameters can
be tuned. For each of the parameter discussed previously we would like to have a common tuned value
for all cases.
However, for the initial conditions we need individual estimation for each case. Moreover, we would
also need them to be tuned for the evaluation where
the parameters tuned are kept fixed. The initial conditions to be estimated for each measurement case
are specified by the element freeStartValues. Select
the element freeStartValues in the tree browser. It is
specified in the same way as done for tunerParameters. In the select dialog we tick the start values for
the angle and velocity of the two joints.

To specify the criterion, select calibrationCriteria.
Clicking on Select displays a Select browser where
we check pendulumAngle.phi and armAngle.phi.
This fills the “name” column.

The criterion is a weighted sum of the integrated
square difference with respect to measured value for
each variable.
The measurement files to be used are specified by
the element calibrationCases. It also specifies
whether a file is to be used for calibration or validation.

The elements optimizer and integrator allows advanced setting of optimization and simulation parameters. We use their default settings, except for
simulation time that we need to specify.

Clicking OK fills in the variable names in the first
column and start values in the “Value” column.

The Modelica Association

Running the calibration
When all the input data have been entered, the calibration is started by clicking “Execute” on the dialog. The two next plots compare the simulation result
with the obtained tuned parameters and measured
data where the pendulum starts in a horizontal

259

Modelica 2005, March 7-8, 2005

H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M. Otter

tion this was originally a Manutec r3-robot. It was
then updated with incorporating CAD-data from a
KUKA-robot, and the geometry was modified to fit
the CAD-data.
position. The result shows a good agreement. The
tuned parameters were validated against another experiment where the pendulum starts in a more upright position. The system is nonlinear and it is of
interest to validate the model for cases where the
amplitudes of the pendulum are large.

Figure 1 Animation of the robot
The robot consists of a 6 degree-of-freedom mechanical structure modelled as the multibody system
“mechanics” (= bodies connected together by revolute joints). The calculation of the animation can be
optionally switched off to increase simulation speed,
which is especially important during an optimization
run. Every joint is driven by a drive train called
“axis1”, “axis2”, ..., in the next figure:

The jump in the pendulum angle in the validation
case between –100° and –80° is due to problems of
handling wrap-around in the measurement device.
The agreement is good, in particular for the pendulum motions. The modeling of the arm may be improved by a more elaborate modeling of the arm
friction. However, that is out of the scope of this paper.
2.2

Figure 2 Composition diagram of robot
The desired reference motion is generated in component “path” and as input it has the start and end angle
of each axis. All signal data is communicated via a
“data bus”.

Robot optimization

In this section it is demonstrated how to optimize the
controller parameters of a robot for a set of cases
consisting of different loads and reference motions.
Description of the robot
The model is chosen as the r3-robot from the Modelica standard library. As described in its documenta-

The Modelica Association

260

Figure 3 Drive train of one axis

Modelica 2005, March 7-8, 2005

Optimization for Design and Parameter Estimation

One drive train consists of a controller, an electrical
motor, a gearbox (which includes the bearing friction). The controller of one axis is a P-PI cascade
controller, i.e., has the simplest form useful for a
servo drive (in most industrial robots, more sophisticated controllers are used). The goal of the optimization is to tune the values of the 3 controller parameters of every axis:
• kp – gain of position controller
• ks – gain of speed controller
• Ts – integrator time constant of speed controller
The difficulty is that this controller should work well
with a fixed set of values for all paths and operating
conditions encountered by the robot. This makes it
impossible to use standard, linear control design
methods.
Optimization setup
The structure of the optimization setup is similar to
the calibration setup:

the Select dialog to browse the model parameters.
The parameter values for the different cases used to
optimize the design of the controller are then given
by filling out the cases form as below (the selected
parameter names appear as column headings):

Simulation cases are defined by specific settings of
model parameters that are given as labels “startAngle2”, “startAngle3” etc. in the figure above. Note
that in the reference trajectory axis 2 goes through
different movements in the different cases, whereas
axis 3 is fixed in different positions (all other axes
are fixed to the default reference angle in all cases).
In practice, robots are optimized for a larger number
of cases.
Optimization criteria
If we compare the actual axis speed with the reference speed we normally get the following:

The tuner parameters are the 3 controller parameters
of each axis as discussed above. They are easily entered in the tunerParameter dialog by using the Sellect dialog. The snapshot below shows the dialog
when the controller parameters of axis 2 have been
selected. Numeric values have also been entered for
“Value” to be used as the start of the optimization
and minimum and maximum values that are used as
box constraints during optimization and optionally
also for scaling:

For design optimization the goal is in general not to
simply minimize these errors, as it would be for a
calibration, but something more advanced.
For the design optimization we thus have to introduce additional blocks to measure the performance
of the axis, these are introduced by extending the
robot-model with an additional performance component for the reference signals (containing different
performance indicator blocks).

In order to specify the different cases of the optimization, the case parameters are first selected by using

The Modelica Association

261

Modelica 2005, March 7-8, 2005

H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M. Otter

In the performance Modelica model, the following
performance indicator blocks are present (these
blocks are from a criteria library that contains several
predefined useful criteria blocks):
•

Block “Overshoot” computes the overshoot
(here: the maximum deviation from the reference
angle) after the referenced motion has come to a
rest. This is performed very precisely by triggering an event whenever the derivative of the
input signal is zero (here: whenever the speed is
zero), i.e., a minimum or maximum of the signal
is reached and storing the corresponding signal,
if its absolute value is larger than the previously
stored value. The last stored value is the overshoot which shall be minimized.

•

Block “SettlingTime” computes the time until a
signal stays completely within a tolerance band
around zero, after the reference motion is in rest.
This is performed by triggering an event whenever the input signal passes through this band
and storing the corresponding time instants. The
last stored value is the settling time which shall
be minimized.

The usage of these two blocks is shown above. As
can be seen the angle error is used as input to the
“overshoot” block whereas the speed error is used as
input in to the “settlingTime” block.
This is connected to the bus to get the reference signals and the actual values for the specific axis. We
then select two reference indicators, the overshoot
and the settling time, in the optimizer:

The Modelica Association

As an alternative to using criteria blocks in the
model one can compute the criteria in a postprocessing function that operates on the simulation
results and which is selected in the drop down menu
shown below. In this case we select the final value
for these two criteria:

We also have to set the demand values. Based on
first simulations and specifications we set the overshoot demand to 3/1000 [rad/s] and the settling time
to 0.3 [s]:

262

Modelica 2005, March 7-8, 2005

Optimization for Design and Parameter Estimation

Applying these values as demand values results in
the following weighted criteria:
case
overshoot settling time
High 1
0.6854
0.7588
Low 1
1.5106
0.9855
High 2
0.8332
0.5579
Low 2
1.7887
1.0468
The values indicate satisfactory behavior in cases
with load (cases “High 1” and “High 2”), but bad
overshoot performance in unloaded cases (cases
“Low 1” and “Low 2”).
After finalizing the optimization setup, a click on
“Execute” starts the design optimization. As a result
of the first optimization run, which converges after
30 function evaluations, we obtain the following
tuner and corresponding weighted criteria values:
kp2
ks2
Ts2

High 1
Low 1
High 2
Low 2

0.6175
0.9985

0.7161
1.2027

The overshoot demand is satisfied, The settling time
slightly increases to 1.2027 for the worst case “Low
2”. We might stop the design optimization here. In
other cases, one might change demands, select other
simulations cases and criteria. In the next figure, results for the 3 runs (initial, first and second optimization run) are shown for case “Low 2”:

3.0776
2.5089
0.08896

overshoot settling time
0.5929
0.8998
1.0315
1.0902
0.6510
0.7157
1.1956
1.1955

3

Overshoot has been improved but settling time is
slower. The equal and largest criteria values in case
“Low 2” indicate a conflict between the 2 criteria
which usually can only be solved when one criterion
is eased off.
We decide to force the overshoot criteria that they
reach their demand values and to put lower emphasis
on settling time. This is accomplished by applying
all overshoot criteria as inequality constraints during
the next optimization run forcing the optimizer to
perform improvements in these criteria until the demand value is reached. Criteria to be minimized
(here settling time) may increase. The next run results in:
kp2
4.0722
ks2
4.8897
Ts2
0.070565

High 1
Low 1

High 2
Low 2

overshoot
settling time
0.7623
0.8965
0.8845
1.1855

The Modelica Association

Customizable user interfaces

Experimentation includes operations that require rich
interfaces to supply all the information needed to
perform the task.
For model components, parameters have been visually split into groups and tabbed pages, representing
logical grouping of primary and secondary parameters. However, the individual data items comprise a
relatively “flat” structure.
For calibration and optimization the interface contains a much deeper hierarchical structure, and the
complexity at each level is also greater. For example,
it is common that subitems contain variable amount
of data, typically represented by arrays of records.
To handle the increased complexity, the graphical
user interface of Dymola has been extended in two
dimensions:
• The nested structure is visualized by a tree,
which makes relationships easier to understand
and allows easy navigation between data items.
• Specialized GUI elements, for example, for file
and color selection, can be enabled by annotations, which facilitate common input operations.
Several of these improvements are useful also for
simpler data structures, and the specialized GUI elements can also be used for parameters of models. In

263

Modelica 2005, March 7-8, 2005

H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M. Otter

other words, all the features discussed below can be
easily utilized by every user. It is even possible to
make a copy of the calibration and/or optimization
setup and adapt the user interface to the specific
needs of an end-user with more specialized menus.
3.1

Nested structures

shown above), which offers maximum overview in a
compact format.
Alternatively it is possible to inspect and edit
individual array elements, which has the advantage
of displaying descriptions for each input field and
that data can be grouped and put under different tabs.
Each page corresponds to one row in the combined
view.

Model calibration will be used as an example. The
function CalibrateModel takes a record (setup) as its
input parameter. The structure of the record contains
among other elements an array of type TunerParameter, which in turn contains several attributes.
function CalibrateModel
"Calibrate model to measured data"
input ModelCalibrationSetup setup;
...
end CalibrateModel;

The implementation of the tree view also ensures
that data filled out by the user is propagated. For
example, changes to an individual tuner parameter
must be visible when the user switches to the tabular
view of all tuner parameters. Changes in a modifier
at a high level is propagated down to more detailed
views.

record ModelCalibrationSetup
String Model;
TunerParameter tunerParameters[:];
...
Optimizer optimizer;
Integrator integrator;
end ModelCalibrationSetup;

3.2

record TunerParameter
"Model parameter to be optimized ..."
String name="" "Full name of ...";
Boolean active=true "true, if ...";
...
end TunerParameter;

The GUI is automatically built from the data structure declarations. The nested structure of the input to
CalibrateModel is evident in the tree view at the left.

The tree serves two puposes. First it shows the
structure and makes it easier to understand what
information must be provided. The tree view corresponds exactly to the data structure. Second, it is
used to navigate between multiple “pages” (input
forms) that are swapped into the space at the right.
The component tunerParameters is an array of
records, each containing several variables. The user
can choose a combined tabular view of the array (as

The Modelica Association

New GUI elements

The graphical user interface can greatly simplify
certain input tasks with some additional support.
Although it is always difficult to strike a balance
between features and complexity, the following operations have been found useful in the experimentation environment.
The deployment of these GUI elements is controlled
by model annotations, either at the class level or on
individual variables.
Predefined choices. A list of values suitable to a
particular type or application are presented. A simple
example is “true” and “false” for Boolean. Selection
of a criteria function is specified by this annotation:
CriterionSpecification criteria
"Criteria specification"
annotation (choices(
choice=FinalValue(),
choice=SettlingTime(),
choice=Overshoot()));

To the user the choices are presented in a drop-down
combobox:

264

Modelica 2005, March 7-8, 2005

Optimization for Design and Parameter Estimation

Because parameters which depend on the selected
function must also be specified, pressing the “edit”
button will display a dialog for the parameters to the
chosen function.
Color selection. Colors can typically be represented
by RGB (red, green, blue) or HSV (hue, saturation,
value) tuples. Although they could be specified numerically by the user, a colorful dialog makes selection much easier.
File selection. Standard dialogs for selecting files
either for reading or writing data. The filename is
stored in the corresponding variable.
Variable selection. Several operations in the experimentation environment involves the selection of
variables from the model, for example, parameters to
optimize. A specialized selection dialog simplifies
the task considerably. Furthermore, additional data,
such as, start/min/max values can be extracted.
In this case a detailed specification (in the form of an
annotation) is needed to move data into the right
elements of a table, and if needed resize the table.
User-defined labels. The default labels used in the
tree view or in the combined tabular view are constructed from variable names found in the data
structure. By use of annotations, other labels can be
specified or even extracted from actual data in the
structure.

then requirements' satisfaction of a design alternative
(II) is said to be better than of a design alternative (I)
if α ( II ) < α ( I ) . If α ≤ 1 , the design alternative is
called a satisfactory solution, because in that case
each criterion is less than the respective demand
value. In particular, a best possible design alternative
is characterised by α * = min {α } , yielding the overall constraint optimization problem which can be
solved by standard optimization methods:

4

that γ ≥ max{qij (T ), ij ∈ S min } . Instead of (1), we

Solving the Multi-Criteria
Optimization problem

In a multi-criteria optimisation problem setup all
weighted criteria qij = cij / dij , ij ∈ S min can be combined to a vector q , where S min denotes the set of
all criteria (i) to be minimised defined in all simulation cases (j). In order to decide whether a solution
q I is better than a solution q II , these vectors should
be completely comparable. However, comparing
each vector component individually, some components can be better, others can be worse. To make
criteria vectors completely comparable a vector norm
has to be introduced.
We prefer to use the max-norm, because weighted
criteria with positive ‘the smaller the better’ values
and quality limiting demands as upper bounds yield a
most visible comparative satisfaction assessment of
design alternatives in case of the max-norm. Define
for all weighted criteria

min max{cij (T ) / dij }
T

ij ∈S min

cij (T ) ≤ dij ,

ij ∈ Sinequality

cij (T ) = dij ,

ij ∈ Sequality

(1)

Tmin ,k ≤ Tk ≤ Tmax ,k
The disadvantage of this approach is the lack of differentiability of the aggregation function. Thus,
methods relying on gradients (like SQP methods)
can encounter difficulties in this case.
To overcome the problem of differentiability we
provide two mechanisms: an exponential approximation of the max-function yielding a smooth overall criteria and a reformulation by ‘equivalent constraints’. In the latter case the min-max problem can
be reformulated by an equivalent constrained problem. Let γ be a new variable for which we impose
can solve an equivalent optimization problem with
the extended parameter vector x = [T , γ ] . The aggregation function to be minimized is simply α (x) = γ .
Defined inequality and equality constraints are applied as in (1) while the components to be minimized
are added as additional constraints as
qij ( x) ≤ γ ,
ij ∈ Smin
The main advantage of this formulation is that the
functions are differentiable provided the defined
problem criteria are differentiable. The disadvantage
is that a problem of higher dimension is solved and
additional constraints are added. However, the application of this formulation of the min-max problem is
recommended whenever a gradient based optimization method is used. There is an option to choose
other aggregation functions like weighted sum:

α := ∑ | qij |, ij ∈ S min
ij

α := max{qij }, ij ∈ S min ,
ij

The Modelica Association

265

Modelica 2005, March 7-8, 2005

H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M. Otter

Optimization Methods
At the moment 5 different methods to solve the optimization problem (1) are implemented for use with
Modelica:
1. Sequential quadratic programming (SQP)
2. Quasi Newton (Bounds)
3. Pattern search (Pattern)
4. Simplex method (Simplex)
5. Genetic algorithm (GA)
The Sequential Quadratic Programming (SQP) approach can be used to solve the general optimization
problem and has usually a super-linear convergence
(= faster than linear, and slower than quadratic convergence). Bounds on tuners and linear equality and
inequality constraints are met exactly during the iterations. The SQP approach needs gradients of functions and constraints. SQP in combination with the
reformulation of the min-max optimization problem
as an equivalent constraint problem is the method of
choice for general optimization or calibration problems.
The Quasi Newton method (Bounds) is an algorithm
intended to solve large optimization problems but
can only handle simple bounds constraints on the
tuners. “Bounds” needs also gradient information of
the aggregation function.
The Pattern Search approach is a derivative free
search method. It is numerically more robust in
tackling with non-smooth criteria than other methods.
The Simplex approach is also a derivative-free algorithm and employs linear approximations to the objective and constraint functions. The main advantage
of SIMPLEX over many of its competitors is that it
treats each constraint individually when calculating a
change to the variables, instead of lumping the constraints together into a single penalty function. A
drawback of this method is that even bound constraints can be violated during computation.
The genetic algorithm (GA) is a global optimization
technique. The basic algorithm allows only simple
bounds on the variables. Thus, to address more general constraints, penalty function techniques are employed. The genetic algorithm search method is
based on evolution principles which guarantee the
survival of the fittest individual. The use of GA for
optimization is normally quite costly in terms of
function evaluations.

The Modelica Association

5

Conclusions

An environment was presented to optimize Modelica
models in Dymola, especially with regards to design
optimizations and calibration of unknown model parameters.
It is possible to prepare a customized GUI in Dymola
for specific tasks such as optimization. This makes it
possible to customize the optimization menus. Since
the customization is performed in Modelica (annotations) it is possible for an end-user to also adapt this
to his/her particular needs.
Acknowledgements
Measurements and calibration of the Furuta pendulum was performed by Marco Bracci as a part of his
master-thesis project at the Department of Automatic
Control, Lund Institute of Technology, Lund, Sweden.

References
[1] Åkesson J. (2000): Safe Manual Control of
Unstable Systems. Master Thesis, ISRN
LUTFD2/TFRT--5646—SE, Department of
Automatic Control, Lund Institute of Technology,
Lund, Sweden.
[2] Dynasim (2005): Dymola - Users’ Manual
[3] Joos H.-D., Bals J., Looye G., Schnepper K., Varga
A. (2002): A multi-objective optimisation based
software environment for control system design.
Proc. IEEE International Conference on Control
Applications, Glasgow, Scotland, Sept. 18-20, pp. 714.

266

Modelica 2005, March 7-8, 2005

Nonlinear Inverse Models for Control

Nonlinear Inverse Models for Control
Gertjan Looye, Michael Thümmel, Matthias Kurze, Martin Otter, Johann Bals
DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany
{Getjan.Looye, Michael.Thuemmel, Matthias.Kurze, Martin.Otter, Johann.Bals}@DLR.de

Abstract
A general technique to design advanced controllers
for non-linear systems is described, using component
oriented modeling and symbolic algorithms as used
for Modelica models. Starting point are linear design
techniques that use linear inverse models as a core
part of the controller structure. Starting from such a
structure, the approach is to replace the linear inverse
model with a nonlinear one, resulting in a controller
that is applicable over the full operating range of the
(nonlinear) plant. It is shown that nonlinear inverse
models may be automatically generated from the
plant model in Modelica.

1

Introduction

The subject of this article is the systematic design of
controllers for nonlinear systems, based on inversion
of the plant model. Traditional design techniques
require the nonlinear plant model to be linearised
around a stationary operating point, after which linear methods may be applied to synthesize a controller. In order to make this controller work over the
full operating range of the plant, robust design techniques and/or gain scheduling are applied. The first
approach may considerably reduce achievable performance if the plant dynamics vary strongly over
the operating range, whereas the latter may involve
designing many controllers at a grid of operating
points and finding an interpolation scheme in between them.
In linear design, inversion of plant dynamics is
sometimes used to compensate for coupled input /
output responses, or as an easy way to impose specific dynamic behavior of the closed-loop system [7].
Provision is that the linear plant model is minimum
phase and, for some structures, stable. In a nonlinear
context, the application of model inversion additionally provides compensation of nonlinear dynamic

The Modelica Association

behavior of the plant. This is exploited in design
techniques such as feedback-linearization [19].
The design approach in this article starts from any
controller structure that is based on a linear inverse
model of the plant. This model is replaced with a
nonlinear inverse one, resulting in a controller that is
valid for the full operating range of the plant. In case
the plant model is available in Modelica, it will be
demonstrated that inversion can be performed automatically, exploiting symbolic algorithms and code
generation features of a Modelica simulation environment. This allows for a highly automated design
process that directly results in nonlinear controllers
that work in all operating conditions of the plant,
avoiding the need for gain scheduling.
This article is structured as follows. First general
aspects of nonlinear inverse models are reviewed, as
well as the possibility to derive these automatically
from Modelica. In section 4, a number of common
controller structures are discussed, for which the described design approach is applied. Next, a design
example will be discussed. In section 6 a number of
common problems in deriving and applying nonlinear inverse models will be described, as well as possible solutions or workarounds.

2

Inversion of Nonlinear Models

The goal is to use a nonlinear plant model in a controller in order that the nonlinearities of the plant are
directly taken care of in the control system. For linear systems, several control structures are known
where an inverse plant model is part of the controller. A single-input-single-output plant might be described as transfer function

y=

n( s )
u
d ( s)

(1)

where “u” is the plant input, “y” is the plant output,
“n(s)” is the numerator and “d(s)” is the denominator

267

Modelica 2005, March 7-8, 2005

M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals

of the transfer function. In section 4 several control
structures will be investigated where an inverse
model

u=

d ( s)
y
n( s )

(2)

is part of the controller. Basically, the plant and the
inverse plant model “cancel” each other due to the
connection structure and by additional control blocks
a desired transfer function of the closed loop system
can be achieved. Although, this seems to be quite a
“brute” force method, it will be shown that by appropriate adaptations practically useful control systems can be designed.
The essential idea is as follows:
1. Take any control structure for linear systems that
utilizes a linear inverse plant model.
2. Replace the linear inverse plant model by a more
detailed nonlinear inverse plant model.
3. Determine the remaining part of the control system by appropriate techniques, e.g., by tuning
controller coefficients via parameter optimization.
Several different controller structures according to
this technique will be discussed in section 4. The
difficult part is issue (2): The nonlinear plant model
should be constructed in a convenient way and the
inverse model should be directly derived from the
plant model. It turns out that Modelica is very well
suited for this approach because Modelica is designed to model complex systems, and since Modelica tools, like Dymola [5], can generate nonlinear
inverse models automatically:
A continuous Modelica model is primarily mapped
to a DAE (= set of Differential Algebraic Equations)
of the form:

0 = f (x , x, y , u)

(3)

where x(t) are variables that appear differentiated in
the model, y(t) are algebraic and u(t) are known input functions of time t. It is possible to transform
system (3) to the following state space form, at least
numerically:

 x 1 
x 
 2  = f (x , u)
y 1 1
 
w

y=

s +1
u
( s − 2) ⋅ ( s + 3)

(5)

The inverse model is constructed as

u=

(4)

where x1 and x2 form vector x such that the subset
vector x1 is the state vector and contains the independent variables of x. The new vector w contains
higher order derivatives of x and of y that appear

The Modelica Association

when differentiating equations of f(..) and that are
treated as algebraic variables. For the computation of
f1(..), it might be necessary to solve linear and/or
non-linear algebraic systems of equations. The equations to be differentiated can be determined with the
algorithm of Pantelides [15]. The selection of the
state variables x1 can be performed with the “dummy
derivative method” of Mattsson and Söderlind [16].
Both algorithms are, for example, available in the
Modelica simulation environment Dymola [5].
An inverse model of the DAE (3) is constructed by
exchanging the meaning of variables: A subset of the
input vector, uinv, with dimension ninv, is treated no
longer as known but as unknown, and ninv previously
unknown variables from the vectors x and/ or y are
treated as known inputs. The result is still a DAE
which can be handled with the same methods as any
other DAE. Examples are given in the following sections. This technique of constructing non-linear inverse models has been first applied in [17][18]. An
inverse model can only be used in a controller if the
DAE of the inverse model has a unique solution and
if it is stable. For linear systems the latter requirement means that the plant must be a minimum phase
system. In section 6 it is discussed how to proceed if
these requirements are not fulfilled.
Since the transformation from (3) to (4) might differentiate equations, the known inputs of the inverse
model may be differentiated too, i.e., the derivatives
of these inputs must exist and must be provided analytically up to a certain order. These derivatives can
be provided if, e.g., the inputs are available as analytic functions that can be differentiated sufficiently
often, or by a desired reference model that in combination with the inverse DAE results in a DAE that
does not require derivatives of inputs. Often, the reference model is selected as a filter such that a combination of the filter states yields the needed derivatives. For linear systems, this approach is well
known. Take for example the following linear system with one zero and two poles:

( s − 2) ⋅ ( s + 3)
1
⋅
y
( s + 1)
(Ts + 1)

(6)

In order that the inverse model is causal (i.e., can be
implemented as an algorithm), additional poles have
to be added until the degree of the denominator is
larger or, at least, as large as the degree of the numerator. For this reason, a filter 1/( Ts + 1 ) has been
connected in series, making the combined transfer

268

Modelica 2005, March 7-8, 2005

Nonlinear Inverse Models for Control

function causal. Another possibility is not to control
y, but one of its derivatives instead:

y = s ⋅ y =

s ( s + 1)
⋅u
( s − 2) ⋅ ( s + 3)

The transfer function is proper now and may be inverted:

u=

( s − 2) ⋅ ( s + 3)
y
s ( s + 1)

4
2
3

Connecting this controller with the plant (5) in series
results in integrator behavior. A simple feedback
loop may be added to place the integrator pole at a
desired location.

3

is described by the equation “u1 = u2”. If the filter
order is too low the DAE is not causal and Dymola
prints an error message of the following form (Dymola version 5.3b and later):
Error: The model requires derivatives of
some inputs as listed below:
Order of input derivative

Constructing Inverse Models

With a Modelica simulation environment, such as
Dymola, the practical derivation of inverse models is
straightforward, even for complex systems:
1. Define the plant as Modelica model and include
input and output signals of the plant over which
the inversion shall take place.
2. If necessary, provide a reference model or input
filter of appropriate relative degree. The relative
degree may be known from physical knowledge
of the plant dynamics, or can be automatically
derived by Dymola as described below.
3. Connect the “u1” inputs of a “Modelica.Blocks.Math.TwoInputs” block to the plant
outputs, the “u2” inputs of this block to the outputs of the reference model, and the input of this
model to an input signal connector (Modelica.Blocks.Interfaces.RealInput) that defines the
desired plant outputs.
A typical example is shown in Fig. 1. On the left side
the plant model with one input and one output is

Fig. 1. Definition of inverse model with Modelica

present. On the right side, a filter is used as reference
model. The output of the filter should be connected
to the output of the plant. This is not directly possible, because signal connectors can only be connected
according to block diagram semantic and in block
diagrams it is not allowed to connect two output signals with each other. For this reason the “TwoInputs” block is used. It has two inputs u1 and u2 and

The Modelica Association

u1
u2
u3

Error: Failed to reduce the DAE index
In the second column the Modelica names of the input signals are listed that need to be differentiated
according to the differentiation order of the first column. The numbers in the first column are therefore
the minimum order of the corresponding filters.
If the inversion is to be based on a time derivative of
the output, a sufficient number of integrators needs
to be added, instead of increasing the filter order.
There is always a filter order / number of integrators
for which the system will translate. The higher the
filter order, the more problems will occur when applying it in a control system. In such cases, one
might remove dynamic elements from the plant and
try it again. One might even use a stationary plant
model.

4

Example Controller Structures

In this section different controller structures will be
discussed that follow the general approach outlined
in section 2.
4.1

Inverse Model in Feedforward Path

Different variants of linear controllers with two
structural degrees of freedom are known. The most
general form for linear, single-input/single-output
systems has been proposed and analyzed by Kreisselmeier [12]. According to the approach sketched in
section 2, the generalization using nonlinear inverse
models is shown in Fig. 2. This structure has been
applied in [22] to the control of robots and has been
successfully validated with hardware experiments. In
flight control, the “model following approach”, see
for example [2], is a special case of this structure
whereby the reference model is known as the “command block” providing state references for the inverse model as well as the feedback controller.
In Fig. 2 the multi-input/multi-output plant has inputs u, measured signals ym and outputs yc that are
primarily controlled. In many cases yc ∈ ym. For this
controller structure the number of inputs must be

269

Modelica 2005, March 7-8, 2005

M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals

yc,d(t) reference
inverse
model y ,y ..,y (p) plant model
c,d r
c,d r
c,d r

ud

e
ym,d

feedback
controller

-

u

uc

yc
plant
ym

controller
Fig. 2. Controller with two structural degrees of freedom and
an inverse plant model in the feedforward path

controller
e
yc,d

-

u

inverse
plant model

feedback
controller

plant

yc = ym

Fig. 3. Compensation controller using an inverse plant model in the feedback path

yc,d

controller
feedback
controller

inverse
plant model

u

plant

ym

Fig. 4. Feedback linearization

uc

u
+

yc
plant

controller part for robustness

filter
-

ym

(p)

y m f ,y m f ..,y m f

inv. desired
plant model

filter

Fig. 5. Forcing a “desired plant” behavior using an inverse desired plant model in the feedback path

identical to the number of controlled variables:
dim(yc) = dim(u). In this case the inverse plant
model with (known) inputs yc and unknown outputs
u is used in the feedforward path of the controller to
compute the desired actuator inputs ud to the plant.
A “reference model” defines the desired dynamic
behavior of the closed loop system. It is often most
convenient to use a filter, since the filter is parameterized by just the cut-off frequency, once the filter
order and the filter type is fixed, and because a filter
provides the “optimal” reference model with transfer
function “1” below the cut-off frequency. There are
also other useful choices of the reference model, see
for example [2] for in-flight simulation.
The outputs yc,dr of the reference model are the inputs
to the inverse plant model. By solving a DAE system
(3) or the symbolically transformed system (4), the

The Modelica Association

inverse plant model computes the desired measurement signals ym,d and the desired plant inputs ud. A
feedback controller is used to stabilize the overall
system and to improve robustness. This might be a
simple PID like controller.
It can be shown that the feedback controller has no
effect, as long as the plant and the inverse plant
models are identical, the plant and the inverse plant
models are stable and both start at the same initial
conditions. In this case the “reference model” determines the input/output behavior, i.e., it is the transfer
function of the closed loop system. If these assumptions are not fulfilled, a control error occurs and the
controller has to stabilize the system and cope with
the imprecise inverse plant model and its initial conditions.
The structure in Fig. 2 has several advantages:

270

Modelica 2005, March 7-8, 2005

Nonlinear Inverse Models for Control

•

The two controller parts (inverse plant model
with reference model and feedback controller)
can be designed independently from each other.
• The controller structure can be applied to unstable plants provided the inverse model is stable,
see section 6.1.
• Since the inverse plant model is in the feedforward path, the calculation of ud and of ym,d might
be performed offline if possible, so that hard
real-time requirements for the solution of the inverse plant model are not present.
The disadvantage of this structure is that for some
applications the feedback controller may still have to
be scheduled as a function of the operating conditions.
Inverse model-based feedforward control will be
demonstrated at hand of an example in section 5.
4.2

Compensation Controller

The disadvantage of the inverse feedforward controller can be avoided by moving the inverse model into
the feedback path. This is shown in Fig 3. The feedback controller now only “sees” the combined inverse and plant model. The structure is a generalization of the linear compensation controller described
in Föllinger [10], page 266. For linear plant models
the “feedback controller”, see Fig. 3, must have a
relative degree that is equal or larger than the relative
degree of the plant, in order that the system is proper.
For single-input/single-output systems, a useful
“feedback controller” is

uc =

1
⋅e
r ( s) − 1

(7)

Under the assumption that the desired and the actual
plant behavior is identical, the inverse and the actual
plant model “cancel” each other and the transfer
function from yc,d to yc is identical to 1/r(s), i.e., r(s)
of the feedback controller defines the “desired”
closed loop behavior. Note that it is assumed that yc
is measurable (in this case, yc = ym). Alternatively,
the procedure as described in section 2 may be applied: integrators are added to the inverse model input before designing the feedback controller.
This structure has the disadvantage that it can be applied to stable plants only. Also the inverse plant
model needs to be stable. For a linear plant model
this is obvious, since otherwise an unstable pole/zero
cancellation occurs, resulting in an internally unstable system. For multi-input/multi-output systems it is
nearly always possible (also for unstable plants) to
construct the inverse of a stationary desired plant
model. Once the control error e has reached a staThe Modelica Association

tionary value, the inverse plant model leads to a decoupled control loop. In other words, the different
outputs might be controlled independently from each
other by simple PID-like single-input/single-output
controllers and the stationary inverse plant model is
used to decouple the control loops from each other.
4.3

Feedback linearization

A complete theory to use nonlinear plant models as
the controller kernel is “feedback linearization” (in
aerospace applications also known as Nonlinear Dynamic Inversion, NDI), see for example Isidori [11]
and Enns et. al. [7]. The basic structure is given in
Fig 4. The principal difference compared with the
compensation and feedforward controllers (Fig. 2,3)
is that the states in the inverse model are obtained
from the actual plant, via measurement and estimation. Contrary to the compensation controller, the
methodology can also be applied to unstable plants.
When deriving feedback linearizing control laws
manually, the outputs to be controlled are differentiated until an analytical relation with a control input
is found [19]. To this end “Lie” algebra is used. The
number of required differentiations is the so-called
relative degree of the specific output. If the system
model is available in Modelica, the derivation of the
control laws can be automated using a similar procedure as described in section 2. However, instead of a
filter of appropriate relative degree, a set of integrators is added (see section 2):

yi =

1
νi
s pi

where νi is the ith new model input, corresponding
with the ith output (with relative degree pi). The desired dynamic behavior of the closed-loop system is
then imposed by application of an additional feedback law, like for example:

ν i = k0,i ( ymd ,i − ym ,i ) − k1,i ( ym(1),i )... − k( pi −1),i ( ym( pi,i −1) )
(8)
Note that this feedback law requires availability of
the (pi-1)th derivative of the controlled output. This
derivative may be obtained from measurements or,
less favorably, from the computed value in the inverse model. In aerospace applications first or no
time derivatives are usually required, since relative
degrees of controlled variables tend to be low (1 or
2). One reason for this is that control laws are designed in the form of multiple cascaded loops [7]. In
case the inverted model exactly represents the true
system, the closed loop system becomes:

271

Modelica 2005, March 7-8, 2005

M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals

ym , i =

k0,i
p

s + k( p −1),i s

p −1

+ ... + k1,i s + k0,i

ymd ,i

Note that the coefficients may be selected to match
the reference model in Fig. 2.
In case time derivatives of the desired output yc,d,i are
available, the relative degree (i.e. phase lag of the
response) of this linear closed loop system may be
reduced, provided that these are not too fast as to
require too large control inputs.
An important disadvantage of feedback linearization
is that the state vector of the plant must be fully
available from measurement and/or estimation.
Automatic generation of feedback linearization control laws in Modelica will be illustrated in section 5.
This procedure has been applied for an automatic
landing system, see [13], and manual control laws
for a fighter aircraft, see [21]. The software code for
the automatic landing system was automatically generated with Dymola and successfully flight tested on
a small passenger jet [3], see the figure below that
shows one of the automatic landing tests.

4.4

Robust Controllers

All previous controller structures require that the
plant model used as inverse system in the controller
match the real plant “sufficiently” accurate. The
controller structure in Fig. 5 uses an inverse model to
achieve a more robust design. It was developed for
linear systems with the goal to enhance robustness
against disturbances and model errors, see [14][23]
[1]. This structure is called “disturbance observer” in
the literature although the name is misleading since it
is actually an additional structural degree of freedom
for a controller. It can be designed independently
from the main control loop. In Fig. 5 the generalization for nonlinear systems is shown: One important
part is an inverse model of a desired plant behavior
in the feedback path. Additionally, the same filter is
present at two places. The standard disturbance
observer uses a linear model for the inverse plant
model. A nonlinear desired plant model provides
more freedoms, since it might be impossible that a
physical system can be forced to have the same

The Modelica Association

linear behavior in its whole operating range. Note,
there is the requirement that the number of
measurement signals is identical to the number of
plant inputs: dim(ym) = dim(u).
For a single-input/single-output system where all
parts are linear, the transfer function from uc to ym is
given by:

ym =

1
⋅u
1 − F ( s) F ( s) c
+
P( s)
Pdes ( s )

(9)

where F(s) is the filter, P(s) is the plant and Pdes(s) is
the desired plant transfer function in the feedback
loop. For low frequencies, F(s) ≈ 1 and therefore
ym ≈ Pdes ( s) ⋅ uc . For high frequencies, F(s) ≈ 0 and
then ym ≈ P ( s ) ⋅ uc . The effect of the disturbance
observer is therefore, that it enforces the desired
plant behavior for low frequencies. In other words, if
there are modeling errors or disturbances then the
disturbance observer enforces a desired plant behavior below the cut-off frequency of the filter, i.e., the
controller designed for the desired plant will usually
work considerably better.
The disturbance controller is usually combined with
other controller structures. For example, by combining it with the structure from section 4.1, a controller
with 3 structural degrees of freedom is obtained:
• An inverse plant model from yc to u in the feedforward path is used for command following and
for providing the desired measurements ym,d.
• An inverse plant model from ym to u in the feedback path is used to make the closed loop system
robust against model errors and disturbances.
• The feedback controller in the feedback loop is
used to stabilize the system.

5

Example application

In this section the feedforward and feedback linearization controller structures as discussed in the previous section will be illustrated on the following example (the plant description is from Föllinger [9],
page 279):
A substance A is flowing continuously into a mixing
reactor. Due to a catalyst, the substance reacts and
splits into several base substances that are continuously removed. The reaction generates energy and
therefore the reactor is cooled with a cooling medium. The cooling temperature Tc(t) in [K] is the
primary actuation signal. Substance A is described

272

Modelica 2005, March 7-8, 2005

Nonlinear Inverse Models for Control

by its concentration c(t) in [mol/l] and its temperature T(t) in [K] according to the following DAE:

γ = c ⋅ k0 ⋅ e − ε / T
c = − a11 ⋅ c − a12 ⋅ γ + a13
T = − a21 ⋅ T + a22 ⋅ γ + a23 + b ⋅ Tc

(10)

{ }

with

k0 = 1.24 ⋅ 1014

a11 = 0.00446

a21 = 0.0303

ε = 10578

a12 = 0.0141

a22 = 2.41

b = 0.0258

a13 = 0.00378

a23 = 1.37

turns out that this DAE has two states. One possibility is to use the filter states {x, c} as state vector x1
of the overall system. Here, the original plant states
{c, T} are used as state vector x1. Transforming the
equations to the state space form (4) results in the
following sequence of assignment statements to
compute the derivative c, T of the state vector and
of the output Tc as function of {c, T}

γ := c ⋅ k0 ⋅ e−ε / T
c := − a11 ⋅ c − a12 ⋅ γ + a13
x := c + c / ω

For the given input Tc(t) these are 1 algebraic equation for the reaction speed γ(t) and two differential
equations for c(t) and T(t). The concentration c(t) is
the signal to be primarily controlled (= yc) and the
temperature T(t) is the signal that is measured (= ym).
5.1

x′ := ( cdes − x ) ⋅ ω

c′′ := ( x′ − c ) ⋅ ω

γ ′ := ( c′′ + a11 ⋅ c ) / a12


T2  γ′


T :=
c
⋅
−

ε ⋅ c  k0 ⋅ e − ε / T

T := (T + a ⋅ T − a ⋅ γ − a

Inverse Model in Feedforward Path

The inverse plant model is constructed from (10) by
assuming that the variable to be controlled, i.e., the
concentration c(t), is a known time function. By inspection or by using the Pantelides algorithm [15] it
turns out that the first two equations of (10) have to
be differentiated:

ε ⋅c  

T  ⋅ k0 ⋅ e − ε / T
2
T




c = −a11 ⋅ c − a12 ⋅ γ

γ =  c +

(11)

(10) and (11) are the inverse model of (10). A filter
with an nth order pole on the negative real axis is
used as “reference model”. Since the second derivative of the input appears (= c ), at least a filter of order 2 is needed, such as:

c=

1

( s / ω + 1)

2

⋅ cdes

(12)

with cdes the desired concentration, ω = 2π f and f
the cut-off frequency of the filter. A state space description of the filter is given by:

x = ( cdes − x ) ⋅ ω
c = ( x − c ) ⋅ ω

(13)

(15)

c

21

22

23

)/b

For notational clarity, the time derivatives of variables that are treated as purely algebraic variables (=
“dummy derivative method”) are denoted with an
apostrophe, such as γ ′ . Equations (15) are a set of
differential equations in state space form: Given the
desired concentrations cdes , it is possible by numerical integration to compute the desired cooling temperature Tc (= ud in Fig. 2) and the desired substance
temperature T (= ym,d in Fig. 2). The latter is compared with the measured substance temperature
forming the control error e as input to the feedback
controller.
Even for this rather simple system, the derivation of
the nonlinear feedforward controller is not so easy.
Such a manual derivation becomes impractical if the
plant model consists of hundreds or of thousands of
equations as it is usual in complex Modelica models.
It is now demonstrated how to derive this nonlinear
feedforward controller in an automatic way:
.

The needed second derivative of c is obtained by
differentiating the second equation of (13):

c = ( x − c ) ⋅ ω

(14)

Equations (10), (11), (13), (14) are the DAE of the
inverse model of (10) with a prefilter of order 2, i.e.,
these are the connected blocks labeled as “inverse
plant model” and as “reference model” in Fig. 2. It
The Modelica Association

273

Fig 6. Modelica model of mixing unit with
constant cooling temperature T_c

Modelica 2005, March 7-8, 2005

M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals

controller
controller

Fig 9. Control system with nonlinear feedforward path for mixing unit

In Fig. 6 a Modelica model of the mixing unit is
shown. The constant input is the cooling temperature; the outputs are the concentration c and the temperature T of the substance. This model contains just
the equations (10). Simulation results of this model
are shown in Fig. 7. As can be seen, the system is
unstable at this operating point

sufficient to stabilize the system. A controller gain of
20 is selected.
Simulation results are shown in Fig. 10 for a jump of
c_des = 0.492 to 0.237. The straight lines correspond
to the nominal case, where the plant and the inverse
plant model have the same parameters. The result is
a good control behavior. The dashed lines correspond to the case where the parameters of the plant
are 50 % higher as the parameters of the inverse
plant model to check the robustness of the design
(only parameter ε was not changed because the result is very sensitive to it). As can be seen, the result
is still satisfactorily. For an actual design, it is useful
to perform a Monte Carlo simulation by varying all
model parameters and initial conditions of the plant
systematically in order to determine how robust the
control system is

Fig. 7. Simulation results of mixing unit for c(t0) =
0.237 mol/l, T(t0) = 323.9 K, T_c(t) = 308.5 K

In Fig. 8 the inverse model of the mixing unit is constructed by connecting the input “c_des” via a filter
to the “c” output of the mixing unit, i.e., the concentration c is treated as known input signal.

Fig 8. Inverse model of mixing unit

When this system is translated without the filter,
Dymola reports that the second derivative of c_des is
needed. In a second step, the filter is included with
order = 2 and Dymola translates without an error.
Afterwards, the inverse model is connected with the
plant model according to Fig. 2. The result is shown
in Fig. 9. In order to not have a jump in the cooling
temperature, a filter order of 3 instead of 2 is actually
used. The cut-off frequency of the filter is set to
1/300 Hz. It turns out that a simple P controller is
The Modelica Association

274

Fig. 10. Simulation results of mixing unit of Fig. 8
Straight line: same model parameters for plant and
inverse plant model. Dashed line: model parameters
of plant are enlarged by 50 %

Modelica 2005, March 7-8, 2005

Nonlinear Inverse Models for Control

Fig 12. Closed loop system of mixing reactor and feedback linearization controller

5.2

Feedback linearization

The compensation control scheme and the feedback
linearization cannot be applied directly to the example plant, since the concentration c is not measurable.
One possibility is to use model knowledge in combination with estimation (e.g. a Kalman filter), but this
is beyond the scope of this example. For this reason
it is assumed that the concentration is measurable. In
Modelica, design of feedback linearization and the
compensation controllers start in the same way. This
time two integrators are added, instead of an input
filter, see Fig. 11.

whereby c is available from measurement and c is
computed or obtained from differentiation. By
choosing

k1 = (2π f ) 2 ,

k2 = 2(2π f ) ,

with f = 1/300 Hz, exactly the same closed loop dynamics is obtained as with the input filter of second
order in section 5.1. Starting from the ideal response

1
k1
= 2
r ( s ) s + k2 s + k1
the feedback controller may also be shaped as:

k1s 2
1
2
Tc =
s = 2
r ( s) − 1
s + k2 s

Fig 11. Inverse model of mixing unit for feedback linearization (compare with Fig. 8)

In the case of the compensation controller, the inversion work is done. For feedback linearization, the
states in the inverse plant model must be replaced
with measured ones. This can be performed by setting the flag
Advanced.TurnStatesIntoInputs = true
before translation to transform all states into inputs
in the generated code. This code can be incorporated
with the export feature of Dymola in another environment, such as Simulink from Mathworks. Currently, it is not possible to import this transformed
system in Modelica again. Dynasim plans to support
this in the future. For the example, the differentiated
equations (11) are added manually to the model, and
c and the plant states (c,T) are selected as input
variables (in case of complex models this manual
derivation is not practical). The design is finished by
adding the feedback controller. In case of feedback
linearization, a usual choice is:

Fig 13. Closed-loop and ideal step response of the mixing
reactor

c" = k1 (c des − c) − k 2 c

The Modelica Association

275

Modelica 2005, March 7-8, 2005

M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals

whereby in the numerator s 2 has been added, since
the input of the inverse model is effectively the second time derivative of cdes. Fig. 13 shows the response of the closed loop system to the same command as in Fig. 10. The command input has been
smoothed with a first order filter (as in Fig. 8). The
over-all closed-loop system is depicted in Fig. 12.

6

Difficulties with Inverse Models

When constructing inverse models for industrial systems, it is often the case that the generated inverse
models do not work as expected. In this section, the
major reasons are discussed and it is explained how
to circumvent such problems.
6.1

ing the plant. E.g., in the example above, the approximate inverse plant model would be:

u=

s1
f

s2

Usually, it is required that the inverse model is a stable system. For example, in the structure of Fig. 2,
the inverse model is in the feedforward path and if it
would not be stable, the overall system would be
unstable as well. For linear single-input/single-output
systems this situation is well known and can be easily analyzed. For example, take the following linear
plant model:

s −1
u
( s − 2) ⋅ ( s + 3)

(16)

The inverse model together with a reference model is

u=

( s − 2) ⋅ ( s + 3)
y
( s − 1) ⋅ (Ts + 1)

(17)

As can be seen, the inverse model is unstable, because the plant has an unstable zero. In other words,
for linear systems the plant must be a minimum
phase system in order that the inverse model is stable. For a general DAE no stability proof exists.
Therefore many simulations have to be performed
with the inverse DAE to check whether it is stable in
the desired operation region. For certain classes of
DAEs, it might be possible to prove that the inverse
model is stable. An alternative is to linearize the
plant model around several stationary operating
points and check whether the transmission zeros are
stable. Of course, none of these checks can guarantee
that the inverse DAE is stable for simulations or stationary points that have not been analyzed.
If the inverse plant is unstable, only approximate
inverse plant models can be used for the design. For
linear single-input/single-output systems this can be
achieved by removing unstable zeros before invert-

The Modelica Association

(18)

For a non-linear plant, one might choose other outputs of the plant as inputs to the inverse model, since
this might change the stability behavior of the inverse plant, see for example [20]. Alternatively, the
plant might be modified before inversion. These advices are demonstrated by the crane example in Fig.
14.

Unstable inverse models

y=

( s − 2) ⋅ ( s + 3)
y
(Ts + 1) 2

ϕ

Fig 14. Crane consisting of horizontal moving
crab and a load on a rope
The crane consists of a horizontally moving crab and
a rope on which the load is attached. For simplicity,
the load is modeled as a mass point. The crab is
driven by the external force “f”. The horizontal position of the crab “s1” and its derivative “v1” are
measured. The goal is to move the load to a specified
horizontal position “s2”.
For a non-linear disturbance observer, the inverse
model from s1 to f is needed, since s1 is measured.
The system is first linearized around the stationary
position where the rope hangs vertically down (ϕ =
0). The transfer function from f to s1 has 2 conjugate
complex zeros on the imaginary axis, signaling an
undamped oscillation of the inverse model. This can
be improved by including linear damping (= d ⋅ ϕ )
in the revolute joint for the inverse plant used in the
controller. If the damping constant d is large enough,
the two zeros on the imaginary axis are moved to the
negative real axis. The disturbance observer is able
to force the plant (that does have low damping) moving in such a way as if there would be high damping.
The major goal is to position the load, i.e., to control
the horizontal position “s2” of the load. Therefore,
the feedforward control should use the inverse model
from s2 to f. The transfer function from f to s2 of the
linearized model has no zeros and a relative degree
of 4. Constructing the inverse model from the nonlinear plant model requires, however, a filter of order
2 instead of 4 as suggested by the linearized model.
Simulating the inverse model results in a division by
zero if ϕ = 0° or ϕ = 180° . To summarize, the
structure of the inverse model equations is different

276

Modelica 2005, March 7-8, 2005

Nonlinear Inverse Models for Control

at these two points and at ϕ ≠ 0° and ϕ ≠ 180° (the
DAE index is 5 for ϕ = 0° and ϕ = 180° and the
DAE index is 3 otherwise). Since the division by
zero occurs when computing ϕ , the plant model
should be changed to compute ϕ in a different way.
This can be accomplished by taking the inertia of the
load into consideration (previously it was neglected).
With a non-zero inertia, the transfer function from f
to s2 of the linearized plant has 2 conjugate complex
zeros on the imaginary axis and a relative degree of
2. Again, by introducing damping in the revolute
joint, these two zeros are moved to the negative real
axis. Note, that the inverse model is very insensitive
with respect to the newly introduced load inertia.
To summarize, for the crane example the inverse
plant models from s1 to f and from s2 to f can be
constructed by inverting a modified plant that has a
load inertia and additionally damping in the revolute
joint. A simpler alternative is also available: Before
inversion, the angle φ is fixed to 0° and therefore s1
= s2, and the plant to be inverted is described by the
equations (mcrab is the mass of the crab and mload is
the mass of the load):

(mcrab + mload ) ⋅ 
s1 = f

(19)

which can be easily inverted. This example demonstrates that it might be necessary to slightly modify
the original plant model in order that the inverse
model of the plant can be used in a controller.
6.2

Equations that cannot be inverted

A plant may have equations that cannot be inverted.
Examples are time delays, backlash, friction, hysteresis. This can be fixed by approximating the problematic elements in such a way that the resulting
equation leads to a unique inverse.
3

2

y1

1

0

-1

y2

-2

-3
-2.5

0.0

2.5

u

Fig. 15. Backlash (y1) and approximate
backlash (y2)
A typical example is shown in Fig. 15. The original
backlash characteristic y1 = f1(u) is not invertible
The Modelica Association

because for y1 = 0, there are an infinite number of
solutions (u = -1 ... +1). In Fig. 15 an approximation
y2 = f2(u) is shown that is strict monotonic and
therefore the inverse function has a unique solution.
It might also occur that tables have to be inverted.
Formally, a table in one dimension is defined as a
function y = f(u). Inversion of this function means to
solve a non-linear equation. This can be often quite
easily avoided by providing already the inverse tabulated values u = g(y) in the plant before inverting the
plant model. The advantage is that the solution is
faster and more robust. This problem was, e.g., encountered in [21], where control surface effectiveness of a military jet tended to have a local maximum as a function of the deflection. This was solved
by adapting tables and internal limitations of control
commands.
The inverse plant model may have also other singularities at particular operating points or regions that
prevent an inversion, e.g., due to divisions by zero,
singular linear or singular non-linear systems. The
reason is that the corresponding inverse model has
no or infinitely many solutions in particular points or
in particular regions of the state space. Again, one
remedy is to change the plant model before the inversion, e.g., by neglecting dynamic elements or by
approximating components with functions that are
less problematic to invert.
6.3

Actuator limits

Every control system is inherently limited by constraints in the actuator or other parts of the plant and
therefore the question arises how to cope with these
restrictions. When inverting a plant model, such constraints have to be removed before the inversion.
Otherwise no unique solution of the inverse exists
anymore, because there are infinitely many solutions
when an actuator is in one of its limits. As a result,
usually only the trivial action is possible to add appropriate limiters to the outputs of inverse models.
This will only help for short-time violations of the
constraints because the control system is effectively
switched off when the actuators are in their limits.
The most effective way to cope with actuator constraints in any control system is to adapt the desired
control signals, such as yc,d(t) in Fig. 2. In the most
general case this means to solve a trajectory optimization problem, i.e., to determine actuator signals
u(t) such that the plant outputs yc(t) have a desired
behavior, e.g., reach the desired position in minimum
time or with minimum energy, without violating the
plant constraints. The result is used as yc,d(t). A typical example can be found in [8]. Note, if the plant is

277

Modelica 2005, March 7-8, 2005

M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals

unstable and the inverse plant model is stable, it
might be considerably simpler to solve the trajectory
optimization problem with the inverse plant instead
with the plant model. Usually, trajectory optimization problems are difficult to solve and therefore
highly simplified plant models are used.
Take for example the crane model from section 6.1.
The basic requirement is to move the crab from position s1=a to s1=b in a short time. The plant model is
simplified by fixing the angle to ϕ = 0° resulting in
equation (19). Based on (19), the actuator limit
f ≤ f max can be directly transformed into a limit of
the acceleration:


s1 ≤ f max / ( mcrab + mload ,max )

(20)

Together with limits on the maximum speed, due to
the maximum speed of the motor, s1 ≤ s1,max , and
the requirement to move in minimum time from a to
b it is straightforward to construct the analytic solution of the desired movement s1,d(t). This solution is,
e.g., available via the block Modelica.Blocks.Sources.KinematicPTP. Note, the plant model used
for the trajectory optimization problem and for the
inverse plant model in the feedforward path according to Fig. 2 are identical here. In such a case, the
feedforward controller can be removed and can be
replaced by the result of the trajectory optimization:
s1,d and f1,d = (mcrab + mload , max ) ⋅ 
s1,d . For the trajectory optimization problem an fmax should be used
that is, say, 10 % - 20 % smaller as the actual limit in
order to provide some margin for the feedback controller.
If the desired control variables yc,d(t) are not known
in advance but generated online, e.g., by an operator,
online optimization techniques have to be used: The
operator request is reduced such that the plant constraints are fulfilled in the next sample time instant.
A well known measure in flight control is the socalled daisy-chain. In case a control input saturates, a
secondary, redundant control input is brought in that
provides the remaining required control power. In
[21] for example, lateral deflection of the thrust vector is used to yaw the aircraft in case the rudder saturates.
6.4

Real-time implementation

If inverse plant models are part of the controller, linear and non-linear systems of equations as well as
non-linear differential equations might have to be
solved in every sampling interval of the controller.
The techniques developed for hardware-in-the-loop

The Modelica Association

simulations can be also applied for such an application. The methods described in [6] are available in
Dymola [5] with the Dymola real-time option and
can be applied by selecting the appropriate options
when translating the inverse model (Simulation /
Setup / Realtime / Inline integration method). Only
fixed step integrators can be used for a real-time application. Via simulations, the appropriate step size
of the integrator has to be determined.
6.5

Robustness

As already mentioned in section 5, the use of inverse
model equations gives rise to robustness issues, since
any mismatch between the inverted model equations
and the actual plant will leave part of the nonlinearities and couplings uncompensated. The usual approach is to provide robustness to model uncertainty
via the (linear) feedback controller (Fig. 2,3,4) or the
filter (Fig. 5). This can be done by application of a
robust control synthesis technique [2], or by robust
parameter tuning in a classical structure, e.g. using
multi-model techniques and enforcing sufficient stability margins [13].
Tolerances on parameters in the model also appear in
the inverse model equations. In [13] it has been
shown that these parameters may be very effectively
used as additional tuning parameters in multiobjective optimization. The result is a model that is
basically inverted at a location in the parameter
space that provides the highest level of robustness.

7

Summary

Several control structures have been discussed that
are based on non-linear inverse plant models. These
structures are attractive since it is possible to cope
directly with operating point dependencies. The difficult part to construct an inverse model can be performed automatically even for complex systems: The
plant is modeled with Modelica, inputs and outputs
are exchanged and a Modelica simulation environment, such as Dymola, generates automatically the
appropriate C code for the inverse plant model, including real-time integration algorithms. The generated code can be easily embedded into Simulink
from Mathworks using the corresponding Dymola
export option. Via Mathworks Realtime-Workshop,
the code can be finally downloaded to different target processors.
The presented controller structures can be used in all
types of areas such as control of robots, vehicles,
aircrafts, satellites, ships, motors, air conditioning

278

Modelica 2005, March 7-8, 2005

Nonlinear Inverse Models for Control

systems. The most important requirement is that an
appropriate plant model is available. Then, the inverse modeling approach is in principle fully automatic, although the practical application is usually
more difficult. The essential issues have been discussed in section 6 and also possible remedies

References
[1] Ackermann J., Blue P., Bünte T., Güvenc L.,
Kaesbauer D., Kordt M., Muhler M., and Odenthal D.
(2002): Robust Control: The Parameter Space
Approach. Springer-Verlag.
[2] Adams, R.J., Banda, S. Robust Flight Control
Design Using Dynamic Inversion and Structured
Singular Value Synthesis. IEEE Transactions on
Control Systems Technology, 1(2):80-92, June 1993.
[3] Bauschat, M., Mönnich, W., Willemsen, D., and
Looye, G. Flight testing Robust Autoland Control
Laws. In Proceedings of the AIAA Guidance,
Navigation and Control Conference, Montreal CA,
2001.
[4] Duda H., Bouwer G., Bauschat J.M., Hahn K.-U.
(1997): A Model Following Control Approach. In
“Robust Flight Control: A Design Challenge” by J.-F.
Magni, S. Bennani and J. Terlouw (editors), Springer
Verlag, pp. 116 – 124.
[5] Dynasim (1994): Dymola – Users Manual
(http://www.dynasim.com)
[6] Elmqvist H., Mattsson S.E., Olsson H. (2002): New
Methods for Hardware-in-the-Loop Simulation of
Stiff Models. 2nd International Modelica Conference,
March 18-19, DLR Oberpfaffenhofen, Germany, pp.
59-64. Download: http://www.Modelica.org/Conference2002/papers.shtml.
[7] Enns, D., Bugajski, D., Hendrick, R., and Stein, G..
Dynamic Inversion: An Evolving Methodology for
Flight Control Design. In AGARD Conference
Proceedings 560: Active Control Technology:
Applications and Lessons Learned, pages 7-1 – 7-12,
Turin, Italy, May 1994.
[8] Franke R., Rode M., and Krüger K. (2003): On-line
Optimization of Drum Boiler Startup. 3rd Int.
Modelica Conference, Linköping, Nov. 3-4, pp. 287 –
296. Download: http://www.Modelica.org/Conference2003/papers.shtml.
[9] Föllinger O. (1998): Nichtlineare Regelungen I,
Oldenbourg Verlag, 8. Auflage.
[10]Föllinger O. (1994): Regelungstechnik. Hüthig
Verlag, 8. Auflage.
[11]Isidori A. (1995): Nonlinear Control Systems. 3rd
Edition, Springer Verlag.
[12]Kreisselmeier G. (1999): Struktur mit zwei
Freiheitsgraden. Automatisierungstechnik at 6, pages
266-269.

The Modelica Association

[13]Looye G. (2001): Design of Robust Autopilot
Control Laws with Nonlinear Dynamic Inversion.
Automatisierungstechnik at 49-12, p. 523-531.
[14]Ohnishi K. (1987): A new servo method in
mechatronics. Trans. Japanese Society of Electrical
Engineering, vol 107-D, pp. 83-86.
[15]Pantelides C.C. (1988): The consistent initialization
of differential-algebraic systems. SIAM Journal of
Scientific and Statistical Computing, pp. 213-231.
[16]Mattsson S.E., Söderlind G. (1993): Index reduction
in differential-algebraic equations using dummy
derivatives. SIAM Journal of Scientific and
Statistical Computing, pp. 677-692.
[17]Mugica F., Cellier F.E. (1994): Automated synthesis
of a fuzzy controller for cargo ship steering by
means of qualitative simulation. Proceedings of the
European Simulation MultiConference (ESM'94),
Barcelona, Spain, pp. 523-528,
[18]Otter M., Cellier F.E. (1996): Software for Modeling
and Simulating Control Systems. The Control
Handbook, by W.S. Levine (editor), CRC Press, pp.
415 – 428.
[19] Slotine, J.E, Li, W. Applied Nonlinear Control.
Prentice Hall, Englewood Cliffs, N.J., 1991.
[20] Snell, A. Decoupling of Nonminimum Phase Plants
and Application to Flight Control, AIAA-20024760 AIAA Guidance, Navigation, and Control
Conference and Exhibit, Monterey, California, 2002.
[21]Steinhauser R., Looye G., Brieger O. (2004): Design
and Evaluation of a Dynamic Inversion Control
Law for X-31A. Proc. 6th ONERA-DLR Aerospace
Symposium, Berlin, June 22-23, pp. 25-33.
[22]Thümmel M., Otter M., Bals J. (2001): Control of
Robots with Elastic Joints based on Automatic
Generation of Inverse Dynamics Models. IEEE/RSJ
Conference on Intelligent Robots and Systems, Oct.
29- Nov. 3rd, Hawaii, U.S.A.
[23]Umeno T., Hori Y. (1991): Robust speed control of
dc servomotors using modern two degrees-offreedom controller design. IEEE Trans. Ind.
Electron, 38-5, pp. 363-368.

279

Modelica 2005, March 7-8, 2005

The Modelica Association

280

Modelica 2005, March 7-8, 2005

An Empirical Study on Debugging Equation-Based Simulation Models

An Empirical Study on Debugging Equation-Based Simulation Models
Peter Bunus
Department of Computer and Information Science
Linköping University, Sweden
petbu@ida.liu.se

Abstract
A typical problem which often appears in Modelica models is when too many/few equations are specified. This
leads to a situation where the simulation model is inconsistent and therefore cannot be compiled and executed.
We propose a methodology for detecting and repairing
over- and under-constrained situations based on graph
theoretical methods. Components and equations that cause
the irregularities are automatically isolated, and meaningful error messages for the user are presented. The potentially large number of error fixing alternatives is reduced
by applying filtering rules extracted from the modeling
language semantics.
The paper illustrates that it is possible to localize and
repair a significant number of errors during static analysis
of a Modelica model without having to execute the simulation model. In this way certain numerical failures can be
avoided later during the execution process. The paper
proves that the result of structural static analysis performed on the underlying system of equations can effectively be used to statically debug real models.
Keywords: Modelica, debugging, structural and static
analysis, mathematical modeling, structural validation.

1

Introduction

Mathematical modeling and simulation of complex physical systems is emerging as a key technology in engineering. Modern approaches to physical system simulation allow users to specify simulation models with the help of
equation-based languages. Such languages have been designed to allow automatic generation of efficient simulation code from declarative specifications. Complex simulation models are created by combining available model
components from user-defined libraries. The resulted
models are compiled in a simulation environment for efficient execution.
Unfortunately, errors are made and inconsistencies are
easily introduced in the simulation models. A significant
part of the model development effort is spent on detecting
deviations from specifications and subsequently localizing
the sources of such errors. A typical problem which often
appears in physical system modeling and simulation is

The Modelica Association

when too many/few equations are specified in a system.
This leads to a situation where the simulation model is inconsistent and therefore cannot be compiled and executed.
The user should deal with over- and under-constrained
situation by identifying the minimal set of equations or
variables that should be removed from the system in order
to make the remaining set of equations solvable. For example, if there are too many equations in a system of
100 000 equations, which equations should be removed?
Currently the only systematic technique is to remove
equations one by one until the equation that caused the inconsistency is identified and finally removed from the system. It can easily be imagined that, if a static debugger
presents a small subset of over-constraining equations,
from which the user can select the equation that needs to
be eliminated from the overall model can greatly reduce
the amount of time required to get the simulation working.
Currently there are essentially no advanced tools that
can handle the debugging of equation-based languages at
the source code level and provide useful error fixing solutions. The aim of the research presented in this paper is to
considerably improve the situation, especially with respect
to debugging the Modelica language. However, powerful
graph-theoretic methods can help to pinpoint possible
candidates for erroneous equations. A dramatic reduction
in the number of erroneous equation candidates can be
achieved by applying new methods such as semantic filtering.
In this paper we describe an empirical evaluation of
debugging of automated debugging techniques for detecting and repair structural inconsistencies in equation-based
simulation models. We focus on performance of debugging tools that use static analysis tools integrated into a
Modelica compiler where the main purpose was to reduce
the number of debugging alternatives when structural inconsistencies were present in the model. Static analysis
techniques only involve statically available information,
such as which variables are present in which equations in
and equation-based model. No assumptions regarding the
inputs and outputs of the simulation models are made. The
development of static and dynamic techniques for equation-based languages have been addressed by our previous
research (Bunus 2004 [1], Bunus and Fritzson 2003 [2],
Bunus and Fritzson 2004 [3]).
The remainder of the paper is organized as follows:
Section 2 presents the problem formulation and a motiva-

281

Modelica 2005, March 7-8, 2005

P. Bunus

tional example. Section 3 gives a brief description of the
algorithms for detecting and debugging over-constrained
situations that arise during the modeling phase with equation-based languages. Section 4 presents an evaluation of
our debugging framework based on several benchmarks.
Section 5 presents the overall architecture of a prototype
debugger developed in the context of a Modelica compiler. Finally Section 6 presents our conclusions and future work.

2

ES = {e1 ,… et } where t < n and ES ⊂ E if n > m (we
have more equations than variables ) or to the to the problem of finding the maximal subset of variables
VS = {v1 ,… vk } where k < m and VS ⊂ V if n < m (we
have more variables than equations ).
As an example let us consider a Modelica model consisting of a sinusoidal voltage source and a resistor connected together. This model is trivial, but it serves as a
straightforward vehicle for introducing several fundamental debugging concepts.

Problem Formulation and Motivational Example

connector Pin
Voltage v;
Flow Current i;
end Pin;

Mathematical modeling proceeds by specifying a set of
mathematical equations or functional relations denoted
E = {e1 ,… en } involving a set of variables denoted
V = {v1 ,… vm } . In the general case a system of n equation
with m variables or unknowns can be described by the following equality:

model TwoPin
Pin p, n ;
Voltage v;
Current i;
equation
v = p.v - n.v; 0 = p.i + n.i; i = p.i
end TwoPin;

ei (v1 ,… vm ) = ci
(2.1)
where ci are constants and i = 1… n . Solving the system
of equations E is the problem of finding the set of solutions S = {( s1 ,… sm ) ∈ T m | e( s1 ,… sn )} where T is the domain of equations, which fulfill the equality (2.1). The relation (2.1) can be expanded into:

model Resistor
extends TwoPin;
parameter Real R;
equation
R*i = v;
end Resistor;

a11v1 +

model VsourceAC
extends TwoPin;
parameter Real VA=220; parameter Real f=50;
protected constant Real PI=3.141592;
equation
v=VA*(sin(2*PI*f*time));
end VsourceAC;

a1m vm = c1
(2.2)

an1v1 + anm vm = cn
where aij , i = 1… n, j = 1… m are real coefficients. In a matrix-vector notation, (2.2) has the form: Av = c

⎛ a11 … a1m ⎞
⎛ v1 ⎞
⎛ c1 ⎞
⎜
⎟
⎜ ⎟
⎜ ⎟
where A = ⎜
and
v
c
=
=
⎟
⎜ ⎟
⎜ ⎟ (2.3)
⎜a
⎟
⎜
⎟
⎜c ⎟
anm ⎠
⎝ n1
⎝ vm ⎠
⎝ n⎠
A necessary condition for the existence and uniqueness of
a solution S is that matrix A is a square matrix (the number of equations is equal to the number of variables) and
there exists permutations P1P2 such that P1 AP2 has a nonzero diagonal. This condition guarantees the structural
singularity of the system of equations. The structural singularity checks whether the system of equations is wellposed or not. It is only a necessary but not sufficient condition for the existence and uniqueness of a solution. The
more powerful notion of numerical singularity will guarantee the existence and uniqueness of a solution. However
the checking the numerical singularity is as expensive as
solving the system of equations. Therefore when analyzing the system of equations in this stage we assume that
the structural non-singularity is a sufficient abstraction for
implying that the equation system has a unique solution.
Further analysis based on numerical values and numerical
singularities is delayed until the dynamic analysis stage.
If the system of equations is structurally singular we
switch from the problem of finding the set of solutions S
to the problem of finding the maximal subset of equations

The Modelica Association

model Ground
Pin p ;
equation
p.v = 0
end Ground;
model Circuit
Resistor R1(R=10); VsourceAC AC; Ground G;
equation
connect (AC.p,R1.p); connect (R1.n,AC.n);
connect (AC.n,G.p);
end Circuit;

We introduce an additional equation (i=23) inside the
Resistor component in order to over-constrain the simulation model. The flattened equations corresponding to the
Circuit model is depicted in Figure 1.
eq1
eq2
eq3
eq4
eq5
eq6
eq7
eq8
eq9
eq10
eq11
eq12
eq13
eq14
eq15

R1.v = -R1.n.v + R1.p.v
0 = R1.n.i + R1.p.i
R1.i = R1.p.i
R1.i R1.R = R1.v
R1.i = 23
AC.v = -AC.n.v + AC.p.v
0 = AC.n.i + AC.p.i
AC.i = AC.p.i
AC.v = AC.VA*sin[2*time*AC.f*AC.PI]
G.p.v = 0
AC.p.v = R1.p.v
AC.p.i + R1.p.i = 0
R1.n.v = AC.n.v
AC.n.v = G.p.v
AC.n.i + G.p.i + R1.n.i = 0

var1
var2
var3
var4
var5
var6
var7
var8
var9
var10
var11
var12
var13
var14

R1.p.v
R1.p.i
R1.n.v
R1.n.i
R1.v
R1.i
AC.p.v
AC.p.i
AC.n.v
AC.n.i
AC.v
AC.i
G.p.v
G.p.i

Figure 1. Flattened equations and variables corresponding
to the Circuit model.

282

Modelica 2005, March 7-8, 2005

An Empirical Study on Debugging Equation-Based Simulation Models

It should be noted that the number of equation is greater
than the number of variables and therefore we are facing a
structurally nonsingular problem.

3

Debugging Over- and Underconstrained Models

rectional edges and orienting all other edges from equation to variable nodes. The layout of the directed graphs
derived from the undirected bipartite graphs has been rearranged into a tree representation for the purpose of increasing understandability for the reader of the paper.

eq11

The methods proposed in this section present a strategy to
deal with overdeterminancy by identifying the minimal set
of equations that should be removed from the system in
order to make the remaining set of equations solvable. The
idea is to isolate the over-constraining part of the bipartite
graph associated to the underlying system of equations
and to perform reasoning based on specific properties of
the specified subgraph. Efficient graph transformations,
based on rules derived from the semantics of the modeling
language are also performed on the subgraphs. We are going to show how these rules are automatically derived
from the modeling language semantics and how the associated annotations to the equations contribute to the filtering of the combinatorial explosion of possible error fixing
solutions. Those interested in more details may wish to
consult Bunus and Fritzson 2004 [3] or Bunus 2004 [1].

Step 1: Isolating the over-constraining part.
In step 1, from the flattened intermediate form of the
equations the associated bipartite graph is derived and a
maximum cardinality matching is found. The Dulmage
Mendelsohn canonical decomposition (Dulmage and
Mendelsohn 1963 [4]) will lead to two different subgraphs: a well-constrained part WG and an overconstrained part OG1+ as depicted in Figure 2. The maximum cardinality matching is shown in Figure 2 with bold
edges.
eq1

var1

eq2

var2

eq4

var3

eq3

var4

var5

eq5

var6

eq6

var7

eq12

var12

var9

eq15

var14

eq13

var13

eq14

eq6

var5

var3

var11

eq4

eq13

eq9

var6

AC.v = AC.VA*
sin[2*time*AC.f*AC.PI]
var9

eq5

eq14
var13
eq10
G.p.v = 0

Figure 3. A directed graph associated to the overconstrained part.

Step 2: Reducing the over-constraining equations
by using structural information.
The general error fixing strategy in the case of overconstrained equation subsystems is to remove the extra
equations. An immediate fix to the over-constrained part
is to remove one of the equation nodes, which will lead to
a well-constrained part. However, as it can be seen from
Figure 4, not all the equation edges can be safely removed.
eq11

eq11
var1

var7

var7

eq1

eq6

eq6

var5

var3

var11

var5

var3

var11

eq4

eq13

eq9

eq4

eq13

eq9

var6

var9

eq5

eq14

var6

var9

eq5

eq14

R1.i == 23

R1.i == 23

var13

well-constrained part

var13

eq10

eq10

G.p.v == 0

G.p.v == 0

Figure 4. The elimination of an unsafe equation node
(eq1) from the over-constrained subgraph (on the left)
leads to two disconnected components (on the right).

over-constrained part

Figure 2. Canonical decomposition of an over-constrained
system.
It can be seen that equation eq11 is not covered by the
found maximum cardinality matching. Therefore equation
eq11 is a non-saturated or free vertex of the equation set,
therefore it is a source for the over-constrained part OG1+ .
Next, starting from eq11, the directed graph can be derived from the undirected bipartite graph, as illustrated in
Figure 3, by exchanging all the matching edges into bidi-

The Modelica Association

eq1

R1.i = 23

var10

eq8

eq9

var11

var7

var8

eq7

eq10
eq11

var1

By removing an equation node and the corresponding incident edges from the bipartite graph the remaining undirected graph must remain connected. In our particular example the set of over-constraining equations that satisfy
this condition is {eq11, eq13, eq10, eq5, eq9}. It should
be noted that the safe removal of equation nodes only refers to the bipartite graph representation of the intermediate code of the flattened set of equations, and it is influenced by only structural properties of the bipartite graph.
If we would like to further reduce this set of equations,

283

Modelica 2005, March 7-8, 2005

P. Bunus

removal criteria derived from the semantics of the modeling language would need to be developed and included in
the debugging strategy.

Step 3: Reducing the over-constraining equations
by using semantic information
As we have seen in the previous example not all the overconstraining equations are possible to remove without
causing further structural failures in the model description.
By taking into account simple rules derived from the language semantics we can safely discard some other elimination alternatives as well.
We note that equation eq11 (AC.p.v = R1.p.v) is
generated by a connect equation from the Circuit
model and the only way to remove the equation eq11 is to
remove the original connect(AC.p, R1.p) equation.
However, removing the above-mentioned equation will
remove two equations from the flattened model since the
connect equation expands into two equations. It is obvious that this modification cannot be performed by the user
at the original source code level.
In order to provide a mechanism to reason about the
erroneous model under consideration based on language
semantics rules the equations need to be annotated. We
define an annotated equation as a record with the following structure:
< Equation,
Name,
Description,
No. of associated equations,
Class name,
Flexibility level,
Connector generated,
No. of linked equations
>

The Class Name indicates which class the equation comes
from. This annotation is extremely useful in exactly locating the associated class of the equation and therefore providing concise error messages to the user in terms of
original source code statements.
The No. of associated eqs. field defines the number of
equations which are specified together with the annotated
equation inside the same model. For an equation that belongs to the TwoPin class the number of associated equations is equal to 3. If one associated equation of the class
needs to be eliminated the value is decremented by 1. During debugging, if the equation R1.i * R1.R = R1.v is
diagnosed to be an over-constraining equation and therefore needs to be eliminated, then the elimination is not
possible because the model will be invalidated (the No. of
associated eqs. cannot be equal to 0) and therefore other
solutions need to be investigated.
The flexibility level, in a similar way as defined in
Flannery and Gonzalez 1997 [5], allows the ranking of the
relative importance of the equation in the overall flattened
system of equations. The value can be in the range of 0 to
3, with 0 representing the most rigid equation and 3 being

The Modelica Association

the most flexible equation. In practice, it turns out that the
equations generated by connections are more rigid from
the constraint relaxation point of view than the equations
specified inside the model. This means that preference is
given to repair strategies that involve the removal of equations which defines the behavior of a particular component and not to topology changes of the circuit given by
the connection equations. We set the flexibility value to 0
for those equations that should not be removed or modified. These equations are locked for editing which means
that an automatic debugger should not consider any repair
strategy that would involve the modification or the removal of the equations associated to such a component.
For example the equations of components that come from
well tested and trusted libraries can have this value set to
zero.
The Connector generated is a Boolean attribute
which tells whether the equation is generated or not by a
connect equation. Usually these equations have a very
low flexibility level.
The No. of linked equations attribute specifies how
many other equations are linked with the current equations. Equations that come from connect equations or
from parent objects (such as the TwoPin partial component) have this attribute greater than zero. Removing an
intermediate equation that has this attribute greater than
zero will trigger the removal of other intermediate additional equations equal to the number of linked equations.
This is due to the fact that the removal of an intermediate
equation is only possible by removing the original source
code that generated that equation. By doing this all the
generated intermediate equations by the original equation
will be removed.
It is worth noting that the annotation attributes are
automatically initialized by the static analyzer. These are
incorporated in the front-end of the compiler, by using
several graph representations of the declarative objectoriented program code. Therefore the user does not need
to manually annotate the source code. A debugger preprocessor takes care of the automatic generation and initialization of the annotating code. In this way a mapping
between the intermediate code and original declarative
code is kept during the translation phases.
The annotations associated to the set of equivalent
over-constraining equations {eq11, eq13, eq10, eq5, eq9}
are shown in Table 1.

Table 1. The associated annotations of the remaining
over-constraining equation set
Name

Equation

No. of
assoc.
eqs.

Class

Flex. Con.

name

level gen.

No.of
linked
eqs.

eq11

AC.p.v=R1.p.v

3

Circuit

1

Yes

1

eq13

R1.n.v= AC.n.v

3

Circuit

1

Yes

1

eq10

G.p.v=0

1

Ground

2

No

0

eq5

R1.i=23

2

Resistor

2

No

0

eq9

AC.v=AC*VA*sin..

1

VsourceAC

2

No

0

The equation node eq11 was already analyzed and can
therefore be removed from the set. Equation node eq13 is

284

Modelica 2005, March 7-8, 2005

An Empirical Study on Debugging Equation-Based Simulation Models

removed as well, for the same reasons as equation eq11.
By analyzing the remaining equations {eq10, eq5, eq9},
one should note that they have the same flexibility level
and therefore candidates for elimination with equal probability. However, by analyzing the value of the No. of associated eqs. annotation, equation eq10 and eq9 have this
attribute equal to one, which means that they are the only
equations that define the behavior of the model. Removing
one of these equations will invalidate the corresponding
model component, which is probably not the intention of
the modeler and therefore not acceptable as an error fixing
solution.
By examining the annotations corresponding to equation eq5 one can see that it can safely be removed because
its flexibility level is high. The removal of eq5 will not
trigger the removal of any other equation since it has no
linked equations (indicated by the value of No. of linked
eqs. annotation which is equal to 0). Moreover, removing
equation eq5 will not invalidate the model since there is
another equation defined inside the Resistor model
(R1.i * R1.R = R1.v) denoted by the value of No. of
associated eqs. annotation which is equal to 2.

Step 3: Outputting the debugging alternatives.
After selecting the right equation for elimination the debugger tries to identify the associated class of that equation based on the Class name parameter defined in the annotation structure. Having the class name and the intermediate equation form (R1.i=23), the original equation can
be reconstructed (i=23) to exactly indicate to the user the
equation that needs to be removed in order to make the
simulation model well-constrained. In this case the debugger correctly located the faulty equation previously introduced by us in the simulation model.
When multiple valid error fixing solutions are possible and the debugger cannot decide which one to choose, a
ranked list of error fixes is presented to the user for further
analysis and decision. In those cases, the user must take
the final decision, as the debugger cannot know or does
not have enough information to decide which equation is
over-constraining. The advantage of this approach is that

the debugger automatically identifies and solves several
anomalies in the declarative simulation model specification without having to execute the system.
When debugging under-constrained systems (more
variables than equations are present in the system) two
distinct strategies can be considered. The first strategy
considers the removal of the free variables while the second strategy considers the addition of new equations to the
overall system of equations, which must contain the free
variables. Additionally, the second strategy takes into account extra variables that can be added to the introduced
new equation. New equations can be introduced at different levels in the object hierarchy.

4

Experimental Validation

In this paper we are interested in the quality of structural
and semantics filtering rules employed in the proposed
static debugging algorithm for correcting over- and underconstrained system of equations extracted from simulation
models expressed in the Modelica language.
Firstly, we have modified several working simulation
models by inserting additional equations in the model
definitions at various places, thereby over-constraining the
whole system models. In this first set of experiments we
were interested if over-constraining situations are detected
and how many repair possibilities are reported by the debugger.
A short description of the benchmark programs and
the over-constraining nature for each example is given in
Table 2. The measurements in Table 2. were performed as
follows. We built several Modelica simulation models that
were structurally correct. Then we have modified each example by inserting an extra equation in different components of the simulation model. In this way the models became over-constrained. During the translation phase the
system of flattened equation and each equation was annotated. In the next step a canonical decomposition was performed on the structurally singular system of flat equations and the over-constraining graph was isolated. Based
on the over-constraining graph the reduced set of

Table 2. Benchmark program description for over constrained systems.
No. No
of
of
var. eq.

Test model Description

scircuitR

1+

scircuitPin

3+

generatorR

dcmotorR

2+

1+

A simple electrical circuit model consisting of a resistor connected
in parallel with a continuous voltage source. The Resistor 14
component is over-constrained by an extra equation.
A simple electrical circuit model consisting two resistors connected in parallel with a direct current source. The TwoPin com- 20
ponent is over-constrained by one extra equation.

Over Red. over Semantic Debugging
contr. constr.
filtering alt.
part
part

15

9

5

1

1

23

19

15

3

1

A generator circuit model similar where the Resistor compo49
nent is over-constrained by one an extra equation.

51

35

22

6

3

A direct current motor circuit model where the Resistor com36
ponent is over-constrained by one an extra equation.

37

31

29

7

7

The Modelica Association

285

Modelica 2005, March 7-8, 2005

P. Bunus

over-constraining equations was computed.
This set of equations was further reduced by
scircuitR
using semantic filtering rules. Based on this
final set of equation the error messages are
40
37
output to the user. The numbers of debugging
35
scircuitPin
alternatives are shown in the last column of
31
30
29
Table 2. Figure 5 depicts the number of overgeneratorR
23
constraining equations obtained after each
22
20
19
dcmotorR
reduction step.
15
15
Secondly, we investigated the detection
10
9
capabilities of the static debugger when un7
7
6
5
der-constrained situation were purposely in3
3
1
1
0
troduced in the simulation model by deleting
No. of flat
No. of over- No. of reduced
No. of
No. of
equations or adding extra variables in the sysequations
debugging
constraining oversemantically
constraining
equations
reduced
alternatives tem. The modifications performed on each
model are described Table 3. The debugging
equations
equations
of the under-constrained system was perFigure 5. Number of over-constraining equations obtained after
formed by considering only those corrections
each reduction step during structural debugging.
that imply the removal of a free variable from
Table 3. Benchmark program description for under-constrained systems
step 1

51

50

step 3

step 2

step 4

No. of equations

1+

3+

2+

1+

No
of
eq.

Test model Description

scircuitR

1−

scircuitPin

3−

generatorR

dcmotorR

1−

2−

A simple electrical circuit model consisting of a resistor connected
in parallel with a continuous voltage source. In the Resistor
component an extra variable has been declared (Real s) and the
equation R*i=v*s was introduced instead of the correct equation
R*i=v.

14

15

8

5

1

1

A simple electrical circuit model consisting two resistors connected in parallel with a direct current source. The TwoPin component is under-constrained by introducing an extra variable
(Real s) and by exchanging equations 0 = p.i + n.i with
s = p.i + n.i.

20

23

7

4

3

1

A generator circuit model. In the Resistor component an extra
variable has been declared (Real s) and the equation R*i=v*s
was introduced instead of the correct equation R*i=v.

49

51

28

21

3

1

A direct current motor circuit model. In the Resistor component an extra variable has been declared (Real s) and the equation R*i=v*s was introduced instead of the correct equation
R*i=v.

37

36

30

28

4

4

51

50

step 1

step 2

30
28

28

step 3

step 4

1−

scircuitR
40

No. of variables

36

scircuitPin3−
30

23
20

No. Under Red. over Semantic Debugging
filtering alt.
of
contr. constr.
var. part
part

21

generatorR 2 −
15

dcmotorR1 −
10
8
7
5
4
0

No. of flat
variables

No. of underconstraining
variables

No. of reduced
underconstraining
variables

4
3
1

4
1

No. of
semantically
reduced
variables

No. of
debugging
alternatives

Figure 6. Number of under-constraining variables obtained after each
reduction step during structural debugging.

The Modelica Association

286

the system. Figure 6 displays the number
of under-constraining variables after each
reduction step. After each step during the
structural debugging the number of free
variables that can be removed from the
system is dramatically reduced. It should
be noticed in Figure 6 that the largest reduction in the number of free variables
and implicitly in the number of debugging alternatives presented to the user is
achieved by the semantic filtering phase.
We are interested in the quality of
structural and semantics filtering rules
employed in the proposed static debugging algorithm for correcting over- and
under-constrained system of equations
extracted from simulation models ex-

Modelica 2005, March 7-8, 2005

An Empirical Study on Debugging Equation-Based Simulation Models

pressed in the Modelica language. Table 4 shows the percentage reduction in the number of equations/variables
that need to be examined by user after each step in the debugging process.

Table 4. Percentage reduction of the number of equation/variables that need to be examined by the user after
each reduction step.

compiler. The tool is able to successfully detect and provide error-fixing solutions for typical over and underconstrained situations, which might appear during the
modeling stage using Modelica. Figure 7 show the general
architecture of our static debugger.
User

Test model No. of flat Step1 Step 2 Step3
Step 4
eq./.var
1+
15
40.0% 66.7% 93.3% 93.3%
scircuitR
3+

23

17.4%

34.8%

87.0%

95.7%

2+

51

31.4%

56.9%

88.2%

94.1%

1+

37

16.2%

21.6%

81.1%

81.1%

1−

15

46.7%

66.7%

93.3%

93.3%

3−

23

69.6%

82.6%

87.0%

95.7%

2−

51

45.1%

58.8%

94.1%

98.0%

36

16.7%

22.2%

88.9%

88.9%

scircuitPin

generatorR
dcmotorR

scircuitR

scircuitPin

generatorR
dcmotorR

1−

Modelica
Source
Code

Implementation

For the previously presented graph decomposition techniques to be useful in practice, we must be able to construct and manage the graph representation of equationbased specifications efficiently and integrate them into an
automatic or semi-automatic debugging tool. The use of
graph-based tools in structural analysis is of great interest
both in displaying properties of systems of equations and
also in following and performing symbolic manipulations
of variables and equations when modeling with equationbased languages (Harman 2005 [6]). We show how existing graph theoretical decomposition techniques can be
adapted and integrated into debugging tools integrated
into simulation environments that employs such languages.
At this stage we are able to provide an overview of
the proposed framework developed for the Modelica language and Modelica-based simulation environments. Even
if we have limited our prototype implementation to the
Modelica language, the developed debugging kernels can
easily be adapted to handle other object-oriented equationbased languages as well. It is important to note that the
proposed debugging framework can easily be integrated
into the existing Modelica compilers.
AMOEBA (Automatic MOdelica Equation-Based
Analyzer) is the static analysis module that we have designed and implemented in order to attach it to a Modelica

The Modelica Association

Automatic Modelica
Equation-Based
Under-Constrained
System Analyzer

Analyzer

Graph
Mapper

Parse Flat
Code

Symbolic
Engine

BLT Form

Symbolic
Engine

Code
Generator

C code

Figure 7. AMOEBA integration into the compilation
framework.

As can be seen in Figure 5, Figure 6 and from the percentage reduction Table 4, the proposed algorithm for debugging over- and under-constrained systems is very efficient
in reducing the number of debugging alternative shown to
the user. On the average, 91% of the irrelevant candidates
were eliminated, which allows the user to look for the bug
among the few remaining candidates, thus dramatically
improving bug localization effectiveness.

5

Over-Constrained
System Analyzer

Parsing and
Semantic
Analysis

Flat
Modelica
Source
Code

AMOEBA

Code
Transformer

Error
Presentation

Below we present each phase of the static analysis with
the corresponding module:
The flattened equations are transformed into the bipartite graph representation by a Graph Mapping module.
The canonical decomposition algorithm applied by the
BLT module in the compiler splits the graph into three distinct subgraphs corresponding to an over-constrained system of equations (too many equations are present), an under-constrained system (too few equations or too many
variables are present in the system) and a well-constrained
system of equations (the number of variables is equal to
the number of equations). A simple heuristic filtering rule
assumes that the well-constrained part obtained after decomposition will lead to a solvable system of equations
and therefore need not be included in any repair strategy.
If under- or over-constrained situations are detected, this
means that there are some inconsistencies in the model.
The Over- and Under-Constrained System Analyzers
applies the algorithms presented in previous sections, in
order to transform these graphs into a well-constrained
graph and elaborate the necessary program modifications.
The Code Transformer module needs to validate the
program correction: it must assure that there exists a semantically correct source code program that can be translated into the intermediate program correction. The source
code transformations must be performed only by using
atomic changes at the original source code level. Finally,
the error fixing solution is output by the debugger in terms
of atomic changes that need to be performed on the original source code in order to obtain a valid original source
code program that will generate the corresponding program modifications at the intermediate code level. When
multiple error fixing solutions exist, the annotations attached to the flattened equations are used in the process of
eliminating some of the modifications and prioritizing the
remaining ones.
The Error Presentation module is responsible for presenting error messages to the user based on the previously

287

Modelica 2005, March 7-8, 2005

P. Bunus

obtained valid source code modifications. Before being
presented to the user, the output is filtered. For example,
all the modifications that would involve atomic changes
on locked components are eliminated and the remaining
corrections are ranked based on equations annotations.
This module handles most of the user interaction necessary for the debugger to complete the missing formal
specification of the program. At this level the user can be
confronted with several error fixing corrections that will
eliminate the symptom of the detected inconsistency at the
intermediate code level. The corrections that most closely
correspond to the programmer's view of the model structure should be selected.

6

Conclusions

Structural analysis techniques are widely used for assessing the correctness and the credibility of mathematical
models expressed with the help of equations. Experience
has taught us that pre-processing a system of equations
pays high dividends by reducing the time for finding inconsistencies and efficiently correcting them. From the
user point of view, such techniques are extremely beneficial because they provide guidance during early stages of
the simulation model building process and do not require
solving the equations system.
The paper illustrates that it is possible to localize and
repair a significant number of errors during static analysis
of object-oriented equation-based modeling languages
without having to execute the simulation model. In this
way certain numerical failures can be avoided later during
the execution process. The paper proves that the result of
structural static analysis performed on the underlying system of equations can effectively be used to statically debug Modelica simulation models.
This paper describes one of the first experimental
studies on how these new static debugging techniques perform on erroneous model examples. We have presented an
empirical evaluation of proposed static analysis based debugging paradigm for equation-based languages. Our
studies demonstrated that static analysis can dramatically
reduce debugging time, suggesting the potential of structural analysis as a highly effective approach.
Currently, the debugger’s functionality is limited
mostly due to our inability to compile the full Modelica
language. Therefore only a limited number of real world
examples with limited size and complexity have been
tested. The integration of the presented debugging tech-

The Modelica Association

niques into the Open Source Modelica framework is underway. In order to provide a complete debugging framework for the Modelica language we intent to integrate the
proposed structural analysis techniques with the existing
debugger for the algorithmic subset of the Modelica language proposed by Pop and Fritzson 2005 [7].
We claim that the techniques developed and proposed
in this paper are suitable for a wide range of equationbased languages and not only for the Modelica language.
These techniques can be easily adapted to the specifics of
a particular simulation environment. Our claim is based on
the close integration of the developed debugging techniques and the compilation process. Most of the existing
compilers for equation based languages share the same
principles.

Acknowledgements
This research was supported by Center for Industrial Information Technology (grant CENIIT 05.02) at Linköping
University Sweden.

REFERENCES
[1] Bunus Peter. (2004). Debugging Techniques for EquationBased Languages. PhD Thesis. Department of Computer and
Information Science, Linköping University, 2004.
[2] Bunus Peter and Peter Fritzson. (2003). "Semi-automatic
Fault Localization and Behaviour Verification for Physical
System Simulation Models." In Proceedings of the 18th
IEEE International Conference on Automated Software Engineering. (Montreal, Canada, October 6-10, 2003).
[3] Bunus Peter and Peter Fritzson. (2004) "Automated Static
Analysis of Equation-Based Components." Simulation:
Transactions of the Society for Modeling and Simulation International. Special Issue on Component Based Modeling
and Simulation., vol. 80: 8, August 2004.
[4] Dulmage A.L. and N.S. Mendelsohn. (1963) "Coverings of
bipartite graphs." Canadian J. Math, vol. 10, pp. 517-534.
[5] Flannery L. M. and A. J. Gonzalez. (1997) "Detecting
Anomalies in Constraint-based Systems." Engineering Applications of Artificial Intelligence, vol. 10: 3, pp. 257-268.
[6] Harman Peter. (2005). " Visualisation of Model Transformation Algorithms for a Modelica Translator." In Proceedings
of the 4th International Modelica Conference. (Hamburg,
Germany, 7-8 March, 2005).
[7] Pop Adrian and Peter Fritzson. (2005). "A Portable Debugger for Algorithmic Modelica Code." In Proceedings of the
4th International Modelica Conference. (Hamburg, Germany, 7-8 March, 2005).

288

Modelica 2005, March 7-8, 2005

2005
Proceedings of the
4th International Modelica Conference
March 7-8, 2005
Hamburg University of Technology
Hamburg-Harburg, Germany

Gerhard Schmitz (editor)

Volume 2

organized by
The Modelica Association and
the Department of Thermodynamics, Hamburg University of Technology
All papers of this conference can be downloaded from
http://www.Modelica.org/Conference2005/papers/

Proceedings of Modelica’ 2005
Hamburg University of Technology,
Hamburg-Harburg, Germany, March 2005
Editor:
Prof. Dr.-Ing. G. Schmitz
Published by:
The Modelica Association (http://www.Modelica.org) and
the Department of Thermodynamics,
Hamburg University of Technology (http://www.tt.tu-harburg.de)
Printed by:
COPY-DRUCK
Gesellschaft für Digital- und Offsetdruck mbH

The Modelica Association

Modelica 2005, March 7-8, 2005

Preface
The first Modelica Conference took place October 2000 in Lund, Sweden. Since then, Modelica has
been more and more established as a preferred modelling language for complex multi-domain systems.
This is indicated by the high number of registrations from industry and science for the 4th International Modelica Conference which is held between March 7th and 8th 2005 at Hamburg University
of Technology (TUHH). But it is also indicated by the number of excellent papers submitted to the
program committee which made the task of selecting papers for oral and poster presentation very
difficult and, last but not least, by the exhibition during the conference at which around 10 companies
will present themselves. The proceedings contain the papers of the 60 oral presentations and 9 poster
presentations given at the conference. The ability of Modelica as a multi-domain simulation language
is demonstrated impressively by the various fields that are covered, e.g. digital electronic devices,
hybrid electric power trains, waste water processes or thermodynamic applications.
With the special features of the Modelica language, e.g. object-oriented modelling and the ability to
reuse and exchange models, Modelica has become – among other things – a further step towards of an
integrated engineering design process. In some fields Modelica is being used as a standard platform for
model exchange between suppliers and OEM’s, for example in case of vehicle air conditioning systems.
A key issue for the success of Modelica is the continuous development of the Modelica language by
the Modelica Association under strict observance of backward compatibility to previous versions. The
broad base of private and institutional members of the Modelica Association as a non-profit organization ensures language stability and security in software investments.
The Modelica Conference 2005 was organized by the Modelica Association and by the Department
of Thermodynamics of Hamburg University of Technology (TUHH), Germany. Together with the
entire team of the local organizing committee I would like to wish all participants an excellent and
fruitful conference.

Hamburg-Harburg, March 1, 2005

Gerhard Schmitz

The Modelica Association

289

Modelica 2005, March 7-8, 2005

Contents

Program Committee
• Prof. Gerhard Schmitz, Hamburg University of Technology, Germany (Program chair).
• Prof. Bernhard Bachmann, University of Applied Sciences Bielefeld, Germany.
• Dr. Francesco Casella, Politecnico di Milano, Italy.
• Dr. Hilding Elmqvist, Dynasim AB, Sweden.
• Prof. Peter Fritzson, University of Linköping, Sweden
• Prof. Martin Otter, DLR, Germany
• Dr. Michael Tiller, Ford Motor Company, USA
• Dr. Hubertus Tummescheit, Scynamics HB, Sweden

Local Organizers
• Gerhard Schmitz
• Katrin Prölß
• Wilson Casas
• Henning Knigge
• Jens Vasel
• Stefan Wischhusen
• TuTech Innovation GmbH

The Modelica Association

290

Modelica 2005, March 7-8, 2005

Contents
Volume 1
Session 1a
Mechanical Systems

11

I. Kossenko, Moscow State University of Service, Russia: Implementation of Unilateral
Multibody Dynamics on Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F. Schiavo, G. Ferretti, L. Viganò, Politecnico di Milano, Italy: Object-Oriented Modelling and Simulation of Flexible Multibody Thin Beams in Modelica with the Finite
Element Method . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
T. Pulecchi, M. Lovera, Politecnico di Milano, Italy: Object-oriented modelling of the
dynamics of a satellite equipped with Single Gimbal Control Moment Gyros . . . . . .
H. Elmqvist, M. Otter, J. Dı́az López, Dynasim AB, Sweden; DLR Oberpfaffenhofen,
Germany: Collision Handling for the Modelica MultiBody Library . . . . . . . . . . .

Session 1b
Chemical Systems and Thermodynamic Systems I

13

25
35
45

55

F. Cellier, À. Nebot, ETH Zürich, Switzerland; Universitat Politecnica de Catalunya,
Spain: The Modelica Bond-Graph Library . . . . . . . . . . . . . . . . . . . . . . . . .
J. Ungethüm, German Aerospace Center, Stuttgart, Germany: Fuel Cell System Modeling
for Real-time Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
M. Rubio, A. Urquı́a, L. González, D. Guinea, S. Dormido, UNED and CSIC,
Madrid, Spain: FuelCell Lib - A Modelica Library for Modeling of Fuel Cells . . . . . .
E. Larsdotter Nilsson, P. Fritzson, Linköping University, Sweden: A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems

57
67
75
85

Session 1c
Methods I

95
F. Casella, Politecnico di Milano, Italy: Exploiting Weak Dynamic Interactions in Modelica 97
H. Olsson, H. Tummescheit, H. Elmqvist, Dynasim AB; Modelon AB, Sweden: Using
Automatic Differentiation for Partial Derivatives of Functions in Modelica . . . . . . . 105
L. Saldamli, B. Bachmann, P. Fritzson, H. Wiesmann, Linköping University, Sweden;
FH Bielefeld, Germany; ABB, Switzerland: A Framework for Describing and Solving
PDE Models in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
P. Aronsson, P. Fritzson, Linköping University, Sweden: A Task Merging Technique for
Parallelization of Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123

The Modelica Association

291

Modelica 2005, March 7-8, 2005

Contents

Session 2
Poster session

129

D. Aiordachioaie, M. Munteanu, E. Ceanga, University of Galati, Romania: Some
Results on Neutral Modelling of the Steel Continuous Casting Process . . . . . . . . .
C. Clauß, E. Erler, Fraunhofer Institute, Dresden, Berufliches Schulzentrum, Freital, Germany: Switched Capacitor Simulation with Modelica . . . . . . . . . . . . . . . . . . .
K. Berg, K. Nyström, Linköping University, Sweden: Hydrological modeling in Modelica
P. Harman, Ricardo UK Ltd.: Visualisation of Model Transformation Algorithms for a
Modelica Translator . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
C. Martin,A. Urquı́a, S. Dormido, UNED Madrid, Spain: Modeling of Interactive Virtual Laboratories with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
K. Nyström, P. Aronsson, P. Fritzson, Linköping University, Sweden: Parallelization
in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
S.E. Pohl, J. Ungethüm, DLR Stuttgart, Germany: A Simulation Management Enviroment for Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
A. Siemers, I. Nakhimovski, D. Fritzson, Linköping University, Sweden: Meta-modelling
of Mechanical Systems with Transmission Line Joints in Modelica . . . . . . . . . . . .

Session 3a
Automotive Simulation I

131
141
149
155
159
169
173
177

183

J. Eborn, H. Tummescheit, K. Prölß, Modelon AB, Sweden; TUHH, Germany: AirConditioning - a Modelica Library for Dynamic Simulation of AC Systems . . . . . . . 185
D. Limperich, M. Braun, G. Schmitz, K. Prölß, DaimlerChrysler AG; TUHH, Germany: System Simulation of Automotive Refrigeration Cycles . . . . . . . . . . . . . . 193
M. Hommel, Volkswagen AG, Germany: First Results in Cluster Simulation of Alternative
Automotive Drive Trains . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201

Session 3b
Thermodynamic Systems II

211

C. Kral, A. Haumer, M. Plainer, Arsenal Research, Vienna, Austria: Simulation of
a thermal model of a surface cooled squirrel cage induction machine by means of the
SimpleFlow-library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
S. Micheletti, S. Perotto, F. Schiavo, Politecnico di Milano, Italy: Modelling Heat
Exchangers by the Finite Element Method with Grid Adaption in Modelica . . . . . .
W. Steinmann, DLR Stuttgart, Germany: Calculation of Thermophysical Properties in
the Modelica Library TechThermo . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
M. Tiller, Ford Motor Company, USA: Development of a Simplified Transmission Hydraulics Library based on Modelica.Fluid . . . . . . . . . . . . . . . . . . . . . . . . .

Session 3c
Methods II

213
219
229
237

245

B. Johansson, P. Krus, Linköping University, Sweden: Probabilistic Analysis and Design
Optimization of Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
H. Elmqvist, H. Olsson, S.E. Mattsson, D. Brück, C. Schweiger, D. Joos, M.
Otter, Dynasim AB, Sweden; DLR, Oberpfaffenhofen, Germany: Optimization for
Design and Parameter Estimation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
M. Thümmel, G. Looye, M. Kurze, M. Otter, J. Bals, DLR Oberpfaffenhofen, Germany: Nonlinear Inverse Models for Control . . . . . . . . . . . . . . . . . . . . . . . . 267
The Modelica Association

292

Modelica 2005, March 7-8, 2005

Contents

P. Bunus, Linköping University, Sweden: An Empirical Study on Debugging EquationBased Simulation Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281

Volume 2
Session 4a
Automotive Simulation II

299

L. Morawietz, S. Risse, H. Zellbeck, H. Reuss, T. Christ, TU Dresden, University of
Stuttgart, BMW Group, Germany: Modeling an automotive power train and electrical
power supply for HiL applications using Modelica . . . . . . . . . . . . . . . . . . . . . 301
E. Surewaard, M. Thele, Ford Forschungszentrum Aachen, RWTH Aachen University,
Germany: Modelica in Automotive Simulations - Powernet Voltage Control during
Engine Idle . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
T. Bünte, A. Sahin, N. Bajcinca, DLR Oberpfaffenhofen, University of Siegen, Germany:
Inversion of Vehicle Steering Dynamics with Modelica/Dymola . . . . . . . . . . . . . 319

Session 4b
Thermodynamic Systems III

329

W. Steinmann, J. Buschle, DLR Stuttgart, Germany: Analysis of thermal storage systems
using Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331
S. Wischhusen, G. Schmitz, TUHH, Germany: Exergy-analysis of a direct-evaporating
cooling plant with heat reclaim . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 339
T. Ziehn, G. Reichl, E. Arnold, TU Ilmenau; Fraunhofer Institute Ilmenau, Germany:
Application of the Modelica library WasteWater for optimisation purposes . . . . . . . 351

Session 4c
Tools I

357
G. Ferretti, M. Gritti, G. Magnani, G. Rizzi, P. Rocco, Politecnico di Milano, Italy:
Real-Time Simulation of Modelica Models under Linux / RTAI . . . . . . . . . . . . . 359
M. Najafi, S. Furic, R. Nikoukhah, Imagine; INRIA-Rocquencourt, France: SCICOS: a
general purpose modeling and simulation environment . . . . . . . . . . . . . . . . . . 367
R. Dorling, Advanced Dynamic Systems, Peterborough, U.K.: Model Validation and the
Modelica Language . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 375

Session 5a
Engines

383

J. Batteh, M. Tiller, A. Goodman, Ford Motor Company, USA: Monte Carlo Simulations for Evaluating Engine NVH Robustness . . . . . . . . . . . . . . . . . . . . . . . 385
S.E. Pohl, M. Gräf, DLR Stuttgart, Germany: Dynamic Simulation of a Free-Piston Linear
Alternator in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393

Session 5b
Thermodynamic Systems IV

401
T. Hirsch, W. Steinmann, M. Eck, DLR Stuttgart, Germany: Simulation of transient
two-phase flow in parabolic trough collectors using Modelica . . . . . . . . . . . . . . . 403
L.J. Yebra, M. Berenguel, S. Dormido, M. Romero, CIEMAT-PSA; Universidad de
Almeria; UNED, Spain: Modelling and Simulation of Central Receiver Solar Thermal
Power Plants . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413

The Modelica Association

293

Modelica 2005, March 7-8, 2005

Contents

A. Cammi, F. Casella, M. Ricotti, F. Schiavo, Politecnico di Milano, Italy: ObjectOriented Modeling, Simulation and Control of the IRIS Nuclear Power Plant with
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 423

Session 5c
Tools II

433
A. Pop, P. Fritzson, Linköping University, Sweden: A Portable Debugger for Algorithmic
Modelica Code . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 435
O. Johansson, A. Pop, P. Fritzson, Linköping University, Sweden: ModelicaDB - A Tool
for Searching, Analysing, Crossreferencing and Checking of Modelica Libraries . . . . 445

Session 6a
Automotive Simulation III

455
C. Schweiger, M. Dempsey, M. Otter, DLR Oberpfaffenhofen, Germany; Claytex Services Ltd, UK: The PowerTrain Library: New Concepts and New Fields of Application 457
P. Bengtsson, H. Jansson, N. Pettersson, T. Sandberg, Scania CV AB, Sweden:
Development of a Modelica Heavy Vehicle Modeling Library . . . . . . . . . . . . . . . 467
M. Tiller, Ford Motor Company, USA:: Evaluation of Motor and Battery Requirements
for Hybrid-Electric Powertrains during Cranking . . . . . . . . . . . . . . . . . . . . . 477

Session 6b
Thermodynamic Systems V

485

W. Casas, K. Prölß, G. Schmitz, TUHH, Germany: Modeling of Desiccant Assisted Air
Conditioning Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
B. Oehler, Airbus Deutschland GmbH, Germany: Modeling and Simulation of Global Thermal and Fluid Effects in an Aircraft Fuselage . . . . . . . . . . . . . . . . . . . . . . . 497

Session 6c
Modelica Language

507
J. Mauss, DaimlerChrysler AG, Berlin, Germany: Modelica Instance Creation . . . . . . . 509
P. Fritzson, A. Pop, P. Aronsson, Linköping University, Sweden: Towards Comprehensive Meta-Modeling and Meta-Programming Capabilities in Modelica . . . . . . . . . . 519
C. Nytsch-Geusen et. al., Fraunhofer Institutes, Germany: MOSILAB: Development of
a Modelica based generic simulation tool supporting model structural dynamics . . . . 527

Session 7a
Electrical Systems

537

C. Clauß, U. Donath, A. Schneider, E. Weber, Fraunhofer Institute for Integrated
Circuits, University of Applied Sciences Mittweida, Germany: Standard Package Modelica.Electrical. Digital . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
C. Kral, A. Haumer, Arsenal Research, Austria: Modelica libraries for dc machines, three
phase and polyphase machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
Th. Bödrich, Th. Roschke, Dresden University of Technology; Saia-Burgess Dresden
GmbH, Germany: A Magnetic Library for Modelica . . . . . . . . . . . . . . . . . . . 559

The Modelica Association

294

Modelica 2005, March 7-8, 2005

Session 7b
Real-Time and Reactive Systems

567
M. Otter, K.-E. Årzén, I. Dressler, DLR Oberpfaffenhofen, Germany; Lund Institute
of Technology, Sweden: StateGraph-A Modelica Library for Hierarchical State Machines 569
J. Bäckman, M. Edvall, Metso Paper AB, Sweden: Using Modelica and Control Systems
for Real-time Simulations in the Pulp & Paper industry . . . . . . . . . . . . . . . . . 579

Session 7c
Modelica Interfaces

585
J. Köhler, A. Banerjee, ZF Friedrichshafen AG, Germany: Usage of Modelica for transmission simulation in ZF . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
M. Tiller, Ford Motor Company, USA: Implementation of a Generic Data Retrieval API
for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
H. Olsson, Dynasim AB, Sweden: External Interface to Modelica in Dymola . . . . . . . . 603

The Modelica Association

295

Modelica 2005, March 7-8, 2005

The Modelica Association

296

Modelica 2005, March 7-8, 2005

Index of Authors
Elmqvist, Hilding . . . . . . . . . . . . . . . . . 45, 105, 255
Erler, Elisabeth . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
Ernst, Thilo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527

Årzén, Karl-Erik . . . . . . . . . . . . . . . . . . . . . . . . . . 569
Aiordachioaie, Dorel . . . . . . . . . . . . . . . . . . . . . . 131
Arnold, Eckhard . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Aronsson, Peter . . . . . . . . . . . . . . . . . 123, 169, 519

Ferretti, Gianni . . . . . . . . . . . . . . . . . . . . . . . 25, 359
Fritzson, Dag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 177
Fritzson, Peter 85, 113, 123, 169, 435, 445, 519
Furic, S. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367

Bäckman, Johan . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Bödrich, Thomas. . . . . . . . . . . . . . . . . . . . . . . . . .559
Bünte, Tilman . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Bachmann, Bernhard . . . . . . . . . . . . . . . . . . . . . 113
Bajcina, Naim . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Bals, Johann . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
Banerjee, Alexander. . . . . . . . . . . . . . . . . . . . . . .587
Batteh, John J. . . . . . . . . . . . . . . . . . . . . . . . . . . . 385
Bengtsson, Per . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Berenguel, M. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
Berg, Karin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
Brück, Dag . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255
Braun, Marco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Bunus, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
Buschle, Jochen . . . . . . . . . . . . . . . . . . . . . . . . . . . 331

González, Leandro . . . . . . . . . . . . . . . . . . . . . . . . . 75
Goodman, Adam. . . . . . . . . . . . . . . . . . . . . . . . . .385
Gräf, Markus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
Gritti, Marco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Guinea, Domingo . . . . . . . . . . . . . . . . . . . . . . . . . . 75
Harman, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
Haumer, Anton . . . . . . . . . . . . . . . . . . . . . . 213, 549
Hirsch, Tobias . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
Holm, Andreas . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Hommel, Mathias . . . . . . . . . . . . . . . . . . . . . . . . . 201
Jansson, Henrik . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Johansson, Björn. . . . . . . . . . . . . . . . . . . . . . . . . .247
Johansson, Olof . . . . . . . . . . . . . . . . . . . . . . . . . . . 445
Joos, Dieter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 255

Cammi, Antonio . . . . . . . . . . . . . . . . . . . . . . . . . . 423
Casas, Wilson . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
Casella, Francesco . . . . . . . . . . . . . . . . . . . . . 97, 423
Ceanga, Emil . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 131
Cellier, François E. . . . . . . . . . . . . . . . . . . . . . . . . . 57
Christ, Thomas . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Clauß, Christoph . . . . . . . . . . . . . . . . . . . . . 141, 539

Köhler, Jochen . . . . . . . . . . . . . . . . . . . . . . . . . . . . 587
Kossenko, Ivan . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Kral, Christian . . . . . . . . . . . . . . . . . . . . . . . 213, 549
Krus, Petter . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
Kurze, Matthias . . . . . . . . . . . . . . . . . . . . . . . . . . 267

Dı́az López, José . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
Dempsey, Mike . . . . . . . . . . . . . . . . . . . . . . . . . . . .457
Doll, Ulrich . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Donath, Ulrich . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Dorling, Richard . . . . . . . . . . . . . . . . . . . . . . . . . . 375
Dormido, Sebastian . . . . . . . . . . . . . . . 75, 159, 413
Dressler, Isolde. . . . . . . . . . . . . . . . . . . . . . . . . . . .569

Larsdotter Nilsson, Emma . . . . . . . . . . . . . . . . . . 85
Leopold, Jürgen . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Limperich, Dirk . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Looye, Gertjan . . . . . . . . . . . . . . . . . . . . . . . . . . . . 267
Lovera, Marco . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 35
Magnani, Gianantonio . . . . . . . . . . . . . . . . . . . . 359
Martin, Carla . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 159
Mattes, Alexander . . . . . . . . . . . . . . . . . . . . . . . . 527

Eborn, Jonas. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .185
Eck, Markus . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 403
Edvall, Mattias . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
The Modelica Association

297

Modelica 2005, March 7-8, 2005

Mattsson, Sven Erik . . . . . . . . . . . . . . . . . . . . . . 255
Mauss, Jakob . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 509
Micheletti, Stefano . . . . . . . . . . . . . . . . . . . . . . . . 219
Morawietz, Lutz . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Munteanu, Mihai . . . . . . . . . . . . . . . . . . . . . . . . . 131

Surewaard, Erik. . . . . . . . . . . . . . . . . . . . . . . . . . .309
Thümmel, Michael . . . . . . . . . . . . . . . . . . . . . . . . 267
Thele, Marc . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 309
Tiller, Michael M. . . . . . . . . . . 237, 385, 477, 593
Tummescheit, Hubertus . . . . . . . . . . . . . . 105, 185

Najafi, Masoud . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
Nakhimovski, Iakov . . . . . . . . . . . . . . . . . . . . . . . 177
Nebot, Àngela . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
Nikoukhah, R. . . . . . . . . . . . . . . . . . . . . . . . . . . . . 367
Nordwig, André . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Nouidui, Thierry . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Nyström, Kaj . . . . . . . . . . . . . . . . . . . . . . . . 149, 169
Nytsch-Geusen, Christoph. . . . . . . . . . . . . . . . .527

Ungethüm, Jörg . . . . . . . . . . . . . . . . . . . . . . . 67, 173
Urquı́a, Alfonso . . . . . . . . . . . . . . . . . . . . . . . 75, 159
Vetter, Matthias . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Viganò, Luca. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .25
Weber, Enrico . . . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Wiesmann, Hansjürg . . . . . . . . . . . . . . . . . . . . . . 113
Wischhusen, Stefan . . . . . . . . . . . . . . . . . . . . . . . 339
Wittwer, Christof . . . . . . . . . . . . . . . . . . . . . . . . . 527

Oehler, Bettina . . . . . . . . . . . . . . . . . . . . . . . . . . . 497
Olsson, Hans . . . . . . . . . . . . . . . . . . . . 105, 255, 603
Otter, Martin . . . . . . . . . . . 45, 255, 267, 457, 569

Yebra, Luis Jose . . . . . . . . . . . . . . . . . . . . . . . . . . 413

Perotto, Simona. . . . . . . . . . . . . . . . . . . . . . . . . . .219
Pettersson, Niklas . . . . . . . . . . . . . . . . . . . . . . . . . 467
Plainer, Markus . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
Pohl, Sven-Erik . . . . . . . . . . . . . . . . . . . . . . 173, 393
Pop, Adrian . . . . . . . . . . . . . . . . . . . . . 435, 445, 519
Prölß, Katrin . . . . . . . . . . . . . . . . . . . . 185, 193, 487
Pulecchi, Tiziano . . . . . . . . . . . . . . . . . . . . . . . . . . . 35

Zellbeck, Hans . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Ziehn, Tilo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351

Reichl, Gerald . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Reuss, Hans-Christian. . . . . . . . . . . . . . . . . . . . .301
Ricotti, Marco E. . . . . . . . . . . . . . . . . . . . . . . . . . 423
Risse, Silvio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 301
Rizzi, Gianpaolo . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Rocco, Paolo . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 359
Romero, M. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 413
Roschke, Thomas . . . . . . . . . . . . . . . . . . . . . . . . . 559
Rubio, Miguel A. . . . . . . . . . . . . . . . . . . . . . . . . . . . 75
Sahin, Akin . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 319
Saldamli, Levon . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Sandberg, Tony . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Schiavo, Francesco . . . . . . . . . . . . . . . . 25, 219, 423
Schmidt, Gerhard . . . . . . . . . . . . . . . . . . . . . . . . . 527
Schmitz, Gerhard. . . . . . . . . . . . . . . .193, 339, 487
Schneider, André . . . . . . . . . . . . . . . . . . . . . . . . . . 539
Schneider, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Schwarz, Peter . . . . . . . . . . . . . . . . . . . . . . . . . . . . 527
Schweiger, Christian. . . . . . . . . . . . . . . . . .255, 457
Siemers, Alexander. . . . . . . . . . . . . . . . . . . . . . . .177
Steinmann, Wolf-Dieter. . . . . . . . . .229, 331, 403
The Modelica Association

298

Modelica 2005, March 7-8, 2005

Session 4a
Automotive Simulation II

The Modelica Association

299

Modelica 2005, March 7-8, 2005

The Modelica Association

300

Modelica 2005, March 7-8, 2005

Modeling an automotive power train and electrical power supply for HiL applications using Modelica

Modeling an automotive power train and electrical power supply for
HiL applications using Modelica
Lutz Morawietz1 Silvio Risse1 Thomas Christ2
Hans Zellbeck1 Hans-Christian Reuss3
1 Dresden

University of Technology
Institute of Combustion Engines and Automotive Engineering
George-Baehr-Str. 1c, 01062 Dresden
{morawietz, risse, zellbeck}@ivk.tu-dresden.de
2

BMW Group
Energy management und CO2
80788 München
Thomas.Christ@bmw.de
3

University of Stuttgart
Institute for Internal Combustion Engines and Automotitve Engineering
Pfaffenwaldring 12, 70569 Stuttgart
reuss@ivk.tu-stuttgart.de

Abstract
Fuel consumption and emissions are key issues in automotive development. An intelligent energy management helps to improve both factors. Tools for developing new management strategies can be off-line simulation as well as Hardware-in-the-Loop (HiL) simulation. This paper gives an overview over a joint project
between Dresden University of Technology and the
BMW Group. In this project an EnergyLibrary
containing power train and electrical power net models is improved.
The paper will describe the thermodynamic
model of the internal combustion engine (ICE),
the alternator model, and the implemented
NeuralNetworkLibrary in more detail. On
the HiL test bench component measurements and new
energy management strategies for the electrical power
net can be tested.

1

Introduction

Legal regulations on fuel consumption and the rising
need of comfort and safety are the main issues in automotive development.
One main field of interest is the reduction of fuel
The Modelica Association

consumption by optimizing the auxiliary units, the
warm-up behavior of the internal combustion engine
(ICE) and the electrical power net [4].
The electrical energy management controls the energy generation, distribution and storage in the electrical power net. It enhances the robustness of the system
and is capable of reducing the fuel consumption.
The interaction between the electrical power net and
the drive train occurs at the alternator. A rising demand of electrical energy leads to an increased driving torque of the alternator and therefore to an increased fuel consumption. The alternator’s torque demand plays an important role in the dynamic behavior
of the ICE, especially at idle speed.
For fuel consumption the thermal behavior of the
ICE plays another dominant role. Between 10-20%
of the fuel during the New European Driving Cycle
(NEDC) is used for the warm up.
This paper describes some enhancements made to
the BMW model library used for energy flow prediction. The models are derived from measurements
generated on an engine test bench, a Hardware-in-theLoop (HiL) test bench, and during vehicle testing.
The presented results were developed in a joint
project of Technische Universität Dresden and BMW
Group.

301

Modelica 2005, March 7-8, 2005

L. Morawietz, S. Risse, H. Zellbeck, H. Reuss, T. Christ

2

Approach and Tools

(i) DriveLine includes Engine, GearBox,
Tank, Axles, and CargoSystems

The goal is to model the electrical power net, the auxiliary units, and the ICE including its thermodynamic (ii) DriveEnvironment includes Tracks,
Driver, and BusSystem
behavior using Modelica/Dymola.
The overall vehicle model consists of objects of
many different physical domains such as electronics, (iii) AuxiliaryUnits include BeltDrive,
ClimateUnit, HydraulicUnits, and
mechanics, thermodynamics, hydraulics, pneumatics
PowerNet
as well as control systems and is described in section
3.1.
(iv) Blocks include non Modelica standard blocks
The model parameters are gained using different
measurement environments:
Each component model (e.g. the ICE) consists of
the
following packages:
(i) on an ICE test bench the ICE itself and the auxiliary units are measured
(ii) in a test vehicle all internal car data (e.g. CAN),
electrical currents and voltages, pressures, temperatures and torques of engine and auxiliary
units can be recorded.

(i) Basis including templates for icons, connector
(e.g. rotational flanges, bus), and component specific sub models
(ii) BusSystem including the bus signals that the
component uses for its communication

(iii) HiL test bench for the electrical power net where
single components of the power net, especially (iii) Models including various types of models (e.g.
various warm up models). Those models can be
the alternator, can be examined
selected via Choice.
Using these test environments, realistic inputs for the
HiL test bench and model validation can be generated. (iv) Record which represents the parameter strucThe HiL test bench is especially important since one
ture for the most commonly used models.
can efficiently test new components and control strategies in real time. The interaction with other subsystems in a car can be analyzed.
In real time environments high simulation speed is
crucial. Therefore the models were adapted accordingly by eliminating unnecessary dynamics and expensive computations. Most of the model behavior is represented using look-up tables or Neural Networks.
At BMW more and more system simulations are
carried out in object oriented simulation environments.
Modelica is currently in use for the simulation of the
electrical power net, the air conditioning, the fuel consumption and hybrid drive trains.

3

Model

As mentioned earlier fuel consumption is the main foFigure 1: Library structure and vehicle model
cus of the simulations done in this project. In the first
stage the car is simplified to its longitudinal dynamThe main model is assembled by the Choice
ics. The model frame work, the thermodynamic en- blocks of each component model. That way structural
gine model, and the power net are described.
changes in the model can be made comfortably.1 The
top level of the car model and the library structure can
3.1 EnergyLibrary
be seen in figure 1.
1 For example a change between automatic and manual
The developed model library, shown in figure 1 is divided into four main packages:
GearBox

The Modelica Association

302

Modelica 2005, March 7-8, 2005

Modeling an automotive power train and electrical power supply for HiL applications using Modelica

The Bus and Record structure are assembled in
a similar tree structure by instantiation. Thus the bus
signals are grouped after simulation in a concise tree
structure as shown in figure 2. We established the
same tree structure in the model library, the simulation
model, the parameters, and the bus system.

torque of the auxiliary systems Taux has to be considered. The load torque of the auxiliary systems is determined for every relevant unit in separate models. Additionally for each torque a temperature dependence is
included. These dependencies are caused by the tribological behavior.
Thermodynamic Behavior

Figure 2: Simulation of the New European Drive Cycle showing the structured Bus
The model parameters are managed by a parameter
database which also allows pre-processing.

3.2

Thermodynamic Model of an ICE

The thermal behavior of an ICE is defined by its heat
capacities, heat transfers and thermal conductivities as
well as its surrounding conditions. The heat capacities can be divided into two major groups. There are
constant heat capacities which arise from engine construction and varying heat capacities following from
fluid systems. For the latter ones the oil and the coolant
circuit are relevant. The oil temperature has a direct influence on the engine friction T f ric . Therefore it plays
an essential role in ICE fuel consumption.
Although different thermodynamic libraries for
modelling fluid flow already exist in Modelica, none of
them seem able to be run on a real time platform. Due
to that a more basic FluidFlowLibrary was developed. All fluid systems are described by a stationary pressure drop model and defined as an incompressible single medium. Because phase changing of the
medium appears only locally during standard driving
cycles (e.g. NEDC, FTP75) it is not taken into consideration. This has negligible influence on the thermal
behavior of the overall system.
In the FluidFlowLibrary mainly TwoPortcomponents are used. The connectors are reduced to
the variables: Pressure p, temperature T and the flow
variables mass flow rate ṁ and heat flow rate Q̇.

The temperature has a major impact on the behavior of
the ICE and the auxiliary units. To be able to simulate
the warm-up phase a thermodynamic model of the ICE
is necessary. Additionally several environmental conditions and different auxiliary loads have to be taken connector Port_A
Modelica.SIunits.Pressure p;
into account.
Torque Balance

flow Modelica.SIunits.MassFlowRate mdot;
Modelica.SIunits.Temperature T;
flow Modelica.SIunits.HeatFlowRate Qdot;
end Port_A;

An essential requirement of the model is the determination of the relevant torques taking into account difBesides to the two connectors for the fluid transfer,
ferent auxiliary and engine loads. According to [3] the
a
heat
port HeatPort A from the standard Modeltorque balance is given by the following equation:
ica library was inserted. For each of the control vol0 = Tind − T f ric − Taux − Te f f
(1) umes mass and energy balance equations are applied.
The internal energy ∆U is calculated with the help of
The indicated engine torque Tind is defined as the the enthalpy flows Q̇in , Q̇out at the connectors and the
possible drive torque which theoretically can be used heat losses Q̇heat at the volume boundary. As a referif the engine is mechanically free of losses. Te f f rep- ence value the mean temperature Tmean of the volume
resents the torque used for the vehicle movement. Be- is used. Work due to change of volume is not taken
side the losses caused by the engine friction T f ric the into account.
The Modelica Association

303

Modelica 2005, March 7-8, 2005

L. Morawietz, S. Risse, H. Zellbeck, H. Reuss, T. Christ

3.3

model volume
...
equation
...
//energy balance equation
dU=Qindot + Qoutdot + Qheatdot;

Electrical Power Net

The components of the electrical power net can be divided into four parts:
(i) generators: alternator

// heat transfer equations
Qindot = Port_A.mdot*cp*Port_A.T;
Qoutdot = Port_B.mdot*cp*Port_B.T;

(ii) storage devices: battery, double layer capacitor
(iii) converter: DC/DC converter

//equations for heat loss
Qheatdot=HeatPort_A.Q_dot;
Tmean=HeatPort_A.T;

(iv) loads: seat heating, fan, driving light

//equation for the internal energy
dU = m*cp*der(Tmean);
...
end heater;

The media qualities depending on temperature, e.g.
density, specific heat capacities c p , are computed for
each volume separately. Either look-up tables or polynomial functions are used for these calculations [6].

Figure 4: Object diagram of a simplified power net
Figure 4 shows the model of a simplified power net.
The Loads are modelled in three simple ways:
ohmic resistance the resistance is independent of
voltage and current
power sink the consumed power is independent of
voltage and current
current sink the consumed current is independent of
voltage
More effort is needed modelling storage and distribution devices and power sources.
Figure 3: Thermodynamic network of the ICE model
Alternator model
Figure 3 shows a part of the thermodynamic network model. It consists of several heat capacities
(i.e. oil, coolant, solid material of the engine) and
their heat transfers. The contact to the rest of the ICE
model and its environment is defined by the standard
HeatPorts, the Bus connectors and the earlier described ports for the fluid flows (orange). These connectors allow the exchange of oil and coolant between
ICE and other components in the cooling circuit.
The Modelica Association

In a conventional power net the alternator is the only
source for electrical power. With regards to modelling
two aspects are of interest:
(i) Fuel consumption caused by the alternator
(ii) Computation of the charge-balance
(iii) Dynamic behavior at changing electrical loads

304

Modelica 2005, March 7-8, 2005

Modeling an automotive power train and electrical power supply for HiL applications using Modelica

The dynamic behavior of the generated current influences the voltage stability of the power net. It
also causes a dynamic torque which affects the ICE.
Close to idle speeds this torque causes unwanted disturbances in the engines smoothness.
In modern alternators the so-called Load Response
Control is used to improve the engine smoothness. It
limits the slew rate of the generator current.

In order to determine the slew rate the input signal
has to be derived once. For discontinuous input functions the derivation is not defined at all times. Therefore we introduce the auxiliary variable x and the sampling time Ts.
The link between the electrical and mechanical domain is realized employing a Neural Network. It evaluates the alternator torque in depending on its current
and revolution speed. The MechanicalLosses
model includes all bearing friction and fan losses.

4

Neural Network Library

At system level mechatronic components mostly exhibit strong nonlinear behavior. Often this behavior is
hard to describe in a mathematical way. Even if it is
described mathematically the models need a high computational power and are not usable on a real time platform. In this case another way of describing this behavior can be realized with the help of look-up tables
or Neural Networks [5]. In general Neural Networks
require less memory than look-up tables but employing lager networks the computational effort will rise.
Figure 5: Model of an alternator
The lower need of memory is of greater interest for
real time simulation.
Figure 5 shows the connection between the thermal,
To be able to use Neural Networks in Dymola a
mechanical, electrical and control part of the alterna- NeuralNetworkLibrary was developed. It can
tor.
be used to simulate feed-forward networks with up to
The alternator CurrentController compares two hidden layers.
the reference voltage and the actual voltage and controls the current between the electrical pins.
Part of the CurrentController is the Load Response Control implemented employing a rate limiter:
model RateLimiter "Rate limiter"
extends Modelica.Blocks.Interfaces.SISO;
parameter Real RR
"Maximum rising slew rate";
parameter Real FR
"Maximum falling slew rate";
parameter Real Ts=0.01 "Sampling time";
Real x "auxiliary variable";
equation
if initial() then
y = u;
x = 0;
end if;

Figure 6: Parameters of the Neural Network Model

der(x) = (u - y)/Ts;
der(y) = smooth(0,noEvent(
if der(x) > RR then RR else if der(x) < FR
then FR else der(x)));
end RateLimiter;

The Modelica Association

In figure 6 the parameter window of a neural network can be seen. The dimension of the Neural Network is defined as an array named dim. The user can
choose from zero to two hidden layers. Every layer

305

Modelica 2005, March 7-8, 2005

L. Morawietz, S. Risse, H. Zellbeck, H. Reuss, T. Christ

has its own activation function. The weights and bias
values are loaded from a Matlab file during initialization of the process. The input and the output are vector
ports. The size of the vector depends on the number of
input and output neurons, respectively.
First tests were performed at a dSPACE system to
estimate the performance of the Neural Networks in
comparison to look-up tables. Therefore a real time
simulation was carried out on the HiL test bench described in section 5. The look-up table in the generator model (figure 5) was replaced by a fully connected
Neural Network with two input neurons, one output
neuron and two hidden layers. The first layer consists
of 20 neurons, the second one of 10. As activation
functions the hyperbolic tangent was used.
Using the explicit Euler method for inline integration the computational need of the Neural Network is
only slightly higher than for look-up tables. But further work needs to be done varying the size of the Neural Network and using different activation functions.

5

can be seen. Two power sources are implemented.
On one hand there is a physical alternator driven by
an electric motor. On the other hand a programmable
current source can be used. To emulate the alternator
behavior the model described in section 3.3 is used.
A dual power net can be realized by using a system of three busbars. This way various topologies can
be build up using power sources, storage devices and
power electronics.

Dymola in a HiL environment

For measuring component parameters and testing
strategies for energy management a Hardware-in-Loop
(HiL) test bench was built. It is kept modular so that
the boundary between hardware and software can be
shifted in a certain range. With this concept it is possible to cut free the complex system of the electrical
power net to different degrees.

Figure 8: Operating and monitoring the HiL test
bench with dSPACE ControlDesk
The HiL computer is based on a dSPACE modular
hardware system. The core of this system is a DS1005
where the models are computed on a 500 MHz PowerPC. Further, the dSPACE expansion box includes
several boards for analog and digital signal I/O, CAN
interfaces and digital signal processing. The user interface to the real time system is given by the software
dSPACE ControlDesk. In figure 8 a screen shot can be
seen. [1]
The task of the dSPACE system is both to monitor
and control the HiL test bench and to simulate models
under real time conditions. An electronic controlled
load replaces the electrical consumer load. Its input
is derived from profiles measured in a test vehicle or
from the models described in section 3.3. The other
necessary input data to the HiL environment, e.g. engine speed, surrounding temperature, control voltage
of the generator, are gained in a similar way either by
simulation or measurement.
The main goals for the HiL environment are:
(i) compare the alternator behavior to the alternator
model

Figure 7: Schematic structure of the HiL test bench
In figure 7 a schematic of the test bench structure
The Modelica Association

(ii) implement the model of the ICE including thermal behavior

306

Modelica 2005, March 7-8, 2005

Modeling an automotive power train and electrical power supply for HiL applications using Modelica

References

(iii) test energy management strategies
So far the step size for the integration at the real time
system is set to 1 ms.

[1] dSPACE: http//www.dspace.de
[2] Dymola: Dymola User Manual, Version 5.3a.
Dynasim AB, http://www.dynasim.se, 2004
[3] Heywood, J.: Internal Combustion Engine Fundamentals. McGraw-Hill, Inc., 1988
[4] Meir, F., Bertram, M., Christ, T.,Reuss, H.-C.,
Morawietz, L., Büchner, S.: Energiemanagement
des elektrischen Bordnetzes im Kraftfahrzeug Werkzeuge der Funktionsentwicklung. Proceedings of the VDE Congress, Berlin, 2004
[5] Krug, C.: Ein Beitrag zur dynamischen Modellierung des Verbrennungsmotors für Ausgaben
der Echtzeit-Simulation. München, Germany,
PhD thesis, Department of Car-electornics and
electrics, Dresden University of Technology,
2003

Figure 9: Example of an HiL simulation result
As an example for HiL simulation figure 9 shows an
experiment using the alternator model. In this case the
components of the power net are the controlled load,
a real battery and the alternator model controlling the
electronic power source. As load current a measured
blinker current with an additional load step at 7 s was
taken. The slew rate of the alternator current was limited by the earlier described Load Response Control.
The difference between load and alternator current has
to be equalized by the battery current. During this time
the voltage drops from alternator voltage (13.5 V) to
the battery voltage (12.6 V).

6

[6] Verein Deutscher Ingenieure: VDI-Wärmeatlas.
Springer Verlag, 2002

Conclusions

The existing model libraries for automotive power
train and power net were extended for better thermal
engine modeling and electrical real time simulation.
The simulation platform enables us to develop new energy management strategies and test them under realistic conditions. For real time application the Modelica/Dymola models are included in a Simulink/dSpace
environment. First tests are done replacing commonly
used look-up tables by Neural Networks to reduce the
size of the real time code without generating computational overhead.
In automotive every day use the Modelica/Dymola
environment has proved to be a useful tool.
The Modelica Association

307

Modelica 2005, March 7-8, 2005

The Modelica Association

308

Modelica 2005, March 7-8, 2005

Modelica in Automotive Simulations - Powernet Voltage Control during Engine Idle

Modelica in Automotive Simulations Powernet Voltage Control during Engine Idle

Erik Surewaard
Ford Forschungszentrum Aachen
Suesterfeldstrasse 200
52072 Aachen, Germany

Marc Thele
RWTH Aachen University
Jaegerstrasse 17-19
52066 Aachen, Germany

esurewa1@ford.com

marc.thele@isea.rwth-aachen.de

Abstract
Due to the increasing electric power demand of future vehicles, problems may be expected with the
voltage stability of the powernet. In conventional
vehicles, control of the powernet voltage can be lost
when the loads in the electric powernet request more
power than can be supplied by the generator. In that
case voltage control of the powernet will be lost
since the generator will not be able to follow the
voltage setpoint. The voltage of the electric powernet
will drop to and follow the battery voltage. This will
go impaired with undesired voltage fluctuations resulting in light flicker and blower motor fluctuations,
which can be noticed by the vehicle occupants. This
will have a negative effect on customer perception.
This paper describes both physical plant models and
control algorithms, which can be used for simulation
of the electric powernet. By making use of the
ModelicaVMA structure that has been set-up by
Tiller et. al. in [1], a simulation model is set-up including detailed models of: (i) a battery, (ii) generator, (iii) heated front windscreen and (iv) an internal
combustion engine. In the case of de-icing the front
windscreen during engine idle, simulations have
been performed to investigate what the effect is of (i)
engine idle speed control and (ii) load switching
compared with the conventional situation.

1

of vehicle chassis functions, e.g. Electric Power Assisted Steering (EPAS) and Electronic Damping
Control (EDC). Since the electric powernet will get
an increasingly important function in the vehicle,
electric load models will also become increasingly
important for future vehicle simulations. That the
Modelica language can be of great benefit in electric
powernet simulations has already been shown by the
author in [2], [3] and [4]. That Modelica is also suitable for control system development will be shown
in an application for powernet voltage control during
engine idle. Based on the ModelicaVMA structure,
this paper describes physical models and control algorithms, which can be used to investigate voltage
stability of the electric powernet during engine idle.

2

Powernet Voltage Stability

Fig. 1 shows a schematic of the powernet of a conventional vehicle in which the generator voltage is
the only variable that can be actively controlled.

Introduction

The average electric power drawn in a conventional
vehicle, shows a rising trend over the years. This is
on the one hand caused by the growing amount of
electric comfort loads but also by the electrification
The Modelica Association

Fig. 1 Powernet topology for a conventional vehicle in
which only the generator voltage can be controlled

309

Modelica 2005, March 7-8, 2005

E. Surewaard, M. Thele

Dependent on the amount of requested electric
power by the loads, two powernet states can occur:
1. The powernet state in which the requested electric power is LOWER than the maximum that
can be supplied by the generator. In this state
the powernet voltage will be close to the voltage
setpoint of the generator: in a conventional vehicle the voltage setpoint (e.g. 13.7V) of the
generator is above the open circuit voltage of
the battery (12.7V). Therefore the battery will
be charged continuously in this state.
2. The powernet state in which the requested electric power is HIGHER than the maximum that
can be supplied by the generator. In this state
the additional requested power will be drawn
from the battery. The saturated generator will
not be able to follow the given setpoint and control of the powernet voltage will be lost: the
powernet voltage will be determined by the battery. This will go hand in hand with voltage
fluctuations which can be noticeable to the vehicle occupants: e.g. light flicker, changes in noise
generated by the blower fan.
In conventional vehicles, the demand of electric
power is usually highest during winter time when
the engine is idling and the heated front screen is
activated. The generator is usually saturated in this
situation resulting in a loss of control of the powernet voltage. This paper will investigate means to
prevent loosing voltage control in this situation by
using idle speed control or reducing the electric
power to a load.

3

Battery

Fig. 2 shows the battery model that has been described by Surewaard in [3]. The issue with this
model is that overcharging is not well described
since the overcharging process is difficult to investigate with impedance measurements. The first step
that is taken in the improvement of the battery model
is to include the mass transport processes, which
have been described by Thele in [5]. Mass transport
processes will have a significant effect on the equilibrium voltage, also known as Open Circuit Voltage
(OCV), of the battery. Detailed information on the
Inclusion and research on the overcharging reaction
is still in progress at the moment.
For a lead-acid (PbA) battery the discharge reaction
that occurs at the positive electrode surface is the
reaction of sulphuric acid and lead dioxide into lead
sulphate and water whilst consuming two free electrons:

PbO 2 + HSO -4 + 3H + + 2e - → PbSO 4 + 2H 2 O
The discharge reaction that takes place at the negative electrode surface, is that lead and sulphuric acid
react to lead sulphate and two hydrogen protons,
forming two free electrons:

Pb + HSO -4 + H + → PbSO 4 + 2 H + + 2e −
During charging above-mentioned reaction will take
place in the opposite direction.
The reasons for including mass transport processes
in the battery model are the following processes:
ACID FORMATION/CONSUMPTION AND
DIFFUSION
During discharging, sulphuric acid is consumed
at the contact surface of both the positive and
negative electrode. During charging sulphuric
acid is formed at the electrode surfaces, which
are in direct contact with the electrolyte. The
differences in concentration will result in mass
transport (diffusion) of sulphuric acid.
CHARGE MIGRATION
This is the movement of charged particles (ions)
due to the electric field that exists between the
positive and negative electrode. HSO4- ions and
electrons will be attracted by the positive electrode, H+ protons will be attracted by the negative electrode.

Fig. 2 Battery model as described in [3]

The Modelica Association

310

Modelica 2005, March 7-8, 2005

Modelica in Automotive Simulations - Powernet Voltage Control during Engine Idle

3.1

Electrode Equilibrium Potential and Acid
Formation/Consumption

The equilibrium potential of the positive and negative electrode is dependent on the acid concentration.
According to Bode in [6], the molarity of sulphuric
acid can be calculated from the sulphuric acid concentration by:
3
4
2
6
3
m = 1.00 ⋅ 10 ⋅ C + 3.55 ⋅ 10 ⋅ C + 2.17 ⋅ 10 ⋅ C +
8
4
2.06 ⋅ 10 ⋅ C

3.2

( )

(m ) +

(m ) + 0.0216 ⋅ log 4 (m )
2
= −0.295 − 0.0736 ⋅ log(m ) − 0.0305 ⋅ log (m ) −
3
4
0.0305 ⋅ log (m ) − 0.0120 ⋅ log (m )
0.0432 ⋅ log

u−

2

3

(2a)

(2b)

Acid formation/consumption at the electrode surface
has been modeled with the following equations:
q

q

+

−

3−2⋅t

=

+
⋅i
d ⋅ A ⋅ F ⋅ 3600

(3a)

=

2 ⋅t −1
+
⋅ −i
d ⋅ A ⋅ F ⋅ 3600

(3b)

( )

in which q+ and q- are the flows of acid ions, t+ the
transfer number for cations, d the electrode thickness, A the effective electrode surface, F the Faraday
constant and i the current.
The above-mentioned equations have been implemented in a Modelica model for the positive and
negative electrode of which Fig. 3 shows both top
level icons.

Both the positive and the negative electrode have a
porous structure, thereby increasing the surface area
of the electrode with the bulk electrolyte. Due to the
reaction that occurs during (dis)charging, the porosity of both electrodes will change. The maximum
porosity of the electrode, i.e. the maximum amount
of open space in the electrode, will be reached when
the electrode is fully charged. Assuming the electrode porosity to be dependent on the battery State of
Charge (SOC) and having a volume change as function of the amount of discharged energy, the electrode porosity has been described in a Modelica
model. The top level icon of this model is displayed
in Fig. 4a.

(a)

(b)

Fig. 3 Electrode equilibrium potentials which are dependent on acid concentration: (a) positive electrode, (b) negative electrode

In the figures the lower connector is the 'concentration' connector which has been defined as:

The Modelica Association

(b)

Fig. 4 Top level icon of the (a) electrode porosity model
and (b) electrode-electrolyte diffusion model

3.3

(a)

Electrode Porosity

(1)

in which C represents the acid concentration and m
the molality. The electrode potential can now be calculated by the following equations:
u + = 1.628 + 0.0739 ⋅ log m + 0.0331 ⋅ log

connector ConcentrationNode
Modelica.SIunits.Concentration C
"Concentration [mol/m3]";
flow Real q(final unit="mol/s")
"Diffusive flow";
end ConcentrationNode;

Acid Diffusion and Charge Migration

For acid diffusion and charge migration, complex
diffusion equations have been set-up based on equations described by Thele in [5]. These equations have
been implemented in a Modelica model. The Modelica model, including all equations for acid diffusion
and charge migration, is displayed in Fig. 4b. Three
concentration connectors can be seen which from left
to right represent (i) the positive electrode, (ii) the
bulk electrolyte and (iii) the negative electrode.
Since the diffusion processes are temperature dependent, the model contains a thermal connector.
The inputs to the electrodes are their specific porosities, of which the model is discussed in the previous
section.

311

Modelica 2005, March 7-8, 2005

E. Surewaard, M. Thele

3.4

4

Complete OCV Model

By combining the submodels that have been described in the previous subsections, the OCV model
can be constructed, which is based on mass transport
processes. This model is displayed in Fig. 5.

Heated Front Windscreen

A component in the electric powernet, which consumes a significant amount of electric power and has
a relatively long thermal time constant, is the electrical heated front windscreen.

Fig. 7 Electric heated front windscreen: the area that is
heated
Fig. 5 OCV model including mass transport processes

The numbered submodels in Fig. 5 are a representation of: (1) battery parameters, (2) battery state information to be used for the porosity determination,
(3) and (4) the equilibrium potential of respectively
the positive and negative electrode, (5) the diffusion
processes and charge migration, (6) and (7) the porosity of respectively the positive and negative electrode. Item (8) represents the top level icon.
The battery model that is described by Surewaard in
[3] is extended with the OCV model based on mass
transport processes by defining it as a replaceable.
The parameter window for the battery model, including the replaceable OCV model, is displayed in Fig.
6. The already 'OCV_Simple' model is extended by
the
model
described
in
this
paper:
'OCV_MassTransportProcesses'.

Fig. 6 Zoom of the parameter window of the battery
model in which the OCV replaceable is highlighted

The Modelica Association

The electric heated front windscreen basically consists of a sandwich of materials: a Polyvinyl Butyral
(PVB) layer on which the tungsten heating wires are
placed, sandwiched between two glass layers. A
schematic of the layered structure is displayed in Fig.
8.

Fig. 8 Schematic overview of the different layers in an
electric heated windscreen

The two-dimensional heat transfer model that is setup for the electric heated windscreen is displayed in
Fig. 9. Basically each material layer is modeled by
taking the thermal mass in the center of the layer.
The thermal mass is connected to the outer surface of
the layer by it by two thermal conduction elements,
each having half the thickness of the total layer.
Apart
from components
of
the
Modelica.Thermal.HeatTransfer library, two new
components have been developed: (1) a thermal

312

Modelica 2005, March 7-8, 2005

Modelica in Automotive Simulations - Powernet Voltage Control during Engine Idle

mass representing the ice layer including the phase
change from ice to water at 0°C, and (2) a thermal
wire component, which converts electric power to a
heat flow. The left and right thermal connectors in
Fig. 9 represent respectively the inner and outer surroundings of the vehicle. Heat transfer between the
screen surface and the surroundings takes place via
both convection and thermal radiation.

A measurement has been performed where the windscreen was initially at room temperature (approx.
18.5°C). The measured voltage at the terminals of
the windscreen is used as input for the model. The
simulated current and temperature have been compared with the measured current and temperature.
The comparison of these results is displayed in Fig.
11 (heated windscreen was active in the timeframe
between 5 and 250 seconds).

(a)
Fig. 9
Electro-thermal model for the electric heated
windscreen

For the material constants and dimensions, use has
been made of data supplied by the manufacturer of
the heated screen and from literature. The model is
validated by comparing simulated data with invehicle measured data with the electric heated windscreen active. The windscreen temperature is measured with a thermocouple attached to the inner surface of the windscreen (Fig. 10).

(b)
Fig. 11 Comparison between simulated and measured
data of the heated windscreen: (a) temperature, (b) current

It can be seen from Fig. 11 that the simulated results
correspond well with the measured data.

5
Fig. 10 Thermocouple attached to the inner surface of
the windscreen

The Modelica Association

ModelicaVMA - Vehicle Idle Model

For the simulations, use will be made of the Vehicle
Model Architecture (VMA), which is based on the
description by Tiller in [1]. Since we are interested in

313

Modelica 2005, March 7-8, 2005

E. Surewaard, M. Thele

the engine idle state of the vehicle, the top level
VMA model can be simplified to the one displayed
in Fig. 12. The idle speed model contains the following physical plant and controller models: (1) driver,
(2a) accessory drive, (2b) accessories controller, (3a)
powerplant, (3b) powerplant controller, (4) transmission, (5a) electrical system, (5b) electrical system
controller and (6) top level controller. The models of
above-mentioned subsystems will be discussed in the
following subsections.
(a)
(b)
Fig. 13 Top level icons of (a) the accessory subsystem
and (b) the powerplant subsystem

5.4

Electrical

The electrical subsystem and controller are represented by respectively items (4a) and (4b) in Fig. 12.
The model of the electrical subsystem is displayed in
more detail in Fig. 14 and includes the following
models: (1) activation signal for the electrical windscreen, (2) switch of the electrical windscreen, (3)
controllable PWM switch, (4) residual electrical
loads, (5) battery, (6) heated windscreen and (7) top
level icon of the electrical subsystem.
Fig. 12 Top level VMA model for the engine idle state

5.1

Driver

The driver subsystem is represented by item (1) in
Fig. 12. Since the simulation will be performed with
the engine idling, the driver subsystem will output a
closed throttle position.
5.2

Accessories

The accessory subsystem and the accessory controller are represented by respectively items (2a) and
(2b) in Fig. 12. The accessory subsystem includes a
table lookup based generator model and also includes the belt losses. The top level icon of the accessory subsystem is displayed in Fig. 13a.
5.3

Powerplant

The powerplant subsystem and controller are represented by respectively items (3a) and (3b). An existing Simulink based model of an engine including its
controllers (e.g. idle speed controller), which is used
for fuel economy simulations at Ford, is converted to
ModelicaVMA. The top level icon of the powerplant
subystem is displayed in Fig. 13b.

The Modelica Association

Fig. 14
Electrical subsystem containing battery,
switches, heated windscreen and residual electrical loads

The strategy is to initiate the simulation with the
heated windscreen inactive. After 3 seconds, the
switch of the electrical windscreen will be closed so
that it becomes active. The residual electrical loads
are approximated by in-vehicle measured loads (having the electric heated screen inactive): 55A from 0-

314

Modelica 2005, March 7-8, 2005

Modelica in Automotive Simulations - Powernet Voltage Control during Engine Idle

100s, 40A during 100-200s and 20A after 200s. The
reason for the high load current during the first 200
seconds is that the glow plugs are active (Diesel engine).
5.5

Transmission

The transmission subsystem is represented by item
(4) in Fig. 12. For the idle speed simulations, it is
modeled by having a closed clutch having the neutral
gear engaged. The transmission subsystem includes
both the engine and gearbox sided inertia and a table
lookup model for the spinning losses in the neutral
gear. The top level icon of the transmission subsystem is displayed in Fig. 15a.

(a)

NOTE: the PWM switch as displayed by item (3) in
Fig. 14 is not used in this strategy since it will not be
available in a conventional vehicle.
6.2

Strategy 2 - Idle Speed Control

This strategy is based on the fact that the maximum
generator output current can be increased if the idle
speed is increased. The principle is displayed in Fig.
16. When the idle speed would be kept constant at
say 750 rpm, the maximum output current will be
approximately 70 A. When however the idle speed
would be increased, the maximum generator output
current also increases. Raising the idle speed above
1500 rpm would no benefits for the generator displayed in Fig. 16.

(b)

Fig. 15 Top level icons of (a) the transmission subsystem
and (b) a top level controller implementation

5.6

Top level Controller

The top level controller is represented by item (6) in
Fig. 12. Three top level controller models have been
developed, each having a different voltage control
strategy. The voltage control strategies will be discussed in the following section. The top level icon of
on of the controllers is displayed in Fig. 15b.

6

Voltage Control Strategies

The top level controller, which is also known as the
Vehicle System Controller (VSC), will control the
idle speed of the engine, the voltage setpoint of the
generator and if available the PWM frequency of the
electric heated windscreen. Three control strategies
will be investigated:
6.1

Strategy 1 - Conventional

Conventional 'strategy' where the idle speed is independent of the saturation of the generator. The engine idle speed setpoint will be 750 rpm.

The Modelica Association

Fig. 16 Maximum generator output current as function of
engine speed

The strategy that is implemented is that if the vehicle
is in idle, the engine idle speed is controlled to reach
a generator saturation of 95%. The window in which
the idle speed is allowed to be changed is limited by
a lower boundary of e.g. 750 rpm and a upper boundary of e.g. 1500 rpm (cf. Fig. 16).
NOTE: the PWM switch as displayed by item (3) in
Fig. 14 is not used in this strategy since it will not be
available in a conventional vehicle.
6.3

Strategy 3 - Pulse Width Modulation

Pulse Width Modulation (PWM) switches can be
added to specific electric loads in the powernet as
has been proposed by for instance Graf in [7]. The
powernet layout for this variant is displayed in Fig.
17.

315

Modelica 2005, March 7-8, 2005

E. Surewaard, M. Thele

Fig. 17 Powernet variant in which next to the generator
voltage also the electric power to a (group of) loads can be
controlled

By adding a controllable PWM switch, an additional
control variable is introduced in the electric powernet next to the generator voltage. By reducing the
electric power flowing to (a group of) loads, the total requested electric power can be controlled. In this
way exceeding the maximum electric power that can
be delivered by the generator can be prevented. According to Rienks [8], an approach is to add PWM
switches to comfort loads, e.g. seat heating and
screen heating, since these loads have a relative long
time constant. Temporarily reducing the amount of
electric power flowing to comfort loads will not affect customer acceptance as badly as loosing control
of the powernet voltage and by that cause for instance light flickering.
In strategy 3, the PWM switch to the electric heated
screen is controlled in such a way that the maximum
output current of the generator is not exceeded: the
power flowing to the heated screen is reduced to
prevent the generator to saturate and loose control of
the powernet voltage. The engine idle speed setpoint
is kept constant at 750 rpm in this strategy. The setpoint for the generator setpoint is set to 95%.

7

(SOC) is taken 70% and the initial temperature equal
to that of the frozen windscreen: -3°C.
For the simulations the initial condition is a vehicle
that has a frozen windscreen (-3°C, 200µm thick ice
layer). The electrical heated windscreen will be activated after 3 seconds after the simulation is initiated.
The simulation will be stopped when the outer surface temperature of the heated windscreen has
reached 3°C. The complete simulation will take
place with the engine in idle state. The output data of
interest is (i) the cumulative fuel consumption, (ii)
the voltage of the powernet, (iii) the engine idle
speed and (iv) the time before the outer surface temperature of the windscreen has reached 3°C. The results for the three different strategies are as follows:
7.1

Voltage Stability and Generator Saturation

(a)

Simulation Results

One of the advantages of using the ModelicaVMA
structure is the fact that all models can be redefined
since they are defined as replaceable. The simulation
results that will be described in this sections, have
been obtained by making use of the ModelicaVMA
structure with the subsystem and controller models
from Section 5 and the control strategies from Section 6. For the model parameters, use has been made
of real vehicle data (Diesel engine, 120A generator
and a 400W electrical heated front screen). A 12V
lead-acid battery parameter set has further been used
in the simulations: the initial battery State of Charge

The Modelica Association

(b)
Fig. 18
(a) Powernet voltage for the three different
strategies, (b) generator saturation

It can be seen from Fig. 18a that operating the electric heated windscreen with the conventional strategy

316

Modelica 2005, March 7-8, 2005

Modelica in Automotive Simulations - Powernet Voltage Control during Engine Idle

will result in loosing control of the powernet voltage.
It can be seen in Fig. 18b that this is caused by the
fact that the generator is saturated in this case. The
amount of power requested by the electric powernet
exceeds in the conventional case the power that can
be delivered by the generator . Therefore the generator setpoint can not be followed and the powernet
voltage will drop to the battery voltage. After 200
seconds the glow plugs will become inactive and the
generator is from this point on able to supply the total requested electric power and therefore follow its
voltage setpoint.
With the two other strategies (i.e. idle speed control
and PWM control), the generator saturation can be
controlled to 95% and therefore the voltage of the
powernet can be maintained at 14.2V.
7.2

the generator saturation is controlled to 95% by
changing the PWM frequency of the electric heated
windscreen. Fig. 20 shows the simulated PWM frequency. Again the steps are caused by the reduction
of the residual loads (as also explained in the previous section).

Effect of Engine Idle Speed Control

Since the second strategy makes use of engine idle
speed control to increase the generator output, it is
interesting to see the difference in the engine speed
for the three strategies. Fig. 19 shows this. Where
the engine speed remains 750 rpm with the conventional and the PWM controlled strategy, the engine
speed with the idle speed control strategy is increased to improve the generator output. The stepped
decrease of the engine speed can be explained by the
residual loads (cf. Section 5.4): 55A from 0-100s,
40A during 100-200s and 20A after 200s.

Fig. 20 Percentage of maximum load that the electric
heated windscreen is operated with (PWM)

7.4

Heating Performance and Fuel Economy

Other factors of interest are the time before the temperature of the outer surface of the heated screen has
reached 3°C and how many fuel is used until this
point is reached. Fig. 21 shows the temperature of
the outer surface. It can be clearly seen that there is a
significant difference between the three strategies:
the strategy with idle speed control is the fastest (total time is 290 seconds), followed by the conventional strategy (total time is 365 seconds) and the
PWM controlled strategy (total time is 507 seconds).

Fig. 19 The effect of engine idle speed control

7.3

Effect of PWM Control

As discussed in Section 6.3, adding a PWM switch
to the heated windscreen can be used to reduce the
load and therefore maintain powernet voltage stability. Dependent on the amount of power requested,

The Modelica Association

Fig. 21 Outer surface temperature of the electric heated
windscreen.

The cumulative fuel consumption during the heating
of the frontscreen is displayed in Fig. 22. The gradi-

317

Modelica 2005, March 7-8, 2005

E. Surewaard, M. Thele

ent for the idle speed control can be explained by the
fact that the fuel consumption at higher engine
speeds is larger (due to engine / transmission / generator losses). The total amount of fuel used is: 50
gram for the conventional strategy, 52 gram for idle
speed control and 69 gram for the PWM controlled
case.

Fig. 22 Cumulative fuel consumption during the heating
process

7.5

Summarized Results

The following table summurizes the results from the
previous subsections.
Table 1 Summarized results
Conv.

Idle
speed

PWM

Stable voltage? (yes/no)

NO

YES

YES

Time to reach 3°C [s]

365

290

590

Fuel used [g]

50

52

69

The idle speed control is evidently the preferred solution: no additional components are needed (as
PWM switches). By controlling the idle speed, the
voltage can be kept stable, the (time) performance of
the heated windscreen can be increased and that all
without paying a fuel penalty compared with the
conventional strategy.

Ploumen, Maurice Rienks and Thomas Gerhards are
thanked for their support and ideas.

References
1. Tiller, M., Bowles, P. and Dempsey, M., "Development of a Vehicle Model Architecture in
Modelica", ", Proceedings of the 3rd International
Modelica Conference, pp. 75-85, Linköpig Sweden, 2003
http://www.modelica.org/Conference2003/papers
/h32_vehicle_Tiller.pdf
2. Surewaard, E., Tiller, M. and Linzen, D., "A
Comparison of Different Methods for Battery and
Supercapacitor Modeling", SAE paper 2003-012290, 2003
3. Surewaard, E., Karden, E. and Tiller, M., "Advanced Electric Storage System Modeling in
Modelica", Proceedings of the 3rd International
Modelica Conference, pp. 95-102, Linköpig
Sweden, 2003
http://www.modelica.org/Conference2003/papers
/h11_Surewaard.pdf
4. Surewaard, E., Kok, D., and Tiller, M., "Engine
Cranking: Advanced Modeling and an Investigation of the Influence of the Initial Crank Angle
and Inertia", SAE paper 2004-01-1875, 2004
5. Thele, M., Buller, S., Sauer, D.U., De Doncker,
R.W. and Karden, E., "Hybrid Modeling of
Lead-Acid Batteries in Frequency and Time Domain", Journal of Power Sources, Article in Press,
2005
6. Bode, H., "Lead-acid Batteries", Wiley, 1977
7. Graf, A., "Power Semiconductors to Drive Energy Management", Second Aachener Elektroniksymposium, Institut fuer Kraftfahrwesen, Aachen,
2004
8. Rienks, M. and Kok, D., "Development and Implementation of Electrical Power Distribution
Management", Second Aachener Elektroniksymposium, Institut fuer Kraftfahrwesen, Aachen,
2004

Acknowledgements
The authors wish to thank Eckhard Karden, battery
expert of the Energy Management Group of Ford
Motor Company and Dirk Uwe Sauer of the RWTH
Aachen University for their great ideas in battery
modeling. Also Daniel Kok, Michael Tiller, Serve

The Modelica Association

318

Modelica 2005, March 7-8, 2005

Inversion of Vehicle Steering Dynamics with Modelica/Dymola

Inversion of Vehicle Steering Dynamics
with Modelica/Dymola
Tilman Bünte1 Akin Sahin2 Naim Bajcinca1
1 German Aerospace Center (DLR), Institute of Robotics and Mechatronics,
Oberpfaffenhofen, D-82230 Wessling, Germany
2 University of Siegen

Abstract

vehicle is obtained. With inverse simulation of vehicle
steering dynamics for a given desired trajectory and
velocity profile, the aim is computation of the steering
The task of steering a vehicle is an exercise which is
wheel angle input required from the driver.
usually considered hierarchically in terms of the two
subtasks path planning and path following. With the Reference trajectories may be defined in terms of the
driver in the loop some essential man dependent tasks curvature ρ as a function of the arc length λ. The refsuch as sensing, information processing, and motor erence trajectory of a double lane change maneuver is
function affect the steering quality. In case of sim- presented as an example. For tracking the reference
ulations, the same applies correspondingly for driver path with a lateral displacement τ, instead of Cartemodels. In this paper the aim is to investigate vehicle sian coordinates a trajectory based coordinate system
steering dynamics independent of any driver-related (λ, τ) is employed. In section 2, the representation of
properties. The path is therefore assumed given by a reference trajectories and the trajectory based coordireference trajectory together with a speed profile. The nate system are explained in detail. For developing and
steering angle which is necessary for exact or at least investigation of the concept of vehicle steering dynamapproximate path following is sought after. This al- ics inversion, two vehicle models are considered: the
lows for plausible comparative assessment of different common linear single track model and a detailed vehivehicle’s steering dynamics in terms of the demanded cle model from the Modelica vehicle dynamics library.
steering effort for a certain maneuver. On the other These models are introduced in section 3.
hand, this approach requires dynamic inversion of vehicle steering dynamics which represents the main fo- If some requirements like regularity and uniqueness
cus of this paper. Two vehicle models, the common of solutions hold, inverse models may be obtained in
single track model and a detailed model from the Mod- Modelica by simply providing equations for the outelica vehicle dynamics library are investigated. Since puts and removing an adequate number of equations
exact inversion of the detailed vehicle model turns out for the original inputs. The perfect inverse of the denot to be feasible, approximate inversion is accom- tailed vehicle model from the Modelica vehicle dyplished by means of a novel control structure called namics library (using rigid linkages for the suspeninverse disturbance observer. Simulations of a double sions) is easily achieved. However, it turns out that the
lane change maneuver are conducted for illustration. detailed vehicle model is non-minimum phase. ThereFinally, wavelet power spectra of the steering angle fore, the inverse vehicle model is unstable and can not
be simulated. To overcome this problem, as a trade-off
signal are used for steering effort assessment.
we use approximate inversion of models, such that the
resulting system is stable. For this purpose, a novel
high gain control scheme, the inverse disturbance ob1 Introduction
server [1] is utilized. The inverse disturbance observer combines exact inversion of a simplified model
In the usual way of simulating vehicle models, a driver as feedforward control and high-gain feedback for romodule provides inputs to the vehicle in terms of the bust tracking performance. Simulation results for a
steering wheel angle and gas/brake pedal position. As double lane change maneuver illustrate the effectivea result of this forward simulation, a trajectory of the ness of the applied approach in section 4.
The Modelica Association

319

Modelica 2005, March 7-8, 2005

T. Bünte, A. Sahin, N. Bajcinca

−3

2 Reference trajectories and coordinate system for path tracking
For inverse vehicle simulations investigated in this paper, the vehicle’s speed and a reference trajectory for
the vehicle’s position are given. The reference point
on the vehicle representing its position is assumed to
be located at the center of the front axle. With perfect inversion, this reference point exactly follows the
reference trajectory, otherwise the task is to make the
lateral displacement from the reference trajectory as
small as possible. Therefore, this problem is closely
related to the problem of path tracking for automatic
car steering.

2.1

For the mathematics involved with the path tracking problem, it is not expedient to describe the vehicle’s position with Cartesian coordinates. Therefore,
rather a trajectory based coordinate system (λ, τ) is
employed, see Fig. 2. It consists of the arc length λ
referring to the point (xre f (λ),yre f (λ)) on the reference
trajectory which is closest to the vehicle and the lateral
displacement τ, also referred to as tracking error. That
is, τ is the signed closest perpendicular distance to the
reference trajectory.

τ

λ

.

λ

λ

Figure 2: Vehicle position in trajectory based coordinates (λ,τ).

Reference trajectories

In this paper, the reference trajectory is defined in
Cartesian coordinates (xre f (λ), yre f (λ)) as a function
of the arc length λ. Any reasonable trajectory of a vehicle cruising at finite speed may be assumed continuous and at least twice differentiable. With ρ(λ) and
φ(λ) denoting the curvature and the track angle respectively, the following relations hold:



 
φ0
φ
ρ
d
0
 :=
 xre
 xre f  =  cos(φ) 
f
dλ
0
yre f
yre f
sin(φ)

yref(λ) [m]

ρ(λ) [1/m]

x 10
Steering dynamics of different vehicles may be com10
4
λ=90m
pared in terms of the steering inputs being necessary to
3
5
perform a specific maneuver. The objective is to estab2
0
λ=120m
lish a method which can be used to assess the steering
λ=60m
1
−5
dynamics of vehicles with specific modifications like
λ=30m
λ=150m
0
active steering control. Therefore, in section 5 the dou0
50
100
150
0
50
100
150
λ [m]
xref(λ) [m]
ble lane change steering inputs are compared for two
single track models with significantly different loadFigure 1: Curvature (left) and reference trajectory
ing. For analyzing the steering efforts of the two ve(right) for a double lane change.
hicles, wavelet transform is applied. Conclusions on
easiness or difficulty for a driver when driving these
cars can be drawn from wavelet power spectra.
2.2 Coordinate system for path tracking

A coordinate transformation between Cartesian coordinates (xveh , yveh ) and trajectory based coordinates
(λ, τ) needs to be accomplished. The unit vector
0 ]T is perpendicular to the reference trajec[−y0re f , xre
f
tory and is oriented to the left hand side of the trajectory. Hence, the distance between the position of the
vehicle and the reference trajectory may be written as




(1)

∆x
∆y




:=

xveh − xre f
yveh − yre f




=τ

−y0re f
0
xre
f


.

(2)

The coordinate transformation can be done in the following way: Elimination of τ in (2) yields the nonlinOur approach is to start from a definition of ρ(λ) and ear equation
solve (1) for φ, xre f , and yre f using appropriate initial
0
0
conditions. See Fig. 1 for an exemplary definition of
∆x xre
(3)
f + ∆y yre f = 0
ρ(λ) and the resulting reference trajectory (xre f , yre f )
for a double lane change maneuver.
which can be solved for λ.
The Modelica Association

320

Modelica 2005, March 7-8, 2005

Inversion of Vehicle Steering Dynamics with Modelica/Dymola

02 + y02 = 1 (see (1)) together with general, for inverse simulations executed in Dymola
Using the fact xre
f
re f
the given output where required needs to be differenti(2) yields
ated one or multiple times w.r.t. time. The look-up ta0
0
τ = ∆y xre
(4) bles we use, however, only provide derivatives w.r.t. λ
f − ∆x yre f .
since the reference trajectory does not depend on time.
Multiple solutions may exist for equation (3). Only Therefore, if needed the time derivatives are supplied
the closest solution where |τ| has its minimum value is by special functions1 . They are calculated from the acrelevant and is to be selected. This ambiguity makes tual value of λ̇ and the corresponding derivatives w.r.t.
evident that the introduced trajectory based coordinate λ. If necessary, higher derivatives w.r.t. λ are supplied
system is only suitable in a sufficiently narrow vicin- in extra columns in the look-up tables. As an example
ity of the reference trajectory. This assumption holds, the Modelica code
since accurate path tracking is aimed at.
dxdlambda = TableFunc.y(tableIDintx, 3,lambda);

Later, the coordinate transformation will be considered a part of the vehicle models. Linearization, as
may be necessary, is done in the following way. A virtual object exactly following the reference trajectory
as defined in section 2.1 senses a lateral acceleration
given by
ayre f = ρ(λ) λ̇

2

(5)

with λ̇ denoting the object’s speed. Under the assumption of small tracking error τ and small chassis side
slip angle the lateral acceleration of a vehicle closely
tracking the reference trajectory with speed v (entailing v ≈ λ̇) can therefore be represented by
ayveh = ayre f + τ̈.

(6)

Hence,
τ=

2.3

1
(ayveh − ayre f ) .
s2

(7)

Implementation in Modelica

During the simulation the actual value of λ needs to
be solved from equation (3) for each integration step.
This is automatically done by Dymola, provided that
0 (λ) and y0 (λ) are known. Therexre f (λ), yre f (λ), xre
re f
f
fore, in our Modelica model we provide look-up tables
depending on λ that contain values for xre f , yre f , and φ
each with the derivative w.r.t. λ. These look-up tables
are pre-calculated from (1) in Matlab, saved to matfiles, and used in Modelica/Dymola for interpolation
at simulation time. According to our experience, the
selection of the proper solution of (3) does not cause
any problems since the solution for λ is continuously
and monotonically increasing along the followed reference trajectory.

0 from the look-up table (referred
is used to retrieve xre
f
to by its identifier tableIDintx, 3rd column stores first
derivative) for the actual value of λ. This is the used
package:
package TableFunc
function y // here y means a generic output
input Integer ID, index;
input Real u;
output Real y;
external "C" y=
dymTableIpo1_my(ID,index,u);
annotation (derivative=ydot);
end y;
function ydot
input Integer ID,index;
input Real u,dudt;
output Real dydt;
protected
Real dydu;
algorithm
dydu :=
dymTableIpo_my(ID,index+1,u);
dydt := dydu*dudt;
annotation
(derivative(order=2)=yddot);
end ydot;
function yddot
... // analogous to ydot
end yddot;
function dymTableIpo_my
input Integer ID,index;
input Real u;
output Real y;
external "C" y=
dymTableIpo1_my(ID,index,u);
end dymTableIpo_my;
end TableFunc;

The C function dymTableIpo1 my provides the table
look up. It corresponds to dymTableIpo1 which can be
found in dymtable.c in the Dymola source directory.
Note the annotations. The standard way of differentiating inputs from look-up tables is thus replaced by
use of the function ydot (yddot respectively) while applying the chain rule.

1 The authors thank Andreas Pfeiffer (DLR) for his helpful supA special problem occurs with the simulation of perfectly inverted vehicle models (see section 4.1). In port.

The Modelica Association

321

Modelica 2005, March 7-8, 2005

T. Bünte, A. Sahin, N. Bajcinca

3 Vehicle Models

forces at the front and rear wheels can be written as

Vehicle steering dynamics in this paper are explored
using two models with essentially different levels of
detail. Firstly, for basic considerations the very simple single track model is implemented in Modelica.
Secondly, for more advanced investigations, a detailed
vehicle model from the Modelica vehicle dynamics library is used. In both cases, the trajectory which normally is the output of a driving maneuver is defined
together with a speed profile and the necessary steering input is asked for. Therefore, both the reference
trajectory and the coordinate transformation as defined
in section 2 are added to the model description.

3.1

The linear single track model

The single track model [2] is a simple linear vehicle
model commonly used in the analysis and control
design of lateral and yaw dynamics. The wheels
of the each axle are considered lumped together in
the center of the vehicle. The roll, pitch, and heave
motions are neglected. In Fig. 3 the single track
model is illustrated. Its major variables and geometric
Fr

v

CG

Ff

β

r
`f
`r
Figure 3: Single track model.
parameters are
Ff (Fr )
ψ
r = ψ̇
β
v
` f (`r )
iL
δf
δS = i L δ f

lateral wheel force at
front (rear) wheel
yaw angle
yaw rate
chassis side slip angle at
center of gravity (CG)
speed, i.e. magnitude of
velocity vector at CG
distance from front (rear)
axle to CG
steering gear ratio
front wheel steering angle
steering wheel angle

δf

Ff (α f ) = µc f 0 α f ,

Fr (αr ) = µcr0 αr

(8)

with c f 0 , cr0 being the tire cornering stiffnesses at the
front and the rear wheels, µ the road adhesion factor
and α f and αr the tire side slip angles at the front and
the rear wheels given by




`f
`r
α f = δ f − β + r , αr = − β − r
(9)
v
v
The mass of the vehicle is m and J is the moment
of inertia w.r.t. a vertical axis through the CG. Under
the assumptions of small side slip and steering angles
and slowly varying velocity the linearized equations of
motion are
 


Ff + Fr
mv(β̇ + r)
=
(10)
Ff ` f − Fr `r
J ṙ
The lateral acceleration of the vehicle at the front axle
is
ayveh = v(β̇ + r) + ṙ ` f .

(11)

For linear considerations, (7) may be used for the lateral position w.r.t. the trajectory based coordinate system. Otherwise, the velocity of the vehicle’s CG is




ẋCG
cos (ψ + β)
=v
(12)
ẏCG
sin (ψ + β)
The front axle (i.e. vehicle reference point) position is

 



xveh
xCG
cos(ψ)
=
+`f
(13)
yveh
yCG
sin(ψ)
The single track model will be used later as a simple
substitute for the fully detailed standard vehicle dynamics model from the Modelica vehicle dynamics library [3] (which is parametrized as a BMW 3-series
car by default). The corresponding parameters for the
single track model were determined in [4] and they are
also used here: iL = 16.94, l f =1.0203m, lr =1.5297m,
m = 1482.9kg, J = 2200kg m2 , c f 0 = 91776 N/rad and
cr0 = 77576 N/rad. Only dry road conditions are considered here, therefore µ = 1.

3.2

Detailed vehicle model

The vehicle dynamics library [3] of Modelica provides
Linearizing the tire force characteristics lateral wheel models for vehicle dynamics simulation. It consists of
The Modelica Association

322

Modelica 2005, March 7-8, 2005

Inversion of Vehicle Steering Dynamics with Modelica/Dymola

a detailed mathematical model comprising the multibody differential equations. Since this library is freely
available, documented and well known to the Modelica user community, no further details are stated here.
In this paper the Modelica vehicle model described
in [4] is used. The standard chassis level 2 vehicle
model is completed by the simple power train model
and brakes. Furthermore, a PI speed controller sets an
adequate gas/brake pedal position and makes the vehicle accurately follow a desired speed profile. Finally,
a wheel slip controller approximates the function of
an antilock braking system (ABS). In the sequel, this
model will be referred to as the detailed vehicle model.

4 Perfect and approximate inversion
of vehicle steering dynamics
The vehicle models used in this paper (see section 3)
are considered as SISO (single input single output)
systems with the steering wheel angle δS being the input and the lateral displacement τ from the reference
trajectory being the output. The ideal conception of
the model inversion process (referred to as perfect inversion) is to obtain a steering wheel angle signal such
that the lateral displacement τ is always zero. Simulations executed with perfectly inverted models are denoted inverse simulations here. Inversion of the longitudinal dynamics (i.e. speed) may in general be considered as well. Here, however, we focus on steering (i.e.
lateral) dynamics. Along the way, the vehicle speed
v is set or controlled to match a given profile v(λ) or
alternatively v(t). Hence, speed is rather considered a
set varying parameter than an input or output. If perfect steering dynamics inversion is not possible, approximate inversion is aimed at. That is, the resulting
lateral displacement τ and steering wheel angle error
respectively should be as small as possible.
For both models, single track model and detailed
model, we first try to achieve perfect inversion. As will
be shown, this is possible for the single track model. In
contrast, perfect inversion of the detailed model turns
out not to be feasible in terms of a converging simulation. Therefore, a novel high gain control scheme
is applied to approximately invert the detailed model.
This approach may incidentally also be applied to the
task of high fidelity path tracking for real world automatic car steering.

tration. Exemplarily, the double lane change maneuver
introduced with Fig. 1 is considered with a constant
speed of 20m/s .

4.1

Perfect inversion of the vehicle models in
Modelica/Dymola

The option of perfect inversion of Modelica models
has already been exploited in a number of applications
such as automatic generation of control laws for the
control of aircraft [5] or industrial robots [6]. Inverse
models may be obtained in Modelica by simply providing equations for the outputs and relaxing an adequate number of equations for the original inputs. As
pointed out in [6], the derivation of the inverse system
equations may require to differentiate certain parts of
the model equations. Therefore, the model equations
need to be continuous and differentiable. Moreover,
since it may be necessary to the differentiate the given
output signals too, their time derivatives must exist and
be provided up to a certain order. Therefore, as explained in section 2.3, look-up tables for the trajectory
variables and their derivatives w.r.t. λ are provided in
the models together with functions to form the respective time derivatives.
With nonlinear models, for a given output not necessarily any solution in terms of input functions does exist. On the other hand, multiple solutions may exist
for the same inverse simulation problem. So far, we
have not worked on these questions. We have rather
assumed conditions (i.e. moderate lateral acceleration)
which do not cause corresponding problems.
One necessary condition for perfect inversion is that
the considered input/output dynamics of the model is
minimum phase. Otherwise the inverted model is not
stable and therefore inverse simulation is not feasible.

4.1.1

Perfect inversion of the single track model

For investigating the perfect inversion of the single
track model, the implementation of its equations and
its parameters in Modelica as described in section 3.1
is employed. The model includes the reference trajectory look-up tables for the double lane change maneuver and the coordinate transformation (3),(4) introduced in section 2. The set of equations is completed
In the course of this section, simulations of the in- by τ = 0 and v = 20m/s and thus the number of equaverted models are conducted for the purpose of illus- tions matches the number of unknowns. The model

The Modelica Association

323

Modelica 2005, March 7-8, 2005

T. Bünte, A. Sahin, N. Bajcinca

sation about straight driving (x(λ) = λ, y(λ) = 0, δS =
0, r = 0, ψ = 0, τ = 0, λ̇ = v = 20m/s). The pole-zero
map reveals a fast zero at s ≈ 90 in the right half plane.
The corresponding non-minimum phase behavior can
be explained by the suspension construction of the
steered front axle. It can briefly be depicted imagining an idle vehicle at zero speed. If the steering wheel
is turned then the front end of the car moves slightly
to the opposite direction due to the suspension’s caster
characteristic. In normal drive operation, this effect
superimposes with the remaining vehicle steering dynamics and results in non-minimum phase behavior.
When inverting the model, the right half plane zero befrag replacements
comes a fast unstable pole which makes simulation of
the perfectly inverted model impossible. Therefore, in
t [s]
the next section a stable approximately inverted model
Figure 4: Front steering angle δ f for the double lane will be generated using accurate path tracking control.
change maneuver (v = 20m/s) obtained by inverse sim- For this purpose, a novel control structure denoted inulation of the single track model. Two parameter sets verse disturbance observer is employed.
are used: light vehicle and heavy vehicle. Also results
for the approximately inverted detailed vehicle model 4.2 Approximate inversion of the detailed ve(see section 4.2.2) are shown.
can be successfully translated and simulated. The resulting front steering angle δ f is shown in Fig. 4. The
parameters of the light vehicle are those given in section 3.1. For comparison, the simulation is repeated
with a heavy vehicle. Its parameters are the same except for double values of mass m and inertia J.
Light vehicle

0.05

Heavy vehicle

0.04

Detailed vehicle model

δ f [rad]

0.03
0.02
0.01

0

−0.01
−0.02
−0.03
−0.04
−0.05

0

1

2

3

4

5

6

7

8

9

10

hicle model

PSfrag replacements
4.2.1 Inverse disturbance observer
4.1.2 Perfect inversion of the detailed vehicle
The inverse disturbance observer (IDOB) was recently
model
introduced in [1] as a modification of the common disThe detailed vehicle model is inverted in the same way turbance observer (DOB) structure. Basically, both
by adding the equation τ = 0 and by setting the target
d
value for speed control to 20m/s. The steering wheel
u
y
uyin
n
G
angle is relaxed, i.e. any direct equation for driver
steering input is removed.
Q
PSfrag replacements
We attempted to invert models with different suspenn
G̃−1
N
yr
sions. With the SimpleSuspension the translation of
−
the model was successful. However, the integration
Figure 5: DOB scheme.
in Dymola terminated 0.13s after start of the simulation due to missing convergence of the corrector. With
the MacPhersonSuspension2 Dymola was not able to
yr
yn
u
G−1
N
differentiate some of the model equations, therefore,
this inverse model could not be translated successfully.
Q
The last-mentioned problem was not investigated fury
ther since we found out, that the detailed vehicle model
G
− n d
is non-minimum phase which causes stability problems at any rate when simulating its inverse. This is
Figure 6: IDOB scheme.
also the reason why the inverse simulation using SimpleSuspension did not converge.
DOB (see Fig. 5) and IDOB (see Fig. 6) are two degree
For illustration of the non-minimum phase dynamics, of freedom control structures that combine high-gain
the pole-zero-map of the transfer function from steer- and exact model inversion facilities in a simple configing wheel angle δS to lateral displacement τ was inves- uration. The design parameters are an invertible nomtigated. The transfer function was obtained by lineari- inal model GN (G̃N respectively) approximating the
The Modelica Association

324

Modelica 2005, March 7-8, 2005

Inversion of Vehicle Steering Dynamics with Modelica/Dymola

plant dynamics G (which is assumed to be stable) and a
Q-filter which commonly has unity gain and low-pass
properties. Compared with DOB, in the IDOB structure the block positions of the plant G and the nominal
model GN are simply interchanged (which partly gives
a different meaning to the involved signals). Therefore, with IDOB the inverted nominal model G−1
N is in
the feedforward part instead of the feedback as it is the
case with DOB.

perfect model inversion u = G−1 yr one of the following two criteria would be sufficient:
Q → 1 or GN → G

(15)

The IDOB structure combines the facilities of both
high gain (subordinate loop with Q → 1) and inversion
with feedforward control GN → G in the same structure. Also it is important to notice that with the IDOB
structure, the approximate inverse of the model G is
DOB and IDOB structures are used for different pur- obtained without inverting the model explicitly.
poses. The aim of the traditional DOB is matching the
On the other hand, considering y as the output of the
dynamics of the controlled system to a nominal model
system, IDOB becomes a plant controller for output
GN . However, in case of IDOB the aim is matching the
tracking:
closed loop dynamics to G−1 . Therefore, the IDOB
control structure is especially applicable for dynamic
G
y
=
(16)
model inversion (in this case G represents the model to
yr
GN (1 − Q) + G Q
be inverted) and output tracking problems (in this case
In the frequency operating domain, Q → 1 holds and
G represents a plant).
therefore, y → yr i.e. good output tracking is achieved.
IDOB combines the facilities of feedforward control
using an inverted nominal model of the plant and high Due to its similar structure, the IDOB holds the known
gain feedback in a very simple structure while pre- robustness properties of the disturbance observer in
serving the advantages of each principle. In the IDOB terms of disturbance and measurement noise rejection.
Hence, the sensitivity (S) and complementary sensitivstructure G−1
N acts as a feedforward control. The term
−1
GN (s) · yr (s) provides the main portion of the plant ity (T ) functions are the same as with DOB:
input u(s) where yr is the setpoint for y. The suborGN (1 − Q)
y
dinate positive gain feedback loop containing the Q(17)
S= =
d GN (1 − Q) + G Q
filter forces this approximate inversion signal to converge to the perfect inversion signal and also provides
y
GQ
robustness to the inversion process due to its high gain
T=
= 1−S =
(18)
feedback feature.
−n
GN (1 − Q) + G Q
The IDOB structure serves as an approximate model Within the IDOB frequency operating domain (Q →
inversion method for a model G if the relation between 1), disturbances are attenuated (S → 0). For high frethe signal yr and the plant input u is considered:
quencies (Q → 0), noise is attenuated (T → 0).
u
1
=
yr
GN (1 − Q) + G Q

(14)
4.2.2

Recall that Q is a low pass filter with unity gain. The
frequency interval between zero and the bandwidth
of Q is denoted the frequency operating domain of
the IDOB. In the frequency operating domain, Q → 1
holds and therefore, u → G−1 yr . At high frequencies,
the gain of Q tends to zero, therefore u → G−1
N yr which
at least provides the input signal based on the model
GN . In the case that G is non-minimum phase and
GN is a minimum phase approximation for G, then by
proper choice of the bandwidth of Q the stability of the
IDOB system can be ensured. In practice, the bandwidth of Q will be chosen according to a compromise
between (robust) stability and (robust) performance.

Application of IDOB for approximate inversion of the detailed vehicle model

As was shown in the last section, the IDOB needs a
nominal model GN . For approximate inversion of the
detailed vehicle model by means of IDOB, the single
track model is adopted as nominal model. It is easily invertible as already demonstrated in section 4.1.1.
The actual single track model parameters (see section
3.1) were determined for good approximation of the
detailed vehicle model [4].

However, the IDOB may not directly be applied to
approximately invert the whole vehicle model since
IDOB requires a stable plant but the vehicle dynamIt can be concluded from (14) that for approximating ics with steering wheel angle δS as input and lateral
The Modelica Association

325

Modelica 2005, March 7-8, 2005

PSfrag replacements

T. Bünte, A. Sahin, N. Bajcinca

a

yref

a

3

yveh

2

δ

1
2

−

a [m/s ]

blabla

τ

4

λ

ρ λ ⋅ λ&

0

y

τ

−1
−2
−3
−4

0

20

40

60

80

100
t [s]

120

140

160

180

200

Figure 8: Lateral acceleration control
with IDOB.

Figure 7: Path tracking control with IDOB.

displacement τ as output involves two integrators, see
(7). Based on (5)-(7), for approximate inversion of the
whole detailed vehicle model we adopt a hierarchical
control structure according to Fig. 7:
ays = ayre f − (Kd s + K p ) τ
ayveh = GIDOB · ays

ayre f by virtue of the proposed IDOB based control.
Remarkably, in this simulation the absolute value of
the lateral displacement τ is less than 1.5mm (not depicted here). The steering wheel angle obtained is
shown in Fig. 4 and can be well compared to the light
(19) vehicle single track model.
(20)

A subordinate high bandwidth IDOB is used to make
ayveh → ays . The Q-Filter is chosen a first order lowpass filter with a 0.03s time constant. An outer PD
control loop with lower bandwidth compensates for
the remaining tracking error τ. In the IDOB structure,
henceforth only the stable part of the vehicle dynamics with output ayveh is considered. ay,s is the set point
for the inner IDOB loop and GST M represents the single track model adopted as nominal model which corresponds to eqns. (8)-(11) . Note that the speed parameter of G−1
ST M is scheduled with the actual speed of
the detailed vehicle model. δS is the steering wheel
angle signal which is in the focus of interest. The
reference lateral acceleration ayre f may be considered
as a known external disturbance. Therefore disturbance feedforward compensation is applied according
to Fig. 7. The resulting transfer function to τ is

5 Comparative assessment of the
steering dynamics using model inversion
In order to track a given trajectory with a given velocity profile, different vehicles potentially need different steering efforts. Therefore, using the inverse simulation results, steering dynamics of different vehicles
may be compared in terms of the required steering efforts.

Assuming that the bandwidth of the IDOB transfer
function is sufficiently high (GIDOB → 1), the bandwidth and damping of the outer PD control loop may
directly be affected by the PD parameters which are
chosen as Kd = 12, K p = 36.

To illustrate our approach, the light vehicle and the
heavy vehicle from section 4.1.1 are compared. The
steering angles of these two models necessary to perform the double lane change maneuver with a constant
speed of 20 m/s were given in Fig. 4. As it may be
seen in this figure, the magnitude of the heavy vehicle
steering angle is larger than that of the light vehicle
during the maneuver. Moreover, especially in the time
interval ca. [3s, 6s] it is recognizable that the heavy vehicle needs to be steered slightly earlier than the light
vehicle to follow the reference trajectory. That is, the
look-ahead-time the driver needs to drive the heavy vehicle is larger compared to the light vehicle.

Fig. 8 shows a simulation result of the approximately
inverted detailed vehicle model performing the double lane change maneuver. The results are presented
in terms of the actual vehicle lateral acceleration ayveh
which well tracks the reference lateral acceleration

In the remainder of this section a method is established
to quantify the conclusions mentioned above on the
magnitude and look-ahead-time. Wavelets are used for
appropriate time-frequency analysis of the steering angle signals.

τ
ayre f

=

GIDOB − 1
.
IDOB (Kd s + K p )

s2 + G

The Modelica Association

(21)

326

Modelica 2005, March 7-8, 2005

WPS

WPS
0.02

0.02

0.015

0.015

0.01

0.01

0.005

0.005

PSfrag replacements

0
70

0
70

60

60
50

50
8

40

Scale

Scale

4

20
2

10
0

6

30
4

20

Time [s]

2

10

Time [s]

0

Figure 9: Wavelet power spectrum of the light
vehicle steering angle using Morlet wavelet function.

5.1

8

40

6

30

Figure 10: Wavelet power spectrum of the heavy
vehicle steering angle with Morlet wavelet function.

Wavelet transform

5.1.1

Time-frequency analyses map the time domain signals into a two dimensional representation of energy
versus time and frequency. Wavelet transform is a
time-frequency analysis method that breaks a signal
down into its constituent parts, wavelets, for analysis. Wavelets are oscillatory, scalable functions which
are non-zero only within a limited spatial and Fourier
regime. In the continuous wavelet transform, which is
used in this paper, a wavelet is translated (time-shifted)
through the signal. At each instant (i.e. time grid point)
it is compared with the signal by means of evaluating
the time integral of their product. This procedure is repeated for a grid of wavelets with different time scales.
As a result, coefficients representing the similarity between sections of the signal and the scaled wavelet
are produced. More detailed information on wavelets
and wavelet transform may be found in [7], [8]. The
wavelet transform returns a time-scale representation
of the signal instead of the time-frequency representation. The scale is proportional to the reciprocal of the
frequency. Large scales correspond to small frequencies and vice versa.

Wavelet transform of the steering angle signals

One of the basic problems in wavelet transform is
choosing the appropriate wavelet function for the analysis of a given signal. In the wavelet transform of the
steering signals, Morlet wavelet function is used, since
it is recommended [9] for the analysis of time signals
with smooth variations. In Figures 9 and 10 wavelet
power spectra (WPS) of the steering angles of the light
and heavy vehicles are given, respectively.
The two WPS are quite similar in terms of the scale
and time locations of the local maxima, i.e. both signals have similar frequency contents at corresponding
70

60

50

Scale

acements

Inversion of Vehicle Steering Dynamics with Modelica/Dymola

40

30

20

replacements
The single track model steering anglePSfrag
signals
from
Fig. 4 are now compared in terms of wavelet power
spectra. At every instant, the time-scaled wavelet that
locally best matches with the steering signal yields the
Time [s]
maximum wavelet power spectrum value. Therefore,
the local frequency content of the signal can be esti- Figure 11: Wavelet power spectrum of the light vehicle
mated from the scale value at which a local maximum steering angle (black lines) and eavy vehicle steering
angle (gray lines) with Morlet wavelet function.
occurs.
10

0

The Modelica Association

327

1

2

3

4

5

6

7

8

9

Modelica 2005, March 7-8, 2005

T. Bünte, A. Sahin, N. Bajcinca

instants. However, almost throughout the entire timescale domain, WPS of the heavy vehicle steering angle
has higher power values compared to the light vehicle.
This shows that the heavy vehicle needs more steering amplitude compared to the light vehicle all along
the maneuver. This result coincides with the previous
observation in the time-domain.
In Fig. 11 both WPS’s are drawn in the same 2-D
plot to make the differences between them better visible. The time of the local maxima can be more easily
detected in Fig. 11. The power contour lines of the
heavy vehicle steering angle are shifted to earlier instants by about 0.14s-0.18s compared to the light vehicle. This shows that the look-ahead-time needed to
steer the heavy vehicle is correspondingly larger than
for the light vehicle.

Acknowledgment
The authors are grateful to Professor Wolfgang
Wiechert from the University of Siegen Department of
Simulation for academic supervision of the work [10]
resumed in this paper.

References

Using continuous wavelet transform with the Morlet
wavelet function we are thus able to quantify the conclusions we already made from the time-domain plot
of the steering angles. Another aspect in the comparison of the steering efforts is the frequency content of
the signals. In Fig. 11 it may be noticed that there
are mainly two accumulations of local maximum scale
values which are at scale values 14 and 35. The scale
values 14 and 35 corresponds 0.58 Hz and 0.23 Hz
respectively which are frequencies that prevail in the
signals. From Figs. (9, 10 it may be noticed that the
steering angle of the heavy vehicle contains relatively
higher power values at scale 14.

[1] N. Bajcinca and T. Bünte, “A novel control structure for dynamic inversion and tracking,” Accepted for IFAC World Congress, 2005.
[2] P. Riekert and T. Schunck, “Zur Fahrmechanik
des gummibereiften Kraftfahrzeugs,” Ingenieur
Archiv, vol. 11, pp. 210–224, 1940.
[3] J. Andreasson, “Vehicle dynamics library,” Proceedings of the 3rd International Modelica Conference, pp. 11–18, 2003.
[4] S. Heller and T. Bünte, “Modelica vehicle dynamics library: Implementation of driving maneuvers and a controller for active car steering,”
in Proc. 3rd International Modelica Conference,
(Linköping, Sweden), 2003.
[5] G. Looye, “Design of robust autopilot control
laws with nonlinear dynamics inversion,” Automatisierungtechnik, pp. 523–531, 2001.

In other words, the heavy vehicle has to be steered
with higher amplitudes, with a relatively larger portion
of high frequencies and earlier (i.e. with more lookahead-time) than the light vehicle. Hence, we conclude that the heavy vehicle is more difficult to drive.

[6] M. Thümmel, M. Otter, and J. Bals, “Control
of robots with elastic joints based on automatic
generation of inverse dynamics models,” Proc. of
2001 IEEE/RSJ International Conference on Intelligent Robots and Systems, pp. 925–930, 2001.

6 Conclusions

[7] R.
Polikar,
The
wavelet
tutorial.
http://engineering.rowan.edu/∼polikar/WAVELETS/WTtutorial.html.

[8] S. Qian and D. Chen, Joint Time-Frequency
Exact inversion of simulation models in principle is
Analysis, Methods and Applications. Upper Sadsupported by Modelica/Dymola. However, it may be
dle River, NJ USA: Prentice-Hall, Inc., 1996.
the case that models do not comply with the requirements to make inversion feasible. If so, approximate [9] M. O. Domingues, “On wavelet techniques in atmospheric sciences,” First Latin American Adinversion may be an expedient way to still achieve usevanced School on Space Environment, 2004.
ful results. High fidelity path tracking was demonstrated by means of the inverse disturbance observer [10] A. Sahin, Inversion of vehicle dynamics with
based control. This provides a pretty accurate approxModelica. University of Siegen, 2005. M.Sc.
imation of the steering angle signal which would rethesis.
sult in perfect tracking. The time-scale wavelet power
spectrum of the steering angle signal is an adequate
basis for assessment of the steering effort.
The Modelica Association

328

Modelica 2005, March 7-8, 2005

Session 4b
Thermodynamic Systems III

The Modelica Association

329

Modelica 2005, March 7-8, 2005

The Modelica Association

330

Modelica 2005, March 7-8, 2005

Analysis of thermal storage systems using Modelica

Analysis of thermal storage systems using Modelica
Wolf-Dieter Steinmann
Jochen Buschle
German Aerospace Center
Institute of Technical Thermodynamics
Pfaffenwaldring 38-40, 70569 Stuttgart

Abstract
Modelica is used for the analysis of different kinds
of thermal storage system for applications in power
plants and process industry. The analysis includes
concepts using sensible heat storage media, latent
heat systems and steam accumulators. The temperature range for these systems is between 200°C –
400°C, the maximum thermal power is 100MW. For
the various storage systems physical models are implemented in Modelica. Modelica is also used for
system analysis simulating the interaction of the
storage unit with the other components. The results
of this system analysis help to improve the efficiency
y of storage systems significantly.
Keywords:thermal energy storage; solar power
plant; steam accumulator

1

2
2.1

Storage systems for solar thermal
power plants
Storage systems using sensible heat

Solarthermal power plants use concentrated solar
insolation to drive a thermodynamic power cycle [1].
Today’s commercial systems use trough shaped mirrors to heat a synthetic oil flowing in absorber pipes
located in the focus line (Figure 1). At temperature
up to 390°C the heat transported by the oil is used to
generate steam to drive a turbine. The total electric
capacity of these parabolic trough power plants operated in California is 350MW, by continuous optimisation the costs for electricity have been reduced
to 0,14US$/kWh, so parabolic trough power plants
are the most economic system for large scale generation of electricity from solar energy.

Introduction

Thermal energy storage systems are a promising option for improving the efficiency of power plants and
process heat utilization in industry. These systems
represent an additional tool for energy management
in thermal processes by bridging the gap between
demand and availability of energy. At the present
time the range of proven storage systems for providing thermal energy at temperatures exceeding 100°C
is limited. Various solutions have been proposed, the
selection of a concept strongly depends on the characteristics of the process. The aim of current research
project is to develop storage systems for commercial
applications. For three different basic storage concepts Modelica is used to identify the interaction of
the storage unit with the other components of the
systems. Using models from the library TechThermo
Modelica proves to be an effective tool for the analysis of the dynamics of energy storage systems.

The Modelica Association

Figure 1: Parabolic trough collectors at solar test
center near Almeria, Spain.
In recent years significant research activities have
been initiated in Europe to improve the parabolic
trough technology to promote a market introduction
in areas like the Mediterranean region. Important
components for increasing the efficiency of these
solarthermal systems are systems for the storage of
thermal energy. These storage systems help to reduce
the dependence on the course of solar insolation.

331

Modelica 2005, March 7-8, 2005

W. Steinmann, J. Buschle

Thermal Storage System

Solar Field

Thermal Oil Cycle

plant. More than 90% from the lines forming the
source code the complete model were taken from
TechThermo; the additional modelling mostly defines characteristics of the charge/discharge process.
Figure 3 shows the first model level representing the
complete power plant with the three main components and a control unit that defines the mass flows
in the system. The focus of the analysis lies on the
storage model. Due to economic aspects low cost
materials like concrete are used as storage mass.
Since these candidate materials usually exhibit low
values for heat conductivity the temperature of the
storage mass is not homogenous.

Power Block

G

G

Figure 2: Schematic of parabolic trough power plant
with integrated storage unit
One storage concept is based on sensible heat storage
in solid media [2]. A tubular heat exchanger is integrated into the storage volume. During the charge
process, hot oil from the solar collectors is used to
heat up the storage mass; during the discharge cycle
cold oil enters the storage unit and is heated up.
Modelica is used for the simulation of the storage
unit [3]. The results provide the basis for the design
of a storage test facility and are applied for the development of operation strategies. This proves to be
an ideal application of Modelica since
−

−

−

−

−

the system combines a detailed physical
model (spatial discretized storage unit)
with less detailed models for the power
cycle and the solar collectors
Modelica allows continuous and discrete event modelling which is necessary for the analysis of the transition
from charging to discharging
the characteristic duration of a
charge/discharge cycle is in the range of
24 hours; the computing time needed by
Modelica is less than 0.1% of the simulated time interval.
the analysis requires modifications of
the structure of the power plant. The
graphical interface of Modelica allows a
quick variation of the number and interaction of components.
although the storage unit represents a
non-conventional component, it can be
modelled by combination of well
known fundamental physical processes;
the extent of required additional modelling is small

TechThermo was used for the modelling of the storage unit integrated in the parabolic trough power

The Modelica Association

System level

ThermalStorage

SolarCollector

PowerBlock

Control
Unit

Figure 3: Main components of the Modelica model
of parabolic trough power plant with integrated
storage unit
Figure 4 shows the model of the storage unit: the
system is assumed to be composed of parallel tubes
surrounded by storage material, the radial temperature distribution and the flow field inside the tube
should be identical for all tubes at the same axial
position. Since characteristic lengths of the storage
unit are in the range of about 500m the assumption
of a radially symmetric temperature distribution
around the tubes is necessary to avoid a significant
increase in computing time resulting from a three
dimensional calculation of the temperature inside the
storage mass. The errors resulting from this assumption seem to be acceptable. The storage tube is discretized in axial direction. Modelica offers the declaration of arrays of components which are interconnected, spatial discretization is done by connecting
models for a storage segment of length dz in series.
The number of elements depends on the length of the
storage unit and varies between 50 and 100. The
build up of the model of the storage segment is
shown. The model is composed of a model for the
fluid volume, the tube and the surrounding storage

332

Modelica 2005, March 7-8, 2005

Analysis of thermal storage systems using Modelica

material, heat is transferred between these three
models in radial direction. There is also a heat and
mass flow in axial direction to the neighbouring
segments. The model for the surrounding storage
material includes a spatial discretization in radial
direction to account for the limited thermal heat conductivity of the storage mass.

390
∆r = 0.01m

385

Temperature [°C]

380
375
370

∆r = 0.0275m

∆r = 0.045m

365
∆r = 0.08m

360
355

L

350
0

∆r = 0.0625m

2000

4000

6000

8000

10000

da

Time [s]

Figure 6: Example for results of storage simulation:
temperature of storage material at various radial
positions

da
di

The energy provided by the storage unit during discharge is used to generate electricity, so the analysis
has to consider the transformation of heat into mechanical work by the Rankine cycle. The Rankine
cycle demands heat at different temperature levels,
the temperature of the oil flowing back to the storage
unit is also dependent on the temperature of the oil at
the exit of the storage unit. Modelica was used for
the simulation of the complete power plant including
storage and solar collectors. Figure7 shows the electric energy provided during the discharge process for
different configurations of the storage unit. The total
storage mass remains constant. The Modelica results
show that an optimised operation strategy can lead to
an increase of storage capacity of about 200%. This
improvement is achieved by an adjustment of the
storage unit to the specific requirements of solar collectors and the power cycle [3].

da

Figure 4: Physical storage model composed of parallel tubes discretized in axial direction

Segment level
Segment n-1
Storage Material

Segment n
Storage Material

da

dz

da

dz

da

dz

Segment n+1
Storage Material

Tube

Tube

Tube

Oil

Volume

Oil

Volume

Oil

Volume

Figure5: Cut-out of the model of a single pipe of the
storage system discretized in axial direction by serial connection of models for a pipe segment

240

modular charging + discharging

220
200

Electric Power [MW]

Figure.5 shows the internal build up of the model for
the fluid volume: the model is composed of a component including the conservation laws for mass and
energy, two models calculating friction pressure loss
and a model for the convective heat transfer between
fluid and tube wall. These components are completed
by a property model providing the correlations between the thermal state variables.

180
160
140

modular charging
120

modular discharging
100
80

The storage model was used to identify the influence
of material and geometry parameters and provide the
basis for an economic optimisation. Figure 6 is an
exemplary diagram for the time course of temperature at various radial positions in the storage material. The simulated time interval includes a charge
cycle, a break and a discharge cycle.

The Modelica Association

60
40
0

basic configuration
500

1000

1500

Time [s]

2000

2500

3000

Figure7: Example for system simulation: electric
power provided by the power plant during the discharge process.

333

Modelica 2005, March 7-8, 2005

W. Steinmann, J. Buschle

The identification of this option to reduce the investment costs for the storage unit was mainly possible due to the simulation results.

2.2

Storage systems using latent heat storage
media

atmospheric conditions at temperatures exceeding
100°C. In order to extend the application range of
water based thermal storage system, water was
stored in pressurized vessels to increase the saturation temperature. These storage systems are called
steam accumulators since usually they are intended
for supplying saturated steam [5].
Discharge pipe

Solarthermal power plants using thermal oil as heat
transfer medium in parabolic trough absorber pipes
have been optimized in recent years, a further progress demands the modification of the basic principle. The direct steam generation (DSG) in the absorber-pipes improves the efficiency of the parabolic
trough technology by eliminating the synthetic oil
and the heat exchanger and increasing the maximum
process temperature [4]. The estimated reduction in
electricity generation costs is in the range of 25%.
In DSG systems more than 50% of the thermal energy is needed for the evaporation process which
takes places at nearly constant temperature. Regarding second law efficiency, a DSG system must be
able to store and release thermal energy at nearly
constant temperature, sensible storage systems can’t
be used. Instead, the utilization of latent heat from
the melting / solidification process seems a promising concept for constant temperature storage systems.
First concepts for latent heat storage systems a similar to the sensible heat storage systems using concrete: a heat exchanger is embedded in the storage
material (phase change material - PCM). Instead of
the thermal oil, steam flows in the heat exchanger.
Modelica is also used for the initial analysis of the
PCM –storage system. The first model is a modified
version of the model for sensible heat storage: the
concrete storage material is replaced by the model
for the PCM storage material, the thermal oil in the
pipe volume is replaced by a steam flow. Due to the
reuse of already existing models, the development
time for the first model of the PCM storage model
could be reduced significantly.

3

Steam accumulator systems

Due to its high volumetric heat capacity and low
mass specific costs water represents an ideal storage
medium. Unfortunately, it can’t be applied under

The Modelica Association

Savety valve

Water level
gauge

Charging pipe

Charging nozzle
Feed pipe

Circulation pipe

Drain

Figure 8: Cross section steam accumulator
Figure8 shows the cross-section of a steam accumulator. Most of the volume is filled by the liquid phase
that is covered by the saturated steam phase at the
top of the vessel.
Both phases are in thermodynamic equilibrium. If
the steam is discharged directly from the accumulator, steam is produced by evaporation from the boiling liquid part. The latent heat of evaporation is cooling down the content of the storage vessel. This leads
to a new thermodynamic equilibrium and accordingly to a lower pressure. To charge the accumulator
steam is brought into intimate contact with the water
content, in order to distribute the heat, released from
the condensing steam, uniformly throughout the liquid.
The main parts of a steam storage installation are:
- Storage vessel for holding the storage medium
- Devices for charging and discharging the
steam
- Accessories for carrying out the storage operation
- Regulators for the automatic control of the
storage installation
Storage Vessels
The production costs of the vessel are the most important item in the total cost. For this reason the design of the storage vessel is central to the layout of
the installation as a whole. The best shape provides

334

Modelica 2005, March 7-8, 2005

Analysis of thermal storage systems using Modelica

minimum weight, is simplest to produce and takes up
the least floor space. From considerations of strength
the storage vessels are best made circular in crosssection, i. e. their basic shape is that of a cylinder.
The ends are elliptic or hemispherical in shape. In
practice an average length-to-diameter ratio of 4 has
been found to be the best.
3.1

Charging and Discharging Devices

Indirect steam accumulators use a liquid as the storage medium, so that the steam must be condensed to
be stored. This can be achieved by blowing it into
the liquid contained in the accumulator. The incoming steam bubbles condense in the liquid or pass into
the steam space, depending on the thermodynamic
equilibrium in the vessel. The bubbles which rise to
the steam space increase the pressure and lead to a
higher saturation temperature, so that the next bubble
might condense. To use the entire storage content,
the charging process requires circulation. Ruth invented a method that consists of nozzles which turn
the flow of steam upwards. The nozzles are surrounded by a circulation pipe, wherein the water
flows upwards. The minimum temperature loss is
composed of the difference between the steam space
and the uppermost liquid layer and the difference
between the saturation temperatures due to the additional pressure of the water at lower depths. Depending on the accumulator pressure and the steam intake
there is a certain depth for the nozzles which minimizes the overall temperature loss. To avoid introducing charging steam into the storage vessel itself
an external condenser and evaporator can be used.
3.2
Accessories
All storage installations require efficient thermal insulation to reduce cooling losses to an economic
level. The fittings on the pressure vessel itself are the
safety valve, the anti-vacuum valve and the blowdown valve. The thermal expansion of the vessel can
be considerable in all directions and simultaneous
adjustment must be provided in the piping by smooth
or curved pipe bends or by bellow-type compensators. Measuring instruments for indicating the charging state in the accumulator are of special importance.
3.3
Regulators
To maintain a certain state in the accumulator or in
the piping system regulation by valves is required.
The regulator can be acting as a reducing valve,

The Modelica Association

opening with falling pressure in the downstream controlled piping. It can also be acting as an overflow
valve with increasing pressure in upstream controlled
piping.
Figure 9 shows the Modelica model for the varyingpressure accumulator. The central part of the model
is the vessel. In the vessel the mass and energy balance for an open control volume is solved. The
volumetric and caloric properties are calculated
within the equation of state model that is connected
to the vessel model via a thermal state connector. All
connectors are defined in the TechThermo library.
To represent the mass of the vessel shell a heat capacity is connected due a thermal resistance to the
vessel. The pressure loss of the mass flow during
charging the accumulator is represented by two
models. The first is used to calculate the static pressure increase below the water line in the vessel. The
second model computes the pressure loss of a flow
due friction with a coefficient called Zeta.
3.4

Simulation Model and Results
Pressure loss
due water level
Pressure loss
due nozzle

Mass flow
outlet

Heat
capacity

Thermal
resistance

vessel

Mass flow
Boundary
Condition

Equation
of state

Figure 9: Modelica model of steam accumulator

3.5
Mass and energy balance in the vessel
The energy equation for a control volume that relates
energy and mass flows has following form
dE
= m& in
dt

⎛ w2
p ⎞
⋅ ⎜⎜ in + g ⋅ z in + u in + in ⎟⎟
ρ in ⎠
⎝ 2

⎛ w2
p
− m& out ⋅ ⎜⎜ out + g ⋅ z out + u out + out
2
ρ
out
⎝

335

⎞ & &
⎟ + Q − We
⎟
⎠

Modelica 2005, March 7-8, 2005

W. Steinmann, J. Buschle

If we assume that the changes in kinetic and potential energy are zero and there is no external work we
obtain an equation for the internal energy of the control volume
dU
= hin ⋅ m& in − m out ⋅ m& out + Q&
dt

vapour part is received from the Soave-RedlichKwong cubic equation of state
p=

RT
a(T )
−
v − b v ( v + b)

by rearrangement to the normal form

Conservation of mass means that the change of mass
in the control volume must equal the difference between the mass entering the system and the mass
leaving the system
dm
= m& in − m& out
dt

The specific internal energy in the control volume
consists of the internal energy of the liquid part and
the internal energy of the vapour part
u = (1 − x ) ⋅ u liq + x ⋅ u vap

⎡ RT ⎤ 2 ⎡ a(T ) − RTb
⎤
⎡ a(T )b ⎤
v3 − ⎢
− b2 ⎥ ⋅ v − ⎢
⎥⋅v + ⎢
⎥=0
p
⎣ p ⎦
⎣
⎦
⎣ p ⎦

and using Cardano’s method. R and b are material
dependent constants. a(T) is a temperature dependent
variable.
The enthalpy is estimated with the departure function
for the Soave-Redlich-Kwong cubic equation of state
⎡ ∂a(T )
⎤ 1 ⎛ v + b ⎞ a(T )
− a(T )⎥ ⋅ ⋅ ln⎜
h − h o = ⎢T ⋅
⎟−
∂
T
⎣
⎦ b ⎝ v ⎠ v+b
⎞
⎛ v
+ R ⋅T ⋅ ⎜
− 1⎟
⎝v−b ⎠

with the steam quality x in the following form
x=

and a polynomial equation for the enthalpy of the
ideal gas

m vap
mliq + m vap

h − hT0 = AIG (T − T0 ) +

3.6
Thermophysical properties of steam
The volumetric and caloric properties are calculated
with the Soave-Redlich-Kwong cubic equation of
state, the departure function for the cubic equation of
state, the Antoine saturation pressure correlation and
the enthalpy of the ideal gas. The results are within
an error of 5 %.
A closed system that consists of a liquid and its vapour in thermodynamic equilibrium has 1 degree of
freedom. So if e.g. the temperature is known the
pressure, the enthalpy, etc. can be calculated in the
following way.
For a known temperature the pressure is given by the
Antoine pressure correlation
ln( p) = AA −

+

B IG 2
C
2
3
(T − T0 ) + IG (T3 − T0 )
2
3

D IG
4
(T4 − T0 )
4

For the enthalpy of the liquid part the results are not
satisfying. A better approach is to calculate the latent
heat of evaporation and subtract it from the enthalpy
of the vapour. The latent heat of evaporation is received from the Antoine vapour pressure correlation
in combination with the Clausius-Clapeyron equation

∆hlv =

B A ⋅ ∆vlv
T

⎛ T
⋅ ⎜⎜
⎝ T + CA

2

B

A
AA −
⎞
⎟⎟ ⋅ e T +C A
⎠

The differentiation between the state of superheated
steam and the state of wet steam is realised by an ifclause.

BA
T + CA

With the known temperature and the calculated pressure the specific volume of the liquid part and the
The Modelica Association

336

Modelica 2005, March 7-8, 2005

Analysis of thermal storage systems using Modelica

if (x > 1 and p < p_sat) then
x = 1;
else
p = p_sat;
end if;

If the steam is superheated the steam quality x is
fixed to 1. Else the system pressure is calculated with
the saturation pressure correlation.

evaluated regarding the requirements of the specific
process. Often, the duration of a charging / discharging cycle often exceeds durations of 24h. The capability of Modelica to simulate efficiently the transient behaviour of systems over such periods offers
an important option for optimization.
Further development will also include steam accumulator with integrated phase change material. This
concept is intended to increase the storage capacity
of steam accumulators. Here, most of the needed
models are already available from the current simulation projects.

References
3.7

First Results

[1]

[2]

[3]

[4]
Figure 10: Temperature and pressure rise in steam
accumulator during charging process
In Figure 10 first simulation results of the varyingpressure accumulator model are shown. The vessel is
charged with superheated steam at a temperature of
about 550 Kelvin and a pressure of 10 bar. The initial temperature of the vessel is 373 Kelvin. If the
vessel is in thermodynamic equilibrium the temperature of the vessel will not exceed the saturation temperature belonging to the pressure in the vessel. As it
can be seen, limiting for the charging procedure is
the pressure of the superheated steam. A bigger
amount of energy could be stored if an indirect
charging device is used.

4

[5]

Winter, C.-J ,C.-J., Sizmann, R. L., VantHull, L. L.: Solar Power Plants, SpringerVerlag, Berlin, 1991
Dinter, F., Geyer, M., Tamme, R.:Thermal
Energy Storage for Commercial Applications, Springer-Verlag, Berlin 1990
Tamme, R., Laing, D., Steinmann, W.D.:Advanced Thermal Energy Storage
Technology for Parabolic Trough, ASME J.
of
Solar
Energy
Engineering
126
(2004), pp.794-800.
Eck M., Zarza E., Eickhoff M., Rheinländer
J., Valenzuela L.: Applied Research concerning the Direct Steam Generation in Parabolic
Troughs, Solar Energy, Vol. 74 (2003) pp.
341-351
Beckmann, G., Gilli, P.V. “Thermal Energy
Storage“, Springer Verlag, 1984

Conclusions

In particular the results of the system analysis of
storage units prove to be a very useful tool for the
optimization. For a selected application, the thermal
energy provided by the storage system must be

The Modelica Association

337

Modelica 2005, March 7-8, 2005

The Modelica Association

338

Modelica 2005, March 7-8, 2005

Exergy-analysis of a direct-evaporating cooling plant with heat reclaim

Exergy-analysis of a direct-evaporating cooling plant
with heat reclaim
Stefan Wischhusen1
Gerhard Schmitz
Hamburg University of Technology
Department of Thermodynamics
Denickestr. 17, D-21073 Hamburg
1 wischhusen@tuhh.de

Abstract
In this paper the modelling of a direct-evaporating
two-stage cooling plant with the refrigerant ammonia
(R717) will be described. The plant model is used to
determine the power consumption as well as the possible heat reclaim to the domestic hot water system of
the plant. In a sensitivity study important control parameters of the plant are evaluated for electricity, water
and natural gas consumption. One characteristic operating point is investigated in an exergy-analysis [1, 2]
to find potential for energy savings.

comparison to other refrigerants. Drawbacks are the
flammability and toxicity. Experiences go back to the
19th century when David Boyle (1873) and later Carl
von Linde (1876) developed the first compression
chillers using ammonia. The chiller created by Linde
was used in breweries for cooling beer.

Since industrial refrigeration plants are operated
many hours per year the energy consumption is
relatively high and therefore capital investment for
increasing the efficiency returns faster than in plain air
conditioning plants which are just seasonally used. A
dynamic simulation is carried out because of the high
Keywords: Refrigeration, Exergy-analysis, Heat rerefrigerant and water capacity of the plant.
covery, Ammonia, R717, Two-stage system

1

Introduction

Probably the largest application for industrial refrigeration is cooling and freezing of food. Large
plants are needed to provide refrigeration throughout
all seasons of a year covering all production steps
during the processing, storage and transportation.
Most of the plants are built in a direct-evaporating
architecture where the refrigerant is evaporated in
each cold storage or consumer. In contrast to that,
indirect evaporation with a secondary cooling agent is
used for air conditioning systems in large buildings.
The reason for this is a lower pressure loss for liquid
media in extensive pipework.

2 Refrigeration Plant Topology and
Functioning
In order to provide cooling capacity at two temperature levels (-10 ◦ C and -35 ◦ C) the compression of
the working fluid is separated into two stages: The
high pressure (13.5 bar/2.91 bar) and the low pressure
(2.91 bar/0.9 bar) cycle, displayed in Fig. 1. The
low pressure compression provided by two screw
compressors (“Booster”, 1 → 2) can be operated
independently while one high pressure compressor
is always needed to reject the waste heat over the
condensers. Therefore, a higher cooling capacity is
always necessary on the high pressure side with three
screw compressors installed (3 → 4). The waste heat
is mainly rejected to the ambience by evaporative
condensers, which incorporate air and water for
evaporative cooling (5 → 6,7).

Historically, ammonia (R717) is one of the best
known refrigerants in industrial applications and
it has suitable properties like a high evaporation
heat at moderate densities and a range of feasible
saturation pressures at common working temperatures
(especially with regard to low temperature applica- Since there is a high demand for domestic hot water
tions). An economical advantage is its low price in (DHW) in the plant during production times (mass
The Modelica Association

339

Modelica 2005, March 7-8, 2005

S. Wischhusen, G. Schmitz

Figure 1: Simplified plant schematic including the refrigeration and domestic hot water system
is essential in order to supply pure liquid medium to
the pumps and evaporators of each stage. The separating vessel on the intermediate pressure level (10,13
→ 3,12,14) is equipped with an intercooler because
of the superheated low stage gas which needs to be
cooled down to saturation conditions before it can
be compressed again by the screws of the second stage.

90

Pressure [Mpa]

flow rates are as high as 8 kg/s) it is convenient to
recover waste heat by cooling compressor oil and high
pressure gas in a water-cooled excess heat exchanger
(4 → 5) and a water-cooled condenser (5 → 8). Those
heat exchangers (HX) are of shell and tube type.
Following German domestic water ordinance the
heat exchangers have to be cooled indirectly to avoid
a contamination with ammonia in case of leakage.
Subsequently, the condensate flow is fed into the high
pressure receiver (V=2 m3 , 8 → 9) where it can be
tapped for expansion or cooling the low stage and high
stage screws (9). The latter compressors (3 → 4) just
draw liquid ammonia when the cooling water temperature is too high to ensure an oil temperature of 48 ◦ C.
Like oil the liquid ammonia may be injected into the
suction side of the compressor to decrease the outlet
temperature of the compressed gas. To remove the oil
fraction from the superheated refrigerant vapour, an
oil separator for each compressor is necessary which
is also used as a tank storage.

50

6, 7, 8, 9

12, 14

10

5 4

35

2

3

-10

13

15
16

-35

17

1

Specific enthalpy [kJ/kg]

Unlike in one-stage refrigeration systems, the ex- Figure 2: p,h-diagram for R717 of the two-stage repanded refrigerant is first stored in a phase separator frigeration system – Arabic numerals with regard to
(V=11 m3 , each) to remove flash gas. This component Fig. 1
The Modelica Association

340

Modelica 2005, March 7-8, 2005

Exergy-analysis of a direct-evaporating cooling plant with heat reclaim

In applications with temperatures below 4 ◦ C a defrost
system has to be applied to each cooling coil which
is in contact with (humid) air. For this purpose
superheated refrigerant tapped before the excess HX
is used occasionally by switching a valve at each
evaporator.
The total cooling capacity of the screw compressors is
847 kW on the low stage (-35 ◦ C) and 2308 kW on the
high pressure side whereof 1461 kW are available for
-10 ◦ C consumers. The rated power consumption of
the compressor motors sums up to 200 kW for the
Boosters and 693 kW on the high stage. Accordingly,
the evaporative and water-cooled condensers have a
cooling capacity of 3910 kW (incl. desuperheat HX)
at a saturation temperature of +35 ◦ C.
The capacity control of the system is realised by a
variable valve in the screw compressors which can
throttle the effective mass flow rate at constant speed.
The lowest continuous working point is limited to
10 % of the rated capacity. Below that operation point
the motor is driven in an on-off procedure. Internally,
the oil flow is adjusted so that a constant oil inlet
temperature can be provided. The mass flow rate of
oil is almost of the same magnitude as the refrigerant
flow to ensure a sufficient lubrification, sealing and
cooling. All compressors are organised in a load
dependent cascade, operating as many machines as
needed.

(2250 hours/a) and on the medium pressure side by
cooling storage rooms at -10 ◦ C (8760 hours/a) (see
Fig. 3). The load profile of the low temperature consumers varies between 30 and 1100 kWth and for the
normal cooling between 100 and 2300 kWth . Thanks
to the data measurement of the plant’s operator the
hourly power and water consumption (see Fig. 4) as
well as the product flow of the plant is known and it is
considered as boundary conditions for the system simulation. Since the unknown cooling requirement is an
important input variable of the load dependent simulation it has to be calculated from known and assumed
variables like the power consumption and the product
flow. On the low temperature side (LT, 16 → 17) the
refrigeration load can be estimated by the following
equation:
Q̇0, LT = ṅ prod · 11 kJ + Q̇0, aux

(1)

where ṅ prod denotes the flow rate of product. Each
product entity has a heat capacity of 11 kJ in the corresponding temperature range and Q̇0, aux stands for the
smaller amount of additional refrigeration which averages 30 kW. The refrigeration load for room cooling Q̇0, MT (12 → 13) at an evaporation temperature of
ϑ0 =-10 ◦ C results from the following equation
Q̇0, MT = Pel ·COP − Q̇0, LT

(2)

applying an average coefficient of performance
COP =3. Despite the fact that the peak load of both
stages sums up to 3,400 kW (see Fig. 3) their occurIn an analogous manner the three evaporative con- rence is separated. The highest total load is not larger
densers are enabled in an pressure dependent cascade than 2,450 kW.
at operating points ranging from 9 to 12 bar. At
low pressures, the spray water pumps are activated
followed by the ventilation of the cooling towers. The
mass flow rate through the parallel condensers and
cooling towers is adjusted naturally since a lower heat
transfer rate leads to higher pressure losses due to the
rising resistance in one branch.
The refrigeration process is also shown in a logarithmic p,h-diagram for NH3 in Fig. 2.

3

Boundary Conditions and Measurements

Time [h]

Figure 3: Annual load duration curve for refrigeration
Since the cooling demand is changing dynamically the
plant is not driven continuously but in a typical load Not available are ambient conditions for that time,
profile (see Fig. 4) which is dominated on the low pres- so that weather data from a test reference year of the
sure side (-35 ◦ C) by shock-cooling of food entities corresponding region in Germany has been used to
The Modelica Association

341

Modelica 2005, March 7-8, 2005

S. Wischhusen, G. Schmitz

1400

below:

Load −10°C
Load −35°C
1200

• Electricity cost: 70 e/MWh (Compressors, cooling towers, pumps),

1000

• Gas price: 35 e/MWh (DHW supply),

600

• Fresh water cost: 0.89 e/m3 (Cooling towers),

[kW]

800

400

• Charge for waste water: 2.29 e/m3 (Cooling towers).

200

0
1.01

2.01

3.01

4.01

5.01

6.01

7.01

Time[dd.mm]

4 Modelling of Plant and Components

10
Water mass flow
9

First of all it should be pointed out, that the modelling
in this case was focused on the simulation of the
refrigeration plant with the integration of the heat
6
recovery. The models for hydronic systems have been
5
supplied by the model libraries of HKSim [3, 4, 5].
4
Pfafferott has shown that a dynamic simulation of
3
mobile refrigeration systems is possible [6]. He used
2
Modelica for modelling of thermohydraulic elements
1
integrating dynamic energy and mass balances and a
0
quasistatic impulse balance. Unfortunately, such de9.03
10.03
11.03
12.03
13.03
14.03
15.03
Time[dd.mm]
tailed component models are not suitable for complex
systems, especially when long simulation periods are
Figure 4: Typical cooling requirement (t.) and DHW investigated. The typical period in the current project
consumption profile (b.)
is one week and more in order to detect improvements
and present them in a financial suitable resolution.
8

[kg/s]

7

calculate the performance of the cooling tower model
(temperature and relative humidity as inputs). The
temperature of the fresh water was assumed to change
in a sinusoidal way between 10 ◦ C at the beginning of
spring and 13 ◦ C in late summer.

When applying the Finite Volume method in fluid
modelling it is important to have a medium property
model for all technical relevant states. This is given by
a fundamental equation of state which was elaborated
by Baehr and Tillner-Roth for a few important refrigerants [7] also including R717. The two-phase region
has to be modelled by polynomial functions which depend on one thermodynamic state variable (T or p).
It is known that the simulation of the gaseous and
two-phase region can be rather efficiently performed,
when the density ρ (or the specific volume v, resp.)
and the temperature T are used as states and inputs
to the highly non-linear equations. The dimensionless
Helmholtz-function is defined as:

The mass flow rate of consumed domestic hot water
(E,F,G) is also dynamically changing. The highest
flow rates occur at the beginning of each production
day (see Fig. 4). Those days are contemporaneously
characterised by a high cooling demand on the low
temperature side because of the necessary product
cooling. This fact combined with a considerable water
demand during production times results in a very
worthwhile potential for heat recovery. On the other
1
hand the mass flow rate of water in the meantime is
Φ := f (T, v) ·
.
(3)
not high enough to provide a sufficient condensation
RT
and cooling capacity.
Provisions have to be made with regard to the calculation of liquid state properties. In this region the
Important for an economical analysis of an existing simulation may become stiff since small changes (or
plant are the energy and media prices which are listed even integration failures) in temperature at nearly
The Modelica Association

342

Modelica 2005, March 7-8, 2005

Exergy-analysis of a direct-evaporating cooling plant with heat reclaim

Cooling towers
Water tank

Cooling circuit
Condenser
Excess HX
Booster

HP-compressors

Phase separator
and intercooler

Phase separator

Receiver Expansion
valve

-10°C-consumers

-35°C-consumers

Figure 5: Plant model integrating the two stage refrigeration cycles, cooling water circuit and fresh water tank
constant density result in large pressure gradients.
Those gradients lead to small system time constants
due to the linkage of momentum and mass and energy
balance. This is one reason why a state variable
selection of pressure p and specific enthalpy h is
generally preferred. However, with those states an
iterative calculation of T and v is necessary during
the simulation because the complex property functions can not be transformed symbolically, yet. In
order to optimise the simulation also with respect to
simulation speed it was decided to use a component
related formulation of the balance equations in this
project especially regarding components containing
liquid refrigerant (e. g., refrigerant pumps and other
hydraulic elements). One important and simplifying
assumption is, that industrial plants are operated
more or less continuously even though with variable
utilisation factor. Therefore, heat and mass dissipation
is not taken into account. From this fact follows that
the feed ducts of the evaporators are always passed
through with liquid medium. For those elements the
incompressible formulation of the mass and energy
balance [4] may be used with a constant specific heat
capacity c =4,500 J/(kg·K) and a constant density of
ρ =650 kg/m3 .
The Modelica Association

Very important for achieving a fast and stable simulation is also a component related momentum balance
which should be as simple as possible. A momentum
balance is always needed when a mass shift inside the
system due to pressure gradients has to be calculated.
In other words: It can be expressed ideally and more
efficient if the mass transfer is guarded by a superior
control system. For example, the mass flow through
the expansion valve of each stage is set in order to
realise a constant liquid fill level in the following
phase separator.
The mass flow rates through the parallel passes of the
condenser and cooling towers just depend on the pressure loss across each branch (in steady state always
the same value) which is defined by hydraulic pressure drop correlations. For the quasistatic momentum
balance follows:
0 = pin − pout − ∆ploss


ṁ 2 ρ100
·
.
∆ploss = ∆p100 ·
ṁ100
ρ

(4)
(5)

All parameters indicated by 100 in Eq. 5 refer to one
characteristic operation point. The density factor can

343

Modelica 2005, March 7-8, 2005

S. Wischhusen, G. Schmitz

not be neglected when the liquid fraction is variable
or a dry out of the heat exchanger is possible (here:
condenser). This is often the case in the actual plant
when the cooling water temperature rises due to a low
domestic hot water consumption.

Electricity

On/off

Refrigerant
inlet

Base compressor
model

Oil separator
Generic efficiency

Liquid R717
Moreover, component models which show a phase
model for ammonia
injection
change like condensers and evaporators should not be
separated into multiple volumes to avoid too many
Liquid ammonia
Throttle
inlet
Oil cooling hx
events during simulation. A promising approach could
be a Moving-Boundary-Model [8] although it was
Cooling water ports
not implemented in this work because of the frequent
dry out of the condenser and the load dependent
Figure 6: Diagram layer of a high pressure screw comevaporator model (Q̇0 is an input variable).
pressor model with integrated oil separator, oil cooler
The heat transfer rate from the refrigerant to the liquid and ammonia injection

water in the water-cooled condenser is calculated by a
quasistatic efficiency calculation (P1 -NTU) from [9]. the part load control (part load factor ϕ) and the thermodynamic properties of the refrigerant as well as


the thermodynamic states in the suction and discharge
liq
liq
Q̇liq = P1 ·Cmin · Tin − Tout
, C = c · ṁ (6) chamber. The latter mainly result from the actual heat
transfer of all components in the cycle. With regard to
this plant the suction (index suc) and discharge (index

2
dis) pressure is defined by the capacitive component
!
r
r
,


2
2 NT U
C
C
C

min + 1+ min ·coth
min ·
models (e. g., the excess heat exchanger and the phase
1+ Cmax
1+ Cmax

Cmax
2



separator in the high pressure cycle, see Fig. 5). In or
min
Cmax > 0 & CCmax
< 1 & Cmin > 0 .
P1 =
(7) der to calculate the power consumption the mentioned


1
thermodynamic variables are considered in the calcu

,

NTU

√
1+coth

lation of the total efficiency of the compressor.

2

Cmax > 0 &

Cmin
Cmax

>= 1 & Cmin > 0 .

Since the specific heat capacity at constant pressure c p
is equal to infinity in the two-phase region, a crossing
function has to be implemented realising a “chatterfree” solution when liquid or vapour content is high.
Good experiences were made with a tanh-function
changing its value and derivation steadily at vapour
qualities x =0. . . 0.05 and x =0.95. . . 1. The value of
the function is multiplied with the property value for
the specific heat capacity of the property model.


COP =

f pl
· fth




ṁ
∆p, ϕ psuc , pdis ,
ṁmax

nom nom
psuc , pdis , Q̇0 , Pel , ηmech (8)

The part load function f pl may be derived from manufacturer data or from literature [10]. For the calculation of the rated performance (index rat) at variable
suction and discharge pressures ( fth ) a determination
of the refrigerant’s properties (specific enthalpies h,
entropies s and densities ρ) is carried out. In contrast to
The compressors are modelled in a Super-Model the rated performance at full mass flow rate and variapproach integrating the base compressor model, an able pressures the nominal performance denotes one
oil separator, the water-cooled oil heat exchanger rated operating point at constant pressures.
(fixed properties for liquid oil) and the auxiliary liquid
ammonia injection (see Fig. 6). Instead, the booster
h0, in − h0, out
model incorporates an oil cooling heat exchanger
· ηis · ηmech
(9)
fth =
hisdis − hsuc
permanently fed with ammonia.
rat
ṁrat · hisdis − hsuc
ηis =
(10)
A determining factor for the power consumption of the
Pelnom ηmech
plant is the efficiency of the compressor. The so called
ρsuc nom
ṁrat =
· ṁ
(11)
coefficient of performance (COP) mainly depends on
ρrat
suc
The Modelica Association

344

Modelica 2005, March 7-8, 2005

Exergy-analysis of a direct-evaporating cooling plant with heat reclaim

ṁnom =

Q̇nom
0
h0, in − h0, out

(12)

4.1 Validation of the Plant Model

(13) For the validation of the plant model measurement
data has been supplied by the plant operator. The data
It is assumed that the isentropic efficiency of the com- displays the power, domestic water consumption and
pression at nominal mass flow rate ṁnom is nearly con- waste water flow in an hourly interval. Moreover,
stant for all operating points. In addition, the available some offline-information was collected on a visit of
enthalpy of evaporation is assumed to be ideally used. the plant while the production was on (high cooling
requirement for -35 ◦ C-consumers).
hisdis = h (s (hsuc , psuc ) , pdis )

h0, in = hliq (pc )
h0, out

= hvap (p0 )

(14)
Total power consumption in Jan

4

(15)

5

x 10

Sim
Mes

4.5

el

[kWh ]

3
2.5
2
1.5
1
0.5
0
1.01

2.01

3.01

4.01

5.01

6.01

7.01

Time[dd.mm]
4

7

x 10

Total power consumption in Sep
Sim
Mes

6

5

el

For achieving an efficient simulation only the largest
capacities in the cycle were modelled by control
volumes. Those components are the phase separators
(each 11 m3 ) and the high pressure receiver (2.3 m3 ).
Additionally, the high pressure heat exchangers were
also modelled by using dynamic mass and energy
balances in order to stabilise the solution of the
non-linear system of equations during simulation.
The modelling of the intercooler functionality of the
phase separator on the intermediate pressure level is
realised by mixing of all inbound enthalpy flows and
computing saturated enthalpies for all outgoing mass
flows.

4
3.5

[kWh ]

At very low cooling requirements (10 % of Q̇rat
0 ) the
control system of the compressors stops the continous
operation and activates a two-point control with a
minimum mass flow rate.

4

3

A very demanding component from the modelling
2
point of view is the evaporative condenser which
has three fluid fluxes moving in different directions
1
(Refrigerant: horizontal, air: bottom-top, water: top0
bottom). A detailed model is described by [11, 12].
31.08
1.09
2.09
3.09
4.09
5.09
6.09
Time[dd.mm]
More applied to the needs of complex energy system
simulations seems to be the approach of Stabat and
Marchio [13] which offers a promising approach and Figure 7: Comparison of the total power consumption
in January (t.) and September (b.) with simulation
some successful validation.
results
The model of this study is even more simplified by
using the assumption that the air outlet condition
equals always the mean temperature between the
entering refrigerant and the wet bulb temperature
while the relative humidity is constant. The cooling
capacity can be adjusted by a variable mass flow
rate of air. The supplied characteristic curve for the
ventilation yields the power consumption of the motor.

The Modelica Association

The comparison of the power consumption shows a
good agreement. In both simulated periods of one
week in January and September respectively the simulation result is slightly higher than the measurement.
The relative deviation is less than 7.7 % (Fig. 7).
Obviously, the power consumption of the plant is
overpredicted when the production cooling is off .

345

Modelica 2005, March 7-8, 2005

S. Wischhusen, G. Schmitz

Item

Measurement

Simulation

29.04.04, 13:00

23.05.03, 13:00

Heat reclaim

ϑ

[◦ C]

ϑ [◦ C]

HX “Excess”, water

25 / 38

29 / 37

HX “Condenser”, water

20 / 28

17 / 29

HP screw 1, oil

52

45

HP screw 1, gas

70

60

HP screw 3, oil

55

45

HP screw 3, gas

68

63

pc [bar]

pc [bar]

11.5

11.7

Receiver
Conden. pressure

ond law of thermodynamics to completely turn heat
into power by reducing the temperature of a medium
to ambient conditions. The exergy E represents that
part of energy which is technically useful and can be
extracted without restrictions to work. The specific exergy e is expressed by:

e = h − h0 − T0 (s − s0 ) + 0.5(c2 − c20 )
|
{z
} |
{z
}
thermal
kinetic
+ g(H − H0 )
(16)
| {z }
potential

Aux.

The (specific) exergy always depends on the definition
of ambient conditions indicated by the index 0. It is
Table 1: Comparison of temperatures and pressures not always trivial to select the “correct” ambience
for one operating point with comparable boundary and model and the discussion about this issue is not
load conditions
finished, yet. Nevertheless, the exergy represents a
powerful tool for analysing energy systems.
Ambient temp.

20 ◦ C

20 ◦ C

In Tab. 1 some temperatures and pressures displayed
by onboard information systems or thermometers are
listed for one operating point in April. Those values were compared to the corresponding values of the
plant simulation at a similar load condition of the previous year. Especially, the simulated saturation pressure in the condensers, responsible for the attainable
heat recovery, matches the value of the measurement.
The same applies for the cooling water temperatures in
the excess and condensing heat exchanger. A greater
deviation can be seen in the gas and oil temperatures of
the high pressure compressors. It must be pointed out
that the position of the oil temperature sensor could
not be clarified. Hence, the model of the oil cooling
unit was not calibrated again but the parameters of the
plant documentation were used.

Item

1→2
3→4
4→5
5→6
5→7
5→8
6,7,8 → 9
9 → 10
10,2,13 → 3,14
12 → 13
14 → 15
15,17 → 1,16
16 → 17
Total

Total change
of exergy flow
∆Ė tot [kW]

Inner cost
flow
K̇ i [e/h]

-62.15
-142.42
-12.10
-92.02
-44.30
-8.48
2.50
-23.98
-11.96
-47.18
-4.24
-0.76
-195.33
-642,42

-4.60
-10.58
-0.90
-6.83
-3.29
-0.63
0.19
-1.78
-0.89
-3.50
-0.31
-0.06
-14.50
-47.68

Exergy-analysis of the Refrigeration System

Table 2: Inner costs resulting from exergy losses without heat reclaim for one hour continuous operation
(see Fig. 1 for items) – The specific cost for exergy
is 0.074 e/kWhex

For estimating savings potential it is important to know
where the dominating loss mechanisms of a process
are located. Such losses may be noticed in form of
heat transfer, power decrease, mixing and pressure resistances. For the purpose of a clear description of process efficiencies it is necessary to define how much of
an energy portion can be transformed into any other
form of energy. For example, it is not possible to transfer heat from a cooler to a warmer volume in order to
produce power. It is even not permitted by the sec-

In order to express the exergy losses in the corresponding components in terms of hourly costs the change of
exergy is calculated first for an characteristic operating point with active production cooling. The cooling requirement is 485 kW for storage rooms (-10 ◦ C)
and 985 kW for production (-35 ◦ C). At the same time
a domestic hot water consumption of 4.5 kg/s takes
place. Kinetic and potential forms of exergy are neglected and the reference point is set to p0 = 1 bar

5

The Modelica Association

346

Modelica 2005, March 7-8, 2005

Exergy-analysis of a direct-evaporating cooling plant with heat reclaim

Item

Thermal change
of exergy flow
∆Ė i [kW]

Power
consump.
Pel [kW]

Change of
enthalpy flow
∆Ḣ [kW]

Water
consump.
ṁ f r [kg/s]

Waste water
flow
ṁA [kg/s]

Outer
cost flow
K̇ o [e/h]

104.15
255.18
-12.10
-53.02
-25.10
-8.48
2.50
-23.98
-11.96
-41.18
-4.056
-0.76
-181.03
-19.03
5.46
5.15
10.52
-2.08
13.42
-0.68
-8.97
-25.42
-12.85

166.30
397.60
0.00
39.00
19.20
0.00
0.00
0.00
0.00
6.00
0.00
0.00
14.30
0.70
0.00
0.00
0.00
0.00
0.70
0.00
0.00
0.00
0.00

145.63
173.09
-80.64
-1056.08
-494.50
-166.95
0.00
0.00
0.00
485.76
0.00
0.00
983.26
-372.68
169.24
87.59
115.04
0.00
370.97
0.00
106.32
241.12
89.23

0.00
0.00
0.00
0.31
0.15
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00

0.00
0.00
0.00
0.08
0.04
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00
0.00

11.64
27.83
0.00
4.58
2.21
0.00
0.00
0.00
0.00
0.42
0.00
0.00
1.00
0.05
0.00
0.00
0.00
0.00
0.05
0.00
40.93
92.83
34.35

1→2
3→4
4→5
5→6
5→7
5→8
6,7,8 → 9
9 → 10
10,2,13 → 3,14
12 → 13
14 → 15
15,17 → 1,16
16 → 17
VII → I
I → II
III → IV
V → VI
IV,VI → VII
B→C
C→D
D→E
D→F
D→G

Table 3: Change of exergy and enthalpy flow rate for the refrigerant, power and water consumption, waste
water mass flow rate and outer cost flow invested - power rates and media prices are listed in Sec. 3

and ϑ0 =12.4 ◦ C (fresh water temperature entering the
plant). The change of exergy and enthalpy with regard to the refrigerant or cooling water flow is shown
in Tab. 3. An increase of exergy (∆Ė i >0) happens in
the compressors and in those heat exchanger volumes
which show a rising temperature (cooling water HX).
Under the assumption of continuous operation for one
hour the plant consumes a total of 643.8 kWh exergy
in form of electricity. This effort has to be compared to
the thermal profit of the plant which is defined by the
exergy provided by the evaporators and the water tank
to the DHW system. Hence, the exergetic efficiency ζ
follows from the ratio of the actual thermal advantage
to the total exergy input (∑ Pel ):
i
i
i
∑ ĖQ |∆Ė12,13 | + |∆Ė16,17 | + ∆ĖB,D
ζ=
=
= 0.36
∑ Pel
∑ Pel
(17)
This value is more plausible than the COP which
equals 2.28 at the same time. If an economical
analysis shall be carried out it is possible to combine
the change of exergy flow rate ∆Ė i with outer cost
flows K̇ o (see Tab. 3) resulting from power and water

The Modelica Association

consumption. This method is described as “exergy
costing” by Bejan [1]. In a simplifying approach
it can be postulated that all outer costs are divided
by the exergy input in order to calculate the specific
costs of exergy. With this average value the costs of
internal losses are expressed (see Tab. 2). Generally,
the initial costs (e. g. capital investment) should
also be included but in this case an operating plant
is considered and it should be investigated how the
efficiency could be improved without installing new
components. Therefore, the task was not to compare
different components with different initial costs and
thus this contribution was neglected.
The total amount of all costs for this operation
mode is 48 e/h. The largest cost centre in terms
of exergy destruction is encountered in the cooling
towers (10 e/h) followed by the expansion valves
(2.10 e/h) and the phase separator of the high stage
(0.89 e/h) due to the internal heat transfer. Hence,
financial savings can be obtained by reducing exergy
destruction in the evaporative condensers (e. g. by
lowering the saturation pressure or increasing the
mass flow rate through the water-cooled condenser).

347

Modelica 2005, March 7-8, 2005

S. Wischhusen, G. Schmitz

8.20 e/h. In addition, the oil coolers also show a
revenue of 4.39 e/h reducing the loss of the HP screws
1→2
-4.60
0.00
-4.60
from 10.58 e/h to 6.19 e/h. A complete coverage
3→4
-10.58
4.39
-6.19
of
the DHW supply by the refrigeration system is
4→5
-0.90
3.34
2.44
not possible as long as temperatures of more than
5→6
-6.83
0.00
-6.83
60 ◦ C are needed. But it would be possible to realise
5→7
-3.29
0.00
-3.29
5→8
-0.63
6.46
5.83
higher savings (see Tab. 4) if a consumer of 1.913 kW
6,7,8 → 9
0.19
0.00
0.19
at a low temperature of approx. 30 ◦ C could be found
9 → 10
-1.78
0.00
-1.78
or if the temperature level of the high pressure cycle
10,2,13 → 3,14
-0.89
0.00
-0.89
could be increased during production. Moreover,
12 → 13
-3.50
0.00
-3.50
in future low-exergy consumers and storage systems
14 → 15
-0.31
0.00
-0.31
15,17 → 1,16
-0.06
0.00
-0.06
will be available for heating systems and buildings so
16 → 17
-14.50
0.00
-14.50
that more energy can be saved. Currently, 47.68 e/h
Total
-47.68
14.20
-33.48
have to be invested in the refrigeration system (and
Table 4: Costs due to exergy losses and destruction, 16.77 e/h in the DHW system, resp.).
revenue of heat recovery and virtual operating profit in
comparison to conventional system for one hour continuous operation – The specific gain of recovered heat
6 Improvement Measures and Comis 0.039 e/kWhth
Item

Cost flow
K̇ i [e/h]

Revenue
Ġ [e/h]

Virt. op. profit
Ṗ [e/h]

ponent Optimisation

Useful changes of exergy in the evaporators cost
18 e/h so that this can be considered as the minimum
running cost level if the insulation of the rooms or
other consumers could not be further improved.
Up to now the positive impact of the heat reclaim is
missing in this study. To attain the total balance of
costs and revenues the gas savings from the DHW
system are propagated upstream. By means of cooling
water a total of 371 kW waste heat is recovered from
the ammonia or oil, respectively. This is almost 20 %
of the waste heat produced by the cycle. 115 kW are
contributed by the oil coolers (6 %) and 80 kW (4 %)
by the excess heat exchangers. Helmke [14] even
states a potential of 7.4 % for excess heat and 9.2 %
for oil cooling (only high pressure screws).
The actual heat recovery depends strongly on the
availability of cooling water which has only low
temperatures in case of DHW consumption. In order
to supply the demand of hot water (45 ◦ C, 60 ◦ C and
90 ◦ C) a heating capacity of 807 kW is needed.
Assuming an efficiency of 90 % for heating and
specific heat costs of 0.039 e/kWhth the running
costs of a conventional plant would be 31.07 e/h.
Taking the recovered heat into account the costs for
natural gas drop to under 17 e/h and therefore the
heat exchangers for heat reclaim are not representing
a loss of 1.50 e/h but a virtual operating profit of
The Modelica Association

From the exergy-analysis follows that a higher
condensation pressure offers a higher potential for
heat reclaim. This is only worthwhile if the DHW
consumption is high enough. Therefore a mass flow
depending control for the cooling towers is implemented. During production the saturation temperature
is lifted by a throttling of the tower ventilation from
a max. value of 10 bar to 14 bar. Outside production
times it is important to achieve low condensation
pressures (min. 7 bar) in order to reduce the power
consumption (see Fig.8).
Additionally, the compressor cascade is changed so
that the base requirement in winter is provided by the
smallest compressor because the COP is generally
better with a higher part load factor. In summer the
cascade order remains the same because the base load
for cooling storage rooms is often higher than the
maximum capacity of the smallest compressor.
For both periods in summer and winter the running
costs can be reduced by 4 % (see Tab. 5) due to the
increased heat recovery (≈ 20 %) at a slightly higher
power consumption (1 to 2 %). For those savings there
are basically no large investments needed. Compared
to the running costs of the refrigeration plant (≈
200.000 e/a) for one year the possible reduction is
5.000 e/a.
The simulation of one week takes 12 hours on a fast
PC (3 GHz processor) due to on/off-control of the

348

Modelica 2005, March 7-8, 2005

Exergy-analysis of a direct-evaporating cooling plant with heat reclaim

12.5
12
11.5

pmax=14 bar
pmax=12 bar
pmax=11 bar
pmax=10 bar

11

[bar]

10.5
10
9.5
9
8.5
8
7.5
1.01

2.01

3.01

4.01

5.01

6.01

Mode

Jan. act.

Jan. mod.

Sep. act.

Sep. mod.

Power con.
[kWh]
Fresh water
[m3 ]
Waste water
[m3 ]
Heat reclaim
[kWh]
Costs
[e]
Rel. dev.
[%]

46.285

46.887

60.123

61.319

118

126

346

310

39

42

115

103

22.795

27.127

29.966

34.241

2.557

2.446

3.627

3.487

-

-4.3

-

-3.9

7.01

Time [dd.mm]

Table 5: Comparison of power and water consumption, heat reclaim and running costs for one week
in January and September of the actual and modified
plant

14

13

[bar]

12

11

10
pmax=14 bar
p =12 bar
max
pmax=11 bar
pmax=10 bar

9

8
31.08

1.09

2.09

3.09

4.09

Time [dd.mm]

5.09

6.09

Figure 8: Impact of the variable cooling tower control on the condensation pressure in January (t.) and
September (b.)
compressors at part load. If frequent events could be
avoided by a part load function or if a higher plant utilisation is considered the simulation time would be reduced to approximately 1 hour.

7

Conclusions and Outlook

It is possible to simulate even complex refrigeration
plants for longer periods like weeks with a high
amount of unsteady events resulting from a 2-pointcontrol of some components. A modelling approach
aiming to further reduce events during simulation
(e. g., performance curves for on/off-controlled
elements) would yield faster simulation times for
calculating balances of whole years. Attaining this
goal is important since the boundary conditions profile
(test reference year) has a dominating influence on the
total power consumption.

When considering multiple consumers (e. g., refrigeration at different temperature levels, DHW) the system’s control is a key factor for realising an efficient plant operation. In this paper, it was shown
that in even well-designed plants incorporating stateof-the-art subcomponents savings are attainable without much capital investment. The transient simulation offers a method for a holistic analysis of technical systems throughout the product-life-cycle. In
combination with an exergy-analysis it is possible to
find optimisation potential for characteristic operating
points. Basically, the implementation of the exergy
method is easy when necessary medium properties are
provided by the control volume models (see Eq. 16).
Nevertheless, the evaluation may become tedious for
complex dynamic systems especially when economical constraints (energy or exergy costs) have to be considered. For this purpose capable validation and evaluation methods must be implemented to concisely provide the information needed for drawing correct conclusions and finding effective improvement measures.

References
[1] A. Bejan, G. Tsatsaronis, and M. Moran. Thermal
Design and Optimization. John Wiley & Sons, New
York/Chichester/Brisbane, 1996.
[2] V. M. Brodyansky, M. V. Sorin, and P. Le Goff. The
efficiency of industrial processes: Exergy analysis and
optimization. Elsevier, Amsterdam / London / New
York, 1994.
[3] St. Wischhusen and G. Schmitz. Transient simulation
as an economical analysis method for energy supply

The Modelica Association

349

Modelica 2005, March 7-8, 2005

S. Wischhusen, G. Schmitz

systems for building or industry. Applied Thermal Engineering, 24:2157 – 2170, 2004.
[4] St. Wischhusen and G. Schmitz. Numerical Simulation of Complex Cooling and Heating Systems.
In Proceedings of the 2nd Int. Modelica-Conference,
pages pp. 183–191, Oberpfaffenhofen, 2002. Modelica Association.
[5] St. Wischhusen, B. Lüdemann, and G. Schmitz. Halbhermetische hubkolbenverdichter. In Proceedings of
the 3rd Modelica Conference, pages pp. 259–267,
Linköping, Schweden, 2003. Modelica Association.
[6] T. Pfafferott. Dynamische Simulation von CO2 Kälteprozessen für mobile Anwendungen. Shaker Verlag, Aachen, 2005.
[7] H.-D. Baehr and R. Tillner-Roth. Thermodynamische Eigenschaften umweltverträglicher Kältemittel.
Springer Verlag, Berlin, 1995.
[8] J. M. Jensen. Dynamic modeling of Thermo-Fluid
Systems - With focus on evaporators for refrigeration. Department of Mechanical Engineering, Technical University of Denmark, Lyngby (Dänemark),
2003.
[9] R. Shah and D. Sekulić. Fundamentals of Heat Exchanger Design. John Wiley & Sons, Hoboken, USA,
2003.
[10] W. Stoecker. Industrial Refrigeration Handbook.
McGraw–Hill, New York/San Francisco/Washington
D. C., USA, 1998.
[11] W. Leidenfrost and B. Korenic. Experimentelle
Überprüfung einer Berechnungsmethode für die
Leistungsvoraussage verdunstungsgekühlter Kondensatoren. Brennstoff–Wärme–Kraft, 34(1):9–14, 1982.
[12] H.-M. Hellmann. Untersuchung und einheitliche
Berechnung des Betriebsverhaltens von Verdunstungskühlern und –kondensatoren.
Phd thesis,
Technische Universität Braunschweig, Braunschweig,
1991.
[13] P. Stabat and D. Marchio. Simplified model for
indirect-contact evaporative cooling-tower behaviour.
Applied Energy, 78:433–451, 2004.
[14] T. Helmke.
NH3 -Verbundkälteanlagen mit
Schraubenverdichtern kleiner Leistung.
KK Die Kälte- und Klimatechnik, (5), 2000.

The Modelica Association

350

Modelica 2005, March 7-8, 2005

Application of the Modelica library WasteWater for optimisation purposes

Application of the Modelica library WasteWater
for optimization purposes
T. Ziehn*, G. Reichl*, E. Arnold**
* Technische Universität Ilmenau
Department of Automation and
Systems Engineering
P.O. Box 10 05 65, 98684 Ilmenau, Germany
tilo.ziehn@stud.tu-ilmenau.de,
gerald.reichl@tu-ilmenau.de

** Fraunhofer-IITB
Application Center Systems Technology
Am Vogelherd 50, 98693 Ilmenau, Germany
eckhard.arnold@ast.iitb.fraunhofer.de

Abstract
The following work is a contribution to dynamic optimal control strategies of an activated sludge model.
The model is applied to the waste water treatment
plant (WWTP) in Jena, Germany. The model is implemented using the Dymola software package with the
application of the free available Modelica library
WasteWater. On the basis of this model open-loop
and closed-loop (Model Predictive Control MPC) optimizations are applied and the results are evaluated.
The main focus is on the variable operating costs of
the WWTP.
Keywords: waste water treatment, dynamic optimization, model predictive control

1

Introduction and problem description

Nowadays new waste water treatment plants are designed for reliability and safety, not for operational
cost efficiency. Further more sustainable sewage management, which is subject to increasing legal requirements, plays an important role. Therefore, the application of simulation and optimization methods to
the waste water purification process is necessary. The
principal purposes are the reduction of the load for the
environment (adherence to the limits of the effluent parameters) with simultaneous minimization of the waste
water treatment costs.
The free available Modelica library WasteWater [1]
was developed and is successfully applied to the
WWTP Jena. In this plant blowers and pumps are
controlled by simple SISO control loops with standard
The Modelica Association

controllers (usually two-point controllers).
The WWTP Jena is comperatively well equiped with
various on-line measurement devices including COD,
3−
−
NH+
4 -N, NO3 -N and PO4 -P. Only on the basis of this
equipment, investigations concerning dynamic control
strategies become possible.
The cleaning achievement of a WWTP can be evaluated with the help of the effluent parameters of the
receiving water. Some of these effluent parameters
(e.g. NH+
4 -N) of the WWTP Jena are considerably below legal limits. As a result the operating costs are
higher than is necessary. The electrical energy costs
of the blowers and pumps, as well as the sludge disposal costs, represent the main part of the variable
costs which are required to operate the WWTP Jena.
The aim of this work is to find optimal trajectories
for blowers and pumps by using dynamic optimization
methods. Mainly dry weather scenarios were chosen
from the stored data for simulation and optimization
purposes. As a result the minimization of the operation costs of the WWTP, with simultaneous adherence
to the limits of the effluent parameters, becomes possible. These results are used as a basis for further investigations concerning closed-loop operation (Model
Predictive Control MPC).

2 Modelling of the WWTP Jena
The dynamic model of the WWTP is of crucial importance for the model-based optimization. There
is a multiplicity of mathematical models, which describe the waste water purification process. However, these models are almost exclusively applied for
simulation purposes. Due to the complexity of the
used model an object-oriented approach is worthwhile.

351

Modelica 2005, March 7-8, 2005

T. Ziehn, G. Reichl, E. Arnold

QR
COD
NH4−N
PO4−P

FC

air
QR

QRC

FC
FR

primary clarifier

QRC

NO3−N QRC

FR

DO

QRC
DO

DO

FQR
COD
NH4−N
NO3−N
P−tot

NH4−N
NO3−N
TSS

influent
AN

AN/DN(I)

DN(II)

N(III)

DN(IV) N/DN(V)

N(VI)

internal recirculation

QR

effluent
secondary
clarifier

TSS
FC

FC

FC
external recirculation (return sludge)

surplus sludge

Figure 1: Simplified sytem of the Jena WWTP
The programming language Modelica represents
this object-oriented approach. In this context the software package Dymola was used for simulation, since
the C++ code, generated automatically by Dymola, is
particularly suited for optimization purposes. The free
Modelica library WasteWater was used for the implementation of the model of the WWTP Jena. The
library contains the Activate Sludge Models (ASM)
No. 1 to No. 3 [2] and different multi-layer models for
secondary clarifier.
The WWTP Jena is characterised by a connection
size of 145,000 people equivalent (p.e.), a cascadetype denitrification with pre-clarification, biological
and chemical phosphorus removal and sludge digestion. The bio-gas produced by sludge fouling is used
in a block-type thermal power station of 2x250 kW. A
simplified system of the plant is shown in Figure 1.
Existing control loops (usually two-point controllers)
are isolated in and/or removed from the model for the
optimization process, with the goal being to find optimal trajectories (e. g. the control of the blowers for the
air supply into the nitrification tanks). Both, the physical limits of the control variables (blowers, pumps)
and the limits of the effluent parameters (e. g. maximum 1 mg NH+
4 /l) must be kept.
The model of the WWTP Jena is implemented by using the Activated Sludge Model No. 2d of the IWA
task group, which is part of the Modelica library
WasteWater. A summerised description of the model
reads:
dSi
dt
dSO
dt

dXi
dt

Qin
− ri ,
V
i ∈ {I, S, H, PAO, PP, PHA, AUT,

= (Xi,in − Xi )

(3)

T SS, MeOH, MeP}

In equation (1) the index i stands for the different
dissolved concentrations such as inert organic matter
(Si ), substrate (SF + SA ), nitrate nitrogen (SNO ), etc.,
and in equation (3) for the particular concentrations,
which are amongst others the heterotrophic (XH ) and
autotrophic (XAUT ) biomass. Variables subscripted by
index ’in’, e.g. Si,in , indicate concentrations in the flow
Qin entering a considered tank. Equation (2) describes
the balance of the dissolved oxygen and has an additional term for the oxygen uptake (aeration r air ) caused
by the blowers. The reaction rates r i and rO in the balance equations (1) - (3) are given by the model matrix
of the ASM No. 2d. It models 19 relevant concentrations (state variables) and 21 processes per tank. The
WWTP Jena model is described by approximatly 3000
equations and 250 state variables. The complete description and development is available in [2] .

The object oriented approach implemented in
Modelica combines the advantages of a hierachical
model structure and the reusability of model components in a multi-domain modelling environment of
complex dynamic systems. The model components
such as nitrification tank, secondary clarifier, blower,
flow mixer, divider and so on have to be defined for all
types of ASM models because of differing variables
Qin
= (Si,in − Si )
− ri ,
(1) and the number of variables. The components are
V
characterised by internal variables declared indepeni ∈ {F, A, NH, NO, PO, I, ALK, N}
dently of other components, and by connectors linking
Qin
= (SO,in − SO )
+ rO + rair ,
(2) the components.
V

The Modelica Association

352

Modelica 2005, March 7-8, 2005

Application of the Modelica library WasteWater for optimisation purposes

3

Optimal control problem

The optimization based control requires the dynamic
model of the WWTP (developed in section 2). The
whole model and control problem transformation procedure is done automatically by exporting a compiled
flat model representation of the WWTP in C++ from
Dymola [3], that can be used by the optimization
solver Hqp/Omuses [4], [6].

3.1

energy and the amount of air flow into the nitrification tanks could be determined. The blowers responsible for the air supply into the nitrification tanks N(III),
N/DN(V) and N(VI) (Figure 1) represent the main part
of the variable electrical energy costs. The costs resulting from pumps are negligible.
The constrained discrete-time optimal control problem
is numerically solved as a large-scale and structured
nonlinear programming problem in the state and control variables.

Open-loop problem

According to the problem described in section 1 different nonlinear optimal control problems can be formulated and solved taking into account different objective functionals. The main aim of the optimization
is to reduce operating costs, e.g. the electrical energy
cost taking into account the time-dependent electricity
tariff, respectively. The objective functional is minimised with respect to the constraints. Restrictions for
the state variables results from legal limits of effluent
concentrations of the WWTP to the receiving water.
The controls are limited due to the maximum installed
pump and blower capacity.
Using the multi-stage control parameterisation technique described in [4], the continuous optimal control
problem is approximated by a constrained discretetime optimal control problem, that reads:

3.2 Closed-loop problem
The Model Predictive Control (MPC) offers the possibility to merge an optimal control problem solution
into a closed-loop. One substantial advantage in comparison to simple control loops is in the treatment of
constraints for the controls and the state variables. In
this work a nonlinear MPC is considered with an economic cost function. There is no setpoint because of
external input dynamics. The MPC algorithm can be
summerised in the following steps:

h
k
k
J = F(xK ) + ∑ ρke fo,e
(xk , uk , zk ) + fso
f t + (4)
K

k=0

k
k
(xk , uk , zk )
(xk , uk , zk ) + ρko co fo,c
ρks fo,s

i

1. Set: k̂ = 0
2. State estimation: Get the current states x k̂|k̂ using
past measurements, e.g. Nonlinear Moving Horizon State Estimator (NMHSE).
3. Prediction: Get a prediction of the noncontrollable inputs z k|k̂ (reads: inputs at the time
k calculated at the time k̂), k ∈ [k̂, k̂ + K − 1]
for a given horizon K (prediction horizon) using
the process model (summerised description equations (1) - (3)).

with fo,e - electrical energy costs resulting from time4. Optimal control problem: Calculate the future
dependent tariff and electrical energy demand for
control signal uk|k̂ , k ∈ [k̂, k̂ + K − 1] by solving
blower and pump operation, f o,s - sludge disposal costs
an optimal control problem (reference to section
depending on waste sludge flow rate and composi3.1 and equation (4)) with subject to the process
tion, taking into account profit from bio-gas utilisak
model
and the constraints.
tion, co fo,c - chemical dosage costs (negligible), f so
ft
- penalty term for soft constraints (slack variables),
5. Applying: Send the control signal u k̂|k̂ to the proρke , ρks , ρko - weighting factors, xk - model state varicess.
ables, uk - control inputs and zk - non-controllable inputs (e.g. inflow and concentrations).
6. Shift: k̂ = k̂ + 1 and go back to step 2.
The electrical energy costs can be formulated as follows:
Many linear MPC approaches have found successful
applications
and important issues such as online comZ te
fo,e =
c(t) · pel (t)dt
(5) putation, robustness and stability are well addressed.
t0
Within nonlinear MPC, research is still in progress.
with c(t) - time dependent tariff and p el - electrical Therefore, and since the implemented WWTP Jena
energy depending on the air supply into the nitrifica- model has more than 250 state variables with only 10
tion tanks. A linear connection between the electrical measureable outputs, the following application of the
The Modelica Association

353

Modelica 2005, March 7-8, 2005

T. Ziehn, G. Reichl, E. Arnold

Blower for the air supply into tank N(III)

Pump for the sludge recirculation

2.5

2.5
current trajectory
optimal trajectory
constraints

1.5
1
0.5
0
−0.5

1.5
1
0.5
0
−0.5

−1
−1.5

current trajectory
optimal trajectory
constraints

2
Control signal [−1, +1]

Control signal [−1,+1]

2

−1
HT
0

0.5

LT
1
1.5
Time [d]

2

−1.5

2.5

0

0.5

1
1.5
Time [d]

2

2.5

+

Effluent parameter NH4−N

Electrical energy costs
20

2

15

current ammonium
optimal ammonium
constraint

1.5
NH4−N [mg/l]

10

1

+

Costs [EUR/h]

current costs
optimal costs

5

0.5
HT

0

0

0.5

LT
1
1.5
Time [d]

2

0

2.5

0

0.5

1
1.5
Time [d]

2

2.5

Figure 2: Open-loop optimization results (control signals, electrical energy costs and effluent value for NH +
4 -N)
MPC to the model of the WWTP Jena is only considered on nominal conditions. It is assumed that an exact
model of the existing plant is beeing used without any
disturbances and that all state variables are available.
Because of these assumptions the state estimation is
not considered in this work. However, a succesful approach of the nonlinear moving horizon state estimator
to an activated sludge model can be found in [7] and
an application of MPC for an ASM No. 1 can be found
in [8].
For further investigations on the WWTP Jena model
it is advisable to reduce the number of state variables. This can be done for example by using a simple
secondary clarifier instead of a multi-layer secondary
clarifier.
Another simplification is made by assuming that the
non-controllable inputs can be determined exactly and
so the prediction (step 3) is not applied. Only on-line
measured data of the WWTP Jena is used. When applying the MPC algorithm to the real plant investigations regarding the prediction of the non-controlable
The Modelica Association

inputs (inflow and concentrations) are still necessary.
In this context it is also important to examine how prediction errors affect the results of the applied trajectories. The legal limits of the effluent parameters of the
WWTP must always be guaranteed.

4 Results
Primarily dry weather scenarios are considered in the
open-loop investigations. The main point is the minimization of the electrical energy costs taking into account the effluent parameter limits of the WWTP.
Figure 2 shows the results of an open-loop optimization process. The optimal trajectory of one of the
blowers is presented in comparison to the trajectory
resulting from the control by the basic control loops
(Figure 2 upper left). The different electrical energy
tariffs (HT - high tariff and LT - low tariff) are marked
by vertical lines. A piecewise constant approximation of the control variables was chosen to support

354

Modelica 2005, March 7-8, 2005

Application of the Modelica library WasteWater for optimisation purposes

Blower for the air supply into nitrification−tank N(III)
2.5
current trajectory
optimal trajectory
constraints

Control signal [−1,+1]

2
1.5
1
0.5
0
−0.5
−1
−1.5

0

1

2

3

4

5
Time [d]

6

7

8

9

10

+

Effluent parameter NH4−N
2
current ammonium
optimal ammonium
constraint
Rain event →
1

+

NH4−N [mg/l]

1.5

0.5

0

0

1

2

3

4

5
Time [d]

6

7

8

9

10

Figure 3: MPC results (effluent value for ammonium and control signal of the blower for the air supply)
the use of the tariffs more efficiently. In the right
lower part of Figure 2 the effluent parameter of ammonium (NH+
4 -N) is represented. It shows that the chosen upper constraint for ammonium (1 mg NH +
4 -N/l)
becomes active. With optimal trajectories of the blowers the electrical energy costs can be reduced by more
than 10 % (Figure 2 lower right). It is even possible
to achieve a higher reduction of the electrical energy
costs (up to 15 %) by including additional control variables (e.g. the pump for the sludge recirculation, Figure 2 upper right) in the optimization process.
The legal limit for the effluent parameter NH +
4 -N is
about 10 mg/l and therefore much higher than the applied limit of 1 mg/l. However, all investigations are
considered with dry weather scenarios. The limit for
NH+
4 -N is reduced in order to guarantee that the legal limit can be kept even under uncertain conditions.
With a higher limit for NH+
4 -N (e.g. 5 mg/l) the electrical energy costs can be reduced by more than 20 %.
In addition the sludge costs are taken into account and
the control variable responsible for the sludge removal
The Modelica Association

is included in the optimization process. However, it
is necessary to limit the total suspended solids (TSS)
in the secondary clarifier, otherwise too much sludge
would be removed from the whole process. The investigations also consider the bio-gas utilization and the
profit obtained. Further results can be found in [5].
The results of the open loop investigations (due to different scenarios) can be merged with the help of the
Model Predictive Control (MPC) into a closed-loop.
The influence of the prediction horizon and the stepsize on the results is examined. For all further investigations a data record is used, which contains dry
weather data and a rain event.
It can be shown that the prediction horizon is of little importance for optimization results, taking into account the electrical energy costs. Different prediction
horizons from 0.5 days up to 5 days are examined,
with stepsizes from 0.25 days up to 1 day. The results
(electrical energy costs) are nearly the same. Figure 3
shows the results with a prediction horizon of 2 days
and a stepsize of 1 day. The upper part of Figure 3 rep-

355

Modelica 2005, March 7-8, 2005

T. Ziehn, G. Reichl, E. Arnold

resents the control signal of one of the blowers. The
resulting effluent parameter NH+
4 -N is presented in the
lower part of Figure 3. With occurrence of the rain
event (day 8) the chosen upper constraint can not be
kept by using the implemented simple control loops.
Only by applying Model Predictive Control strategies
can the constraint for NH+
4 -N be kept.
In the case of dry weather (day 1 to day 5) it is possible
to save approxamately 11 % on electrical energy costs.
During the entire investigation period of 10 days it is
even possible to save more than 12 % with the optimal
trajectories. The following control variables are taken
into account: the control of the blowers, the control of
the recirculation of the sludge and the control of the
return sludge. With the control of the return sludge
and the recirculation it becomes possible to shift activated sludge at short notice (from the biology into the
secondary clarification and in reverse). However, altogether no TSS is extracted from the process.
Also investigations concerning all costs (electric energy costs and sludge costs) are examined. In this case
the optimization horizon has substantial influence on
the results. The control for the sludge removal is of
substantial importance. In the case that the rain event
is not predicted early enough too much sludge is extracted from the process and with the occurrence of the
rain event it is not possible to keep the necessary cleaning achievements (constraints, e.g. 1 mg NH +
4 -N/l) of
the water since insufficient biomass is available in the
tanks. Only prediction horizons smaller than 6 days
could be investigated since the computer capacity was
exhausted at this point.

5

References

Summery and conclusion

In this work the dynamic optimization method was applied to a WWTP model. With the help of the library
WasteWater an ASM No. 2d model of the WWTP Jena
was examined and evaluated. Different scenarios were
provided and mainly dry weather data were used for
simulation and optimization. The influence of different control variables was investigated by using openloop optimizations. These results could be used in
a closed-loop by applying Model Predictive Control
strategies. It could be shown that regarding the electrical energy costs more than 10 % can be saved in comparision to existing simple control loops. However, to
apply the results and the MPC strategy to the real plant
further investigations are still necessary. The prediction of the non-controllable inputs is not implemented
yet or the state estimation for the state variables.
The Modelica Association

356

[1] G. Reichl. WasteWater - a Library for Modeling
and Simulation of Wastewater treatment plants.
In: Proceedings of the 3rd Modelica Conference,
Linköping, Sweden, Modelica Association, 3-4
November 2003.
[2] M. Henze, W. Gujer, T. Mino and M. v. Loosdrecht. Activated sludge models ASM1, ASM2,
ASM2d and ASM3. Technical report, IWA task
group, 2000.
[3] H. Elmquist et al. Dymola - dynamic modeling
laboratory. User’s manual. Dynasim AB. Sweden, 2001.
[4] R. Franke and E. Arnold. The solver
Omuses/HQP for
structured
large-scale
constrained optimization: algorithm, implementation, and example application, Sixth
SIAM Conference on Optimization, Atlanta,
1999.
[5] T. Ziehn. Untersuchungen zur optimalen
Steuerung der KA Jena mit Hilfe der ModelicaBibliothek WasteWater. Ilmenau, Germany:
Unpublished report, Dept. of Automation and
Systems Engineering, Technische Universität
Ilmenau, 2004.
[6] R. Franke. Formulation of dynamic optimization
problems using Modelica and their efficient solution. Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, 2002.
[7] E. Arnold and S. Dietze. Nonlinear moving
horizon state estimation of an activated sludge
model. In F. G. Filip, I. Dumitrache, and S. S.
Iliescu, editors, Large Scale Systems: Theory
and Applications. 9th IFAC/IFORS/IMACS/IFIP
Symposium, pages 554-559, Bucharest, Romania, 2001.
[8] E. Arnold, S. Dietze, and G. Reichl. Application
of model-predictive control for long-term operation of a municipal wastewater treatment plant.
In K. Konarczak and D. Trawicki, editors, Technology, Automation and Control of Wastewater and Drinking Water Systems, TiASWiK’02,
pages 211-216, Gdansk-Sobieszewo, Poland,
2002.

Modelica 2005, March 7-8, 2005

Session 4c
Tools I

The Modelica Association

357

Modelica 2005, March 7-8, 2005

The Modelica Association

358

Modelica 2005, March 7-8, 2005

Real-Time Simulation of Modelica Models under Linux / RTAI

Real-Time Simulation of Modelica Models under Linux / RTAI
Gianni Ferretti Marco Gritti Gianantonio Magnani Gianpaolo Rizzi Paolo Rocco
Politecnico di Milano, Dipartimento di Elettronica e Informazione
Via Ponzio 34/5, 20133 Milano

Abstract
The paper presents a concept and its implementation
software modules to obtain ready to run real-time simulation code directly from Modelica models. Basically, a Modelica special model building block has
been developed supporting the definition of the realtime input /output variables, their communication with
external tasks or systems (e.g. a real hardware and
software controller), and the scheduling of the periodic
execution of the simulation task. The special module
links to the real-time operating system (Linux with extension RTAI) through a special purpose C library. The
real-time simulation of a 7-DOF space robotic arm is
presented as a test case.

1

Introduction

Simulink and also Dymola [1] models can be interfaced with dSPACE hardware to allow hardware in the
loop simulations. Tools [6] exist also to assist the production of special Simulink models whose simulation
can be run on multi-processor hardware.
On the other side, research efforts are spent to port
the simulators obtained with open-source modeling
tools like MBDyn [3] on real-time [5] possibly distributed platforms, like RTnet [4]. And also, efforts are
spent to generate parallel code from Modelica models [10][11], to be eventually executed on supercomputer platforms [12].
This paper deals with the problem of obtaining ready
to run real-time simulation code directly from Modelica models, so that already available models can be
executed in real-time, and all the powerful Modelica
libraries and the features and tools of a Modelica editor / compiler, such as Dymola, can be exploited for
the development of new models.
The way this goal has been achieved is illustrated in
this paper. In Section 2 the simulation platform requirements and main features are discussed. In Section 3 the proposed real time extension to Modelica
is described. In Section 4 a test case of the real-time
software modules is presented. A detailed open loop
model of the Spider arm, a seven degrees of freedom
Italian space manipulator, is exploited. The real-time
simulated robot arm can also be controlled through
a real-time software controller running on a second
workstation. A short description of this software controller is given in Section 5.

Real-time simulation systems are mainly used for testing and check out of control electronics and other components of complex systems (“hardware-in-the-loop”
simulation), like power plants, aircraft, vehicles, as
well as for training of plant operators, aircraft pilots,
and astronauts.
In real-time simulators model inputs must be acquired
from external devices each sample time and model
equations must be solved within fixed time intervals,
so that a selected subset of computed variables can be
output the next sampling time. To implement real-time
communication with external world and to schedule
model execution exactly each sampling time, the simulation software relies on system primitives whose calls
are added to the model solution code. Usually, an ef- 2 The simulation platform
fort is also necessary to simplify model equations most
2.1 Requirements
demanding from the point of view of computational
burden.
The real-time dynamic simulation software should:
Commercial tools exist that allow to adapt off-line
• satisfy the constraints of periodic real-time exemodels to real-time simulations on dedicated hardcution;
ware. A typical situation consists in porting Simulink
models to dedicated hardware using the Matlab Real
• be able to interface itself with external processes,
Time Workshop [2] or the dSPACE TargetLink [6].
possibly with hardware;

The Modelica Association

359

Modelica 2005, March 7-8, 2005

G. Ferretti, M. Gritti, G. Magnani, G. Rizzi, P. Rocco

• be easily derived from models developed for the order to obtain the maximum processing speed and to
off-line simulation.
avoid the risk of a non convergent solution it is advisable to select the Inline Integration method applied to
the
Implicit Euler algorithm.
2.2 Real-time execution platform
The purpose of obtaining a real-time application imposes the choice of an operating system capable of
supporting the execution of real-time processes.
The Linux operating system extended with the Real
Time Application Interface (RTAI) [7] has been chosen. This operating system supports the execution of
real-time processes, it is open-source, and it is widely
used among the scientific community and in the European research centers.

2.3

Interoperability issues

Many custom libraries are available for Linux / RTAI.
For the purposes of this project, the COMEDI (COntrol and MEasurement Device Interface) [8] library,
developed by the open-source community, is particularly interesting. By means of a set of standard interfaces, COMEDI allows to manage the communication
with hardware boards, and so provides a valid support
for the data exchange on hardware channels. Actually,
a device driver equipped with the COMEDI interface
(see Section 5.2) has been exploited. This driver allows the access to an Ethernet board masking it as an
acquisition board for analog and digital signals.

2.4

3.1 Real-time components
A Modelica component has been developed that allows to transform any Modelica model into a model
suitable for real-time simulation. This Modelica component, is a Modelica block that is called ModRTAI,
and it can be used in the graphical user interface of Dymola as a normal building block of simulation models.
ModRTAI uses a library of functions, called LibRTAI,
which has been also developed within this project. LibRTAI has been entirely developed in the C language
and contains the functions which allow the simulation
code to access the RTAI and COMEDI libraries.
More precisely, by adding to the model development
environment both a ModRTAI component and the LibRTAI library it is possible to perform the activities
mentioned in the project requirements:
• Periodic execution at precise clock ticks of the
simulation task, through access to the RTAI application programming interface;
• Management of the communication with the external world, through access to the interface of a
COMEDI driver.

Real-time model generation

The dynamic models for the off-line simulation were
developed in Dymola [1], a Modelica editor and compiler. In order to make as easy as possible the production of real-time models, it has been investigated the
possibility of deriving the real-time models directly
from the off-line models developed in Dymola. After
having analyzed the features of Dymola, it has been
found possible to use it also for the development and
the compilation of real-time models. So, it is possible
to both reuse the off line models by rapidly adapting
them to the real-time simulation, and to build up some
new model from scratch, with the advantage to use all
the model libraries and the graphical instruments of
such application.

2.5

3 Real-time Modelica extension

Numerical integration issues

The features and the performances of the real-time numerical solvers available in Dymola have been analyzed in order to determine the most appropriate algorithm for the case study. It has been found that in

The Modelica Association

3.2 Porting a model to real-time
By means of the two modules which have been developed it is possible to obtain a Modelica model suitable
for real-time simulation under Linux / RTAI. Given an
off-line Modelica model, the ModRTAI block allows
to select the signals which are input to the model (to
be acquired from the external world), and the signals
which are the output of the model (to be sent to the external world). The ModRTAI block also allows to set a
parameter that states the frequency of the periodic task
running the simulation. This parameter indicates how
much time is left to the numerical solver to evaluate the
transient related to one sampling interval. Only if such
parameter is equal to the sampling interval, the simulation time should match the physical time elapsed since
the instant in which the simulation itself was started;
otherwise the simulation time develops slower than the
physical time of a factor equal to the ratio between the

360

Modelica 2005, March 7-8, 2005

Real-Time Simulation of Modelica Models under Linux / RTAI

task scheduling period and the sampling step of the
transient.
The Modelica model has to be compiled with Dymola under Linux, having selected the Inline Integration option and the Implicit Euler as integration algorithm. The functions library LibRTAI should be installed on the workstation onto which the model is
compiled. The simulator which is generated in such
way is called Dymosim, as a normal simulation binary
file obtained by means of compiling with Dymola a
Modelica model. The only difference is that the Dymosim binary obtained in such way is runnable in soft 1
real-time under Linux / RTAI. Figure 1 resumes the
steps for porting a Dymola model into real-time.

tion. The Ethernet board, equipped with drivers with a
COMEDI interface, emulates a data acquisition board,
as described in Section 5.2.
The entire procedure has been tested using a model
of the Spider robotic arm with detailed descriptions
of motors and transmissions (see Section 4), which
was developed in a former research [14][13]. In this
model the outputs are the seven motor positions, while
in input the model receives the seven motor current setpoints, and a digital signal controlling the brakes that
in the home position block the motors axes. Experimental results about the performance of the Dymosim
real-time simulator obtained with this model will be
illustrated in Section 4.

Figure 2: The simulation process execution cycle.
Figure 1: Development of a real-time Modelica model
using Dymola
3.3
In order to allow the data exchange with external processes, the Dymosim simulator should be run on a
workstation on which the COMEDI library is installed,
and the drivers of the peripheral board onto which
should flow the data signals in input and output to
the simulator are installed too. By now, the simulator has been tested using an Ethernet communication
board, which directs the signals to another worksta1 In Linux / RTAI a hard real-time process runs in the Linux
kernel space and has more strict timing constraints, while a soft
real-time process runs in the Linux user space and has more loose
timing constraints. In Section 4 it is explained why the soft realtime solution has been preferred.

The Modelica Association

The simulator process

The real-time execution of the simulation code has the
purpose of computing, at the chosen frequency, the solution that represents the evolution of the model state.
The output of the model should be passed to an external control unit, which could be another workstation
running the control procedure, or a dedicated hardware controller. The control system, on the basis of
the received data, computes a control action that is sent
to the workstation on which the real-time simulator is
running. The simulator evaluates the new model state
on the basis of the received input. This elementary cycle, illustrated in Figure 2, is executed till the end of
the simulation.

361

Modelica 2005, March 7-8, 2005

G. Ferretti, M. Gritti, G. Magnani, G. Rizzi, P. Rocco

Figure 3: Modelica scheme of the transmission of the real-time Spider robot model.
At every wakeup of the periodic process, the simulator
has to evaluate within a maximum time span 2 the next
model status, and the corresponding outputs. This time
span is equal to the scheduling period of the simulator
process. Since the control loop should be closed on
a digital (either hardware or software) regulator, it is
mandatory that at any wakeup the simulator process is
fed with inputs sampled at a constant frequency, and in
the same way it yields as output some signal sampled
at a constant frequency. This leads to the necessity to
use a fixed step algorithm for the numerical integration, just as the Implicit Euler algorithm is.
As it has been said in Section 3, in order to synchronize with real-time a standard Dymosim process, and
in order to exchange the model inputs and outputs with
the external world, some calls to the external C functions implemented in the LibRTAI have been added in
the ModRTAI block. These functions are:

If initial() or terminal() are true in the Modelica code, RTAIGetData(...) respectively performs the initialization or the finalization of the the
real-time process associated with Dymosim; otherwise
such function performs the real data exchange and then
it suspends the process.
During
the
initialization,
the
RTAI
rt_task_init(...)
function
is
called
to initialize a new RTAI task, and the RTAI
rt_task_make_periodic(...)
function
is called to make this task a periodic one. Other
RTAI APIs are called to set the real-time scheduler, and to initialize and start the RTAI timer at
the chosen frequency. During the finalization, the
rt_task_delete(...) function is called, and
the RTAI timer is stop. During a normal periodic call,
the RTAI rt_task_wait_period() is called at
the end of RTAIGetData(...) in order to suspend
the periodic task.

• RTAIGetInputSample(...)

4 Experimental results

• RTAIGetData(...)
• RTAIPutOutputSample(...)
At every step, when the numerical solver tries to solve
all the equations of the model, these three C functions are called in this order. The first and the third
ones assign the external input variables to the vector
of model inputs, and the vector of model outputs to
the external output variables. By means of these two
functions, the data are only put in some internal buffer
of the LibRTAI module. Instead, the real data exchange with the external process / hardware is done
by RTAIGetData(...).
2 There is no way to set a constraint on a Dymola numerical
integrator forcing it to yield a result at every step within a physical
maximum time. The missed deadline is checked by comparing the
theoretical time in which the result should have been yield with
the time in which the Dymosim process has actually released the
control.

The Modelica Association

As it has been said in Section 3.2, the proposed system has been tested on a detailed model of the Spider robotic arm [13][14] consisting of a total of more
than 12,000 equations listed at compile time. The
robot model includes a seven degrees of freedom mechanical chain, built with the old Modelica MultiBody
library, and an array of seven servomechanisms, each
of which featuring the dynamics of a brushless twophase motor, an analog current controller, an elastic
transmission with backlash and a brake on the motor
axis. A detailed scheme of the elastic transmission
used in the servomechanisms is shown in Figure 3.
The tests have been done running the simulation on a
workstation, and a control action playback on another
workstation. More precisely, the control action was
not computed during the simulation, but it was a record
of the control action of a simulated control system dur-

362

Modelica 2005, March 7-8, 2005

Real-Time Simulation of Modelica Models under Linux / RTAI

ing an off-line simulation of the same command given
to the robot. The real-time model has been tested on a
3GHz Pentium IV workstation with 512Kb of 2 nd level
cache. This processor ensures enough computational
power to simulate the model with an integration step
of 1ms3 and a wakeup period of 1.5ms for the corresponding scheduled process.
It has been experienced an average of 1% of faults,
i.e. periods in which the simulator has not been able
to evaluate the corresponding model transient. The
graph in Figure 4 shows the CPU time not used by
the simulator at each period, during the first 2 seconds
of a simulation. A move command was simulated,
and the command execution was started at 1.1s, which
explains why at this instant the free CPU time dramatically decreases.

ing period are a consequence of the beginning of large
transients, due to the motion start, but the continuous
period variation during the movement and also before
the beginning of the movement, are due to the soft realtime nature of the chosen scheduler.

Figure 5: Dymosim task scheduling interval. Simulation time (in seconds) on x-axis; scheduling interval
(in seconds) on y-axis.

Figure 4: CPU idle time during simulation. Simulation
time (in seconds) on x-axis; CPU idle time (in seconds)
on y-axis.
This result proves that the model is still not ready to
be simulated in a time equal to the physical time on
the testing workstation, since the transient computation occupies half of the CPU time if the robot is still,
but practically all the CPU time if the robot is moving. In order to reach the purpose to simulate with a
scheduling period of 1ms, it is mandatory to simplify
the model, or to use a more powerful workstation.
The graph in Figure 5 shows the physical time span
between two subsequent process wakeups in the same
simulation as before. Figure 6 shows a detail of the
graph in Figure 5. The maximum variation of the
wakeup period is of 40%, while the average variation
is of 1.34%. The picks of variation in the schedul-

The choice of a soft real-time scheduler has been imposed by the nature of the executable binary code generated by Dymola. In fact, the Dymosim native code
executes some operating system calls that do not exploit the RTAI API4 . The OS calls of Dymosim impose
a continual switch from a real-time context to a non-

3 This is equal to the sampling frequency of a typical axis control cycle of an industrial robot controller.

4 For example, all mathematical functions in the numerical integrator do not call the RTAI API.

The Modelica Association

Figure 6: Dymosim task scheduling interval: detail.
Simulation time (in seconds) on x-axis; scheduling interval (in seconds) on y-axis.

363

Modelica 2005, March 7-8, 2005

G. Ferretti, M. Gritti, G. Magnani, G. Rizzi, P. Rocco

realtime context. If the simulator is declared hard realtime at process startup, the continual context switch is
from hard real-time to non-realtime, while if the simulator is declared soft real-time at process startup, the
continual context switch is from soft real-time to nonrealtime. The first kind of switch is much more time
consuming than the second kind, and leads to worse
performances.

5
5.1

Real-time control
The software control application

Within the same project framework, a real-time software control system [16] has been developed which
emulates several functionalities of robot controllers.
This control application can be easily adapted to interact with simulations of robotic arms driven at joint
level. Thanks to the adoption of COMEDI drivers
(which have standard interfaces, as stated in section
Section 5.2), the control system can control without
distinction a physical system, or a model based simulation of the system itself, provided that the two systems
have the same number of input and output channels,
disposed in the same order.
The software control system can be coupled with the
real-time simulator, and each one of these two applications can be used as test bench when adding new
features to the other one. So, the software control system can be used to test new and more refined robot
models, and to analyze their behavior, if compared to
the behavior of the corresponding real robot, while the
real-time simulator can be used to test some innovating
control solutions, without taking the risk of damaging
the robot hardware.
The Linux / RTAI operating system has been chosen
for the control application too, for the same reasons
explained in Section 2.2. To support the design of
the control application, the OROCOS (Open RObot
COntrol Software) [9] framework has been chosen.
The control application is by now capable of executing the position control in joint space for a six 5 degrees of freedom robot. The OROCOS control application can execute a standard control cycle, with
signals exchanged in Real-Time with the controlled
system; moreover, it can publish the variables internal to the controller and the signals received from the
controlled process. Internal variables are published to
non-realtime applications external to the controller, for

reporting purposes. Also, the OROCOS control application can accept the robot motion commands from
a program script, or from some external non-realtime
application.

5.2 The closed-loop data acquisition
Both the control and the simulation applications
should be able to transmit and to acquire signals on
a hardware communication channel. In order to make
any application unaware of the presence of hardware
or software on the other side of the control loop it
has been decided to implement COMEDI drivers for
the communication boards. The COMEDI package
has been chosen because it is an open-source product widely used in the field of automation. Indeed
COMEDI provides a standard for drivers of DAQ
(Digital AcQuisition boards) under Linux.
A COMEDI driver for 3COM 3C90x(B) [15] Ethernet
boards and a COMEDI driver for COMAU BIT3 AT
CARD [15] boards of the COMAU C3G-9000 controller have been developed. Both boards are accessible from real-time processes: the first one is used by
now for the data exchange between the OROCOS control system and the Dymosim simulated process, while
the second one (whose driver is still in a test phase)
will be used for the data exchange with all robots supported by the COMAU C3G-9000 controller.

6 Conclusions and future work

A design concept and the related implementation software for obtaining real time simulation code from
standard Modelica / Dymola models and related software has been presented. They permit to develop
ready to run real time simulation code by fully exploiting the powerful libraries and tools that Modelica / Dymola make available for the model development phase.
The real time simulation of a detailed model of a 7DOF space arm has been afforded as a test bench for
the software, and has proved its versatility and correctness.
With reference to the class of mechatronic systems
models, additional work has to be spent to speed up
model execution by refining or simplifying models of
those phenomena that most affect the computational
burden, like, for instance, non linear friction at low
speed. Indeed, while the model exploited for the actual tests can be simulated in a time which is of the
5 Due to this limitation, the cross tests with the Spider model same order of magnitude of physical time on a highhave been done blocking the seventh joint of the robot.
end mono-processor system, models including friction

The Modelica Association

364

Modelica 2005, March 7-8, 2005

Real-Time Simulation of Modelica Models under Linux / RTAI

equations are much slower and cannot be proposed for [9]
the purposes of real-time simulations. An alternative
approach would be to move on a multi-processor platform, provided that a Modelica compiler tool for par[10]
allel code generation is adopted.

Acknowledgments

OROCOS - Open Robot Control Software
[Online]. Available: http://www.orocos.
org/
Aronsson P, Fritzson P. Parallel Code Generation
in MathModelica / An Object Oriented Component Based Simulation Environment (Conference
paper). In Proceedings of the Parallel / High Performance Object-Oriented Scientific Computing
Workshop, POOSC01 at OOPSLA01, Tampa
Bay, Florida, USA, 14-18 October, 2001.

The authors would like to thank the Italian Space
Agency and the Ministry of Instruction, University,
and Research for the support to this research, in relation to the I/R/217/02 ASI contract and the OASYS [11] Aronsson P, Fritzson P. Multiprocessor Scheduling of Simulation Code from Modelica Modproject.
els (Conference paper) in Proceedings of the
2nd International Modelica Conference, DLR,
References
Oberpfaffenhofen, Germany, Modelica Association, 18-19 March 2002.
[1] Dymola Multi-Engineering Modeling and Simulation [Online]. Available: http://www. [12] Nyström K, Aronsson P, Fritzson P. GridModdynasim.se/
elica - A Modeling and Simulation Framework
for the Grid (Conference paper). In Proceed[2] Real-Time Workshop: Generate optimized,
ings of the 45th Conference on Simulation and
portable, and customizable code from Simulink
Modelling, Copenhagen, Danemark, Scandinamodels [Online]. Available: http://www.
vian Simulation Society, 23-24 September 2004.
mathworks.com/products/rtw/
[13] Ferretti G, Gritti M, Magnani G, Rocco P, Viganò
[3] MBDyn - MultiBody Dynamics Software
L. Object-Oriented Modeling of a Space Robotic
[Online]. Available: http://www.aero.
Manipulator. In Proceedings of the 8th ESA
polimi.it/˜mbdyn/
Workshop on Advanced Space Technologies for
Robotics and Automation 2004, Noordwijk, The
[4] RTnet - Hard Real-Time Networking for Linux /
Netherlands, ESTEC, 2-4 November 2004.
RTAI [Online]. Available: http://www.
rts.uni-hannover.de/rtnet/
[14] Viganò L. Modellistica del Braccio Robotico Europa con Analisi del Controllo nello Spazio Op[5] Attolico M, Masarati P. A Multibody User-Space
erativo [in Italian]. Milano, Italy: Master’s TheHard Real-Time Environment for the Simulation
sis, Politecnico di Milano, 2003.
of Space Robots. In Proceedings of the 5th RealTime Linux Workshop 2003, Valencia, Spain, [15] Minazzi P. Sviluppo di Driver COMEDI in AmReal-Time Linux Foundation, November 9-11,
biente Linux / RTAI [in Italian]. Milano, Italy:
2003.
Master’s Thesis, Politecnico di Milano, 2004.
[6] dSPACE - Solutions for Control [Online]. Avail- [16] Cappellini S, Consonni A. Progetto e Realizable: http://www.dspaceinc.com/
zazione di un’Applicazione Real-Time a Componenti per il Controllo di Robot Manipolatori [in
[7] Cloutier P, Mantegazza P, Papacharalambous S,
Italian]. Milano, Italy: Master’s Thesis, PolitecSoanes I, Hughes S, Yaghmour K: DIAPMnico di Milano, 2004.
RTAI Position Paper. In Proceedings of the
2nd Real-Time Linux Workshop 2000, Orlando,
Florida, USA, Real-Time Linux Foundation, 2730 November, 2000.
[8] COMEDI - The Linux Control and Measurment
Device Interface [Online]. Available: http://
www.comedi.org/

The Modelica Association

365

Modelica 2005, March 7-8, 2005

The Modelica Association

366

Modelica 2005, March 7-8, 2005

SCICOS: a general purpose modeling and simulation environment

SCICOS: a general purpose modeling and simulation environment
M. Najafi‡ , S. Furic, R. Nikoukhah †‡

Abstract
Partial support for Modelica is now provided by the
general purpose dynamical system simulator Scicos.
In particular it is now possible to use component models in Scicos diagrams where the dynamics of the component has been described in Modelica. This paper
presents this new extension of Scicos.
KEYWORDS: Dynamic system simulation; Simulation
software; Component level modeling; Scilab; Modelica

1

Figure 1: A system modeled in Scicos.

Introduction

Scicos is a Scilab1 toolbox for modeling and simulation of dynamical systems [1, 2]. Scicos provides
a hierarchical graphical editor for the construction of
complex dynamical systems, a simulator and a code
generator. For many applications, the Scilab/Scicos
environment provides a free open-source alternative to
Matlab/Simulink and MatrixX.
Very general dynamical systems, including hybrid systems, can be modeled in Scicos [3, 4, 5, 6]. A typical
Scicos diagram is presented in Fig. 1. This diagram
is used to evaluate the performance of an observer by
simulation; the simulation results are given in Fig. 2.
The model of Fig. 1 is composed of ”explicit” blocks,
i.e., block with explicitly identified inputs and outputs.
Modeling with such blocks is called system level modeling. Component level modeling, on the other hand,
allows the use of ”implicit” blocks which are blocks
with port connections which a-priori are not labeled
as inputs or outputs [7]. Implicit blocks are essential
for constructing models which include physical components such as resistors, capacitors, etc., in electricity, or pipes, nozzles, etc., in hydraulics. They are also
useful in many other areas such as mechanics and ther

IMAGINE (www.amesim.com)
† Corresponding author (ramine.nikoukhah@inria.fr)
‡ M. Najafi, R. Nikoukhah are with INRIA-Rocquencourt, Domaine de Voluceau, 78153 Le Chesnay Cedex, France
1 Scilab is a free open-source software for scientific computation, see www.scilab.org and www.scicos.org.

The Modelica Association

Figure 2: Simulation result of model of Fig. 1 in Scicos.

modynamics. In Modelica community implicit blocks
are called acausal [13].
Contrary to explicit blocks, implicit blocks cannot be
modeled as black box objects. The equations realizing the behavior of an implicit block must be available
to the compiler for system reduction and code generation. To describe the behavior of these blocks in Scicos, the Modelica language has been adopted.

367

Modelica 2005, March 7-8, 2005

M. Najafi, S. Furic, R. Nikoukhah

2

Modelica and Scicos

developed using Modelica language. As shown in the
flowchart, if the model contains an implicit block, afEven though Modelica is a rich language having the ter a series of automatic preprocessing steps, implicit
capacity to handle continuous-time and discrete-time part of model is abstracted into a standard block with
behaviors, for the start, we are mainly using Modelica explicit input/outputs; the resulting model can then be
and implicit blocks to model continuous-time dynam- simulated by Scicos [7].
ics; only minimal support is provided for discrete-time
Block Construction level
behavior. The discrete-time behavior, in the Scicos enMODELICA
xd=f(x,u)
vironment, is provided via explicit blocks.
y=g(x,u)
Language
The addition of implicit blocks has been done without
changing significantly Scicos formalism. Even though
implicit blocks can be used anywhere inside a Scicos
Standard Blocks
Implicit Blocks
Toolbox
diagram, they are grouped and replaced with a single
block in a precompilation phase [7]. The mechanism,
which can be compared to the way an amesim 2 or
Model design
Design level
Dymola3 model is integrated in Simulink, is completely transparent to the user.
All blocks
are standard?

No

Create modelica model
of the implicit part

Yes

Modelica to C translator

Create a new block

Incrementally linking the
new block with scicos

Figure 3: Scicos diagram containing both types of
blocks.
Consider for example the Scicos diagram in Fig. 3.
Here we have a fluid level control system. To model
this system in a natural way, a hydraulic source, a regulated valve, a container, a tube, and a well have been
used. The container has a built-in level sensor which
makes the interface with the explicit part of the system,
similarly the valve is regulated through an input signal
from the explicit part of model. The controller and the
display mechanism have been implemented using explicit blocks and the blocks in gray are implicit blocks
that have been developed in Modelica language.

compiling scicos diagram

Simulation

Compile level

Simulation level

(ODE/DAE solver)

Figure 4: system flowchart

2.2 Available implicit toolboxes
2.1

Scicos architecture

To illustrate our method, a simple flowchart given in
Fig. 4 shows how Scicos and Modelica interact. A
designer can select blocks from either standard or implicit toolboxes. Blocks in implicit toolbox have been
2 www.amesim.com
3 www.dymola.com

The Modelica Association

To be able to use implicit blocks in addition to explicit ones in Scicos, several new features have been
added to Scicos. So far, only two palettes with implicit
blocks are available for testing purposes: the electrical and the thermodynamics palettes. The thermohydraulic toolbox and available blocks are shown in
Fig. 5.

368

Modelica 2005, March 7-8, 2005

SCICOS: a general purpose modeling and simulation environment

block having explicit inputs and outputs. Then it generates a Modelica code expressing the behavior of the
new block and save it in a temporary file. This file
is then processed by modelicac 4 which translates
this Modelica code into a C-code describing the behavior of the new Scicos block. Once the C-code is
compiled and incrementally linked in Scilab, Scicos
sees this new block as a standard explicit block; see
Fig. 7. At the end of this procedure, the model is no
longer implicit because all blocks are standard explicit
blocks, so the model can be compiled and simulated
as usual. It should be noted that this procedure is completely transparent to the user [7].

Figure 5: Thematic toolbox

2.3

New link and port type

Implicit blocks or components are interfaced via special links associated with physical quantities such as
current or voltage in electronics, or, flow or pressure
in hydraulics. It would be meaningless for a link representing a voltage to be connected to another link representing the output value of a PID controller. To distinguish between these two, two different link types
have been defined: explicit and implicit links that interconnect explicit and implicit ports respectively. In
Fig. 6 we have a hydraulic container which has four
implicit ports (marked IP) representing liquid outlets
and an explicit port (marked EO) representing a liquid
level sensor output.

Figure 7: In a precompilation phase, all implicit blocks
are grouped to form an explicit block.

2.5 New numerical Solver
Most of the time, after generating C code for implicit part of the model, we end up with a set of
Differential-Algebraic Equations (DAE) that no longer
can be integrated via ordinary differential equation
solvers. It is for this reason that the DAE solver
DASKR [8, 9, 10, 11, 12] has been incorporated into
Scicos.

3 Modelicac, a Modelica compiler
Figure 6: An implicit block can have implicit and ex- Modelicac (acronym of ”Modelica compiler”) is a
plicit ports.
compiler for the subset of the Modelica language we
felt necessary to handle in order to cover the needs of
simulating hybrid models under Scicos. Modelicac is
2.4 Compiling a mixed diagram
an external tool, i.e. it is independent of Scilab, so
4 A Modelica compiler and C code generator written in
To compile and simulate a model containing implicit
blocks, Scicos groups all implicit blocks into a single Objective Caml and included in the Scilab distribution.

The Modelica Association

369

Modelica 2005, March 7-8, 2005

M. Najafi, S. Furic, R. Nikoukhah

one may use it like an ordinary compiler e.g., like a C
compiler. By default, modelicac comes with a module
that generates C code for the Scilab target. However,
since modelicac is free and open source, it is possible
to develop a code generator for another target.

Modelica file
generated by scicos

Modelica
Libraries

*.mo

*.moc
"Close" model

3.1

Modelicac development
"Open" models

Modelicac has been developed in Objective Caml 5
which is a functional programming language developed at INRIA since 1985. This language is distributed with two compiler-development tools (i.e.,
Ocamllex and Ocamlyacc) that offer some nice facilities to build compilers. Furthermore the Objective
Caml compiler is free and open source, that’s why we
adopted it to develop modelicac [16].

3.2

Internal Flat Model

Simplification

Code generation

Modelica compilation using modelicac

*.c

Modelicac is invoked for two purposes: compiling basic models from libraries and generating code for the
target simulation environment. To fulfill the first task,
like generating an object file with a C compiler, modelicac is invoked with the appropriate options from the
command line to generate an object file with ”*.moc”
extension to be used later. The second task of modelicac is compiling the ”main” Modelica model (here
provided by Scicos) and generating a code for the target (here, a C code). In this phase instead of generating
an object file, modelicac performs several simplification steps to generate a code as compact as possible. In
Fig. 8 a simple flowchart shows how modelicac generates a C file from modelica model of a Scicos diagram.

3.3

Supported Modelica subset

Modelica
compilation

Figure 8: Modelicac translation flowchart
3.3.1

Modelica source files

Modelica source files must contain only one class declaration, introduced either by the ”class” keyword or
by the ”function” keyword. So a Modelica source file
may define one of the following things:
An ”open” model is a model with free variables.
There are more variables than equations (e.g. the
model of a resistor in electrical library). The open
models are introduced by the ”class” keyword,
A ”close” model is a model with equal number of
variables and constraints. It is also introduced by the
”class” keyword,
An external function, introduced by the ”function”
keyword.
Of course, only closed models can be simulated. In
order to find classes in the host file system hierarchy,
it is required that the name of the file be the same as
the name of the enclosed class. To compile the ”close”
model modelicac searches the libraries used in the current compilation directory and also in user-defined directories.
The following source code describes a simple resistor
enclosed in a ”Resistor.mo” file:

As said previously, the current version of modelicac
(1.x.x) does not handle the full set of Modelica language constructs. It actually allows only the description of physical models at ”equation” level. A physical model is built as the aggregation of sub-models
or basic types with constraints between variables, and
explicit event declarations (”When”). Currently modelicac has the following main limitations:
Only ”Real” data type is supported.
Inheritance is not currently supported.
”Algorithm” is not supported but it can be defined
as an external C function.
class Resistor

Pin p, n;
parameter Real R "Resistance";

5 caml.inria.fr

The Modelica Association

370

Modelica 2005, March 7-8, 2005

SCICOS: a general purpose modeling and simulation environment

whose nodes on the right represent constraints between variables (i.e., equations). There is an edge
between a left-side node and a right-side node if
and only if the variable represented by the leftside node appears in the equation represented by
the right-side node.

equation
R*p.i = p.v - n.v;
p.i = -n.i;
end Resistor;

An instance of ”Resistor” has two ”connectors” (”p”
and ”n”), that have their own potentials and flows variables (here, the voltage and the current, respectively).
A resistor has also a resistance parameter imposed by
the component through the first equation. The second
equation simply states that the current that flows in the
resistor through ”p” is equal to the current that flows
out through ”n”.

3.4

3. Giving the edges an orientation depending on the
results of the previous step. Edges that link two
coupled nodes are all oriented in a given direction
(either left-to-right or right-to-left) and the other
ones in the opposite direction.

Model simplification

The following tasks are fulfilled by modelicac to simplify and generate a C source file from a Modelica
source code and library object code files:
Obtaining a flat model by replacing an aggregation of sub-models by the set of all their variables
and equations merged together and replacing connection equations by ordinary equations. Symbolic manipulations in modelicac are performed using classical
acyclic graph manipulation techniques
Simplification of trivial or unnecessary equations using symbolic manipulations e.g. in the following system

cos  x  sin  y 	 0

 x 
 sin  y 	 0
cos

z
 x
 y 0
f  x  y z  v  0
the first two equations are fully non-linear and only
the numerical solver can solve the system for x and y.
But the third equation is trivial and z can be obtained
in terms of x and y, so in the rest of equations z is
replaced by x  y. Most of the variables used to connect Modelica components (”connection variables”),
are eliminated in this way.
Causality analysis, i.e. computation of system’s Jacobian matrix. It will be explained further.
3.4.1

2. Finding a coupling (using the Ford and Fulkerson
method for instance)

Causality analysis

Causality analysis performs a few operations in order
to find the so-called ”strongly connected components”
of a system of equations viewed as a directed bipartite
graph [13]:
1. Constructing a bipartite graph whose nodes on
the left represent variables in the system and
The Modelica Association

4. Finding strongly connected components in the resulting oriented graph (using Tarjan’s algorithm
for instance)
5. Sorting the resulting nodes in a topological order.
Each strongly connected component represents a subsystem of the whole system and it is now possible to
perform symbolic simplification steps in order to reduce the number of variables in the system.
3.4.2

Modelicac simplification strategy

Symbolic simplifications typically involve variants of
the Gauss method (to solve linear systems) and simple symbolic simplification methods based on a set of
predetermined patterns (for efficiency reasons) to try
to solve the remaining equations. In modelicac we focused on the second class of simplification methods.
The problem when trying to solve a set of non-linear
equations is to determine a coupling in the bipartite
graph described above that triggers as many simplifications as possible. So the Ford and Fulkerson (or
equivalent) method is not enough for our purposes: instead of taking the first encountered coupling, we want
in addition that the coupling satisfy a given criterion
(e.g. maximizing the potential number of simplifications in the system). Hence the use of a variant of the
Hungarian method which can be seen in modelicac as
a method for finding a coupling based on an additional
constraint called the ”satisfaction”. Practically, that is
done in modelicac by associating a set of pairs (variable, weight) with each equation: given an equation,
each weight indicates whether the equation is ”easy” to
solve with respect to its associated variable or not. For
instance, if an equation contains only one variable, the
weight associated with that variable is low whereas the

371

Modelica 2005, March 7-8, 2005

M. Najafi, S. Furic, R. Nikoukhah

weight associated with any other variable is infinite.
p.v = 0;
end
Ground;
Since modelicac associates low weights with variables
that appear in linear systems, the Hungarian method
”discovers” linear systems by itself and symbolic sub- class Capacitor
Pin p, n;
stitution techniques, when applied to those linear sysReal v;
tems, achieve the same effect as Gaussian elimination.
Real i;
Even though we did not consider the Gaussian elimiparameter Real C "Capacitance";
nation algorithms in modelicac, we got good results.
equation

3.5

C*der(v) = i;
v = p.v - n.v;
0 = p.i + n.i;
i = p.i;
end Capacitor;

A complete (yet simple) example

First, we present the Modelica source code of a few
electrical models from electrical library and then show
how to use these models to construct and compile elabclass Inductor "Ideal electrical inductor"
orated electrical models with modelicac.
Pin p, n;
3.5.1

Real v;
Real i;
parameter Real L "Inductance";
equation
v = L*der(i);
v = p.v - n.v;
0 = p.i + n.i;
i = p.i;
end Inductor;

Connectors

In Scicos libraries ”connectors” are the most basic
open models. Each particular domain (e.g., electrical,
hydraulic, etc.) has a its own connectors that connect
two or more models and exchange quantities. The are
two connector types:
Internal connectors, that allow connection of two
Modelica components, such as ”p” and ”n” pins used
class VsourceAC "Sin-wave voltage source"
in electrical resistor model.
class Pin
Real v;
flow Real i;
end Pin;

External connectors, that allow communication of
a Modelica component with an external environment
(Explicit part of model in Scicos environment, for instance). Instances of ”InPutPort” and ”OutPutPort”
are examples of these connectros types
class InPutPort
input Real vi;
end InPutPort;
class OutPort
output Real v;
end OutPort;

Pin p, n;
Real v;
Real i;
parameter Real VA=220 "Amplitude";
parameter Real f=50 "Frequency";
parameter Real PI=3.1415926 "PI";
equation
v = VA*2*PI*f*time;
v = p.v - n.v;
0 = p.i + n.i;
i = p.i;
end VsourceAC;

3.5.3

”Main class”

In order to perform the simulation of an electrical circuit one normally has to describe the circuit using
These types of connectors are used in sensor and actu- Modelica by defining the components involved (i.e.
ator blocks that can be seen in Fig. 3 and 9.
giving their names and the value of their parameters)
and the connections to establish. Then, modelicac
should be invoked with the appropriate options and ar3.5.2 Electrical component classes
guments. This task is done by Scicos, provided that
These models include the ideal resistor, capacitor, in- the appropriate library exist in Scicos;
ductor, sinusoidal voltage source and ground.
In fact it is not necessary to write any Modelica code
to build a circuit: one can assemble components using
class Ground "Ground"
the Scicos editor and then Scicos automatically builds
Pin p;
equation
the Modelica source code from the graphical specificaThe Modelica Association

372

Modelica 2005, March 7-8, 2005

SCICOS: a general purpose modeling and simulation environment

number of zero-crossings = 0
I/O direct dependency = false
*/
#include <math.h>
#include <scicos/scicos_block.h>
void rlc(scicos_block *block, int flag)
{
double *rpar = block->rpar;
double *z = block->z;
double *x = block->x;
double *xd = block->xd;
double **y = block->outptr;
double **u = block->inptr;
double *g = block->g;
double *res = block->res;
int *jroot = block->jroot;
int *mode = block->mode;
int nevprt = block->nevprt;
int property[3];
/* Intermediate variables */
double v0,v1;

Figure 9: An electrical circuit modeled in Scicos.

if (flag == 0) {
res[0] = x[1]-xd[0]*rpar[0];
res[1] = x[0]+xd[1]*rpar[1]-x[2];
v1=get_scicos_time();
res[2] = x[1]+x[2]*rpar[3]+sin(6.28318530718*v1*rpar[4])*u[0][0];
} else if (flag == 1) {
if (get_phase_simulation() == 1) {
y[0][0] = x[1]; /* main.B8.vo */
y[1][0] = -x[2]; /* main.B9.vo */
} else {
y[0][0] = x[1]; /* main.B8.vo */
y[1][0] = -x[2]; /* main.B9.vo */
}
} else if (flag == 2 && nevprt < 0) {
} else if (flag == 4) {
x[0] = 0.0;
/* main.B1.i */
x[1] = rpar[2]; /* main.B2.v */
x[2] = 0.0;
/* main.B6.p.i */
Set_Jacobian_flag(1);
} else if (flag == 6) {
} else if (flag == 7) {
property[0] = 1;
/* main.B1.i (state variable) */
property[1] = 1;
/* main.B2.v (state variable) */
property[2] = -1; /* main.B6.p.i (algebraic variable) */
set_pointer_xproperty(property);
} else if (flag == 9) {
} else if (flag == 10) {
v0 = Get_Jacobian_parameter();
res[0] = -rpar[0]*v0;
res[1] = 1.0;
res[2] = 0.0;
res[3] = 1.0;
res[4] = rpar[1]*v0;
res[5] = 1.0;
res[6] = 0.0;
res[7] = -1.0;
res[8] = rpar[3];
res[9] = 0.0;
res[10] = 0.0;
res[11] = sin(6.28318530718*get_scicos_time()*rpar[4])
res[12] = 0.0;
res[13] = 0.0;
res[14] = 1.0;
res[15] = 0.0;
res[16] = 0.0;
res[17] = -1.0;
res[18] = 0.0;
res[19] = 0.0;
set_block_error(0);
}
return;

tion and invokes modelicac to convert Modelica code
into C code. In Fig. 9 there is a model of an electrical
circuit modeled in Scicos. Here is its Modelica class
automatically generated by Scicos:
class imppart_rlc
parameter Real P1=0.0001;
parameter Real P2=0.1;
parameter Real P3=25.0;
parameter Real P4=0.2;
parameter Real P5=50.0;
Inductor
B1(L=P1);
Capacitor
B2(C=P2, v(start=P3));
Ground
B3;
VoltageSensor
B4;
CurrentSensor
B5;
Resistor
B6(R=P4);
VVsourceAC
B7(f=P5);
OutPutPort
B8;
OutPutPort
B9;
InPutPort
B10;
equation
connect (B5.p,B3.p);
connect (B7.p,B3.p);
connect (B2.p,B1.p);
connect (B4.p,B1.p);
connect (B6.n,B1.p);
connect (B2.n,B1.n);
connect (B4.n,B1.n);
connect (B5.n,B1.n);
connect (B7.n,B6.p);
B4.v = B8.vi;
B5.i = B9.vi;
B10.vo = B7.VA;
end imppart_rlc;

}

Conclusion

The use of Modelica in Scicos provides a versatile
For this model modelicac generates a C code. This C modeling and simulation tool.
code is incrementally linked with Scicos to be used as
a standard block.
/*
number
number
number
number
number

References
of
of
of
of
of

discrete variables = 0
variables = 3
inputs = 1
outputs = 2
modes = 0

The Modelica Association

[1] C. Bunks, J. P. Chancelier, F. Delebecque, C.
Gomez(ed.), M. Goursat, R. Nikoukhah and
373

Modelica 2005, March 7-8, 2005

M. Najafi, S. Furic, R. Nikoukhah

S. Steer, Engineering and Scientific Computing [13] P. F RITZSON ,Principles of Object-Oriented
with Scilab, Birkhauser, 1999.
Modeling and Simulation with Modelica 2.1,
W ILEY-IEEE P RESS , 2004
[2] J. P. Chancelier, F. Delebecque, C. Gomez, M.
Goursat, R. Nikoukhah, and S. Steer, Introduc- [14] S.E. M ATTSSON , H. E LMQVIST, M. OTTER ,
AND H. O LSSON , ”I NITIALIZATION OF H Ytion à Scilab, Springer-Verlag, 2002.
BRID D IFFERENTIAL -A LGEBRAIC E QUATIONS
[3] R. Nikoukhah and S. Steer,Scicos a dynamic
IN M ODELICA 2.0”, 2nd Inter. Modelica Consystem builder and simulator, IEEE I NTERNA ference 2002, DYNASIM AB, S WEDEN AND
TIONAL C ONFERENCE ON CACSD, Dearborn,
DLR O BERPFAFFENHOFEN , G ERMANY, 2002,
Michigan, 1996.
PP. 9–15.
[4] R. Nikoukhah and S. Steer, Hybrid systems: [15] R. N IKOUKHAH AND S. S TEER , ”C ONDI modeling and simulation, COSY: M ATHEMATTIONING IN HYBRID SYSTEM FORMALISM ”,
ICAL M ODELLING OF C OMPLEX S YSTEM,
International Conference Automation of Mixed
Lund, Sweden, Sept. 1996.
Processes:A D P M Hybrid Dynamic Systems,
D ORTMUND , G ERMANY, 2000.
[5] A. Benveniste, Compositional and Uniform
Modeling of Hybrid Systems, IEEE Trans. Au- [16] W EIS , P IERRE , L EROY, X AVIER , Le Langage
tomat. Control, AC-43, 1998.
CAML, 2 ND ED , D UNOD P RESS , 1999
[6] R. Nikoukhah and S. Steer, Scicos: A Dynamic
System Builder and Simulator, User’s Guide Version 1.0, INRIA Technical Report, RT-0207,
June 1997.
[7] M. Najafi, A.Azil, and R. Nikoukhah, Extending
scicos from system to component level simulation, ESMc2004 international conference, Paris,
France, October 2004.
[8] K. E. Brenan, S. L. Campbell, and L. R. Petzold, Numerical Solution of Initial-Value Problems in Differential-Algebraic Equations, SIAM
publication, Philadelphia, 1996.
[9] A. C. Hindmarsh, ”LSODE and LSODI, Two
New Initial Value Ordinary Differential Equation Solvers”, ACM-Signum Newsletter, Vol. 15,
1980, pp. 10–11.
[10] L. R. Petzold, ”Automatic selection of methods
for solving stiff and nonstiff systems of ordinary
differential equations”, SIAM J. Sci. Stat. Comput., No. 4, 1983.
[11] L. R. Petzold. ”A Description of DASSL: A Differential/Algebraic System Solver”, In Proceedings of the 10th IMACS World Congress, Montreal, 1982, pp. 8-13.
[12] P. N. Brown, A. C. Hindmarsh, and L. R.
Petzold, Consistent Initial Condition Calculation for Differential-Algebraic Systems, SIAM J.
S CI . C OMP., NO . 19, 1998.
The Modelica Association

374

Modelica 2005, March 7-8, 2005

Model Validation and the Modelica Language

Model Validation and the Modelica Language
Dr. Richard Dorling
Advanced Dynamic Systems
Datum House, Commerce Road, Lynch Wood, Peterborough, PE2 6LR, UK

Abstract
Model validation is a crucial aspect of the development of any dynamic system that uses computer
aided engineering (CAE).
The ease of applying model validation techniques is
dependent on the structure of the model, and this is
often dependent on the CAE tool used.
The Modelica language is both well-structured, and
independent of any CAE tool. As such it exhibits
many features that make it ideal in the application of
model validation techniques.
This paper considers various aspects of the Modelica
language and how they relate to the implementation
of a model validation tool.
The validation of a vehicle model is presented as an
example of how the features of the Modelica language are used in the validation process.
Finally, future developments of the Modelica language that would enhance the performance of any
model validation tool are identified.

1

Introduction

Model validation should be an essential ingredient in
any dynamic system development that uses Computer Aided Engineering (CAE) methods.
Comprehensive checks against test data should be
made for even the most rudimentary model in order
to identify any errors and invalid assumptions in the
model. These should then be corrected in order to
gain sufficient confidence in the CAE results.
The term ‘model verification’ is used to describe the
process by which the behaviour of the model is
checked against test data.
The term ‘model validation’ is used to describe the
process by which a model, and/or a real system, is
corrected so that the model and system’s performance match.
Model verification is thus a prerequisite for, and an
essential part of model validation.

The Modelica Association

The problems with implementing model validation
stem from the limitations of existing model verification techniques. These revolve around the comparison of simulation results with test data.
1.1

Existing approach to model verification

The comparison of simulation results against test
data can be carried out in two ways: either using time
histories; or using frequency responses/statistical
data.
The comparison of time histories is notoriously difficult due to the following drawbacks:
1. All inputs to the model must be known.
2. Any errors in a model get magnified during
the simulation since they are integrated to
generate future time histories.
3. Any error space, calculated by taking the difference between the real and virtual results,
will not normally have a single minima.
The above drawbacks in model verification mean
that any attempt at model validation must, at best,
utilise slow global optimisation tools. The requirement for assumptions to be made for unknown inputs
will also have a detrimental impact on the model
validation process.
Although the comparison of frequency responses and
statistical data generally overcome these drawbacks,
both methods suffer from two further shortcomings:
1. Lack of resolution.
2. Concealment of non-linear effects by statistical processing or Fourier transformation.
These particular shortcomings result in poor model
verification and therefore subsequent attempts at
model validation will not characterise the complex
behaviour of a dynamic system. This detailed information is vital when analysing system performance.
1.2

Example, a spring-mass system

Consider a mass, on a non-linear spring and damper,
subject to a disturbance input at the free end as

375

Modelica 2005, March 7-8, 2005

R. Dorling

shown in figure 1. This system has a very simple
mathematic representation, and yet highlights all the
limitations of current model verification techniques
and their impact on model validation.
Force

Displacement

1.3

Spring Characteristic

Figure 1: Example dynamic system

For the purpose of this example it will be assumed
that the only measurement made during a test of the
real system is that of the acceleration of the mass.
Considering the use of time history methods, and
assuming the input to the system is known, it can
immediately be shown that the error space between
the measured and simulated accelerations does not
have a single minima when the mass parameter is
varied (figure 2).
Error = rms(ameasured - asimulated)
80

rms error

60

40

20

0

0.4

0.5 0.6 0.7 0.8 0.9 1 1.2 1.5
simulation mass/actual mass

2

2.5

3

Figure 2: Verification error against mass

Considering frequency response methods, it can be
seen that the frequency response of the system does
not clearly represent the non-linearity of the spring
characteristic, since it is lost within the measurement
noise (figure 3).
Frequency Response

Frequency response

60
40
20
0
-20
-40 -2
10

-1

10

0

10
Frequency (Hz)

1

10

The more complex a system, the more problematic
the limitations associated with current model verification techniques become.
These limitations mean that implementing a model
validation technique for a complex dynamic system
is almost impossible.
In order to develop a proper method for model validation, a robust model verification technique must
first be developed that does not exhibit any of the
drawbacks described above.
A new approach to model verification

The limitations of current model verification techniques all stem from the fact that it is the results of a
model simulation that are compared to test data,
rather than the model itself.
Any new approach to model verification must therefore compare the model itself to test data rather than
the outputs of any analysis. This requires that the
model must be independent of the analysis carried
out on that model.
In order to achieve this, the model must be driven
directly by the test data, and not by a set of inputs
predetermined by the formulation of the model.
It is always possible to reformulate any model so that
it can be driven by any arbitrary data, as long as
there is sufficient data measured about the real system; it is just a matter of matching the number of
equations to the number of pieces of information
required to solve those equations.
When model verification is approached in this way,
the requirement to know all inputs to the model is
immediately removed. Instead, these inputs are derived as part of the model verification process.
In addition, the test data to be used can be differentiated and integrated prior to any analysis. As a result,
errors do not get magnified by integration within the
model and error spaces become well-behaved, exhibiting a single minima.
Finally as this approach is not statistical in nature,
and does not use Fourier transforms, non-linearities
are preserved, as is the resolution of the data.
The Modelica language has several features that are
ideally suited to implementing a model verification
technique based on the approach outlined above.
Firstly, the equations of the model can be rearranged
and manipulated as required. Secondly, the Modelica
language includes only information about the model
itself and not the analysis of that model.

2

10

Figure 3: Measured frequency response of system

The Modelica Association

376

Modelica 2005, March 7-8, 2005

Model Validation and the Modelica Language

1.4



A new approach to model validation

The model verification approach outlined in section
1.3 gives a measure of how well the model matches
the physical system. This measure can be thought of
as determining the ‘error’ between the model and the
physical system, and as stated above this measure is
‘well-behaved’ exhibiting only a single minima at
the point where the behaviour of the model and
physical system agree.
The aim of any model validation process is to ensure
that the behaviour of the model of a system matches
that of its physical counterpart. In this approach, this
is achieved by minimising the above error to an acceptable level.
In order to completely validate a model it is necessary to address two distinct issues: parameter identification and model structure development.
Parameter identification is concerned with tuning the
parameters of the model to minimise the error between the model and physical system, whereas
model structure development examines whether
changes to the components or equations of the model
would reduce this error.
By using the model verification approach discussed
above, in conjunction with a fully parameterised
model that allows replacement and updating of its
individual components, it is possible to implement
both parameter identification and model structure
development techniques.
The Modelica language has several features that enable both parameter identification and model structure development to be implemented. This ensures
that a robust and comprehensive method of model
validation can be applied to Modelica models.

For model structure development components must be replaceable with other representations of that component.
 For model structure development the equations of the model must be available in an
accessible form.
The following additional features are necessary for
the control of the model validation process:
 In order to produce a meaningful result from
the model verification analysis, weighting
factors must be applied to quantities within
the model
 In order to control the model validation
process, attributes need to be associated with
the quantities, components and equations of
the model.
2.1

A model in which simulation and/or integration are
integral parts of the model is of limited use when
implementing model validation technologies, as
these models will inherently suffer from the problems outlined in section 1.1.
Although the Modelica language has been designed
to produce models that will be simulated (integrated
against time) the formulation of these models does
not explicitly require this. Furthermore there is no
necessity for the integrators to be included within the
formulation of the model.
Modelica models can therefore be analysed in ways
other than by simulation techniques, such as techniques based on the model verification and validation approaches described above.
2.2

2

Features of the Modelica language
relevant to Model Validation

There are many features of the Modelica language
that make it ideal for implementing the approach to
model verification and model validation described
above. These features are discussed under six headings. The first four relate to requirements identified
in sections 1.3 and 1.4:
 For model verification it is important that the
model is separate from any analysis of that
model.
 For parameter identification the model must
be fully parameterised.

The Modelica Association

Separation of the model and analysis

Model parameterisation

Full model parameterisation requires that any parameter of the model can be given a new value and
the model re-executed, without the need for extensive recompilation. In this way the sensitivity of the
model to parametric changes can be quickly assessed
by the model validation analysis.
Parameters within a Modelica model are identified as
such by the keyword parameter, used in the definition of that quantity. This allows such quantities to
be treated appropriately, and the model checked for
consistency.
This information can also be used to produce a full
parameterisation of the model. Such a parameterisation would require that each parameter of the model
was stored independently of the equations of the
model, rather than hard coded into those equations.

377

Modelica 2005, March 7-8, 2005

R. Dorling

There is no specific requirement in the Modelica
language for models to be parameterised, and therefore this becomes an implementation issue; the language itself carries all the necessary information for
a full parameterisation of the model.
2.3

Replaceable components

Being able to replace the model of a component with
different variations of that model allows different
component models to be assessed as to their suitability to model a particular physical sub-system.
This, in turn, allows intelligent trade offs to be made
between the simplicity of individual sub-component
models and the accuracy of the model as a whole.
Replaceable components have been part of Modelica
since its first documented version. These allow
components or sub-components of a model to be replaced with different variations of the same component. For example a model of a resistor can be replaced with a model of temperature sensitive resistor.
2.4

Availability of model equations in an accessible form

In a Modelica model, components are described by a
series of equations. These equations are written in a
standard form that can be interpreted, simplified and
re-arranged as necessary.
The accessibility to these equations means that
changes to the basic formulation of the model can be
made, and the impact of such changes assessed with
respect to the behaviour of the model.
In Modelica models, equations are grouped together
under the definitions of the components that they
represent. This makes the user-selection of equations to be assessed straightforward.
2.5

The association of weighting factors with
quantities within the model

In order to generate a representative error from the
model verification process described in section 1.3, it
is important that all the errors across the model are
scaled appropriately during the model verification
process. This ensures that all measurement errors
and all modelling errors are treated equivalently,
rather than giving emphases to those quantities with
a high nominal value.
For example, in a car, if both suspension force and
wheel movements were measured as part of a test, it
would be incorrect to assume that an error of 1N in
the suspension force was equivalent to 1m of deflection in the suspension. In fact, it may be more ap-

The Modelica Association

propriate to make 5kN of suspension force equivalent to 10mm of suspension deflection. Weighting
factors of 5000 and 0.01 would therefore be applied
to these quantities respectively. In fact, in most
cases it makes sense to weight a given quantities error by the nominal value of that quantity.
Such scaling values can usually be determined from
the nominal attribute of quantities within the model,
but this is sometimes not the case, as will be discussed in section 4.
2.6

Attributes for control of the model validation process

Control attributes are required to mark quantities,
components and equations as being included or excluded from the model validation process.
In certain situations it does not make sense for a
quantity, a component or an equation of a component
to be assessed as part of a model validation exercise.
For example, it does not make sense to change an
equation that directly implements a physical law,
such as Newton’s Second Law.
In such cases, it is useful to mark these quantities,
components, and equations within the model, so that
they can be automatically excluded from any model
validation analysis.
Annotations, with their relatively free form, are an
ideal way of marking such quantities, equations and
components, and feeding extra information about the
model into the model validation process.
Using annotations in such a way enables all the important information about the validation process that
relates to the model to be contained within the model
itself.

3

Example: Validation of a model of
a Racing Car.

The validation of a model of a racing car against test
data is presented. The technique used is based on the
model validation approach described above.
The model used for the validation exercise is shown
graphically in figure 4.
The data used for the validation is taken from a test
of the car on a chassis dynamic test rig and consists
of data for:
 Forces applied by aerodynamic loading actuators
 Displacements and Forces applied by road
input actuators

378

Modelica 2005, March 7-8, 2005

Model Validation and the Modelica Language






system. In this case therefore, it is most likely that
the error is caused by the front anti-roll bar, however
it may also be caused by the front springs or the rear
anti-roll bar.
The choice of parameter can usually be made using
the sensitivity index and engineering judgement.
This parameter can then be adjusted, either automatically, or by the user, to a new and better value.
A new table of results similar to table 1, but with one
of the modelling errors removed can then be calculated and the next iteration made.

Accelerations of the body and wheels
Forces in the four pushrods
Displacements of the four dampers
Height, roll and pitch of the body of the car

3.2

Figure 4: Model of a racing car.

The model validation technique used here is, in general, an iterative process where the largest causes of
error are removed first, followed by the second largest, and so on. Each time a source of error is removed, other smaller errors become apparent in the
model.
In this example, one iteration of parameter identification and one iteration of model structure development is presented, together with the overall model
validation results.
3.1

Parameter Identification

Using the model verification technique described in
section 1.3, a time history of the error between the
model and measured data can be derived.
This error is analysed with respect to the model, using a cause and effect analysis, to determine which
parameters are most likely to be causing the error
between the model and the physical system. Furthermore the sensitivity of each parameter to the error is also calculated.
Table 1 shows a sample of results of such an analysis.

Model Structure Identification

As an example of the development of the model
structure, the rear dampers of the vehicle will be
considered.
The model of these non-linear dampers includes an
equation that specifies the force generated by each
damper due to the velocity across the dampers.
The characteristics of this equation can be checked
by removing the equation from the model, or turning
the equation off, and treating the force generated by
the damper as a continuous input to the model.
The model verification process will then generate a
damper force against time that minimises the error
between the model and real system.
The true characteristic of the non-linear damper can
be examined by plotting the damper force against
damper velocity. The form of the original equation
can be checked and revised by considering the shape
of this characteristic versus that generated by the
equation it replaced.
The results for the model validation example are
shown in figure 5, with both the left and right
damper characteristics plotted.

Table 1: Results of Parameter Identification analysis
Parameter
Car.Front.AntiRollBar.Stiffness
Car.Front.Suspension.Stiffness
Car.Rear.AntiRollBar.Stiffness


Correlation
0.945
0.856
0.832

Sensitivity
165.7
1443
-40.54





The values in the column labelled ‘correlation’ determine the likelihood that a particular parameter is
causing the error between the model and the physical

The Modelica Association

Figure 5: Identified Damper characteristic

There is good agreement between both the left and
right dampers, and the expected characteristic.
Comparing the verification errors for the model with
the damper equation turned on and turned off enables

379

Modelica 2005, March 7-8, 2005

R. Dorling

the error attributable to that component to be quantified.
3.3

Model Validation Results

In this example model validation, an initial error of
0.3 was reduces to a final error of 0.01. The model
validation process was stopped at this point as it was
decided that the model was of sufficient accuracy for
its intended purpose.
The reduction in error can be broken down into 3
categories, listed in table 2.
Table 2: Errors with model
Error due to incorrect calibration of sensors

0.18

Error due to incorrect parameters

0.07

Error due to invalid assumptions

0.04

4

Future Developments of the Modelica Language for model validation

Although the Modelica language has many features
that make it an excellent choice for modelling systems that will be validated against test data, it was
originally designed for modelling systems to be
simulated. As such there are two areas where small
changes or developments of the language would improve the validation of Modelica models; these are
extensions to the Real attributes and annotation
specification.
Two further issues are discussed: the interpretation
of Modelica models and the pre-resolution of constraint equations. The resolution of these issues
would benefit both model validation and simulation
tools.
4.1

Extension of the Real type, to include a sensitivity attribute

Although weighting factors can be currently entered
using the nominal attribute of Real quantities, there
is no possibility to enter sensitivity values. There are
two cases in which sensitivity is an issue that need to
be properly addressed when applying model validation techniques.
Firstly, some quantities have a large value, but a
small range; for example, damper lengths as measured on racing cars. A damper may have a static
length of approximately 20 cm, but a variation in this
length of between 18 and 22 cm. In this example,
the nominal value of 20 cm should not be used as a
weighting factor for the error in the damper length;
instead a value of 4 cm should be used. If it was

The Modelica Association

possible to attribute a sensitivity of 4 cm to this
quantity, this could be used to weight any errors attributed to the damper length.
Secondly, it is possible to have quantities that although have a large range, are very sensitive to
variations in their value. Good examples of such
quantities are the wheel speeds of a racing car and
the forward velocity of that car. When calculating
the tyre force, using standard models such as Pacejka, the difference is taken between the forward velocity of the car, and the velocity of the tread of the
tyre relative to the vehicle. This gives the slip of the
tyre on the ground. Changes in slip of only 1% of
the speed of the vehicle can result in large forces
being generated by the tyre. In this case the nominal
value for the velocity of the car would be 50 m/s,
whereas the sensitivity should be 1% of this at
0.5m/s.
For simulation tools sensitivity has not been a problem as the equations are all solved to 0, and tolerances, both relative and absolute are used to determine accuracy. However, such sensitivities may be
useful for giving the user a greater degree of control
of tolerances in specific situations.
4.2

Specific annotations for model validation

In section 2.6, attributes for equations and components were discussed. It was noted that the annotation mechanism in Modelica is suited to the requirements of indicating which equations were to be
included in any model validation analysis.
As with the drawing of graphics and icons for components, it would be useful to include any specification of annotations within the Modelica specification, so that all model validation tools could use a
common source of models.
4.3

Interpretation of Modelica models

Another area of development of the Modelica language is to consider whether it is possible to interpret
(or Just-In-Time compile) Modelica models rather
than pre-compile them.
For the purposes of model validation, interpretation
offers many benefits over compilation as changes to
equations within the model can be assessed more
quickly without the need for recompilation of the
model.

380

Modelica 2005, March 7-8, 2005

Model Validation and the Modelica Language

4.4

Pre-resolution of constraints

It is possible in some cases to pre-solve constraint
equations and generate lookup tables for their solutions.For example, a double wishbone suspension on a
race car, if modelled with solid elements, will have 5
states and 4 constraints. These constraint equations
can be easily removed and lookup tables inserted.
This reduces the size of matrices within the model
validation tool and speeds up the entire model validation process.

5

Conclusions

Model validation should be an essential ingredient in
any dynamic system development that uses Computer Aided Engineering (CAE) methods. The
choice of CAE tools should reflect this, and so it is
important with any modelling language development, such as that of the Modelica language, to consider whether the underlying structure of the language is suitable for the implementation of such
techniques.
The Modelica language uniquely combines several
features that make it an excellent base for the implementation of model validation techniques.

References
[1]
[2]

Dorling R.J. ADS Trackside User Manual.
Advanced Dynamic Systems Limited, 2004.
Modelica Association. Modelica – A Unified
Object-Orientated Language for Physical
Systems Modeling – Language Specification, Version 2.1

The Modelica Association

381

Modelica 2005, March 7-8, 2005

The Modelica Association

382

Modelica 2005, March 7-8, 2005

Session 5a
Engines

The Modelica Association

383

Modelica 2005, March 7-8, 2005

The Modelica Association

384

Modelica 2005, March 7-8, 2005

Monte Carlo Simulations for Evaluating Engine NVH Robustness

Monte Carlo Simulations for Evaluating Engine NVH Robustness
John J. Batteh
Michael M. Tiller
Adam Goodman
Ford Motor Company, Research and Advanced Engineering
{jbatteh, mtiller}@ford.com, akgood@umich.edu

Abstract
This paper describes the use of a designoriented engine cycle simulation model in Modelica
for evaluating robustness of engine NVH (Noise,
Vibration, and Harshness) to noise factors. This paper highlights the novel use of the cycle simulation
model for analytic robustness studies using Monte
Carlo simulations. The Monte Carlo simulations
allow the robustness of a statistically significant engine population to be examined upfront in the product development process. The paper also discusses a
flexible, extensible tool that was developed in conjunction with the Modelica models to streamline the
description, execution, and results post-processing
from the simulations.
Keywords: engine cycle simulation; NVH; Monte
Carlo simulations; Fourier analysis

1

Introduction

Engine NVH is typically one of the vehicle attributes that contributes strongly to customer satisfaction and perceived quality [1]. The customer experiences the NVH characteristics of the vehicle via
multi-sensory feedback. Radiated noise, steering
wheel vibration, and seat track vibration are just a
few of the common audible and tactile feedback
mechanisms.
The vehicle NVH characteristics related to the
engine result from the coupling of the dynamic engine torque with the transfer characteristics of the
vehicle. The vehicle transfer function is affected by
many different system-level design attributes, such
as the design of the engine mounts and engine block,
the vehicle frame design, and the vehicle stiffness,
just to name a few. The design of the individual
components and the overall system design are crucial
for the development of a system that meets the functional requirements while maintaining acceptable
NVH characteristics.
NVH evaluation is often performed on hardware components, primarily early prototypes. Due

The Modelica Association

to the cost and limited availability of prototypes
early in the design process, the evaluations are necessarily restricted in scope and usually at the nominal
design. While more extensive evaluations can be
performed on hardware later in the design process,
the impact of the evaluations on the design is often
limited due to the additional cost and potential program timing impact of design changes further downstream in the product development process. Furthermore, evaluating the impact of the manufacturing
process and capability on the vehicle NVH is extremely difficult with prototype hardware due to the
lack of a statistically significant population.
A robust product design requires the evaluation
of the nominal design performance and sensitivity
with respect to noise factors. This paper presents an
analytic approach for evaluating engine NVH robustness to noise factors. The advantages of analytic
NVH evaluation are many. Analytic evaluations are
a cost-effective way of assessing NVH attributes upfront in the design process where changes are most
easily accommodated. In addition to being costly,
"cut and try" hardware experimentation can be extremely resource-intensive and time-consuming.
Analytic evaluations can provide data in a more
timely manner and allow for streamlining the NVH
audits via batch simulations, parallel computing, and
automated data collection and post-processing. Because even the noise factors can be set and accurately measured in the analytic models, the resulting
data can clearly show the impact and interactions
between the various factors.
In addition, an analytic robustness evaluation can easily include the
impact of manufacturing capability on the resulting
NVH, thereby providing the opportunity for an optimal design including the effects of the manufacturing process for a statistically significant population
representative of that in the hands of the customers.
Furthermore, a detailed knowledge of the nominal
design and its sensitivity to noise factors can lead to
the feeding forward of additional requirements or
control actions for the manufacturing process by the
product development team to ensure robust product
delivery to the customer.

385

Modelica 2005, March 7-8, 2005

J. Batteh, M. Tiller, A. Goodman

2

Engine NVH Analysis

Engine NVH can be quantified in many different ways. One typical way of assessing engine NVH
due to combustion torque is via calculation of the
standard deviation of Indicated Mean Effective Pressure (SDIMEP) in the engine, essentially a measure
the variation in the combustion event amongst the
various cylinders. An engine with good NVH characteristics would typically have uniform combustion
and thus similar power output from the various cylinders. However, past work has shown that SDIMEP
does not often correlate well with engine NVH metrics observed by the customer [1]. A new technique
for evaluating combustion variation called Combustion Torque Uniformity [1]-[2] is applied in this
work. This approach examines the frequency content of the engine torque to analyze combustion nonuniformity. This section describes the models and
techniques used to analytically calculate Combustion
Torque Uniformity metrics for a V6 engine subject
to noise factors.
2.1

Cycle Simulation

At the heart of the analytic engine NVH methodology is the cycle simulation model. This model
describes the detailed thermodynamics of the breathing, compression, combustion, and expansion of the
gas mixture. Figure 1 shows the Modelica representation of the GESIM predictive cycle simulation
model [3]-[4].
The details of the cycle simulation submodels
influence the types of noise factors that can be considered in the NVH analysis. The cycle simulation
model used in this study includes the following submodels:
• Multi-zone, predictive combustion based
on thermodynamics and bulk fluid motion
• Pseudo-species formulation with detailed
mixture property calculations for the
thermodynamic media
• Gas exchange across the valves with the
valve lift kinematically determined from
the cam position and the valve lash
• Detailed thermal response models for the
block, head, and piston
• Intake reservoir boundary conditions including the pressure, temperature, and
composition
GESIM has previously been used to simulate cycleto-cycle variability based on factors related to the
physics of early flame development [5].
The Modelica Association

Figure 1. GESIM cycle simulation cylinder

The cycle simulation model shown in Figure 1
can be inserted into predefined engine templates to
simulate multi-cylinder engines [4], [6]. The multicylinder engine templates use a replaceable cylinder model that is instantiated locally. The specific
engine to be simulated is created by extending the
appropriate engine template (i.e. single cylinder, I4,
V6, etc.) and redeclaring the cylinder model. Figure
2 shows the dual-plenum V6 engine configuration
with each cylinder as the GESIM cycle simulation
model shown in Figure 1.

386

Figure 2. V6 (dual plenum) engine configuration

Modelica 2005, March 7-8, 2005

Monte Carlo Simulations for Evaluating Engine NVH Robustness

The test case for the engine NVH simulations is
shown in Figure 3. This model is an extension of our
existing flexible dyno template [4] and has previously been used for detailed powertrain NVH simulations [7]. Figure 4 shows the code required to
modify the dyno template to simulate a V6 engine
with GESIM cylinders. The engine geometry data is
specified by the redeclare of the EngineData
package. The user defines the test conditions to be
simulated by specifying the engine speed, spark timing, and intake conditions via the engine controller.
An additional block was added to the top-level
model to perform the Fourier analysis of the resulting engine torque and will be discussed in greater
detail in the next section.

magnitude (An) and phase (φn) of the nth order harmonic [1] is given by the following Fourier representation:

An cos(nθ i + φ n )

(1)

where θi is the crank angle. The code excerpt in
Figure 5 illustrates the Modelica implementation of
the discrete Fourier transform calculations.
model OrderAnalysis
…

for m in 1:num_order loop
s_sum := 0;
c_sum := 0;
for i in 1:no_pts loop
s_sum := s_sum + waveform_sample[i]*
sin(4*pi*order[m]*(i - 1)/no_pts)*2/no_pts;
c_sum := c_sum + waveform_sample[i]*
cos(4*pi*order[m]*(i - 1)/no_pts)*2/no_pts;
end for;
s_sum_temp[m] := s_sum;
c_sum_temp[m] := c_sum;
mag[m] := if (order[m] == 0 or order[m] == no_pts)
then 0.5*((s_sum)^2 + (c_sum)^2)^0.5 else
((s_sum)^2 + (c_sum)^2)^0.5;
phase[m] := if atan2(-s_sum, c_sum)*rad2deg < 0
then 360 + atan2(-s_sum, c_sum)*rad2deg else
atan2(-s_sum, c_sum)*rad2deg;
end for;
…

end OrderAnalysis;

Figure 5. Code excerpt from order analysis model

The analysis can be performed either on the
torque from a multi-cylinder engine model or via the
superposition of the calculations from individual cylinders. The following equation can be used to calculate the contribution to the engine harmonic from an
individual cylinder based on the cylinder phasing
and firing order:

Figure 3. Engine NVH test case
model EngineNVH
extends DynoSetup(
redeclare package EngineData = MyEngine,
redeclare model CylinderModel = GESIM,

An cos(φ n − ψ i n )

redeclare model Configuration =
V6DualPlenum(redeclare model
CylinderModel= CylinderModel));
…

end EngineNVH;

Figure 4. Code excerpt from engine NVH test case

2.2

Fourier Analysis

The Combustion Torque Uniformity technique
[1]-[2] analyzes the harmonics of the engine torque
waveform. The torque order content above the 0th
order and less than the firing frequency is computed
via Fourier decomposition. The 0th order torque content represents the work done on the crankshaft while
the magnitude of the other harmonics are non-zero as
a result of non-uniform combustion events. The

The Modelica Association

(2)
th

where An is the magnitude of the n order harmonic
for the ith cylinder, φn is the phase of nth order harmonic for the ith cylinder, and ψi is the firing angle
for the ith cylinder.
As an example of a typical engine torque signature, Figure 6 shows the simulated engine torque
from one firing cycle of a uniform V6 engine along
with the torque from cylinder 3. The engine torque
shows the 6 distinct firings and superposition of the
resulting torque pulses from the individual cylinders.
Note that the torque pulse from each cylinder is identical as there was no noise introduced in the geometry or operating conditions for the individual cylinders. Figure 7 shows the simulated engine torque for
the same V6 engine as in Figure 6 but with the intro-

387

Modelica 2005, March 7-8, 2005

J. Batteh, M. Tiller, A. Goodman

duction of noise into the operation conditions such
that cylinders 1-3 are still operating at a stoichiometric air-fuel (AF) ratio of 14.6 while cylinders 4-6 are
now operating lean at AF=16. In comparing both the
engine and cylinder torques from Figure 6 and
Figure 7, it is clear that the resulting torque signatures are different and could lead to the excitation of
different vehicle NVH modes when coupled with the
transfer function of the vehicle. Table 1 shows the
torque harmonics for Cylinders 3 (AF=14.6) and 4
(AF=16) from the engine in Figure 7. Note that the
lean cylinder has lower torque magnitudes as expected.
Engine

120

Table 1. Cylinder torque harmonic calculations

0
0.5
1
1.5
2

Cylinder 3

2.5

Torque [N.m]

90

3

60

Cyl. 4
AF=16

Mag [N.m]

5.64

4.72

Phase [deg]

0

0

Mag [N.m]

20.61

18.81

Phase [deg]

336.3

335.8

Mag [N.m]

7.79

6.10

Phase [deg]

332.7

335.1

Mag [N.m]

17.15

15.98

Phase [deg]

265.9

262.1

Mag [N.m]

14.91

13.57

Phase [deg]

266.7

264.0

Mag [N.m]

14.57

13.36

Phase [deg]

247.9

245.0

Mag [N.m]

10.82

9.55

Phase [deg]

245.6

243.4

30

2.3

0
-30
0

100 200 300 400 500 600 700
Crank Angle [deg]

Figure 6. Torques from a uniform V6 engine

Engine

120

Cylinder 4

90

Torque [N.m]

Cyl. 3
AF=14.63

Torque Harmonics

60
30
0
-30
0

100 200 300 400 500 600 700
Crank Angle [deg]

Figure 7. Torques from a V6 engine with cylinders 1-3
operating at AF=14.6 and cylinders 4-6 at AF=16

The Modelica Association

Methodology

A key advantage to analytical engine NVH
analysis is the ability to evaluate a statistically significant engine population. Rather than simulate a
large number of V6 engines with a multi-cylinder
engine model subject to various noise factors in the
individual cylinders, it is far more computationally
efficient to simulate a large number of single cylinder engines using the Monte Carlo method [8] to
choose the value of the noise factor(s) for each run
and then "virtually" assemble the single cylinders
into a V6 engine. The following methodology was
used to perform the analytic engine NVH analysis
(see Figure 8):
1. For the given engine, build and calibrate the
single cylinder cycle simulation model.
2. For the operating condition of interest, configure the Monte Carlo simulations by determining the noise factors and their distributions (i.e. from manufacturing process capability, etc.).
3. Perform the Monte Carlo simulations with
the single cylinder model to generate a library of single cylinder results.
4. Assemble multi-cylinder engines from library of single cylinder results.
5. Analyze engine population and calculate statistics of interest.

388

Modelica 2005, March 7-8, 2005

Monte Carlo Simulations for Evaluating Engine NVH Robustness

Figure 8. Engine assembly methodology

3

NestedAnalysis Toolkit

While considerable effort is made in these kinds
of analyses to capture the appropriate level of detail
in the models, it is important not to lose sight of the
bigger picture. Ultimately, the simulation of the underlying model is simply a means of generating data.
Such data can then be used in a variety of ways. For
example, frequently models are used as the basis of a
design optimization process whereby the simulation
evaluates perspective designs according to a set of
objectives or constraints.
For this reason, an analysis tool, called the
NestedAnalysis Toolkit, has been developed internally that can be used to construct models of the
complete analysis. The term “nested” refers to the
fact that complete analysis is composed of a hierarchy of other analyses. For example, in quality and
robustness analyses it is quite common to try and
minimize the variation of a products performance
with respect to uncontrollable noise factors.
Figure 9 shows how such an analysis could be
represented graphically. At the bottom of the hierarchy are individual simulations. Each simulation
represents slightly different conditions. The conditions are generated automatically based on statistical
information about the noise factors being considered
and their impact on the inputs to the simulation. After these simulations are completed, the results are
compiled and analyzed to produce statistical information. This statistical information can then be used
in subsequent analyses (i.e. an optimization process
in this case) to minimize the variation.
The construction of these analyses was originally described in Python [9]. The descriptions were
essentially declarative in nature, and the analysis
engine would use the declarative descriptions of the
analysis to coordinate the complete analysis. In order to make the toolkit more useful to end users, a
graphical user interface was developed. Using the
new interface, users constructed the analyses graphically in a hierarchical manner. The goal of the user
interface was to show users a representation that was
intuitive, like the overview shown in Figure 9.

Figure 10 provides screenshots from a sample Monte
Carlo analysis of a Dymola1 [10] transient model, in
this case the TwoMasses example from the Modelica Standard Thermal library.
While support for running simulations generated from Dymola was a key feature of the toolkit,
the toolkit architecture was developed to accommodate a range of different types of analyses. For example, support for using Excel spreadsheets within
the framework was easily added. Furthermore, each
plug-in added to the framework was developed specifically to support each analysis type. So, for example, the support for Dymola simulations was able
to automatically construct lists of input parameters
and results and display them for the user to choose as
either inputs or outputs in the nested analysis. In
addition, the toolkit has an extensible architecture for
adding node analyses. Currently the architecture
supports Monte Carlo analysis, full factorial Design
of Experiments (DOE), and some optimization functionality. The vision is to be able to develop new
analysis plug-ins as needed. Some examples of possible additional analysis plug-ins are sensitivity
analysis, Latin hypercube sampling, and fractional
factorial DOEs.
There is a fundamental philosophical principle
in our toolkit that bears some explanation. We do
not rely on the simulation tools themselves to provide these capabilities. There are two reasons for
this approach. First, we want our analysis capabilities (Monte Carlo analyses, optimization, etc.) to
work with multiple tools, not just Dymola. Furthermore, we do not want to distract simulation tool developers with functionality that we consider to be
“above” the simulator. That being said, we recognize that there are also great advantages to having
these capabilities integrated into a simulation tool as
well.

Figure 9. Building blocks for hierarchical analyses

1

The Modelica Association

389

Dymola is a trademark of Dynasim AB

Modelica 2005, March 7-8, 2005

J. Batteh, M. Tiller, A. Goodman

4

(a) Analysis construction

(b) Monte Carlo factor selection

(c) Output variable selection
Figure 10. NestedAnalysis Toolkit GUI screenshots for
a Monte Carlo analysis of a Dymola transient model

The Modelica Association

Results

The methodology described in Section 2.3 was
used to simulate the effects of valve lash variation in
a sample V6 engine at a fixed operating condition.
Valve lash is an important design variable as it affects the timing and duration of the valve events, the
maximum valve lift, and the overlap between valves.
Thus, it directly impacts breathing, mixture preparation, and combustion. Since there is some variation
in the lash of each cylinder in the assembled engine
due to the manufacturing process, it is highly desirable to understand the NVH effects of this variability
in the engine population.
The NestedAnalysis Toolkit described in Section 3 was used to establish and perform the simulations with Dymola [10]. One hundred single cylinder Monte Carlo simulations were performed with a
normal distribution for the variation in valve lash.
From the library of 100 single cylinder runs, 10,000
V6 engines were assembled and analyzed. Each engine was assembled by randomly choosing 6 cylinders from the library (see Figure 8). To determine an
appropriate number of engines to assemble to represent the engine population, the number of assembled
engines was increased until the overall engine population statistics converged. To examine the sensitivity of the engine population to the process capability,
the Monte Carlo simulations were conducted with
four different standard deviations for valve lash.
Figure 11 shows three of the simulated valve lash
distributions (note that all distributions are normal
but with different standard deviations).
Figure 12 shows the results of the engine population analyses for the various valve lash distributions. Figure 12a-b shows the histograms of the 1.5
order torque in the assembled engine populations for
σ = 0.02 mm and 0.01 mm, respectively. Figure 12c
shows the engine population statistics for 1.5 order
torque. Note that as the standard deviation of the
valve lash increases, there is both a larger mean 1.5
order torque and more variability in the engine population as indicated by the error bars showing ±1σ
levels. Understanding the sensitivity of the engine
population NVH characteristics to valve lash leads to
the ability to optimize the lash centering and manufacturing process capability to optimize engine population robustness. Furthermore, given a specification
on the various torque magnitudes, the analysis would
also yield information as to the fraction of engines in
the population that would meet the specifications.
While the sample simulations shown here considered a single noise factor with a normal distribution, the approach is general and can be used with

390

Modelica 2005, March 7-8, 2005

Monte Carlo Simulations for Evaluating Engine NVH Robustness

multiple noise factors and a variety of distributions.
Currently the Monte Carlo analysis plug-in supports
normal, log normal, uniform, beta, exponential,
gamma, and Pareto distributions, and the additions of
new, user-defined distributions are trivial. Furthermore, simulations with multiple noise factors can be
analyzed with existing statistical techniques to identify main effects and interactions between the factors.

# of Engines

1500

1000
500

0
0

4
6
To rque [N.m ]

s

2

8

10

8

10

(a) σ = 0.02 mm
σ = 0.005 m m
σ = 0.01 m m
σ = 0.02 m m

# of Engines

80

600

70

400

200

60
0

40

2

4
6
To rque [N.m ]

(b) σ = 0.01 mm

30

3
1.5 Order Torque [N.m]

20
10
0

0

es

PDF

50

0.16 0.18 0.2 0.22 0.24
Co ld Intake Las h [m m ]

0.26

(a) Intake lash

2.5
2
1.5
1
0.5
0
0

σ = 0.005 m m
σ = 0.01 m m
σ = 0.02 m m

80

Mean +- Std. Dev.

0.005

0.01

0.015

0.02

0.025

Valve Lash Standard Deviation [mm]

(c) Engine population statistics
Figure 12. 1.5 order torque analysis for engine
population due to valve lash variation

70
60

PDF

50

5

40
30
20
10
0

0.3

0.32 0.34 0.36 0.38 0.4
Co ld Ex haus t Las h [m m ]
(b) Exhaust lash

Figure 11. Simulated distributions for valve lash

The Modelica Association

Conclusions

This paper discusses a methodology for analytical NVH simulations using the Combustion Torque
Uniformity technique. A novel simulation approach
using a design-oriented cycle simulation model and
the Monte Carlo method for simulating the effects of
noise factors allows the robustness of a statistically
significant engine population to be analyzed upfront
in the design process. In addition, the approach allows for multiple noise factors to be simulated according to various distributions to examine design
sensitivities and interaction effects. The ability to
analytically simulate an entire engine population

391

Modelica 2005, March 7-8, 2005

J. Batteh, M. Tiller, A. Goodman

leads to the opportunity for the optimization of the
engine design coupled with the manufacturing process capability to deliver the most robust product to
the customer. Furthermore, the flexible, descriptive
NestedAnalysis Toolkit has been developed to
streamline the description, execution, and results
post-processing from these sorts of robustness studies.

[9]

[10]

the American Statistical Association,
44 (247), pp. 335-341.
Lutz, M. and Ascher, D., 1999, Learning Python, 1st Ed., Cambridge:
O'Reilly and Associates.
Dymola.
Dynasim AB, Lund,
Sweden, http://www.dynasim.com.

References
[1]

[2]

[3]

[4]

[5]

[6]

[7]

[8]

Stout, J.L., Mancini, M., Host, R., and
Hancock, K., 2003, "Combustion Uniformity as a Measure for Engine Idle
NVH," SAE-2003-01-1429, Society of
Automotive Engineers.
Stout, J.L., 2001, "Engine Excitation
Decomposition Methods and V Engines Results," SAE-2001-01-1595,
Society of Automotive Engineers.
Newman, C., Batteh, J., and Tiller, M.,
2002, "Spark-Ignited-Engine Cycle
Simulation in Modelica", 2nd International Modelica Conference Proceedings,
pp.
133-142,
http://modelica.org/Conference2002/p
apers/p17_Newman.pdf
Batteh, J., Tiller, M., and Newman, C.,
2003, "Simulation of Engine Systems
in Modelica", 3rd International Modelica Conference Proceedings, pp. 139148,
http://www.modelica.org/events/Confe
rence2003/papers/h34_Batteh.pdf
Brehob, D.D. and Newman, C.E.,
1992, "Monte Carlo Simulation of Cycle by Cycle Variability", SAE922165,
Society of Automotive Engineers.
Bowles, P. and Batteh, J., 2003, "A
Transient, Multi-Cylinder Engine
Model Using Modelica", SAE-200301-3127, Society of Automotive Engineers.
Tiller, M., Tobler, W.E., and Kuang,
M., 2002, "Evaluating Engine Contributions to HEV Driveline Vibrations",
2nd International Modelica Conference
Proceedings,
pp.
19-24,
http://modelica.org/Conference2002/p
apers/p03_Tiller.pdf
Metropolis, N. and Ulam, S., 1949,
"The Monte Carlo Method", Journal of

The Modelica Association

392

Modelica 2005, March 7-8, 2005

Dynamic Simulation of a Free-Piston Linear Alternator in Modelica

Dynamic Simulation of a Free-Piston Linear Alternator in
Modelica
Sven-Erik Pohl∗ Markus Gräf†
German Aerospace Center (DLR), Institute of Vehicle Concepts
Pfaffenwaldring 38-40, 70569 Stuttgart

Abstract
This paper presents the modeling and simulation of a
novel development of a free-piston engine in Modelica. The investigated concept is a combination of a
combustion process and a linear alternator designed
to provide clean, efficient energy in a compact engine. To study the features of free-piston engines a
Modelica library is outlined containing basic and advanced component models. Detailed sub-models are
investigated in order to design and improve hardware
components. Control strategies are developed and dynamically tested within the Modelica simulation. Dymola/Modelica was found to be the best tool to examine the dynamic system behavior.
Keywords: free-piston engine, linear alternator, power
electronics, control strategies

Figure 1: The free-piston linear alternator concept

These key features allow for designing a combustion
process with low emissions and development towards
homogenous charge combustion ignition (HCCI). The
variable stroke and variable compression ratio can be
used to optimize the combustion process for part load
conditions. The goal is to achieve a compact electric power engine with high efficiency and reduced
1 Introduction
emissions at low costs. The free-piston linear alternator aims towards automotive application as auxiliary
The free-piston linear alternator proposed by the Ger- power unit as well as power generator in hybrid elecman Aerospace Center (DLR) - Institute of Vehicle tric vehicles.
Concepts (IFK) combines a two stroke combustion engine with a linear alternator. An adjustable gas spring
is used to reset the piston assembly (Figure 1). The 2 Modeling Objectives
engine is designed to enable new degrees of freedom
for advanced optimization of the combustion process. At IFK a hardware demonstrator is currently being
built to investigate the functionality of the free-piston
In contrast to conventional crankshaft engines the freelinear alternator. In parallel to the hardware compopiston design offers mainly three degrees of freedom
nents a dynamic simulation model of the complete systo improve engine performance:
tem is developed using Modelica. A Modelica library
is outlined with the following objectives:
• variable stroke
• specify hardware components

• variable compression ratio

• develop control strategies
• variable piston velocity
• analyze the combustion process
∗ sven.pohl@dlr.de

• evaluate operation modes

† markus.graef@dlr.de

The Modelica Association

393

Modelica 2005, March 7-8, 2005

S.E. Pohl, M. Gräf

Figure 2: Modelica assembly of free-piston linear alternator

• design dynamic system behavior
The investigation of the operation modes and their dynamic transitions are of special interest since knowledge of system reaction on changes in the parameters
is not available. Due to Dymolas dynamic modeling
capability parameter influence on stroke, compression
ratio and piston motion are a simulation focus.

3

Modelica Architecture

A Modelica library was outlined to provide basic and
advanced components for free-piston engine modeling. A major scope is the compatibility with Modelica
standard libraries and with future standards of thermodynamic modeling.
The free-piston linear alternator model can be built
from library components. Figure 2 shows the simulation setup. The control systems, the thermodynamic models of combustion cylinder and gas spring
are shown. The electrical system consists of the linear
alternator and the power electronics. On a sub-layer
the physical effects are modeled in detail: The mass
flows into and out of the cylinders can be observed,
the combustion process is modeled, heat transfer effects are investigated and the thermodynamic properties describe the state of the cylinders.
The FixedShape from the Multibody library is
The Modelica Association

extended to visualize the motion of the piston assembly. The cylinder pressures are visualized by changing
the cylinder color. Figure 3 shows the 3D representation of the free-piston linear alternator. The combustion cylinder is shown on the left, changing color during combustion. The linear alternator is shown in the
middle next to the gas spring cylinder on the right. The
animation is not only helpful for presentation purposes
but also enables the developer to analyze the dynamics
of the free-piston linear alternator model.

Figure 3: Modelica visualization of free-piston linear
alternator

3.1

Interfaces

Modelica provides connector definitions for most
physical domains. However, a common thermodynamic connector is not yet available. Thus, pressure
and temperature are the two potential variables, mass

394

Modelica 2005, March 7-8, 2005

Dynamic Simulation of a Free-Piston Linear Alternator in Modelica

flow rate as well as heat flow rate are chosen to be
the flow variables. Additionally, to satisfy multi-phase
flow conditions, the mass fraction for each species is
added. From this information all necessary thermodynamic properties can be calculated. A code fragment
of the connector definition is shown below:
connector CombustionGas
parameter FKLG.Types.NumberOfSpecies nX;
SI.MassFraction X[nX] "Mass fraction";
SI.Pressure P "Gas pressure";
SI.Temperature T "Gas temperature";
flow SI.MassFlowRate mdot "Mass flow rate";
flow SI.HeatFlowRate Hdot "Heat flow rate";
end CombustionGas;

For an ideal gas for example, the number of species
equals one and the mass fraction is consequently unity.

and common equations. Another benefit from this declaration is the use of selection boxes in higher level
models to switch between all models extended from
the base model. In that way the user can change the
setup of complex models by simply selecting different components from a list. At this time gas properties, fuel models, heat transfer models and combustion models are implemented using the base model approach.

4

The free-piston linear alternator model is divided into
the sub-models of combustion cylinder, linear alternator, gas spring and controls. These components are
built from basic thermodynamic components, like control volumes, valves and pipes. Detailed sub-models
concerning heat transfer and piston blowby are added
to the cylinder model. The gas spring model is validated with experimental data. Both, heat transfer and
blowby model are successfully obtained using other
simulation software.

Complex models tend to exchange a fair amount of information leading to components with several connectors and connections. To reduce the connection complexity a bus system is defined as an assembly of other
connectors. Defining a bus currently becomes tedious
since every signal has to be added by hand. The following code fragment shows the bus implementation
for combustion, gas spring and linear alternator:
4.1
connector Bus
import SI = Modelica.SIunits;
import MoIn = Modelica.Blocks.Interfaces;
// Combustion
MoIn.RealSignal c_pressure (redeclare
type SignalType = SI.Pressure);
MoIn.RealSignal c_temperature (redeclare
type SignalType = SI.Temperature);
MoIn.RealSignal c_position(redeclare
type SignalType = SI.Position);
MoIn.BooleanSignal c_burning;
...
// Gas Spring
MoIn.RealSignal s_pressure(redeclare
type SignalType = SI.Pressure);
MoIn.RealSignal s_temperature(redeclare
type SignalType = SI.Temperature);
MoIn.RealSignal s_massflowOut(redeclare
type SignalType = SI.MassFlowRate);
...
// Linear Alternator
MoIn.RealSignal force(redeclare
type SignalType = SI.Force);
end Bus;

3.2 Base Models
Defining base models for components enables the user
to implement further models with the same external connections but different content. Such a base
model may contain variable declarations, connectors
The Modelica Association

Thermodynamical System

Combustion Modeling

Generally, the simulation of combustion is a highly
complex process involving several disciplines such as
thermodynamics, heat transfer, chemical kinetics, and
fluid motion.
Since the compression ratio and the stroke of the freepiston alternator is not constant through out the operation, a major task is to define an appropriate combustion model. To describe the operation modes of the
combustion process it can be divided into several combustion processes with differing strokes and compression ratios. In other words the free-piston linear alternator contains several conventional combustion cylinders with the same diameter but varying stroke and
compression ratio. The challenge is to find a representative physical process that best describes the combustion behavior with a minimum of input parameters
since experimental data is not yet available. Thus,
a rough approximation of the combustion process is
needed. As a starting point the combustion components presented by Tiller [2] can be used. The cylinder gas is modeled as a single phase ideal gas leading to a straightforward formulation of all connected
components such as valves and pipes for the gas exchange. This is not a truly satisfying solution yet and
a more detailed combustion model is currently under
construction.

395

Modelica 2005, March 7-8, 2005

S.E. Pohl, M. Gräf

Figure 4: Electrical system of linear alternator

4.2

5 Mechanical System

Medium Models

Three property models for perfect air, ideal air and
an air/exhaust gas mixture were implemented as
base layer for the gas spring and combustion components using Modelicas replaceable notation.
The air/exhaust gas properties use the correlations by
Zacharias [4]. To reduce computation time the property model was transferred into Modelica.

The mechanical system is represented by the piston
where the equation of motion is solved. Additionally, a
spring-damper system mechanically prevents the piston from reaching the cylinder heads or the cylinder
pressure from rising above a critical value.

6 Electrical System
4.3

Heat Transfer Models

As described in section 3.1 the cylinder wall heat loss
models are extended from a base heat transfer model.
Two basic approaches for the wall heat loss are available. The first handles the cylinder heat loss for idle
running engines based on the approach by Huber [1].
Secondly, for a firing engine, the approach by Woschni
[3] is implemented.

4.4

Orifice Flow Models

A general orifice flow model using the isentropic flow
formulation found in textbooks is extended for valve
modeling.
Commonly, a small gas leakage between piston and
cylinder exits the cylinder. This blowby gas flow is
based on the orifice flow model. The effective area
is implemented as a parameter and is validated using
experimental data in case of the gas spring.
The Modelica Association

The electrical system consists of the battery, the intermediate circuit, the power electronics module and the
electromechanical model for the linear alternator.
The control unit demands a specific force from the linear alternator. This signal is mapped into a set-value iq
for the inverter control. The inverter control generates
PWM-signals for the IGBT-B6-Modul using the dqtransformation. The IGBT is modeled as a diode and
a switch. The free wheeling diode is put in parallel to
the IGBT. The diode itself is described with 3 characteristic curves, a straight line for the negative branch,
a 3rd grade polynomial equation for the forward characteristics and a straight line for describing the system
beyond the normal operation area.
The linear alternator is described with maps for the
flux linkage and the inductance matrix for every position. This data is impressed on the equivalent circuit
of a permanent magnet machine, composed of a resistor, an inductance and a voltage source for the induced
voltage for all 3 phases.

396

Modelica 2005, March 7-8, 2005

Dynamic Simulation of a Free-Piston Linear Alternator in Modelica

The generated force is calculated after a dqtransformation of the real currents with the inverse
F-iq map described in the beginning. As a result
the linear alternator force is simulated under dynamic conditions including all time constants influencing the over-all system. In addition the Modelica inverter control model will be used in combination with the dSPACE box for controlling the constructed hardware. The power electronics are mainly
modeled using the Modelica.Electrical and
Modelica.StateGraph packages.

7

alternator partly in the expansion phase and partly in
the compression phase. Thus, the gas spring is used
as temporary energy storage. This ”force split strategy” also effects the piston motion depending on the
amount of energy converted in each phase. The simulation results presented in this paper are based on an
equal energy conversion in expansion and compression phase. Extracting the energy in both, compression and expansion phase also reduces the linear alternator size and consequently piston weight. The

Control System

Disconnecting the piston from the crankshaft requires
a new approach to system control since the continuous shaft motion is not available. In fact developing
control strategies is the most challenging task in the
free-piston linear alternator design process.

Figure 6: Comparison of piston velocities for crank
shaft engine versus a free-piston linear alternator
variable volume of the combustion cylinder demands
for flexible valve and ignition timing. An ”electronic
camshaft” needs to be implemented to control valve
In conventional engines it is needless to mention that and ignition timing according to the operation mode.
the crankshaft returns the piston to the starting point For that purpose a virtual camshaft angle is introduced
of a cycle. In a free-piston engine the piston not nec- to coordinate the timing issue.
essarily returns to the same point. The piston position
is strongly dependent on the states in the cylinders and
8 Simulation Results
the energy converted by the linear alternator. A piston
motion control is developed by adjusting the converted In the remainder of this section two simulation apenergy of the alternator such that the piston returns proaches are shown investigating the potentials and
to its starting point. To account for all losses occur- challenges of a free-piston engine.
ring during the cycle the cylinder pressures are taken
as calculation basis. It should be noted that the lin8.1 Step 1: Co-Simulation
ear alternator can be actively used to control the piston
motion. Hence, the linear alternator control can accel- In a first step the combustion process is simulated
erate or slow down the piston to either influence the externally and the combustion thermodynamics are
combustion process or prevent the piston from crash- loaded into the free-piston linear alternator model (see
ing.
Figure 5). In an iterative process the result is then
In order to level the power output the energy released used to re-simulate the combustion process until conby the combustion process is converted by the linear vergence. In that way the combustion process can be
Figure 5: Simulation setup for co-simulation

The Modelica Association

397

Modelica 2005, March 7-8, 2005

S.E. Pohl, M. Gräf

simulated in detail with a well validated programm. 9 Conclusions
Due to unknown inlet and exhaust measures only the
high-pressure part of the combustion cycle is investi- Examining the concept of a free-piston linear engine
two main fields of interest for simulation are detected:
gated.
Firstly, the development and testing of solid control
Figure 6 compares the piston velocity of a free-piston
of the free-piston system before applying it to hardlinear alternator in respect to a conventional crank
ware. On a second level the components involved in
shaft engine. As a result of the degrees of freedom of a
the system, namely the gas spring, the linear alternafree-piston alternator the piston velocity is a function
tor and the combustion process can be studied in the
of the system states.
free-piston context.
The fundamental advantage of the proposed free- The dynamic simulation shows promising results. The
piston engine over a conventional engine is empha- system behavior as well as the cylinder conditions
sized by Figure 7. In the left figure a comparison of can be investigated, even when changing the operation
the engines at full load conditions is displayed. Both mode. Developing control strategies is found to be a
processes show about the same performance. How- challenging task since solid piston control and an elecever, in part load conditions, shown in the right fig- tronic camshaft are needed to ensure principle funcure, the conventional engine keeps its stroke and com- tioning of the free-piston assembly. Control models
pression ratio and the maximum pressure is quite low. have been implemented and tested successfully.
Due to the variability of the free-piston linear alter- Hardware components, such as valves and injectors,
nator the stroke is lowered and the compression ratio naturally have dead times which effect their reaction
is adjusted such that the cylinder pressure reaches a time. A predictive control to time the events in adsufficiently high value. The performance in part load vance will be a focus of further development. Addiconditions of the free-piston linear alternator is conse- tionally, future efforts will be made to extend the freequently higher. This first approach shows the potential piston linear alternator model in order to form a solid
of a free-piston linear alternator in terms of combus- model to be built into a hybrid electric vehicle.
tion enhancement.
In order to implement a complex model of the freepiston linear alternator in the different levels of detail,
subcomponents and components were modeled using
Modelica. The system analysis was performed using
Dymola. Both, the language formulation of Modelica
8.2 Step 2: Dynamic Simulation
and the powerful capabilities of Dymola were found to
meet the expectations.
A transient simulation is performed applying the Modelica model shown in Figure 2 and described in the
References
sections above. Similar to many simulation tasks using DAE-solvers the free-piston linear alternator simu- [1] Huber, K. Der Wärmeübergang schnellaufender,
lation needs solid start values. A solution to this task is
direkt einspritzender Dieselmotoren. Dissertation,
to define a starting sequence where the linear alternaTechnische Universität München, 1990.
tor actively follows a fixed path for a few cycles before
switching to a general operating mode. In the start- [2] Tiller, M. Introduction to Physical Modeling with
ing sequence the linear alternator simulates the pisModelica. Kluwer Academic Publishers, 2001.
ton motion of a crankshaft engine. During operation
Beitrag zum Problem des
the system depends on the states in the cylinders and [3] Woschni, G.
Wandwärmeüberganges
im Verbrennungsmotor.
the energy converted by the linear alternator as well as
MTZ, 26, 1965.
the combustion process. The operation mode, e.g. the
power output, can be changed by adjusting the system [4] Zacharias, F. Mollier-I,S-Diagramme für Verbrenvariables during the simulation process. The dynamic
nungsgase in der Datenverarbeitung. MTZ, 31(7),
change in the system variables directly influence the
1970.
operation mode. Figure 8 displays the change of operation mode from full load to part load conditions.
The piston stroke is reduced and the compression ratio
rises while the power output decreases as expected.
The Modelica Association

398

Modelica 2005, March 7-8, 2005

Dynamic Simulation of a Free-Piston Linear Alternator in Modelica

Figure 7: Comparison of combustion pressure at full (left figure) and part (right figure) load conditions for a
crank shaft engine versus a free-piston linear alternator

Figure 8: Piston position (left) and power output for dynamic Simulation

The Modelica Association

399

Modelica 2005, March 7-8, 2005

The Modelica Association

400

Modelica 2005, March 7-8, 2005

Session 5b
Thermodynamic Systems IV

The Modelica Association

401

Modelica 2005, March 7-8, 2005

The Modelica Association

402

Modelica 2005, March 7-8, 2005

Simulation of transient two-phase flow in parabolic trough collectors using Modelica

Simulation of transient two-phase flow
in parabolic trough collectors using Modelica
Dipl.-Ing. Tobias Hirsch Dr.-Ing. Markus Eck Dr.-Ing. Wolf-Dieter Steinmann
German Aerospace Center, Institute of Technical Thermodynamics
Pfaffenwaldring 38-40, 70569 Stuttgart

Abstract
Parabolic trough power plants are a very promising option for the generation of electricity from renewable
energy resources. The Modelica library ’DissDyn’ is
developed to study the transient behaviour of the twophase flow inside the absorber tubes of such plants.
Equations are based on a homogeneous equilibrium
model for the pipe flow with axial discretization. The
advantages of manually transforming the equations
into explicit state space form are shown. The models
are validated with analytical solutions and measured
data. Using test signals for disturbances in solar irradiation important information on the liquid loads on
field separator and drainage system are gained. By
adding feed-forward control schemes it is shown that
these loads can be reduced significantly.
Keywords: solar thermal power plant; two-phase
flow; simulation; renewable energy; absorber tube

from the steam before the entrance into the superheating section. In the current design realized at a DISS
test loop in Almeria (Spain) a maximum of 1.2 kg/s
of superheated steam at 3 to 10 MPa and 400◦ C is
obtained from one collector loop. For the first precommercial power plant with this technology the dynamic behaviour of the system determines the design
of key components like compact field separators and
the underlying drainage system. A dynamical simulation tool based on the Modelica language is developed
to study the effect of irradiation disturbances and to
evaluate different control strategies. For the assembly
of the final system and the numerical integration the
Dymola program is used.
irradiation

pre-heating/evaporation
compact phase separator
recirculation line

1 Introduction
One way of generating electricity from renewable energy resources is the collection of solar radiation to be
used in solar thermal power plants. Today’s only commercially operated solar power plants in the Mojave
Desert in California are based on a parabolic trough
collector field. A synthetic oil is heated in the absorber tube and generates steam of 10 MPa/370◦ C in
a heat exchanger unit. The steam is used to run a
conventional steam turbine. Current research activities [1] are dealing with the direct solar steam (DISS)
generation in the absorber tube itself. Improvements
are expected by omitting the heat exchanger unit and
allowing for higher steam temperatures thus leading
to an increase in turbine efficiency. To avoid material problems caused by an undefined end of the
evaporation section the collector loop is divided into
two sections, see fig. 1. The evaporation section is
run with a water surplus which has to be separated
The Modelica Association

feed water line

condensor

superheater
buffer
turbine

Figure 1: Configuration of a parabolic trough solar
power plant with direct steam generation

2 Two-phase flow model equations
The central part of the model library is the fluid dynamical model of the two-phase flow in the absorber
pipes. In the following the underlying assumptions
and model equations are presented. For complex models it is advantageous and in this case necessary that
the selection of state variables is done by the programmer and not by the symbolic transformation tool Dymola. It is shown that the combination of pressure and
specific enthalpy is the best choice for the state vari-

403

Modelica 2005, March 7-8, 2005

T. Hirsch, W. Steinmann, M. Eck

.
Qext

ables of the fluid elements. The benefits of this manual
selection of states and transformation of equations are

.
Qext

i-1

Tw

• stable and numerically efficient simulation

i

Tw

. i-1
Q

• independence of system assembly

h

h

• reliable initialization procedure

.
m

. i-1
m

• well defined closure equations.

p

h

Conservation equations

BC

Depending on the location along the collector loop different flow regimes are found in the absorber tube.
Starting with single-phase liquid flow in the preheating part the flow changes into two-phase flow as soon
as saturation conditions are reached. In the superheating section the flow is again single-phase. Superheating conditions also occur in the evaporator section when the end of the evaporation section drys out
due to irradiation transients. Therefore the simulation
model must be able to simulate the flow in the three
regimes but also the transition between them. With a
length of about 1000 m pressure losses in each loop
are significant Fluctuations in irradiation cause large
changes in mass flow and, as a consequence, in absolute pressure in the field. For this reason it is necessary to use pressure-dependent properties for the fluid.
It is assumed that the flow is homogeneous over the
pipe cross-section. In the two-phase region equal velocities and temperatures of water and steam phase
are assumed (homogeneous equilibrium model). The
simulation model is intended to study effects resulting from mass and energy transport which are much
slower than the propagation of changes in pressure.
Therefore infinite velocity of propagation is assumed
for the pressure. This reduces the momentum equation
to a stationary momentum balance for frictional pressure losses. The fundamental equations for conservation of mass, energy and momentum for the control
volume shown in fig. 2.1 thus yield
∂ρ ∂
+ (ρw) = 0
∂t ∂z
∂
Q̇
∂
(ρu) + (ρwh) =
∂t
∂z
V
∂p
= ∆p .
∂z
The system is completed by the energy equation
AW ρ W c W

TW
= Q̇ext − Q̇
∂t

i

h

p
i-1

i

p
i

i

r T

. i+1
m
i+1

p
i+1

i+1
r T

i

element i-1

i+1

i+1

z

BC

Figure 2: Three control volumes for pipe flow.

2.2

Selection of states

Two variables are sufficient to fully describe the state
of the fluid element. The careful choice of the state
variables is of essential importance since it determines
the structure of the final system of equations. For this
work the state variables pressure p and specific enthalpy h are chosen for the following reasons. All
fluid properties can be expressed as a polynomial function of p and h. Using temperature T instead of h
is not possible since temperature and pressure are directly linked in the two-phase region. The steam fraction ẋ can not be used since it is not defined in the
single phase regions. Friction losses cause a conversion of mechanical into thermal energy while the sum
of both h = u + p/ρ stays the same. By using specific enthalpy as a state, pressure loss terms can easily
be defined by just changing the pressure and leaving h
constant. The most important advantage of this selection is that spatially discretized systems will result in a
set of de-coupled equations while a choice of e.g. mass
flows and specific enthalpy leads to a coupled system.
Using the fluid property functions
ρ = ρ(p, h)

(5)

u = u(p, h)

(6)

(1) and average fluid velocity
(2)

w=

ṁ
0.25 π d 2 ρ

(7)

(3) the system of equations (1) to (2) can be rewritten explicit in the time derivatives
(4)

for the surrounding pipe wall.
The Modelica Association

. i+1
Q

.i
m

r T

2.1

i+1

Tw

.i
Q

i-1

i-1
i-1

.
Qext

404

∂h
∂t
∂p
∂t

=

fh h, p, Q̇, ṁ

=

fp h, p, Q̇, ṁ




(8)
.

(9)

Modelica 2005, March 7-8, 2005

Simulation of transient two-phase flow in parabolic trough collectors using Modelica

From these equations explicit state space form can be For the calculation of the saturation temperature Anobtained by replacing ṁ with an inverse pressure loss toine’s law
relation and Q̇ with a correlation for heat transfer.
TB
T0 =
(22)
p  − TC
TA − log10 100

2.3

Fluid properties

Properties of fluids are defined for three regions, namely single phase water (region 1), twophase water-steam (2) and single-phase steam (3) in
the range 3 MPa < p < 12 MPa and 100 ◦ C < T <
500 ◦ C. Since state variables p and h are pre-selected
all properties can be expressed as polynomial function
of these variables. In the two-phase region the steam
fraction x is defined as
h − h0
x = 00
.
(10)
h − h0
with the specific enthalpies at saturation implemented
in polynomial form
h0 (p) = a0 + a1 p + a2 p2 + a3 p3
h00 (p) = A0 + A1 p + A2 p2

.

with the constants TA = 8.1, TB =1656.39, TC =223.2 is
used.
To complete the set of fluid property functions polynomial approximations for the dynamic viscosity, specific heat capacity, heat conductivity and surface tension have been derived for both phases. These quantities are needed for the calculation of pressure losses,
and heat transfer coefficients. Table 1 gives an
overview on the order of the polynomials and the accuracy achieved. High accuracy is desired for saturation enthalpies to reduce the errors in calculating very
small steam fractions.

(11) Table 1: Polynomial order of property functions and
accuracy in the range 3...11 MPa, 500...3500 kJ/kg
(12)

The density in liquid and gas phase is approximated
by polynomials of pressure and enthalpy
ρl (p, h) = b0 (p) + b1 (p) h + . . . + bn (p) hn (13)
ρg (p, h) = B0 (p) + B1 (p) h + . . . + Bn (p) hn(14)
with the coefficients
bi (p) = bi,1 + bi,2 p + . . . + bi,m pm
Bi (p) = Bi,1 + Bi,2 p + . . . + Bi,m p

m

(15)
. (16)

Note that for the homogeneous model the steam fraction x based on the control volume is the same as the
steam quality ẋ based on the mass flows of the two
phases. The mixture density in the two-phase region is
then given by

−1

1
1
1
ρ(p, h) =
(17)
+
x
−
ρ0
ρ00 ρ0
ρ0 = ρl (p, h0 (p))
(18) 2.4
ρ

00

Variable
h0
h00
ρl
ρg
ηl
ηg
λl
λg
cp,l
cp,g
Tl
Tg
σ (T 0 )

Order in p
3
3
3
2
2
1
2
2
2
2
1
3
3

Order in h

2
3
4
2
3
3
3
4
3
3

Rel. error
0.2%
0.02%
2%
0.5%
1%
1%
1%
1%
1%
1%
0.5%
0.5%
1%

Spatial discretisation

00

= ρg (p, h (p)) .

(19) Regarding the whole collector loop, mass flow and
This approach guarantees a continuous transition be- specific enthalpy at the inlet and pressure at the outlet
tween the three regions. The calculation of tempera- are given as boundary conditions. For the spatial disture as function of pressure and enthalpy requires that cretization of equations (8) and (9) an upwind scheme
for a fixed pressure exactly the same temperature is ob- is applied for mass flow and specific enthalpy. Prestained when approaching the saturation line from the sure losses are concentrated downstream of the control
liquid region and the gas region. For this reason poly- volume. Thus the equations yield for control volume i
nomial approximations are set up relativ to saturation

∂hi
conditions,
= fh hi , hi−1 , pi , Q̇i , ṁi , ṁi−1
(23)
∂t

Tl (p, h) = T 0 + c0 (p) + c1 (p) (h − h0 ) + . . . (20)
∂pi
= fp hi , hi−1 , pi , Q̇i , ṁi , ṁi−1
. (24)
0
00
∂t
Tg (p, h) = T +C0 (p) +C1 (p) (h − h ) + . . .(21)
The Modelica Association

405

Modelica 2005, March 7-8, 2005

T. Hirsch, W. Steinmann, M. Eck

2.5

Pressure loss

The mass flow terms in equations (23) and (24) have
to be expressed as function of the state variables. This
is realized by the inverse pressure loss relation
i

ṁ = ṁ

i

i

p, p

i+1

,h

i



.

(25)

To avoid implicit equations a pressure loss correlation
which can be solved analytically for ṁ is used [2].

2.6

Heat transfer

The heat flux Q̇ between wall and fluid is defined with
the wall temperature TW and the fluid temperature T in
control volume i
Q̇i = αi π d l TWi − T i



.

(26)

MassFlow
m dot
h
p

[kg/s]
[J/kg]
[Pa]

mass flow
specific enthalpy
pressure

AmbData
t amb
v wind
alpha wind

[◦ C]
[m/s]
[deg]

ambient temp.
wind speed
wind direction

SolarIrr
altitude
azimuth
I Dir
I Diff

[deg]
[deg]
[W/m2 ]
[W/m2 ]

altitude angle
azimuth angle
direct irradiation
diffuse irradiation

ParabolIrr
cosphi(n)
alpha tr(n)
I Dir(n)

[-]
[deg]
[W/m2 ]

cos(φ)
track angle
direct irradiation

The heat transfer coefficient α can be calculated in
This list is completed by the standard Modelica
terms of the state variables
Signal connector. All fluid-dynamic components
can be linked using the same connector MassFlow.

αi = αi hi , pi , ṁi
(27) This connector is based on the definitions in the
TechThermo library developed at the institute [5]. The
i
other
three connectors are used to transfer information
with ṁ given in equation (25).
on solar irradiation and related quantities like incident
Replacing mass flow and heat flow terms in equaangles.
tions (23) and (24) the final simulation equations in
explicit state space formulation are obtained

3.2
∂hi

=

fh hi , hi−1 , pi , pi−1 , pi+1 , TWi

Solar irradiation models



(28) The transformation of direct irradiation coming from
the sun into heat flux on the absorber tubes can be sub
= fp hi , hi−1 , pi , pi−1 , pi+1 , TWi
.(29) divided into three steps as illustrated in fig. 3. In the
SolarIrradiation model altitude and azimuth
angles of sun position are calculated based on the day
of the year, time of day and geographical latitude and
3 The DissDyn library structure
altitude. This component is prepared for the implementation of functions predicting the intensity of diThe library contains fluid-dynamic models for two- rect as well as diffuse solar irradiation throughout the
phase flow in heated pipes as well as models for day. At present, the magnitude of direct irradiation is
components like tanks, phase separators, valves and specified by an external signal source.
pumps. Models are added to convert the direct normal In the second stage the irradiation finally reaching the
irradiation into a heat flux on each absorber section.
individual collector is reduced by cloud coverage or
by taking the collector out of focus. In the model
ParabolicField the position and orientation of all
collectors
in the field is stored which is used to calcu3.1 Connector definitions
late the optimum track angle and the resulting incident
There are four different types of connectors currently angle for each collector individually. The magnitude
of direct irradiation specified via the SolarIrr condefined in the library:
∂t
∂pi
∂t

The Modelica Association

406

Modelica 2005, March 7-8, 2005

Simulation of transient two-phase flow in parabolic trough collectors using Modelica

I_Dir[n]
cosphi[n]
alpha_tr[n]

azimuth
altitude
I_Dir
I_Diff

Absorber 2
3

2

Absorber 1

AmbData

(only absorber)

Parabolic
Field

1

2

3

4

5

6

7

8

9

...

n

MassFlow

Absorber i

ParabolIrr

Solar
Irradiation

MassFlow

1

Signalsource

Figure 5: Structure of absorber and pipe model

y
s

coverage 1
0
x

vcloud

collector field

Coll 1

Coll 2

...

Pipe 1-2

Coll n

MassFlow

MassFlow

Figure 3: DissDyn-components used to model the path
represent one collector. A row of collectors is comof solar energy from sun to absorber tubes
posed of a number of identical collectors and their interconnecting pipes. For convenience reasons a model
nector is reduced by a cloud coverage and focus infor- collector Row is defined which holds a set of
mation of the collector. The focus signal of each col- absorber and pipe models connected in series. All
lector (range 0 to 1) can be read via the Modelica sig- relevant geometrical parameters for the absorber
nal connector. Varying cloud coverage is represented and pipe model can be defined in this top level
using an one-dimensional cloud coverage signal that model. The irradiation and ambient data information
can be moved with arbitrary speed and direction over is passed to each component as depicted in fig. 6.
the collector field as shown in fig. 4
ParabolIrr
AmbData

Figure 6: Collector Row model as a collection of
absorber and pipe models

one-dimensional
cloud field

3.4

Figure 4: Cloud coverage

Fluid system components

The final stage is the transformation of irradiation The set of fluid models is completed by fluid system
reaching the collector into the effective heat flux on components like
the absorber tube. This task is implemented in the
• phase separator
absorber model where efficiency data for the individual collectors are stored.
• T-junction for flow combination and distribution

3.3

• control valve

Absorber and pipe models

The model equations for two-phase flow in pipes presented in section 2 are used to construct models for
simple pipe flow and for the flow in absorber pipes
of parabolic trough collectors. The spatial discretization can be defined by the number n of axial elements along the pipe section. This is shown schematically in fig 5. For the computation of heat losses
the ambient temperature is given via the AmbDataconnector. The absorber models have another connector ParabolIrr by which information on actual
irradiation, incident angle and theoretical track angle
is provided. Since these values are constant along
one collector each absorber model is intended to
The Modelica Association

• pump
• tank .
Except of the phase separator model all of these components are based on stationary conservation of mass
and energy.

3.5

Control system components

To implement control functionality Modelica control
models and specialized models are used. These models are linked by Modelica Signal connectors. Although these models can in principle be constructed

407

Modelica 2005, March 7-8, 2005

T. Hirsch, W. Steinmann, M. Eck

∆ ha [kJ/kg]

from Standard Modelica blocks new models are de- fer function is derived by Laplace transformation of
fined in order to have direct access to all relevant vari- the change in specific enthalpy at the outlet. While the
ables within one model.
simulation with just one element has large deviations
from the analytical solution a much better agreement
is obtained with high resolution of 20 elements indi4 Validation
cating the consistence of the simulation model.
Comparison in the time domain plottet in fig. 8 shows
The validation of the fluid dynamic models is done in that for high resolution nearly exact agreement is obtwo steps. First the simulation results with different tained. This means that the remaining deviations in
spatial discretization are compared with analytical solutions available under special assumptions like con0.4
stant pressure. Since these assumptions are not valid
0.3
in the real system a direct comparison with measured
analyt.
0.2
data from the DISS test loop is needed in the second
20 elements
5 elements
0.1
step.
1 element

0

4.1

0

10

Analytical models

amplitude and phase angle at frequencies of more
than 1/s are not serious for the system since the contribution of these frequencies is very small. Although the
resolution with 20 elements gives nearly exact agreement the simulation with 5 elements is also very close
to the analytical solution.

−1

10

−2

10

1.5
1
0.5

−3

10

1500

−4

10

−5

1550
t [s]

1600

4
0.1

1

10

100

0
phase in °

2
mass flow [kg/s]

0

10

−120

3
2
1

−240
−360
0.001 0.01

30

Figure 8: Step response to a 1% change in irradiation
for a 20 m two-phase flow absorber

mass flow [kg/s]

amplitude [Jm 2/kgW]

Under some assumptions the set of conservation equations can be solved analytically by Laplace transformations [3], [4]. Using the same simplifications for
the simulation the correct implementation and consistence of the simulation model can be checked.
Fig. 7 shows a comparison of transfer function in
terms of amplitude and phase response for a 20 m absorber pipe section under two-phase conditions. For
this comparison the reaction to a 1% step in irradiation with a spatial resolution of 1 element and 20 elements have been simulated. The corresponding trans-

10
0.001 0.01

20
t [s]

0.1
1
10
frequency in 1/s

3600

3800
t [s]

4000

100

Figure 9: Simulated step response to changes in irradiation of -500 W/m2 at t=1500 s and +500 W/m2
at t=3500 s. 100 m evaporator section with resolution
Figure 7: Transfer function of a 20 m two-phase ab- of 2.5 m (-), 10 m (- -), 33 m (-.-), 100 m (. .)
sorber section: calculated with analytical model (-),
simulated with discretization 1 element (- -), 10 ele- In Fig. 9 simulation results are shown for a 100 m
ments (· · ·)
evaporator section with large changes in irradiation.
The Modelica Association

408

Modelica 2005, March 7-8, 2005

Simulation of transient two-phase flow in parabolic trough collectors using Modelica

These results are obtained without the simplifying assumption of constant pressure. The curves show that
the result with the coarse resolution of 10 m is quite
close to the one with fine resolution. Comparisons are
preformed for the preheating and superheating section
as well giving similar results.

4.2

Comparison with measured data

change of intensity ∆I. The time constant of the collector system is closely linked to the residence time in the
boiler section. Since the residence time for an 800 m
boiler is approximately 700 s a series of short disturbances provokes an overlap of the system reactions.
By using the test signal with three ramps the effects of
this overlap can be studied. On the other hand, if long
intervals are chosen a single isolated disturbance can
be analyzed.

Especially the assumption of constant pressure along
the absorber is not fulfilled if multiple collectors are
connected in series. The comparison with the analytical models on the basis of constant pressure is therefore not sufficient to validate the model. For this task a
direct comparison with measured data from the DISS
test loop is performed for several test days. As an example the reaction of the 500 m collector row (425 m
preheater/evaporator, 75 m superheater) to irradiation
fluctuations is shown in fig 10 in terms of inlet pressure, steam mass flow and steam temperature.
Though there is a small deviation in the absolute value
of inlet pressure the dynamic behaviour is well predicted. Steam production and temperature are in good
agreement which is also observed in the other test configurations. Both the check with analytical models and
the direct comparison with measured data show that
the model assumptions, especially the homogeneous
equilibrium model are valid for this application.

DNI W/m2

1000

The Modelica Association

500
250

pressure inlet [bar]

0
14

steam [kg/s]

15

15.5

40
35
30
14.5

15

15.5

14.5

15

15.5

15

15.5

0.6
0.4
0.2
0
14
350

steam temp. [°C]

14.5

45

25
14
0.8

5 Transient simulation of a collector
loop
The simulation model is used to simulate the reaction
of a collector loop to changes in irradiation. Since the
dynamical behaviour is dominated by the amount of
liquid evaporated, the 800 m boiler section alone is
analyzed in the first step with the superheater replaced
by an adequate pressure loss term. Constant boundary
conditions for feed water flow and enthalpy as well
as recirculation flow and enthalpy are imposed at the
collector inlet. At the outlet of the field the pressure is
fixed at 7 MPa.
Using measured irradiation data as input for the simulation is not useful when looking on general system
behaviour. Moreover comparison of results with other
researchers requires the same set of input data. This is
avoided if a simple test signal is chosen which represents the main characteristics of real irradiation disturbances. In this work three single disturbances in series
are used as a test signal, see fig. 11. This signal is defined only by the two parameters interval length ∆t and

750

325
300
275
250
14

14.5
time [h]

Figure 10: Measured (-) and simulated (· · ·) DISS
plant operation on June 26, 2001. Spatial Resolution 10 m.

5.1

Simultaneous disturbance on all collectors

Fig. 12 shows the simulation results in terms of steam
and water mass flow at the exit of the evaporator section. Irradiation disturbances act simultaneously on

409

Modelica 2005, March 7-8, 2005

T. Hirsch, W. Steinmann, M. Eck

Dt

Dt Dtr

Dtr

I0
DI

t0

t

Figure 11: Test signal of three consecutive irradiation
disturbances.

system while irradiation is reduced. With increasing steam production this additional water is blown
out and causes temporarily high liquid mass flux. In
the ∆t=30 s case two peaks appear in the water mass
flow signal. The first one immediately after irradiation increases and the second one with a delay
of about 700 s just before stationary conditions are
reached. While for short intervals (∆t=30 s, 120 s) the
second peaks of the three disturbances overlap and
form one large peak the single peaks can be identified for longer interval length (∆t=240 s). The maximum in liquid flow reached in this configuration is
about 2.5 kg/s which is 8 times the nominal value. This
results are very important to define the operating conditions for the layout of the compact field separator
and the underlying drainage system.

water [kg/s]

steam [kg/s]

all 8 collectors of the boiler. Three studies with three
different interval lengths are carried out. The intensity for short interval length is 100%, for long intervals only 70% in order to avoid reverse flow in the
pipes. From the steam signal it can be seen that it
takes about 700 s after the last disturbance to reach
again stationary conditions. With a maximum interval
length of 240 s all curves represent a superposition of 5.2 Local disturbances
individual reactions.
Small clouds can cause a local shading of just a num2
ber
of collectors. Simulations are performed with asinterval length ∆t=30 s, intensity ∆I=875 W/m
1.2
1.2
suming local shading of two collectors at a time. The
same
test signal is used as before. An additional con0.8
0.8
figuration
with a recirculation mass flow of 1.0 kg/s
0.4
0.4
instead of 0.25 kg/s is simulated to estimate the im0
0
0
500
1000
1500
0
500
1000
1500
pact of recirculation flow on the system dynamics.
Fig. 13 shows the results for a local shading of the preinterval length ∆t=120 s, intensity ∆I=600 W/m2
heating section (collectors 1 and 2). From the steam
1.2

0
0

500

1000

1500

1.2
0.4
0
0

2000

500

1000

1500

2000

0.4
500 1000 1500 2000 2500
t [s]

1000

2.0
1.0
0.0
0

1500

1.2

1.0
0
0

500

3.0

500

1000

1500

interval length ∆t=240 s, intensity ∆I=875 W/m2

2.0
steam [kg/s]

0.8

0
0

0.4

3.0
water [kg/s]

steam [kg/s]

1.2

0.8

0
0

interval length ∆t=240 s, intensity ∆I=600 W/m2

4.0
water [kg/s]

0.4

interval length ∆t=60 s, intensity ∆I=875 W/m2

0.8

500 1000 1500 2000 2500
t [s]

0.8
0.4
0
0

Figure 12: Reaction of the 800 m evaporator section to
simultaneous irradiation disturbances on collectors 1-8
according to fig. 11. Plotted are steam and water mass
flow at the exit of the evaporator. Feed water 1.2 kg/s,
recirculation 0.25 kg/s, irradiation 875 W/m2 , outlet
pressure 7 MPa.

4.0
water [kg/s]

0.8

steam [kg/s]

water [kg/s]

steam [kg/s]

1.2

500 1000 1500 2000 2500
t [s]

3.0
2.0
1.0
0.0
0

500 1000 1500 2000 2500
t [s]

Figure 13: Reaction of 800 m evaporator section to local irradiation disturbance on collectors 1/2 according
to fig. 11. Plotted are steam and water mass flow at the
exit of the evaporator. Feed water 1.2 kg/s, recirculation 0.25 kg/s (-) / 1.0 kg/s (· · ·), irradiation 875 W/m2 ,
outlet pressure 7 MPa.

The water flow shows large peaks with the maxima
located short time after the rising edge of the dis- production it can be seen that the system reacts very
turbance. Since constant feed flow is injected at the slow. Since the fluid velocity is very small it takes a
entrance of the collector water accumulates in the long time before the change in specific enthalpy leads
The Modelica Association

410

Modelica 2005, March 7-8, 2005

Simulation of transient two-phase flow in parabolic trough collectors using Modelica

flow can not avoid long periods of dryout.
Lokal Shading at the end of the evaporator in collectors 7/8, see fig. 15 is characterized by very small reaction time. The recirculation mass flow has no effect
on the result. Water mass flow reaches its steady-state
values very fast with nearly no dynamical overshooting.
interval length ∆t=60 s, intensity ∆I=875 W/m2
2
water [kg/s]

steam [kg/s]

1.2
0.8
0.4
0
0

200

400

1.5
1
0.5
0
0

600

200

400

600

interval length ∆t=240 s, intensity ∆I=875 W/m2
2
water [kg/s]

1.2
steam [kg/s]

to a significant change in steam production. With increased recirculation flow the residence time in the
preheating section gets smaller and reactions become
faster and more distinct. This effect can be seen clearly
in the water flow in the case ∆t=240 s. Although the
integral value of liquid pushed out of the absorber
is the same for both recirculation flows the temporal
distribution differs. Since evaporation starts further
downstream when collectors 1 and 2 are shaded liquid is stored in the system. This leads to a temporarily
reduced liquid mass flow in the rest of the evaporator and, as a consequence, to a short period of dryout
at t=500 s. By increasing the recirculation flow the
danger of superheating at the end of the evaporator is
reduced. On the other hand much higher liquid peaks
have to be accepted.
If the local shading is concentrated on collectors 4
and 5, see fig. 14, the reaction becomes faster and
the peaks higher. At long intervals there is only weak

0.8
0.4
0
0

500

1000
t [s]

1500

1.5
1
0.5
0
0

500

1000

1500

t [s]

interval length ∆t=60 s, intensity ∆I=875 W/m2
1
0.5
0
0

Figure 15: Reaction of 800 m evaporator section to local irradiation disturbance on collectors 7/8 according
to fig. 11. Plotted are steam and water mass flow at
the exit of evaporator. Feed water 1.2 kg/s, recirculation 0.25 kg/s (-) / 1.0 kg/s (· · ·), irradiation 875 W/m2 ,
outlet pressure 7 MPa.

8.0
water [kg/s]

steam [kg/s]

1.5

200

400

600

6.0
4.0
2.0
0.0
0

800

200

400

600

800

interval length ∆t=240 s, intensity ∆I=875 W/m2
8.0
water [kg/s]

steam [kg/s]

1.5
1
0.5
0
0

500

1000

1500

6.0
4.0
2.0
0.0
0

500

1000
t [s]

6 Combination with control system

1500

Figure 14: Reaction of 800 m evaporator section to local irradiation disturbance on collectors 4/5 according
to fig. 11. Plotted are steam and water mass flow at the
exit of the evaporator. Feed water 1.2 kg/s, recirculation 0.25 kg/s (-) / 1.0 kg/s (· · ·), irradiation 875 W/m2 ,
outlet pressure 7 MPa.
overlapping of the single reactions. Compared with
the shading of the pre-heater the reaction time now depends on the residence time in the two-phase region
which is much shorter. Since the whole evaporator is
nearly at the same temperature a change in steam production requires no heating or cooling of the absorber
tube walls. The difference between small and high recirculation is small since recirculation mass flow has
only minor impact on the average velocity. Compared
to shading of collectors 1/2 the maximum liquid mass
flow has nearly doubled and the dryout effect is much
more critical. Even increasing the recirculation mass
The Modelica Association

A central task of the control system is to inject as much
feed water as can be evaporated according to the actual
irradiation. A standard feed-back control loop based
on a liquid level control in the buffer tank reacts very
slow to changes in irradiation. A much faster reaction
is possible if measured irradiation is used to calculate
the necessary feed flow. Another method is to measure the actual steam production and use this signal
for the feed water pump. Due to model errors both approaches are not able to reach a specified set point in
the buffer level so in any case an additional level controller is necessary. To analyze the potential of these
forward control schemes simulations have been performed. Fig. 16 shows the results for a configuration
of an uncontrolled system, a configuration with feedforward control based on the irradiation measurement
and a configuration with feed-forward control based
on the steam production.
From the feed water signal the time lag between irradiation based and steam production based approach can

411

Modelica 2005, March 7-8, 2005

T. Hirsch, W. Steinmann, M. Eck

be seen. For liquid and gas mass flow at the evapora- that the feed-forward control has shown high potential
tor outlet this lag has nearly no effect. The steam pro- in reducing the necessary buffer size without signifiduction gets more continuous with the feed-forward cant negative side-effects.
control. There is a significant reduction of maximum
liquid peaks and as a consequence in buffer mass com7 Conclusions
pared to the uncontrolled system. The reason is that
A Modelica library for two-phase flow in parabolic
trough collectors is developed and successfully validated against analytical models and experimental data.
For the transient simulation of these complex system
it is necessary to manually select the state variables
and to transform the equations into explicit state space
form. Only with this approach it is guaranteed that initialization and numerical integration are reliable without loosing much of the flexibility the Modelica language offers. The library is used at the institute to simulate the reaction of parabolic trough collector loops
with direct steam generation to fluctuations in solar irradiation.

interval length ∆t=240 s, intensity ∆I=450 W/m2

feed water [kg/s]

1.5
1.0
0.5
0

0

1

2

3

4

5

water [kg/s]

1.00
0.75
0.50
0.25
0

0

1

2

3

4

References

5

buffer mass [kg]

100

[1] E CK M., S TEINMANN W-D. Direct solar steam
generation in parabolic troughs: First results of
the DISS project. In: Journal of Solar Energy Engineering (124), pp. 134-139, 2002.

50
0
−50

0

1

2

3

4

[2] M ÜLLER -S TEINHAGEN H., H ECK K. A simple friction pressure drop correlation for twophase flow in pipes. In: Chem. Eng. Process.(20),
pp. 297-308, 1986.

5

steam [kg/s]

1.5
1

[3] P ROFOS P. Die Regelung von Dampfanlagen.
Berlin, Springer, 1962.

0.5
0

0

1

2
3
t [1000 s]

4

[4] E CK M. Die Dynamik der solaren Direktverdampfung und Überhitzung in Parabolrinnenkollektoren.
VDI-Fortschrittsberichte,
Reihe 6, Nr. 464. Düsseldorf: VDI-Verlag, 2001.

5

Figure 16: Comparison of uncontrolled (-) system
with feed-forward control based on irradiation signal (· · ·) and steam production (-.-). Recirculation 0.25 kg/s, DNI 900 W/m2 .
less water accumulates in the pipes that has to be
pushed out when irradiation again increases. In the
presented disturbance configuration both feed-forward
schemes give similar results. If local shading of
the pre-heating section is used the irradiation based
approach reacts much faster then steam production
changes. This leads to a contradictionary effect for the
buffer level. As a preliminary result it can be stated
The Modelica Association

412

[5] S TEINMANN W.D., Z UNFT S. TechThermo A library for Modelica Applications in Technical Thermodynamics. In: Proceedings of the
2nd International Modelica Conference 2002,
Oberpfaffenhofen, Germany, Modelica Association, 18-19 March 2002.

Modelica 2005, March 7-8, 2005

Modelling and Simulation of Central Receiver Solar Thermal Power Plants

Modelling and Simulation of
Central Receiver Solar Thermal Power Plants
L.J. Yebra†,∗

M. Berenguel∗

S. Dormido‡

M. Romero†

† CIEMAT-PSA.

Ctra. de Senés s/n. Tabernas.
E04200 Almerı́a. Spain. E-mail:{luis.yebra,manuel.romero}@psa.es
∗ Universidad

de Almerı́a. Dpto. de Lenguajes y Computación. Ctra. de Sacramento s/n.
La Cañada. E04120 Almerı́a. Spain. E-mail: beren@ual.es

‡ U.N.E.D.

Escuela Técnica Superior de Ingenierı́a Informática. Dpto. Informática y Automática.
C/ Juan del Rosal, 16. E28040 Madrid. Spain. E-mail: sdormido@dia.uned.es

Abstract
The implementation of advanced control systems to
optimize the overall performance of Central Receiver
Solar Thermal Power Plants is nowadays a priority
research line in CIEMAT-PSA. The development of
dynamic models for use in simulation and control of
this kind of power plants is presented in this article, focused on the CESA-I solar plant. The develFigure 1: CESA-I solar plant at PSA
oped model is based in the thermohydraulic modelling
framework ThermoFluid, and the main components of
the system are presented as well as the respective modelling assumptions. A typical operating cycle is simulated and the results are shown and commented.
Tecnológicas - Research Centre for Energy, Environment and Technology), public organism owned by the
Spanish Ministry of Science and Education. This so1 Introduction
lar plant is located at the Plataforma Solar de Almerı́a
(PSA), South-East Spain. A join project between
This paper presents the current status of the research CIEMAT-PSA, the University of Almerı́a (UAL), the
performed within the framework of modelling and National University of Distance Education (UNED)
simulation of Central Receiver Solar Thermal Power and the University of Seville (US) is being carried out
Plants (CRSTPP). The work is mainly oriented to the in order to develop models and control systems to audevelopment of dynamic models of solar energy plants tomatically control these kind of plants. This test-bed
to be used in the design of automatic control systems plant can be seen in figure 1.
aimed at optimizing global performance. The models
presented in this article are focused on the solar part, The model presented in this paper will be used in the
excluding typical components of power plants like tur- design of hybrid model predictive control and intellibines or generators.
gent control schemes to optimize plant performance,
The system used as test-bed plant is the CESA-I fa- even under start-up and shutdown situations and in the
cility, a CRSTPP belonging to the CIEMAT (Centro presence of highly variable load disturbances due to
de Investigaciones Energéticas, Medioambientales y the daily cycle of solar radiation and passing clouds.
The Modelica Association

413

Modelica 2005, March 7-8, 2005

L.J. Yebra, M. Berenguel, S. Dormido, M. Romero

2

Central Receiver Solar Thermal
Power Plants

level: number of operating heliostats and aiming point
strategy followed, and at the tower level: mass flow
rate demanded by the blowers, inlet water flow and
In this section an overview of the basic components outlet pressure valve position) change.
and operating procedures for a CRSTPP is introduced.
Figure 2 shows an explicative diagram of a general
3 Modelling of CRSTPP
CRSTPP.

Figure 2: Schematic diagram of a CRSTPP
The operation of this kind of plants is based in the concentration of incoming solar energy using a heliostat
field that reflects the incident solar radiation onto a
(typically volumetric) receiver (theoretically onto an
optical point in the 3-D space). As the sun position changes during the day, each heliostat of the field
(composed of 300 heliostat in the case of the CESA-I
plant) has to change its position in real time according
to the selected aiming point on the receiver, as different aiming points can be selected in order to achieve
a uniform temperature distribution on the receiver [7].
The receiver is located at the top of the tower (84 m
height in CESA-I) and acts as an energy exchanger,
receiving solar energy and transferring it to a thermohydraulic circuit with air medium, see figure 2. The
system is also composed by an energy storage tank, an
air/water-steam heat exchanger (evaporator), blowers
and valves. The combined action of the blowers let to
feed either the storage tank or the heat exchanger with
hot air. The evaporator is formed by the primary circuit and a secondary one with subcooled inlet water
and with superheated steam outlet. A measurement of
the overall concentrated input radiation, a controlled
water pump and an outlet controlled valve define the
main boundary conditions for the system. The final
objective of the model is to predict the transient behaviour of the thermodynamics variables associated to
the thermohydraulic output power of the evaporator
(mainly temperature, pressure, and specific enthalpy),
when the external disturbances (concentrated solar radiation, ambient temperature, and wind speed and direction) and controllable inputs (both at the solar field
The Modelica Association

In this paper we will concentrate in the thermohydraulic part of the system, skipping the heliostat field
and assuming a known input radiation power in the receiver as a consequence of the radiation reflected in
the heliostat mirrors and the aiming-point strategy followed [7]. This assumption introduces an error in the
estimated irradiation due to the difficulties that exist in
getting accurate high concentrated radiation measurements.
Due to the fact that the main phenomena are related
to thermofluids, the Modelica language has been used
to develop these models including the ThermoFluid library ([12],[6]) as a framework over which create own
libraries and final component models. The authors
think that this library is an important reference in the
framework of object oriented modelling of thermofluid
systems with Modelica, and its existence makes a nonsense to develop libraries in the same level of modelling of thermohydralic systems.
The work analyzes each of the components of the thermohydraulic circuits of air and water-steam and explain the modelling assumptions, trying to justify each
one as they are oriented to get, by means of the symbolic manipulations that Dymola tool performs, a not
high index DAE system for the complete model, in
which the number of nonlinear algebraic loops is minimized. For this purpose, all the components are classified, following the modelling methodology derived
from the Finite Volume Method (FVM) [10], in Control Volumes (CV in ThermoFluid nomenclature) and
Flow Models (FM in ThermoFluid nomenclature). In
some cases information about the future control system architecture to be implemented is introduced in the
modelling phase. An example of components that are
modelled using this kind of information are the blowers in the air circuit, in which a cascade control will
help avoid the multivariable nonlinear dependence of
the constitutive equations and let consider them like
quasi ideal flow rate generators. Due to the existence
of components whose internal implementation may
vary depending on the modelling hypotheses, the polymorphism and the Modelica language constructs replaceable/redeclare have been specially used in some
of them, for example in the evaporator.

414

Modelica 2005, March 7-8, 2005

Modelling and Simulation of Central Receiver Solar Thermal Power Plants

Figure 3 shows the developed Modelica model of the
system.
The following components are shown: blowers, storage tank, solar receiver, evaporator, control valve,
sensors, pipes and connections. All of them are
directly instantiated and parameterized, or inherited
from ThermoFluid classes. It can be seen how the
air circuit is composed of a solar receiver, tubes, tank,
and evaporator; and the water steam circuit with a water pump, a control valve, tubes, and reservoirs with
boundary conditions. In both circuits the mass transfer connections have been drawn with solid and thick
lines, while colors are used to describe hot fluid (red),
cold fluid (blue), and hot steam (grey). Input-Output
causal connectors appear to access variables of interest
for control purposes like:
Output variables. Boolean indicator for saturated/superheated vapor, several pressures and
temperatures in both media circuits, stored
energy in the tank, mass flow rate in the tank,
mean temperature in the tank, etc.
Input variables. Actuators setpoints: blowers 1 and
2, water pump; and boundary conditions: pressure and temperatures of water inlet, estimated
inlet concentrated radiation, ambient temperature
and pressure, wind velocity.

3.1

ThermoFluid usage

The thermohydraulic interface is formed by connectors from ThermoFluid for single component media
and steady-state momentum balance statement. Due to
the fact that the dynamics of momentum balance are of
no interest for control purposes in the time scales studied at present, the stationary formulation version of
ThermoFluid has been used in all the thermohydraulic
classes utilized.
The modelling methodology adopted from the beginning for the design of the classes was: if there exists
any class in ThermoFluid that implements the physical phenomenon to model, use it with the corresponding parameters; if not, design the classes using inheritance from the high level partial classes from ThermoFluid; in other cases then use proper ThermoFluid
interfaces and base classes and develop the component class with the lacking behavior expressed in differential and algebraic equations from first principles.
In the next subsections the most important components
models will be detailed and the modelling hypotheses
will be explained and justified.
The Modelica Association

3.2 Blowers and Pumps
In this kind of active FM [12], the authors decided to
make a simplifying assumption based on the gained
experience in control of Parabolic Trough Fields with
thermal oil as medium, case of Acurex field of
CIEMAT-PSA [4], [5], and water-steam as medium
in DISS facility [16], [13]. This assumption is that
the water pump and blowers are controlled in a cascade scheme [3] with a local control loop whose dynamics is much faster than the rest of the thermohydraulic system. This assumption has been experimentally validated in blowers and water pump, and helps
simplifying these components models until the possibility of state them as quasi-ideal mass flow rate generators. This approximation lets avoiding the consuming
time work of fitting the nonlinear multivariate curves
of the pumps and blowers. So, the algebraic equation
for these components is ṁ = ṁre f , where ṁre f is the
setpoint of the local pump/blower control loop and is
assigned in a connector to the model, as can be seen in
figure 3.

3.3 Solar Receiver
This component receives energy from the heliostat
field, that concentrates solar radiation in different aiming points to avoid large spatial temperature gradients
that could damage the component. This aiming point
strategy is a research line at present, [7], and is implemented in the heliostat field real time control system.
The total energy flow reflected by the heliostats and
concentrated in the receiver is nowadays estimated, because the practical difficulties in the measurement of
this variable. Therefore, a mean solar concentrated
input power is used for modelling purposes. This
assumption introduces uncertainty in the model, that
makes not to expect from the adjusted and validated
model a precision beyond that of the inlet power. Nevertheless, it is expected that this uncertainty will decrease in the near future with the development and implementation of new sensors and by re-calibrating the
model with new operating data.
Figure 4 shows the Modelica model composed, in a
major number, of ThermoFluid components. This is
the model of the system in which the strongest simplifications have been made, due to the internal design of the system. From a system level point of view,
the receivers are composed of an arrangement of solid
ceramic cups that receive inlet radiation. Due to hydraulic depression caused by external pumping elements (blowers 1 and 2), an air mass flow rate from

415

Modelica 2005, March 7-8, 2005

L.J. Yebra, M. Berenguel, S. Dormido, M. Romero

WaterRes...
class

T
PipeDS2

class
base
FlowSplitS1

Solar

der...

VaporCo...

p
PipeDS3

class

base

der...

class
base

base

Ra...
CT...

SimpleV...

p0, h0

md...

Receiver

Pressur...

Energy

Stored

Vapor

Air

base
class

PipeDS1

To

Water

mdot
HEX Air-Water/S...

ThreePortS1

Blower2

base
class

Blower1

PipeDS4

Thermal Storage Tank

Pressu...

WaterP...

class

base

p
class

base

p0, h0

T

WaterRes...

Figure 3: Modelica model of CESA-I CRSTPP
the environment is established and heated when passing through the ceramic cups. The cups are modelled by wall classes, the air mass and energy conservation by concentrated parameters CV’s and the
medium model for air from medium models. The external boundary conditions are modelled by reservoir
componentes representing external pressure and temperature. The conduction-convection and radiation energy flow from receiver to atmosphere is modelled by
heat transfer classes with the extensions of include expressions for empirical correlations obtained by experimentation. The convection heat transfer between the
CV and the cup array is based in empirical correlations
too. The radiation and convection are modelled using
the Stefan-Boltzmann Law and Newton Cooling Law
[9], in which the radiation conductance in the former
case, and the heat transfer coefficient, in the latest, are
the variables to identify by means of adjusted correlations. The three input connectors represent: concentrated solar radiation in the receiver (radin), derivative of atmospheric pressure and derivative of ambient
temperature, respectively. The former is the estimated
concentrated solar radiation, and the second and third
are used as sources of uncertainties to the model. The
derivative of the pressure lets simulate experimented
effects that wind gusts could cause in the pressure and
temperature close to the receiver. The explicit modelling of disturbances caused by wind are important
The Modelica Association

Figure 4: Modelica model of CESA-I receiver
for control purposes of the temperature of the air leaving the receiver to the circuit.

3.4 Storage Tank
The aim of the storage tank is to accumulate energy to
let the plant operate when irradiation decreases during
a time interval (limited by the tank capacity and layout). The tank can be defined by three states, depending on the mass flow rates of the blowers, see figure

416

Modelica 2005, March 7-8, 2005

Modelling and Simulation of Central Receiver Solar Thermal Power Plants

Hex
Tank

Rec

ṁ1
Blower1

ṁ2
Blower2

Figure 5: Schematic diagram of the air circuit
5, and assuming enough incoming power from the receiver and negligible energy losses to the environment
from the tank:
Loading: ṁ1 > ṁ2 . The energy stored in the tank is
increasing.

Figure 6: Model of the Storage Tank

Unloading: ṁ1 < ṁ2 . The energy stored in the tank
is decreasing.
To close the system of equations it is mandatory to introduce the heat transfer coefficient between the air
Standby: ṁ1 ≈ ṁ2 . The stored energy does not vary
flow and the solid media. This coefficient depends
noteworthily.
of heat transfer correlations using adimensional fluid
The tank is filled with a solid media that is exposed numbers (Reynold, Prandtl, Pecklet,...), geometry of
to thermal contact with air that flows through the tank. the contact surface and thermodynamic and transport
Between the air and the solid media there is an energy properties of the fluid (air in this case). Some of the
exchange by convection phenomena that is described correlation parameters strongly depend on the experiby the Newton Cooling Law and the energy conserved mentation and parameter adjusting phase of the modin the air flow and the solid media. Due to the spatial elling work. See [11].
distribution of the tank, it is modelled as a parameter The tank model, designed using ThermoFluid compodistributed system in the direction of the major dimen- nents, is shown in figure 6, where the discretized air
sion of the tank. This results in a system of partial volume component (DiscAirVolume), the solid media
component (FillMedia) and the component modelling
differential equations (PDE) formed by:
the heat transfer coefficient1 can be observed.
- Differential formulation of mass and energy con- The additional variables that are get out through output
servation through the air volume in contact with connectors for control purposes are:
the media, in the domain defined along the major
- En : total stored energy in the solid media with
spatial dimension of the tank. See [11].
respect to a reference level.
- Differential formulation of energy conservation
- T0 : spatially averaged temperature of the solid
of the solid media, in the domain defined along
media.
the major spatial dimension of the tank. See [11].
To solve the PDE system stated, it is necessary
to spatially discretize the equations. ThermoFluid
provides partial classes [12] in which the discretization with the Finite Volume Method (FVM)
([10]) is applied. One of these classes is ThermoFluid.PartialComponents...Volume2PortDS pT,
which implements this mass, energy and static
momentum conservation equations in a volume
spatially discretized in n subvolumes. For the solid
media, there exists final use classes that implements energy conservation in distributed solids,
ThermoFluid.Components.HeatFlow.Walls.
The Modelica Association

- ṁ : air mass flow rate through the tank.

3.5 Evaporator
The evaporator in CESA tower is a counterflow airwater/steam hex, in which the water/steam flow is he1 In this version of the model, the heat transfer coefficient is
supposed to be constant. Including a dependence of this coefficient using correlations does not pose any additional difficulty,
but redesigning a discretized volume for air, polymorphic with the
first one, with one variable and one equation for the heat transfer
correlation, e.g., Dittus-Boelter [11].

417

Modelica 2005, March 7-8, 2005

L.J. Yebra, M. Berenguel, S. Dormido, M. Romero

licoidal configured through the air flow. For modelling effects, this components has been considered as
a counterflow hex composed of one pipe with air media, one pipe with water-steam media and a wall letting thermal interaction. The simple arrangement can
be seen in figure 7.

PipeDSws

wall

class
base

initws charws

base
class

geows

initair charair

PipeDSair

geoair

ulation, another polymorphic evaporator model has
been developed, in which the subcooled and saturated
regions of water/steam pipe are replaced by an equivalent Moving Boundary Model (MBM) [8]. Figure 8
shows this mixed discretized and MBM model, where
the MBM component has been designed with ThermoFluid interfaces to be connected with the rest of
components.
Although the mixed model lowers the likelihood of
finding chattering in the integration process, it is theoretically less accurate, and experimentally it is harder
to find consistent DAE initial conditions and the validity range of the model is more limited than that of the
fully discretized one.

geoair

initws charws

geows

initair charair

PipeDSws

base
class
Square...

Momentum Balance

Wall

Subcoo...

WaterSteam Medium

Subcoo...

TwoP...

initair2 charair2

Subcooled Twophase MBM

TwoPha...

K(...)

PipeDSair1

initair1 charair1

K(...)

class
base

geoair2
PipeDSair2

The length of the water/steam pipe is 1440 m. and under normal operating conditions the inlet water is in
subcooled region and the outlet vapor is superheated;
thus the dynamical conditions will vary along the pipe
depending on the thermodynamic and transport properties of the water/steam. The configuration shown
in figure 7 is fully discretized in n CV’s in which
mass,energy, and momentum balances are applied2 .
The number of CV’s, n, is a trade off between accuracy and computing cost, so the final choice is the
minimum n that models dominant dynamics for control purposes. Nowadays we are working with values
in the interval [10, 15]. The wall and the air pipe are
discretized with the same discretization level.
In the development of experimental correlations
classes for the heat transfer coefficients sliding models and chattering have appeared with some frequency
around the phase changes of water/steam CV’s. This
phenomena are manifested with more frequency when
CV’s pass from subcooled (region 1 in IAPWS-IF97
standard for water/steam properties, [15]) to saturated
(region 4 in IAPWS-IF97), due to the discontinuities
present in the heat transfer coefficients in the limit
boundary between water and walls. To avoid those
cases in which chattering causes troubles to the sim-

class
base

geoair1

Figure 7: Discretized model of the Evaporator

wall

K(...)

class
base

PipeDSair

w_geo

Figure 8: Mixed Moving Boundary and Discretized
model of the Evaporator
With the help of replaceable/redeclare constructs and
the choices annotations ([2], [1]), the switching between fully discretized and mixed MBM-discretized
models in instantiation time easies the modelling
work.

3.6

Simplified model

Some components of the compound model have been
introduced to maintain the structure and topology in
the model similar to the real system, following the
object oriented approach. Some of them, like pipes,
actually introduce additional differential equations in
the model that could be eliminated due to the fact that
the parameters of the real plant make their time constants and delays too low when compared to the rest of
2 Momentum conservation is stated in staggered CV’s with re- components. Eliminating the pipes implies assuming
spect to those ones which state mass and energy conservation; negligible energy losses and fast dynamics in the mass
conservation due to the low real volume, which is rea[10], [14] and [12].

The Modelica Association

418

Modelica 2005, March 7-8, 2005

Modelling and Simulation of Central Receiver Solar Thermal Power Plants

sonable. The model could be simplified from figure 3 it can be seen how the dominating time constants for
load/unload are different and that the accumulated ento the one shown in figure 9.
ergy can be enough to maintain the outlet superheated
steam during some time. The fourth graph presents the
outlet evaporator water/steam temperature; this augT
ments when the blower2 works until the solar radiation exists, then begins to fall at low rate while stored
Solar
energy remains in the tank. When the energy comAir
ing from the tank is not enough to maintain the superheated steam, it get saturated and then subcooled. The
last graph presents the IAPWS-IF97 regions crossed
by outlet water/steam travel during this simulation; it
can be seen that initially the water is subcooled (region
1), then enters in saturation (region 4), then enters in
superheated (region 2); when the solar radiation disappears at time = 15000s, the storage tank maintains
the superheating state some time until the steam enters
in saturation again (region 4), and finally come back
to subcooled water (region 1) as during the beginning
Figure 9: Simplified model of figure 3
of the process. At present, no real plant data are allowable for model calibration and validation purposes.
Conducted tests are planned to validate each one of the
4 Simulation
components of the model.
WaterRes...

p0, h0

p

base
class

base

Ra...

VaporCo...

CT...

SimpleV...

class

md...

der...

FlowSplitS1

der...

PressureT...

Receiver

Vapor

Energy

Stored

Water

To

mdot

HEX Air-Water/S...

Thermal Storage Tank

PressureT...

Blower1

ThreePortS1

Blower2

WaterP...

class

base

p

class

base

p0, h0

T

WaterRes...

This section shows representative simulation results
using the simplified plant model of figure 9, when the
system executes the cycle detailed below, that represents a typical operation case:

5 Concluding remarks and Ongoing
work

1. Initial state: the storage tank is unloaded, the air This article shows the development of a model of a
circuit is at ambient conditions and the water cir- CRSTPP using the methodology of object oriented development of thermofluid systems. The major part of
cuit is in subcooled region.
the components are based in the ThermoFluid frame2. At time = 0s, an input power of 10MW is re- work for thermohydraulic modelling. The CRSTPP
flected from the heliostat field in the receiver and components and main operation principles have been
the storage tank begins to accumulate energy. No described. For the main components, the modelling
power is delivered to the evaporator.
hypotheses and the composition Modelica diagrams
developed with the Dymola tool have been presented.
3. At time = 2000s, all the energy from the receiver References to the underlying physical phenomena
is delivered to evaporator and the storage tank en- have been made in these composition diagrams, withergy level remains unchanged.
out entering in detail of quantitatively describing them
4. At time = 15000s, the power from the heliostat through differential and algebraic equations; instead,
field is zero (due to a passing cloud, for exam- the basic bibliography and the ThermoFluid classes
ple) and all the energy delivered to the evaporator that implements them have been referenced. Finally,
a simplified model showing a typical operation cycle
comes from the storage tank.
with a real perturbation introduced by clouds has been
The results of this simulation are shown in figure simulated.
10. The first graph presents the input power radia- The ongoing works to develop consists in the adjusttion (Power Rad) from the heliostat field. The sec- ing of the main block models parameters based in the
ond the mass flow rates in blowers 1 (mdot Blower1) experimental results of the real plants, by means of
and 2 (mdot Blower2), delivering energy to the stor- working separately with each shown component with
age tank or evaporator in each time interval. The third its proper boundary conditions. In this work, the valgraph shows the load/unload cycle of the storage tank; idation of empirical correlations for heat transfer and
The Modelica Association

419

Modelica 2005, March 7-8, 2005

L.J. Yebra, M. Berenguel, S. Dormido, M. Romero

Power_Rad
[W]

1E7
0E0
0.0E0

5.0E3
mdot_Blower1

1.0E4

1.5E4

2.0E4

2.5E4

3.0E4

1.0E4

1.5E4

2.0E4

2.5E4

3.0E4

1.0E4

1.5E4

2.0E4

2.5E4

3.0E4

1.5E4

2.0E4

2.5E4

3.0E4

2.0E4

2.5E4

3.0E4

mdot_Blower2

[kg/s]

2
0

0.0E0

5.0E3
Tank_Stored_Energy

[J]

2E8
0E0
0.0E0

5.0E3

Output_Water_Steam_Temp
[K]

800
400
0.0E0

5.0E3

1.0E4

IAPWS_IF97_region_Output_Water_Steam
4
0
0.0E0

5.0E3

1.0E4

1.5E4

Figure 10: Simulation results.

The Modelica Association

420

Modelica 2005, March 7-8, 2005

Modelling and Simulation of Central Receiver Solar Thermal Power Plants

of Automatic Control, Lund Institute of Technolpressure loss will be an important issue.
ogy, Sweden, March 2001.
The final aim is to develop control and automatic operation systems that help operating in the most autonomous way this kind of plants, in the presence of [7] F.J. Garcia-Martı́n, Berenguel M., Valverde A.,
and E.F. Camacho. Heuristic knowledge-based
large disturbances. Automatic start-up and shutdowns
heliostat field control for the optimization of the
of the plants is one of the main objectives in this directemperature distribution in a volumetric receiver.
tion.
Solar Energy, 66:355–369, 1999.
Acknowledgements
This work has been financed by CICYT-FEDER [8] J.M. Jensen and H. Tummescheit. Moving
funds (projects DPI2001-2380-C02-02, DPI2002boundary models for dynamic simulations of
04375-C03, DPI2004-07444-C04-04 and DPI2001two-phase flows. In Martin Otter, editor, Pro1012) and by the Consejerı́a de Innovación, Ciencia
ceedings of the 2rd International Modelica Cony Empresa de la Junta de Andalucı́a. This work has
ference, pages 235–244, Oberpfaffenhofen, Gerbeen also performed within the scope of the specific
many, March 2002.
collaboration agreement between the Plataforma Solar de Almerı́a and the Automatic Control, Electronics [9] Kreith, editor. The CRC Handbook of Thermal
Engineering. CRC Press, 2000.
and Robotics (TEP-197) research group of the Universidad de Almerı́a titled ”Development of control sys[10] S.V. Patankar. Numerical Heat Transfer and
tems and tools for thermosolar plants”.
Fluid Flow. Series in Computational and PhysThe authors want to acknowledge to J.D. Alvarez for
ical Processes in Mechanics and Thermal Scihis help with some of the bitmaps of some Modelica
ences. Taylor & Francis, 1980.
models developed. Of course, thanks to Dr. Jonas
Eborn, Dr. Hubertus Tummescheit and Lund Technol- [11] W.M. Rohsenow, J.P. Hartnett, and Y.I. Cho.
ogy Institute for the development and make public the
Handbook of Heat Transfer. McGraw-Hill, 1998.
ThermoFluid library.
[12] H. Tummescheit. Design and Implementation of
Object-Oriented Model Libraries using Modelica. PhD thesis, Department of Automatic ConReferences
trol, Lund Institute of Technology, Sweden, August 2002.
[1] Dynasim AB. Dymola Users Manual. Version
5.3a. Dynasim AB, Research Park Ideon. SE- [13] L. Valenzuela, E. Zarza, M. Berenguel, and E.F.
223 70 Lund. Sweden.
Camacho. Direct steam generation in solar boilers. IEEE Control System Magazine, 24(2):15–
[2] Modelica Association.
Modelica. a unified
29, 2004.
object-oriented language for physical systems
modeling. language specification. version 2.1. [14] H.K. Versteeg and W. Malalasekera. An IntroTechnical report, Modelica Association, January
duction to Computational Fluid Dynamics. Ad2004.
dison Wesley Longman Limited, 1995.
[3] K.J. Åström and B. Wittenmark. Computer- [15] W. Wagner and A. Kruse. Properties of water
Controlled Systems. Prentice Hall, 1997.
and steam. Springer-Verlag, Berlin, 1998.
[4] M. Berenguel. Contributions to the control of [16] E. Zarza. The Direct Steam Generation with
distributed solar collectors (in Spanish). PhD
Parabolic Collectors. The DISS project (in Spanthesis, Escuela Superior de Ingenieros Industriish). PhD thesis, Escuela Superior de Ingenieros
ales de Sevilla. Spain, March 1996.
Industriales de Sevilla, November 2003.
[5] E.F. Camacho, M. Berenguel, and F.R. Rubio.
Advanced Control of Solar Plants. Springer,
1997.
[6] J. Eborn. On Model Libraries for Thermohydraulic Applications. PhD thesis, Department
The Modelica Association

421

Modelica 2005, March 7-8, 2005

The Modelica Association

422

Modelica 2005, March 7-8, 2005

Object-Oriented Modeling, Simulation and Control of the IRIS Nuclear Power Plant with Modelica

Object-Oriented Modeling, Simulation and Control of the IRIS
Nuclear Power Plant with Modelica
Antonio Cammi∗, Francesco Casella†, Marco E. Ricotti∗, Francesco Schiavo†‡
Politecnico di Milano,
Piazza Leonardo da Vinci 32
20133 Milano
Italy

Abstract
The paper presents the application of the Modelica language to the modeling, simulation, and control of the
new IRIS nuclear power plant, under development by
an international consortium. The plant model, developed by using components from the ThermoPower library, as well as custom-built nuclear components, is
described, as well as the digital control system model,
which will eventually become very realistic. Special
emphasis is put on the use of inheritance and replaceable objects for the management of a family of model
variants over the project life-time. Selected simulation
results are included.

1

Introduction

The IRIS project [3] involves 21 organizations from
10 countries and refers to the design of an innovative, light water reactor with a modular, integral primary system configuration. The reactor pressure vesFigure 1: The IRIS Reactor
sel houses the nuclear fuel, control rods and control rods drive mechanisms, but also all the major reactor coolant system components, including the Compared to conventional PWR plants, however, IRIS
coolant pumps, the steam generators and the pressur- has a set of distinctive features, which directly affect
the control system design:
izer (Fig.1).
• the integral configuration requires a large water
IRIS is basically a PWR (Pressurised Water Reactor):
inventory in the primary loop, whose residence
in the primary loop, liquid water is heated by the nutime is much greater than usual;
clear fuel rods in the core, and is then sent by the
pumps to the primary side of heat exchanger; the sec• a helicoidal once-through steam generator is emondary loop actually generates steam which is sent to
ployed on the secondary side, which has a very
turbines to produce power.
short residence time, compared to the more
widespread U-tube recirculating steam genera∗ Dipartimento di Ingegneria Nucleare “E. Fermi”CESNEF,
tors;
{antonio.cammi,marco.ricotti}@polimi.it
† Dipartimento
di
Elettronica
e
{casella,schiavo}@elet.polimi.it
‡ Corresponding author

The Modelica Association

Informazione,

423

• sprayers are not available to reduce the pressure
in the primary loop during fast transients.
Modelica 2005, March 7-8, 2005

A. Cammi, F. Casella, M. Ricotti, F. Schiavo

The control strategy must take these facts into account,
and a dynamic simulation tool is essential to ensure
that the control objectives can be achieved.
Highly detailed dynamic simulators have been developed for the IRIS reactor [6]. Such simulators, based
on the complex computational fluid-dynamics code
named RELAP [10], are perfectly suited for accident
analysis and safety-oriented evaluations of the reactor design features. On the other side, due to the
amount of the details involved, they cannot be proficiently used for control-oriented dynamic simulation.
Within this framework, the use of the Modelica language offers a viable solution, allowing the development of dynamic simulators that are detailed enough
for control-oriented analysis and yet with limited computational requirements.
To provide the required capabilities for the analysis,
specific models for nuclear reactor components have
been developed, to be applied for the dynamic simulation of the IRIS integral reactor, albeit keeping general
validity for PWR plants. In addition to that, specific
digital control blocks have been developed, so that a
complete model of the plant and of its digital control
system is available.
The paper is organized as follows. An overview of the
plant model is presented in Section 2, while in Section 3 the models specifically developed for nuclear
components are analyzed in detail. Section 4 contains
an overview of the plant digital control system and, in
Section 5, the problem of managing a library of plant
models with different detail levels is tackled. Section 6
presents some closed-loop simulation results. Finally,
Section 7 draws some conclusions and outlines possible future developments.

2

Plant Model

The model of the IRIS plant basically describes the
primary circulation loop, i.e. the reactor coolant loop,
and the secondary loop, i.e. the once-through evaporators, along with the feedwater and turbine systems.
Most of the required models have no specific nuclear
features, and were thus borrowed from the generalpurpose ThermoPower library, designed for the modelling of generic thermo-hydraulic power plants; the
library is an open-source project, described with more
detail in [4]. The only notable exceptions are the reactor core and the pressurizer, which are described in the
next section.
The Modelica Association

Figure 2: Plant flow diagram

2.1

Primary loop

The primary loop (see Fig. 2) starts with the pressurizer (top of the diagram); the pressurizer is connected
by a pressure-loss component to the upper mixing volume, taking into account the mass and energy balances. Starting from the top of the diagram, counterclockwise, the centrifugal pump model can be found,
followed by another plenum model. The primary side
of the heat exchanger between the primary and secondary loop is then encountered, modelled by three
cascaded, finite-volume pipe models; the middle one
describes the section where the coolant is actually in
contact with the secondary side tube bundle. Proceeding onwards, other two plenum models followed by a
pressure loss can be found, leading to the inlet of the
core model (see next Section). This in turn is followed
by another pressure loss, another plenum, and the two
riser sections, modelled by two pipes having different
diameter. The loop is closed by a simple model of
the chemical and volume control system (CVCS), basically a mixer and an ideal flow source. The fluid in
the whole loop is one-phase water, with the exception
of the steam filling the upper pressurizer dome.
The heat transfer between the primary and secondary
loop is modelled by two heat transfer modules and
by the thermal model of the tube metal mass. The
primary-side heat transfer coefficient is held constant
to its nominal value, since the Reynolds and Prandtl
numbers does not vary substantially; on the secondary
side, the heat transfer coefficients can be computed ac-

424

Modelica 2005, March 7-8, 2005

Object-Oriented Modeling, Simulation and Control of the IRIS Nuclear Power Plant with Modelica

cording to different laws, e.g. Chen’s correlation, or
much simpler, empirically tuned curves.

2.2 Secondary loop
The secondary loop is composed of the feedwater system, the helical coil once-through steam generator and
the turbine system. The once-through generator is represented by a finite-volume, 10-node model of the twophase fluid flow, assuming homogeneous flow, i.e. the
same velocity for the liquid and vapor phases.
Currently, the feedwater system is represented by an
ideal flow source, whose flow rate is determined by
the control system, and whose enthalpy is a function of
the plant load level, determined from balance-of-plant
calculations. The turbine system includes a simplified,
linear model of the high- and low-pressure turbines,
plus simplified models of the connection to the grid,
including an idealized synchronous generator, local
loads, and a grid model. The latter ones are included
to provide suitable boundary conditions for the (much
slower) plant dynamics; therefore, they only model active power flows, neglect the electro-mechanical dynamics, and assume perfect synchronism between the
generator and/or the grid.
In the near future, it is planned to replace the feedwater and turbine system models with more realistic
counterparts, including steam bleedings and condensate train, to better represent the actual steam generator dynamics under large load variations. On the other
hand, the finite-volume fluid evaporator model could
be replaced by a simpler version, with moving boundaries between the liquid, 2-phase, and vapor sections,
and an averaged description of each section.

3 Nuclear Components
The Modelica models for “nuclear” components have
been developed to provide solutions which are suitable
both for “general” use and specifically for the IRIS nuclear plant modelling. The main components are the
core, (with separate models for the point kinetic neutronic generation, the fuel thermal dynamics and the
moderator, as depicted in Fig. 3) and the pressurizer;
the main modelling principles are summarized here,
for more details see [1, 2].

3.1

Figure 3: The Core Model Internal Structure
dynamic balance equations, describing the evolution
of the neutronic population and of the precursor concentration. Reactivity feedback from coolant density,
fuel Doppler effect, and rod insertion are accounted
for. The dynamic terms can be switched off, to obtain
a simplified static model, neglecting the fast dynamics.
The neutronic power generated into the fuel is proportional to the neutronic population n, which responds to
the point reactor kinetics balance equations :
6
dn ρ − β
=
n + ∑ λi c i
dt
Λ
i=1

dci β
= n − λi c i
dt
Λ

(1)

i = 1, · · · , 6 ,

where c is the precursor concentration leading to a
delayed neutron source, ρ is the total reactivity of the
core, β is the fraction of delayed neutrons, λ is the decay constant of the precursors and Λ is the characteristic period of the reactor or mean neutron generation
time.
Reactivity feedbacks are taken into account as well, by
considering linear or non linear feedback coefficients,
always negative, for the coolant density effect (αc ), the
fuel Doppler effect (α f ), the effect of the boron concentration (αB ) into the primary fluid as a neutronic
poison and the level of insertion of the control rod
banks into the core (αCR ). These relations are

Point Kinetics Neutronic

ρ = ρCR + ρ f + ρc + ρB ,

ρ f = α f Te f f − Te f f 0 ,
!
1
1
ρc = αc
−
,
vc vc0

(2)

ρB = αB (C −C0 ) ,

The point kinetic neutronic model describes the dynamics of the neutron generation processes in the where Te f f and Te f f 0 are the instantaneous and refercore. The model is based on standard point kinetic ence effective fuel temperature, respectively, obtained
The Modelica Association

425

Modelica 2005, March 7-8, 2005

A. Cammi, F. Casella, M. Ricotti, F. Schiavo

from the fuel model, vc and vc0 are the instantaneous equations read:
and reference specific volumes of the coolant, C and
!
∂T
∂T
∂
1
000
p
p
C0 are the instantaneous and reference boric acid conrk p
+q ,
ρ p c p,p
=
∂t
r ∂r
∂r
centration in the coolant. The boric acid concentration
!
in the coolant depends mainly on the control rods in∂
∂Tg
sertion.
kg
=0 ,
∂r
∂r
The reference values are those corresponding to the
!
∂Tc
∂Tc 1 ∂
nominal, full power operation of the reactor.
=
rkc
.
ρc c p,c
∂t
r ∂r
∂r

3.2

Fuel model

The fuel model describes the dynamics of the thermal
power generated within the core by the nuclear chain
reactions. The neutronic generation model and the fuel
model are linked by a connection between two Modelica standard HeatPort, where the connectors variable are the total power generated and the fuel temperature. A ThermoPower DHT distributed heat transfer connector is used as well, as an interface with the
moderator, modelled by a 1-D flow model.
The model is based on the application of the time dependent Fourier equation (in monodimensional cylindrical geometry) to the three fuel zones: pellet, gap
and cladding (Fig. 4).

(3)

where ρ is the density, c p is the specific heat, T is the
temperature, k is the thermal conductivity, q000 is the
volumetric source term, r is the radial dimension and t
the time, while the subscripts p, g and c stand for the
pellet, the gap, and the cladding, respectively.
The heat transfer model is represented in Fig. 4, with
the pellet discretized into three zones of equal volume.
Eqs.(3), together with the conditions of heat flux vanishing at the pellet center and the continuity of the
temperatures and heat fluxes at the three boundaries
pellet-gap-cladding-coolant allow the determination of
Tp (r,t), Tg (r,t) and Tc (r,t).
In addition to the above equations, five correlations
synthesizing the dependance of c p,p , k p , c p,c and kc as
a function of the fuel temperature and of kg as a function of both the reactor power and the burn-up have
been adopted.
The condition at the cladding-coolant interface is determined by the distributed heat transfer connector
variables.
Finally, the effective fuel temperature, used to evaluate the Doppler feedback contribution on neutronics,
is defined as follows:
4
5
Te f f = T |r=0 + T |r=R .
9
9

3.3

(4)

Moderator

The core moderator is modelled by the ThermoPower
library Water.Flow1D, with a small extension to
make the fluid density available to the point kinetics
model. The coolant model has the same number of
Figure 4: Fuel pellet radial scheme for heat transfer mod- volumes as the fuel. The convective heat transfer beelling
tween the two components is calculated at each node
by
The main assumption of the model is to consider only
φmod = −φc ,
(5)
the radial heat transfer, thus disregarding both the axφmod = γ (Tc − Tmod ) ,
ial and the circumferential diffusions. Fourier’s equation is discretized radially in five zones, and longitudi- where φmod and φc are, respectively, the moderator and
nally in a user-decidable number of segments (N). For the fuel cladding heat flux, γ is the heat transfer cothe pellet, gap and cladding the corresponding balance efficient, and Tmod and Tc are the moderator and fuel
The Modelica Association

426

Modelica 2005, March 7-8, 2005

Object-Oriented Modeling, Simulation and Control of the IRIS Nuclear Power Plant with Modelica

cladding temperatures. Detailed RELAP simulations
have shown that the heat transfer coefficient is approximately constant for all the operating conditions the
control system is concerned with.

3.4

Pressurizer Model

The pressurizer model is based on a lumped parameter approach, which is appropriate to the IRIS case.
Both water properties in the liquid volume and in the
steam volumes are assumed as homogeneous, at equal
pressure but not at thermodynamic equilibrium.
The model is based on two groups of dynamic mass
and energy balance equations, the first for the liquid
phase and the second for the vapor phase inside the
tank. Mass and energy transfer between the two phases
is provided by bulk condensation and surface condensation of the vapor phase, and by bulk boiling of the
liquid phase. Additional energy transfer can take place
at the surface if the steam is superheated.
External interfaces are provided for connections to the
hydraulic loop by a bottom flange and to a safety circuit by a safety flange; also available are a heating
power command input and a level signal probe output.
The heating power input is processed by a limiter and
a low pass filter block to simulate the delay in heating
effect and the limited heaters power. The resulting effective heating power signal drives the production of
saturated steam by the heaters at a rate corresponding to the difference between the enthalpy of the liquid
holdup and the enthalpy of saturated steam. For simplicity, the corresponding steam flow enters directly
the steam holdup, without causing heating of the liquid holdup.
The bottom flange’s flow enters directly the liquid volume; its pressure is increased depending on the liquid
holdup’s level.
The metal wall dynamics is taken into account, assuming uniform temperature. Heat transfer takes place between the metal wall and the two phases and between
the wall and the external ambient at fixed temperature.

4

Control

Figure 5: Control system architecture
At the top level is located a supervisory control system
with the following functions:
• Establish the plant electric power reference signal. Such reference signal will be used to derive
reference and/or feedforward signals for the other
major control loops.
• Monitor
plant
conditions
and
determine/coordinate the appropriate operating
modes for the major control systems.
The control sub-systems have different settings and a
varying structure (i.e., different inputs and different
controller structure) depending on the specific operating mode of the plant.
All the operating modes to drive the plant during the
non-emergency maneuvers have been designed [8];
nevertheless, only the “full-power” control mode (nuclear flux from 20% to 100%) has been fully implemented, simulated and tested yet, so, from here on, the
description will cover only such operating mode.

4.1

The control design of the IRIS nuclear power plant is
a complex task, with objectives that, depending on the
plant operating conditions, vary from the management
of start-up sequences to the recover from turbine or reactor trips and to the grid power/frequency regulation
at full nuclear power.
The Modelica Association

Classic design concepts, for early nuclear units, relied on separate control systems for each control loop,
and limited signal interaction between the loops [9].
This simplified the design of each loop, particularly
with analog control systems where each interconnection added hardware expense. On the other side, the
current trend is for more integrated systems that can
take advantage of coordinating the different control
loops [7]. This allows for more effective plant control,
but complicates the control system failure analysis. A
viable solution for IRIS is the choice of a hierarchical
control system, as depicted in Fig. 5.

Supervisory Control

The supervisory control system uses the normalized
desired power as an input signal to derive the reference and feedforward signals for the lower-level control systems. On the base of the desired power the temperature and nuclear flux reference for the reactor control are derived, along with a pressure reference for the

427

Modelica 2005, March 7-8, 2005

A. Cammi, F. Casella, M. Ricotti, F. Schiavo

The control is based on a PID, its input being the reference pressure signal coming from the supervisory control system and the actual steam pressure measured at
the turbine inlet, with suitably low-pass filtering action. The PID output is then summed to the amplified
frequency mismatch (i.e., the difference between the
actual generator frequency and the desired frequency),
with the gain depending on the grid droop setting. The
4.2 Reactor Control
resulting signal is fed to the TAV drive system after beThe aim of the reactor control is to control the coolant ing filtered by a non-linear algebraic function, which
temperature, and thus the reactor nuclear power, by is an approximate inverse of the TAV characteristic.
driving the control rods stepping system. As a matter
of fact, the reference is a temperature signal coming 4.4 Steam Dump Control
from the upper level, while the measurements include
the core coolant average temperature (obtained as the The steam dump control system must control steam
mean between the temperature at the core inlet and the pressure when the turbine admission valve control is
one at the core outlet) and the nuclear neutron flux (ob- not doing so, and must provide a backup in all other
tained through special sensors enclosed within the core cases. Experience shows that a simple PID control pershielding).
forms well, particularly if the system uses hydraulic
The temperature error, with suitable dynamic compen- steam dump valves, as it will be in the IRIS case.
sation, is used to generate an error signal for determin- The controlled variable is the steam dump valve opening the speed request for the control rods, along with ing, while the controller inputs are the pressure refera power mismatch signal which is used to improve the ence (from the upper level) and the turbine inlet steam
stability and the velocity of the reactor control system pressure (low-pass filtered). Additional steam-dump
response. The power mismatch signal (i.e. the dif- action is available in case of need: the power referference between the reference and the measured neu- ence, filtered through a rate compensator and a suittronic flux) is fed into a rate compensation filter, to able gain, is added to the steam dump valve control
eliminate steady-state influence, and then into a non- signal, to provide a faster response in case of sudden
linear, power-dependant gain, to improve low-power changes in the requested power (e.g., when a reactor or
response while avoiding high frequency excitation of a turbine trip occur and the supervisory control system
the rod stepping system.
instantaneously lowers the power reference).
The combined error signal enters a rod speed program that features a small dead band to avoid high
frequency rod stepping. The speed request thus gen- 4.5 Feedwater Control
erated is then serviced by a servo control system em- The feedwater control system directly controls the
bedded within the control rods drive mechanism. This feedwater flow in the secondary side by acting on a
servo is currently described by a high-level behav- valve located at the feedwater pumps. The structure is
ioral model, which could be eventually replaced by a based on two PID controllers in cascade configuration.
physical-based model.
The inner loop acts to control feedwater flow to the refturbine and steam dump control systems and with the
flow rate reference for the feedwater control. The signals to be fed to the lower systems are derived from
the desired power reference with linear filtering and
through look-up tables based on steady-state plant balances.

4.3 Turbine Admission Valve Control
The turbine system for the IRIS power plant has not
been completely designed yet and it is reasonable to
assume that the turbine supplier will provide most of
the requirements for the turbine control system; however, the design must be compatible with the overall
IRIS plant control strategy. The most important constraint is that the IRIS turbine control will have the
responsibility for controlling steam pressure by acting
on the turbine admission valve (TAV).
The Modelica Association

erence value obtained from the supervisory control. In
the ideal case with perfect settings in the supervisory
controller, this would result in the plant operating at
the desired power, at least in steady state. Of course,
such an open loop control on power would be sensitive to parameter variations, so the outer loop provides
a trim signal to adjust feedwater flow to achieve the desired power by the action of a PID controller with the
reference and the actual power as inputs. The feedwater valve control signal is then filtered by a non-linear
algebraic function, which is an approximate inverse of
the valve characteristic.

428

Modelica 2005, March 7-8, 2005

Object-Oriented Modeling, Simulation and Control of the IRIS Nuclear Power Plant with Modelica

4.6 Digital PI controller

CS = CSmin;
CSport.signal[1] = CSmin;

Models for digital PI and PID controllers, in ISA form,
else
CS = CSwind;
have been implemented. Here, for the sake of brevity,
CSport.signal[1] = CS;
only the PI development is briefly showed: the PID
end;
model development is quite similar.
else
The model is based on the standard industrial ISA for...
mulation, with the output calculation formula obtained
where the parameters CSmax and CSmin, are the upwith a Tustin discretization:
per and lower saturation limits for the control action.
!
With this implementation structure, the controller inte1
CS(s) =K p (bSP(s) − PV (s)) +
(SP(s) − PV (s))
gral state is automatically updated at every execution
TI s
cycle so to be coherent with the last output sample.
!
⇓

Tustin: s =

CS(z) =SP(z)

2 z−1
Ts z + 1

(6)

5

a0 + a1 z−1
b0 + b1 z−1
+
PV
(z)
1 − z−1
1 − z−1

Model Management through the
project life-cycle

with

Object-oriented features such as inheritance and replaceable components are often described as key factors in the development of reusable model libraries.
.
In fact, they can also be extremely useful for the
proper management of families of application models
The complete controller model includes also advanced throughout an engineering project’s lifetime, as it will
features like manual and tracking working mode, out- be explained in this section with reference to the IRIS
project.
put saturation, and anti wind-up mechanism.
The resulting block has two boolean inputs (automatic
and tracking switch signals), four discrete real inputs 5.1 Requirements
(set-point, process value, manual and tracking signals)
During the IRIS project lifetime, a considerable numand a discrete real output (control signal).
The Modelica implementation exploits the language ber of model variants will have to be built and anafeatures for digital blocks, using discrete variables and lyzed; some of them will become obsolete and will
with the instructions enclosed within a sampling loop: have to be discarded, while others should be kept consistently up-to-date. The motivations of the model
when {initial(),sampleTrigger} then
variants are now briefly discussed.
...
[PI computations]
Depending on the specific simulation to be performed,
...
different accuracy vs. computational load trade-offs
end when;
are required. Reference simulations should be perThe anti wind-up mechanism is implemented via an formed with the maximum level of accuracy and deauxiliary variable:
tail, and cross-checked with the results of the reference simulations performed with the certified RELAP
CSwind=pre(CS)+a0*SP+a1*pre(SP)+b0*PV+
code. When performing simulations around a certain
b1*pre(PV);
operating point, some approximations could then be
where Cswind is the auxiliary variable, CS the con- introduced, which are only valid for that operating retrol variable, SP the set-point and PV the process gion; it should be possible to easily check simplified
value.
versions against their more accurate counterparts.
The actual control value is chosen depending on the Some of the plant parameters (e.g. the pump charactercontroller logic state (automatic, manual or tracking)
istics, or some plenum volumes) are not yet definitive,
and on the saturation values, e.g. :
and could change in the future; when one of such paif AUTO then
rameters is changed, it is essential that all the current
if CSwind >= CSmax then
model variants are updated consistently.
CS = CSmax;
Once the initial phase of the control system design has
CSport.signal[1] = CSmax;
been carried out, a systematic simulation campaign
elseif CSwind <= CSmin then
− 2 K p b TI + K p Ts
2 K p b TI + K p Ts
, a1 =
2 TI
2 TI
2 K p b TI − K p Ts
− 2 K p b TI − K p Ts
, b1 =
b0 =
2 TI
2 TI
a0 =

The Modelica Association

,

429

Modelica 2005, March 7-8, 2005

A. Cammi, F. Casella, M. Ricotti, F. Schiavo

must be performed to check that the operational constraints (i.e., the activation thresholds of the protection
system) are never violated in all the predicted operating conditions and transients; thousands of different
simulation runs can be required. To carry out this task,
the simplest and fastest possible variant of the plant
model should be used.
It should be also kept in mind that the plant models will be developed, used, and maintained by different people over a wide time span (several years)
and at widely spaced sites (US, Europe). For instance,
the model presented in this paper will be presumably
frozen for some months, and then possibly resumed
when the project will enter the commercial phase. It
is therefore essential to avoid building a plethora of
distinct models, differing only by some details, which
would be extremely difficult to maintain and document
consistently.
Figure 6: The Base Simulator Model

5.2 Implementation
The top-level structure of the simulator is represented
in Fig. 6: the TGFWS block contains the Turbine/Generator/Feedwater system model; the NSSS
block contains the Nuclear Steam Supply System
model, i.e. the nuclear reactor, with the primary and
secondary loops. The two are connected to each other
by thermo-hydraulic connectors. The control side is
represented by the CS (Control System) block, collecting all the control loops, and the SS (Supervisory system) block, which generates the set points for
the CS based on the plant load request. Three bus
connectors carry the sensor, actuator, and reference
signals. This structure is common to all the possible variants of the model, and thus contained in the
IRISSimulatorBase partial model. Different versions of the simulator can be instantiated by selecting the actual content of each block; for instance, one
could use the simplified TGFWS model described in
Section 2, or a more detailed one.
The NSSS model contains a replaceable model
(HelicalCoil) for the secondary side of the oncethrough steam generator, which can be implemented
by either the finite-volume or the moving boundary
model, and by adding through inheritance the desired
equations to compute the heat transfer coefficient.
Besides that, it is possible to vary dramatically the
degree of detail and the computational load of the
model by changing the number of nodes in the core
and once-through generator models, as well as by
redeclaring the medium models in the primary and
secondary loop components. The default medium
The Modelica Association

models are the IF97-based water models taken from
Modelica.Media, but it is possible to use much
faster models, based either on table interpolation or on
equation-based simplified medium models. The thermodynamic conditions of the fluid in the primary loop
conditions vary in a rather narrow range (140 to 160
bar, 270 to 330 degrees Celsius), so that extremely
simplified models can still be acceptable; the fluid conditions in the secondary loop vary in a broader range,
from subcooled liquid to superheated steam, albeit in a
narrow pressure range around 58 bar, due to the pressure control system action.
Last, but not least, if an incompressible fluid model is
adopted for the primary loop, the fast pressure states
caused by the small compressibility of the fluid, coupled with the small hydraulic resistances around the
circulation loop, are automatically avoided, without
any need to change the component models. This is essential to allow the use of the faster explicit integration
algorithms (e.g. forward Euler).
The simulation suite is then organized as a small library (Fig. 7), containing the “empty” base models,
and the actual models of the different parts, without
any unnecessary duplicate of data. Any specific variant of the simulation model can be instantiated from
this library by using suitable modifiers. For example, the variant V2 of the simulator, using a simple
incompressible water model for the primary loop, 7
nodes in the core model, a finite volume model of the
steam generator with 15 nodes using Chen’s correla-

430

Modelica 2005, March 7-8, 2005

Object-Oriented Modeling, Simulation and Control of the IRIS Nuclear Power Plant with Modelica

6 Simulation
The results of a closed-loop simulation, obtained with
the tool Dymola ([5]), are now presented. The reference transient is a filtered step variation of the electrical load reference, from 90% to 100% and then back
to 90%. Although such a rude transient will never
be performed on the actual plant, it is usually employed to assess the overall dynamic response of the
control system, in terms of speed of response, damping, overshoot, and so on. The normalized transients
of the neutron flux (representative of the generated nuclear power) and of the generated electrical power are
shown in Fig. 8, along with the reference power signal.
The responses are well-damped and with limited overshoot. The neutron flux transient takes into account
the effect of the step-by-step actuation mechanism, as
well as of the dead-band included to avoid persistent
chattering around a specific operating point. The corresponding normalized transients of some control variables (i.e. TAV opening, feedwater flow rate, and rod
insertion) are shown in Fig. 9.
Figure 7: Iris Simulation Suite

tion for the heat transfer coefficient, the variant V1 of
the TGFWS, and the variant 2 of CS and SS, is instantiated as follows:

model IRISSimulator_V2
extends IRISSimulatorBase(
redeclare Plants.NSSS_V1 NSSS(
redeclare package PrimaryMedium =
Media.SimpleIncompressibleWater,
Core(N = 7),
redeclare Plants.HelicalCoilFVChen
HelicalCoil(N=15)),
redeclare Controls.CS_V2 CS,
redeclare Controls.SS_V2 SS,
redeclare Plants.TGFWS_V1 TGFWS);
end IRISSimulator_V2;

Figure 8: Normalized response to a step load variation:
measured variables

IRISSimulatorBase is the empty base model described at the beginning of the section, and its four
replaceable components NSSS, TGFWS, CS, SS
are of type NSSSBase, TGFWSBase, CSBase and
SSBase, which again only contain the interfaces. The
NSSS model in turn contains the replaceable steam
generator model HelicalCoil.
In this way, it is straightforward to maintain a consistent state for a potentially large family of simulator
variants, as well as documenting all of them efficiently.
The Modelica Association

7

Conclusions and Future Work

In this paper, the application of Modelica to the
study of the control system of the new IRIS nuclear
power plant has been presented; this is also the first
industrial-scale application of the ThermoPower Modelica library.
The well-behaved nature of the closed-loop transients

431

Modelica 2005, March 7-8, 2005

A. Cammi, F. Casella, M. Ricotti, F. Schiavo

and Medium Electricity Grids, Dubrovnik, Croatia, June 3-4, 2004.
[2] A. Cammi, F. Casella, M.E. Ricotti, and F. Schiavo. Object-oriented modelling for integral
nuclear reactors dynamic simulation. In International Conference on Integrated Modeling
& Analysis in Applied Control & Automation,
Genoa, Italy, October 3-4, 2004.
[3] M.D. Carelli. IRIS: A global approach to nuclear
power renaissance. Nuclear News, 46(10):32–42,
September 2003.

Figure 9: Normalized response to a step load variation:
control variables

has confirmed that the new reactor concept will not
pose exceedingly difficult problems to the control engineers, compared with already existing PWR plants.
On the other hand, the availability of a detailed dynamic model will allow the study of more advanced
control concepts, to cope with situations such as. e.g.,
load/frequency control in small grids, or improved
management of blackout transients.
The object-oriented features of the Modelica language
(replaceable classes in particular) have been fully exploited to allow the efficient management of all the
variants of the plant simulator, which will be needed
throughout the project’s life-time. The structure of the
simulation suite will allow an easier re-use and extension of the models developed so far, when the project
will eventually enter the detailed engineering phase,
prior to the construction of the first plant.

Acknowledgements

[4] F. Casella and A. Leva.
Modelica open
library for power plant simulation: Design
and experimental validation. In 3rd Modelica Conference, Linköping, Sweden, November
3-4, 2003. http://sourceforge.net/
projects/thermopower/.
[5] Dymola. Dynamic Modelling Laboratory, v. 5.3.
Dynasim AB, Lund, Sweden.
[6] D. Grgic, T. Bajs, and L. Oriani. Development of
RELAP5 nodalization for IRIS non-LOCA transient analyses. In American Nuclear Society Topical Meeting in Mathematics & Computations
(M&C), Gatlinburg, USA, April 6-10, 2003.
[7] IAEA. Modern instrumentation and control for
nuclear power plants: A guidebook. Technical Report 387, International Atomic Energy
Agency, Vienna, 1999.
[8] F. Schiavo and G. Storrick. IRIS control systems
conceptual design. Internal report STD-ES-0434, Westinghouse Electric Company, September,
2004. Westinghouse Electric Company Proprietary.
[9] M. A. Schultz. Control of Nuclear Reactors and
Power Plants. McGraw Hill, New York, 1961.

The authors wish to thank Westinghouse Electric
Company LLC (IRIS project partner), and particularly [10] A. S. L. Shieh, R. Krishnamurthy, and V. H.
Ransom. Stability, accuracy, and convergence
Gary D. Storrick, Luca Oriani and Mario D. Carelli,
of the numerical methods in RELAP5MOD3.
for their contribution and support.
Nuclear Science and Engineering, 116(10):227–
244, 1994.

References
[1] A. Cammi, F. Casella, M.E. Ricotti, and F. Schiavo. New modelling strategy for IRIS dynamic
response simulation. In 5th International Conference on Nuclear Option in Countries with Small
The Modelica Association

432

Modelica 2005, March 7-8, 2005

Session 5c
Tools II

The Modelica Association

433

Modelica 2005, March 7-8, 2005

The Modelica Association

434

Modelica 2005, March 7-8, 2005

A Portable Debugger for Algorithmic Modelica Code

A Portable Debugger for Algorithmic Modelica Code
Adrian Pop, Peter Fritzson
PELAB – Programming Environment Lab, Dept. Computer Science
Linköping University, S-581 83 Linköping, Sweden
{adrpo, petfr}@ida.liu.se

Abstract
In this paper we present the first comprehensive debugger for the algorithmic subset of the Modelica language, which augments previous work in our group on
declarative static and dynamic debugging of equations
in Modelica. This replaces debugging of algorithmic
code using primitive means such as print statements or
asserts which is complex, time-consuming and errorprone.
The debugger is portable since it is based on transparent source code instrumentation techniques that are
independent of the implementation platform.
The usual debugging functionality found in debuggers
for procedural or traditional object-oriented languages
is supported: setting and removing breakpoints, singlestepping, inspecting variables, back-trace of stack contents, tracing, etc.

1

representation with debugging nodes (or sites) that actually performs calls to the debugging functions. We
have introduced a new compiling phase in the compiler
where we walk on the internal representation and augment it with calls to several debugging functions implemented in C.
We have experimented with several ways of augmenting the internal compiler representation with debug
nodes in order to search for the best memory consumption vs. speed of the debugger. These augmentation
choices deal with the way the variables and code position is passed to the debugger functions.
The paper is structured as follows: This section presented an introduction and related work. Next section
presents a debugging session on a short Modelica example, concentrating on the debug functionality. Also
the debugger commands are introduced here. Details
about the debugger are presented in detail in Section 3.
Section 4 presents our conclusion and future work.

Introduction and Related Work

Most language development environments provide
some kind of support for debugging and profiling.
Such techniques have also been developed for Modelica at the prototype level with regards to supporting
declarative debugging of equation-based models [1, 2].
The presented work complements the existing debugging work with the first (to our knowledge) portable
debugger for the algorithmic part of the Modelica language. The debugger is part of the Open Modelica project [3, 4].
There are several techniques for creating debuggers.
Most of them are not portable and rely heavily on
knowledge of the operating system and the underlying
machine [5].
The approach we use in this paper is based on source
code instrumentation of the intermediate representation
in the compiler, similar with the work described in [68]. One can view the Modelica algorithmic code as an
event generator and the debugger as a collector of these
events that reacts to them accordingly.
The compiler has intimate knowledge of the Modelica
code in its internal representation. We augment this

The Modelica Association

2

A debugging Session

This section presents the debugger functionality presenting a debugging session on a short Modelica example. The functionality of the debugger is presented using pictures from the Emacs debugging mode for Modelica (modelicadebug-mode).

2.1

The Debugger Commands

The Emacs Modelica debug mode is implemented as a
specialization of the Grand Unified Debugger (GUD)
interface (gud-mode) from Emacs [9]. Because the
Modelica debug mode is based on the GUD interface,
some of the commands have the same familiar key
bindings.
The actual commands sent to the debugger are also
presented together with GUD commands preceded by
the Modelica debugger prompt: mdb@>.
If the debugger commands have several alternatives
these are presented using the notation: alternative1|alternative2|....

435

Modelica 2005, March 7-8, 2005

A. Pop, P. Fritzson

The optional command components are presented using notation: [optional].
In the Emacs interface: M-x stands for holding down
the Meta key (mapped to Alt in general) and pressing
the key after the dash, here x, C-x stands for holding
down the Control (Ctrl) key and pressing x,
<RET> is equivalent with pressing the Enter key and
<SPC> with pressing Space key.

Instead of writing break one can use alternatives
br|break|breakpoint.
Alternatively one can delete all breakpoints using:
mdb@> cl|clear <RET>

Showing all breakpoints:
mdb@> sh|show <RET>

2.1.3 Stepping and Running
2.1.1 Starting the Modelica Debugging To perform one step (gud-step) in the Modelica code:
Subprocess
C-c C-s
C-x C-a C-s
mdb@> st|step <RET>

The command for starting the Modelica debugger under
Emacs is the following:

To continue after a step or a breakpoint (gud-cont) in
the Modelica code:

M-x modelicadebug <RET> executable <RET>

2.1.2 Setting/Deleting Breakpoints
A part of a session using this type of commands is
shown in Figure 1 below. The presentation of the commands follows.

C-c C-r
C-x C-a C-r
mdb@> ru|run <RET>

Examples of using these commands are presented in
Figure 2. The example uses an extended version of
Modelica [10] and is briefly described in Section 3.1.

Figure 1: Using breakpoints

To set a breakpoint on the line the cursor (point) is at:
C-x <SPC>
mdb@> break on file:lineno|string <RET>

Figure 2: Stepping and running

To delete a breakpoint placed on the current source
code line (gud-remove):
C-c C-d
C-x C-a C-d
mdb@> break off file:lineno|string <RET>

The Modelica Association

2.1.4 Examining Data
There are no GUD keybindings for these commands
but they are inspired from the GNU Project debugger
(GDB) [2].

436

Modelica 2005, March 7-8, 2005

A Portable Debugger for Algorithmic Modelica Code

To print the contents/size of a variable one can write:

Automatic printing of variables at every step or breakpoint can be specified by adding a variable to a display
list:

mdb@> pr|print variable_name <RET>
mdb@> sz|sizeof variable_name <RET>

at the debugger prompt. The size is displayed in bytes.
Variable values to be printed can be of a complex type
and very large. One can restrict the depth of printing
using:

mdb@> di|display variable_name <RET>

To print the entire display list:
mdb@> di|display <RET>

Removing a display variable from the display list:

mdb@> [set] de|depth integer <RET>

Moreover, we have implemented an external viewer
written in Java called ModelicaDataViewer to
browse the contents of such a large variable. To send
the contents of a variable to the external viewer for inspection one can use the command:

mdb@> un|undisplay variable_name <RET>

Removing all variables from the display list:
mdb@> undisplay <RET>

Printing the current live variables:
mdb@> li|live|livevars <RET>

mdb@> bw|browse|gr|graph var_name <RET>

at the debugger prompt. The debugger will try to connect to the ModelicaDataViewer and send the contents of the variable. The external data browser has to
be started a priori. If the debugger cannot connect to the
external viewer within a specified timeout a warning
message will be displayed. A picture with the external
ModelicaDataViewer tool is presented in Figure 3
below:

Instructing the debugger to print or to disable the print
of the live variable names at each step/breapoint:
mdb@> [set] li|live|livevars [on|off]<RET>

Figure 4 shows examples of some of these commands
within a debugging session:

Figure 4: Examining data
Figure 3: External variable browser

2.1.5 Additional commands

If the variable which one tries to print does not exist in
the current scope (not a live variable) a notifying warning message will be displayed.

The stack contents (backtrace) can be displayed using:
mdb@> bt|backtrace <RET>

Because the contents of the stack can be quite large,
one can print a filtered view of it:

The Modelica Association

437

Modelica 2005, March 7-8, 2005

A. Pop, P. Fritzson

3

mdb@> fbt|fbacktrace filter_string <RET>

Also, one can restrict the numbers of entries the debugger is storing using:
mdb@> maxbt|maxbacktrace integer <RET>

For displaying the status of the Modelica runtime:
mdb@> sts|stat|status <RET>

The status of the extended Modelica runtime comprises
information regarding the garbage collector, allocated
memory, stack usage, etc.
The current debugging settings can be displayed using:
mdb@> stg|settings <RET>

The settings printed are: the maximum remembered
backtrace entries, the depth of variable printing, the
current breakpoints, the live variables, the list of the
display variables and the status of the runtime system.
One can invoke the debugging help by issuing:

The Debugger Implementation

This section presents the debugging strategy in detail.
We first start with two examples on how the debugger
instruments the code, and then we enter into the details
of the implementation. The examples illustrate Modelica algorithmic code and some of the new extensions
of the Modelica language like pattern matching and
union type declarations on a simple expression evaluator example.

3.1

Example Applications to Debug

In this section we present two examples of Modelica
algorithms.

3.1.1 Bubble Sort function
The first example application we present for debugging
is a BubbleSort function:
function bubbleSort
input Real [:] unordElem;
output Real [size(unordElem, 1)] ordElem;
protected
Real tempVal;
Boolean isOver = false;
algorithm
ordElem := unordElem;
while not isOver loop
isOver := true;
for i in 1:size(ordElem, 1)-1 loop
if ordElem[i] > ordElem[i+1]
then
tempVal
:= ordElem[i];
ordElem[i]
:= ordElem[i+1];
ordElem[i+1] := tempVal;
isOver := false;
end if;
end for;
end while;
end bubbleSort;

mdb@> he|help <RET>

For leaving the debugger one can use the command:
mdb@> qu|quit|ex|exit|by|bye <RET>

A session using these commands is presented in Figure
5 below:

The instrumented version of this function is presented
below:
function bubbleSort
input Real [:] unordElem;
output Real [size(unordElem, 1)] ordElem;
protected
Real tempVal;
Boolean isOver = false;
algorithm
Debug.register_in("unordElem",unordElem);
Debug.step(...);
ordElem := unordElem;
Debug.register_out("ordElem", ordElem);
Debug.register_in("isOver", isOver);
Debug.step(...);
while not isOver loop
isOver := true;
Debug.register_out("isOver", isOver);
Debug.register_in("ordElem",ordElem);
Debug.step(...);
for i in 1:size(ordElem, 1)-1 loop

Figure 5: Additional commands

The Modelica Association

438

Modelica 2005, March 7-8, 2005

A Portable Debugger for Algorithmic Modelica Code

assert statements because it provides better control
through stop/inspect functionality. As one can see the
code grows quite much when is instrumented, but this
does not affect the final version of the code. For debugging purposes the user is rather interested in correctness of the code than in the speed/size of the code.

Debug.register_out("i", i);
Debug.register_in("i", i);
Debug.register_in("ordElem[i]",
ordElem[i]);
Debug.register_in("ordElem[i+1]",
ordElem[i+1]);
Debug.step(...);
if ordElem[i] > ordElem[i+1]
then
Debug.register_in("i", i);
Debug.register_in(
"ordElem[i]",
ordElem[i]);
Debug.step(...);
tempVal := ordElem[i];
Debug.register_out(
"tempVal",
tempVal);
Debug.register_in("i", i);
Debug.register_in(
"ordElem[i+1]",
ordElem[i+1]);
Debug.step(...);
ordElem[i] := ordElem[i+1];
Debug.register_out("i", i);
Debug.register_out(
"ordElem[i]",
ordElem[i]);
Debug.register_in("i", i);
Debug.register_in(
"tempVal",
tempVal);
Debug.step(...);
ordElem[i+1] := tempVal;
Debug.register_out("i", i);
Debug.register_out(
"ordElem[i+1]",
ordElem[i+1]);
Debug.step(...);
isOver := false;
Debug.register_out("isOver",
isOver);
Debug.step(...);
end if;
end for;
Debug.register_out("i", i);
Debug.register_out(
"ordElem",
ordElem);
Debug.step(...);
end while;
Debug.register_out("isOver", isOver);
Debug.register_out("ordElem",ordElem);
Debug.step(...);
end bubbleSort;

3.1.2 An expression evaluator
The second application is an expression evaluator implemented in the algorithmic Modelica subset extended
with support for recursive tree data structures and a
case-expression construct that allows pattern-matching
and tree traversal. These language extensions are described in a companion paper [10] and are independent
of the implemented debugger described here. For the
sake of completeness we make present the extensions
briefly in the following.
The declaration of an abstract syntax tree (AST) data
type Exp for representing simple expressions:
uniontype Exp
record RCONST Real x1; end RCONST;
record PLUS Exp x1; Exp x2; end PLUS;
record SUB
Exp x1; Exp x2; end SUB;
record MUL
Exp x1; Exp x2; end MUL;
record DIV
Exp x1; Exp x2; end DIV;
record NEG
Exp x1;
end NEG;
end Exp;

The union type declaration above is defining record
constructors for the nodes of the simple expression representation. Examples of expressions represented in
this way can be found in the following table:
Expression
1+2
1-2/3

Table 1: Representing simple expression trees

As presented above, the debugger instruments all
statements using the defined functions from the Debug
package. A statement is analyzed for input and output
variables which are registered with the debugging
framework using register_in and register_out
functions. The function step verify internally if we
have to stop at a breakpoint or continue without stopping and also is responsible for parsing user commands
addressed to the debugger. The instrumentation is better than what a programmer/user would do with print or

The Modelica Association

Modelica constructor form
PLUS(RCONST(1),
RCONST(2))
SUB(RCONST(1),
DIV(RCONST(2),
RCONST(3)))

To be able to evaluate simple expression trees we need
an evaluation function. The evaluation function will
apply pattern matching on the constructors of the expression language and then perform the actual evaluation on the components of the constructor.
Below we present the evaluation function eval of our
simple expression evaluator:

439

function eval
input Exp
exp_1;
output Real rval_1;
algorithm
rval_1 :=
match exp_1
local Real v1,v2;
Exp e1,e2;
case RCONST(v1) then v1;

Modelica 2005, March 7-8, 2005

A. Pop, P. Fritzson

case PLUS(e1,e2) equation
v1 = eval(e1); v2 = eval(e2);
then v1+v2;
case SUB(e1,e2) equation
v1 = eval(e1); v2 = eval(e2);
then v1-v2;
case MUL(e1,e2) equation
v1 = eval(e1); v2 = eval(e2);
then v1*v2;
case DIV(e1,e2) equation
v1 = eval(e1); v2 = eval(e2);
then v1/v2;
case NEG(e1) equation
v1 = eval(e1);
then -v1;
else
assert("Bad expression!"));
end match;
end eval;

Debug.register_out(“v1”, v1);
Debug.resister_in(“e2”, e2);
Debug.step(...);
v2 = eval(e2);
Debug.register_out(“v2”, v1);
Debug.register_out(“v1+v2”,v1+v2);
Debug.step(...);
then v1+v2;
...
else
Debug.step(...);
assert("Bad expression!"));
end match;
Debug.register_out(“realval_1”,realval_1);
Debug.step();
end eval;

This function has as input an expression in the form
presented in Table 1, second column. The expressions
are represented as trees using constructors defined in
the union type Exp. A model that uses this function is
presented below:
model Example
Exp exp=PLUS(
SUB(RCONST(4),
MUL(DIV(RCONST(16),
RCONST(2)),
RCONST(3))),
RCONST(10));
Real result;
algorithm
result := eval(exp);
end Example

As one can see, debugging code is added for each variable. This style of debug code instrumentation can be
changed into one where all the debugging calls are collapsed into just one call Debug.step(...) with more
arguments specifying in or out variables. We have experimented with different debug instrumentation styles
in order to choose the best speed vs. memory consumption for the debugger.
The following instrumentation functions are inserted
into the generated code:
• The functions: Debug.register_in("name",
var) and Debug.register_out("name", var)
register in a data structure the variables which are
live at a certain moment during the execution.
• The Debug.step(...) function then performs a
query of this data structure to show which variables
are available in the current context.
• The function Debug.register_in(...) registers variables that are used in the next statement or
expression.
• The function Debug.register_out(...) registers variables that result from the execution of the
previous statement or expression.

The first component of the Example model defines a
simple tree that corresponds to 4-16/2*3+10 expression. We used this simple expression in the examples
and figures in Section 2.
The instrumented code of the eval function is presented below. The debugging code is underlined to be
more visible:
function eval // instrumented version
import Modelica.Debugging;
input Exp
exp_1;
output Real realval_1;
algorithm
Debug.register_in(”exp1”, exp_1);
Debug.step(...);
realval_1 :=
match exp_1
local Real v1,v2;
Exp e1,e2;
case RCONST(v1) equation
Debug.register_out("v1", v1);
Debug.step(...);
then v1;
case PLUSop(e1,e2) equation
Debug.register_out("e1", e1);
Debug.register_out("e2", e2);
Debug.register_in("e1", e1);
Debug.step(...);
v1 = eval(e1);

The Modelica Association

Note that the debug instrumentation functions are lowlevel C functions that do not fulfill the Modelica requirement of being mathematical functions.

3.2

Overview

In this section we present the compilation path followed by the compiler when instrumenting the code
with debugging calls. The debugger is actually the executable generated by the compiler when instructed to
generate debugging calls before and after each relevant
Modelica statement or expression.
Figure 6 presents both the normal compilation path
performed by the compiler when compiling algorithmic
code and also the path followed by the compiler when
compiling algorithm sections that include debugging
information.

440

Modelica 2005, March 7-8, 2005

A Portable Debugger for Algorithmic Modelica Code

Modelica Code
Parser

function eval
input Exp;
output Real realval_1;
algorithm
...
end eval;

Modified Parser

Modelica
AST

Modelica AST
also
with position
information

Emacs
Modelica
Debug
Mode

Instrumentation
adds debug nodes
Modelica AST
Instumented
with
Debug Nodes
Linking with
the Modelica
runtime

Linking with the
Modelica runtime with
debugging support
Executable +
Debugging

Normal
Executable

else
variables_in = collect_variables(Node);
ode);
variables_out = collect_variables(Node);
position = collect_position(Node);
construct new tree with these nodes:
Debug.register_in(variables_in);
Debug.step(position);
Node;
Debug.register_out(variables_out);
replace Node with the new tree;
end else;
end foreach;

Figure 6: Normal compilation (left) and compilation
with debug support (right)

An overview of our debugging strategy is presented on
the right side of Figure 6. The path taken by the debugger comprises several more steps in order to instrument
the Modelica AST with debug nodes and live variable
information. Also, the runtime system is extended with
several data structures that support debugging and a
parser for the debugger commands.

3.3

Augmenting the Modelica AST with Debug
Call Nodes

The modified Modelica parser saves additional position
information about each statement or expression. This
information is used by the debug instrumentation phase
in order to generate calls to the debugger functions with
exact information on where the current execution is
taking place.
We use a very simple and effective algorithm when
instrumenting the ModelicaAST with debug nodes. We
sketch a pseudo code of this algorithm below:

The compiler can be instructed to generate debugging
nodes only when reaching certain nodes that are conform to a filter. Using this facility one can tell the compiler to perform debug instrumentation only on a certain function or a certain statement of the code. In this
way the delay in the execution speed introduced by the
debugging code can be kept to a minimum.
We have experimented with several ways of creating
the added debug nodes:

foreach ModelicaAST expression or
statement Node
if not filter(Node)
then select next Node;

The Modelica Association

Debugger
command
line and
output buffer

441

• Each variable is registered using a debug function
call either as in or out variable, as in the pseudo
code presented.
• All in variables are collected in a list and passed to
a single function call. The same approach is used
also for out variables. This has an impact on mem-

Modelica 2005, March 7-8, 2005

A. Pop, P. Fritzson

text. The distinction between in (parameters) and
out (results) variables is made when printing variable names.
• Debug.browse_variable() connects to the external viewer, and sends on demand the value of a
variable. This function stops the debugger until the
external viewer is done with the browsing.
• Debug.set_print_depth() sets the depth of
variable printing.
• Debug.max_remembered_stack_entries()
will set the maximum number of entries of the
logged stack trace.
• Debug.display_variable() will add the display variable to a display list to be printed at each
step or breakpoint.
• Debug.undisplay_variable() performs the inverse action of the Debug.display_variable().
• Debug.display() prints the list of variable names
present in the display list.
• Debug.undisplay() clears the display list.
• Debug.stack_add_node() pushes a node name
on the stack trace.
• Debug.stack_remove_node() pops a node name
from the stack trace.
• Debug.status() prints status information on the
extended Modelica runtime, e.g., garbage collections performed, amount of allocated memory, etc.
• Debug.settings() prints the current debugger
settings.

ory consumption, but uses fewer function calls, so it
is faster.
• The in and out variables are collected in two lists
which are passed as arguments to the step function
directly.
The best speed vs. memory consumption is highly dependent on the algorithmic code. However one can experiment with all these choices and choose the best debug instrumentation way for a specific code.

3.4

Short Presentation of the Debugger Library

The debugger library contains several functions implementing the actual debugger functionality and data
structures for bookkeeping of breakpoints, live variables, call stack, types of live variables, etc. The library
is implemented in C.
The debugger library has the following available functions:
• Debug.step(...) function with fixed parameters
file_name,
lineno,
columno,
function_name, next_statement is stopping the

•

•
•

•
•
•
•
•

execution of the algorithmic code if a breakpoint is
reached or one step was performed and waits for
commands from the user. If the commands are not
step or run it waits for more commands from the
user in a cycle. Additional parameters like the live
variables can be also passed to the Debug.step(...) function depending on the debug
instrumentation choice.
Debug.register_in(...)
function and Debug.register_out(...) function are used only
when no live variables are passed to the Debug.step() function. These functions are registering variables, either each variable at a time or several variables as a list.
Debug.parse_command() is called by Debug.step() either at a step or when a breakpoint
is reached.
Debug.execute_command() is called by the Debug.parse_command() when the user issues a
command. Depending on the command several
other functions are executed.
Debug.set_breakpoint() adds the breakpoint
into the breakpoint list.
Debug.delete_breakpoint() deletes the breakpoint from the breakpoint list.
Debug.clear() and Debug.show() clears or
shows all current breakpoints, respectively.
Debug.print_variable() prints the specified
variable to the debugger output.
Debug.print_livevars_names() prints the
names of the variables available in the current con-

The Modelica Association

More functions are actually present in the debug library
(dealing with variable – type mapping, connection to
the external viewer, etc). Here we have only presented
a limited set which has direct connections with the debugger commands presented in the paper.

4

Conclusions and Future Work

We have presented a portable and highly configurable
debugger for extended Modelica algorithmic code. Debugging of large algorithmic Modelica codes is now
possible using our debugger.
As future work we consider extension of the current
debugging scheme and also tighter integration of the
debugger with other Modelica tools.
Integration with declarative equation debugger techniques [1, 2] will be provided in the future, in order to
address debugging of the entire Modelica language
from a central debugger.
We have also started work to integrate the debugger
and the OpenModelica [3] compiler within the Eclipse
Development platform [11] which will provide integrated editing, navigation, simulation and debugging
for the Modelica language.

442

Modelica 2005, March 7-8, 2005

A Portable Debugger for Algorithmic Modelica Code

Acknowledgements
This research was partially funded by Foundation for
Strategic Research (SSF) in the Research in International Software Engineering (RISE) project and by the
Swedish National Graduate School in Computer Science (CUGS). We would also like to thank the reviewers for their feedback.

References
1.

Bunus, P., Debugging and Structural Analysis of
Declarative Equation-Based Languages, in Department of Computer and Information Science.
2002, Linköping University: Linköping, Licentiate Thesis.

2.

Bunus, P., Debugging Techniques for EquationBased Languages, in Department of Computer
and Information Science. 2004, May, Linköping
University: Linköping, PhD Thesis.

3.

Fritzson, P., et al. The Open Source Modelica
Project. in Proceedings of The 2th International
Modelica Conference, 18-19 March, 2002. Munich, Germany,
http://www.ida.liu.se/~pelab/modelica/OpenMod
elica.html.

4.

Fritzson, P., Principles of Object-Oriented Modeling and Simulation with Modelica. 2003:
Wiley-IEEE Press.

5.

GNU, T.F.S.F., The GNU Project debugger, Last
Accessed: December, 2004,
http://www.gnu.org/software/gdb/gdb.html.

6.

Tolmach, A.P., Debugging Standard ML. 1992,
October, Princeton University, PhD. Thesis.

7.

Pettersson, M. Portable Debugging and Profiling. in 7th International Conference on Compiler
Construction, 1998.

8.

Hanson, D.R. and M. Raghavachari, A MachineIndependent Debugger—Revisited. Software—
Practice and Experience, 1999. 29(10): p. 849862.

9.

GNU, T.F.S.F., Emacs, The Grand Unified Debuger (GUD), Last Accessed: December, 2004,
http://www.gnu.org/software/emacs/manual/html
_node/Debuggers.html#Debuggers.

10.

Fritzson, P., A. Pop, and P. Aronsson. Towards
Comprehensive Meta-Modeling and MetaProgramming Capabilities in Modelica, (to appear). in 4th International Modelica Conference,
7-8 March, 2005. Hamburg, Germany.

11.

Eclipse Development Platform, Last Accessed:
December, 2004, http://www.eclipse.org/.

The Modelica Association

443

Modelica 2005, March 7-8, 2005

The Modelica Association

444

Modelica 2005, March 7-8, 2005

ModelicaDB - A Tool for Searching, Analysing, Crossreferencing and Checking of Modelica Libraries

ModelicaDB - A Tool for Searching, Analysing, Crossreferencing and
Checking of Modelica Libraries
Olof Johansson, Adrian Pop, Peter Fritzson
PELAB – Programming Environment Lab, Dept. Computer Science
Linköping University, S-581 83 Linköping, Sweden
{olojo,adrpo,petfr}@ida.liu.se

tation structures’ behaviour is evaluated with simulation.

Abstract
This paper presents ModelicaDB, a tool that provides
several kinds of queries on repositories of Modelica
models.
The Modelica language has a growing user community that produce a large and increasing code base of
models.
However, the reuse of models within the Modelica
community can be greatly hampered in the future if
there are no tools to address a number of management
issues (i.e. scalable searching, analysing, crossreferencing, checking, etc) of such a large repository of models.
We try to address these issues by providing the Modelica community with a ModelicaDB database for storing models and services for quering this database to
perform a wide range of model engineering tasks in a
scalable fashion.
In the long-term, this work also aims at providing integration between Modelica tools and advanced product
development processes that rely on database technology.

1 Introduction
The long-term goal of this work is to efficiently integrate Modelica modeling simulation environments into
the overall product development process for products
that require advanced systems engineering [2].
There are many engineering processes that precede
modeling and simulation, and which output information
that defines structure, configuration, and input parameter data to simulation models of the product.
The following are of particular importance:
• The implementation structure of the product that defines its hierarchical division into different subsystems, their components with parameter values, and
component interconnections.
• Run-cases derived from the product requirements,
which define critical behaviour that the product
must achieve, and for which alternative implemen-

The Modelica Association

Given these, the simulation model designer can select
valid component models from Modelica libraries for
the components in the implementation structure, and
verify that the simulation component’s parameter
values are compatible and transferable from the information in the provided implementation structure.
With valid component models assigned and mappings
of their parameters, other tools can assemble a final
simulation model setup for execution and postprocessing of the simulation results for evaluation
analysis in subsequent engineering processes.
One purpose of ModelicaDB is to provide fast access
to possibly relevant component models in Modelica
Libraries, such that the assignment work can be
speeded up with automation tools.
In many cases, a matching model component will not
be available and ready for use in the Modelica Libraries, so the task of selecting component models is augmented by writing new ones or assembling valid
component models from other components in the Modelica library.
Such work is a creative design task, which is significantly aided if the designer has tools for searching, analysing, crossreferencing, and checking the libraries.
The used libraries have been developed by experienced library developers, and contain valuable designpattern knowledge of how to properly design and implement models, components and libraries. With fast
browsing and navigation tools, the designer can quickly
find similar designs to the one that is needed, study
how they are used/reused as components in other simulation models, and get a good understanding of how to
build a new simulation component.
The continuous development and improvement of
Modelica libraries by the Modelica design group and
similar efforts within companies, indicates that tools
with ModelicaDB functionality would be valuable to

445

Modelica 2005, March 7-8, 2005

O. Johansson, A. Pop, P. Fritzson

the Modelica community [7] for many other purposes
than we intend here.
Preliminary statistics from the Modelica 2.1 and
Modelica 1.5 libraries definitely show that this kind of
tool would be helpful for many engineers for grasping,
sharing, reusing, and following the large efforts in
simulation model development work that is being simultaneously conducted by many people.
The following sections of the paper provide statistics
from the current releases of the Modelica libraries, examples of use-cases for ModelicaDB, an overview of
the product development process and the intended role
of ModelicaDB, the functionality in the user interface
of ModelicaDB, an example of an SQL-query on the
database and finally results, experiences, future work
and conclusions.

2

Statistics from Modelica Standard
Libraries

Preliminary analysis of the Standard Modelica 1.5 and
2.1 libraries give the following statistics:
Modelica Library
Source files
Imports
Class definitions
Components
Equations
Algorithms

V 1_5
36
93
910
1628
1055
99

V 2_1
87
286
1447
4636
2768
633

V 2_1+
144
343
3141
6915
3262
1290

Component_refs
Expression_lists
Real literals

30304
14736
4413

60838
23715
5833

92636
25354
33158

Comments
String Comments

1720
1322

4755
3722

5649
5611

1326
3503
33187
88991
183323

3120
7218
59604
157760
336422

5093
13350
67373
235806
499125

Annotations
String literals
Integer literals
Other
Total elements:

V 2_1+ includes the following libraries: Modelica,
ModelicaReference, ModelicaTest, Modelica_Fluid,
Modelica_Interpolation, Modelica_Media and TeachingMaterial.
The source code directory contents of the libraries was
converted to a single xml file for each library release by
ModelicaXML, which then were preprocessed for import into ModelicaDB.
The Imports row is an indicator of reuse. The Component_refs row gives the count of the uses of a component variables in expressions.
The Comment row is a higher level parse node for
String_comments and Annotations .
String literals and Integer literals are heavily used
within annotations, especially for graphical object annotations in Modelica diagrams.
The above statistics shows that the size of the standard
libraries is substantial. Commercial Modelica development tools [1],[3] provide user interfaces with tree
views of the package hierarchy, connection diagrams,
and string based text searches, for quick navigation in
the libraries.
ModelicaDB adds additional search facilities and
other types of tree views on the libraries, that can help
to speed up the task of creating a new simulation component that efficiently reuses existing component models and design-pattern knowledge.

3 Use-Case Examples for ModelicaDB
The following section briefly describes use-cases that
illustrate use of additional types of views on Modelica
library structures. The views are computed in ModelicaDB, and presented in a tree- or list- based user interface that enables quick navigation with pointing and
clicking.

3.1

The following example use cases illustrate subtasks in
the process of finding reusable components and code
sections for building a new simulation component.

The number columns show the Modelica language
element count from different releases of the Modelica
standard libraries. Modelica 1_5 was downloaded from
the public library page [8]. Modelica 2_1 and 2_1+
were obtained from the Modelica CVS repository
2004-11-15.

The Modelica Association

Finding Relevant Simulation Components

446

• Finding component models with knowledge of the
SI-units their instances will need.
• Finding component models with knowledge of their
connectors.
• Finding equations with knowledge of the type of the
variables used in the expression.
• Finding algorithms with knowledge of their function
call parameters.

Modelica 2005, March 7-8, 2005

ModelicaDB - A Tool for Searching, Analysing, Crossreferencing and Checking of Modelica Libraries

3.2

Finding Relevant Component Using a
Categorization Tree

Categorization trees are an “add-on” feature to Modelica libraries, implemented with annotations.
Categorization trees allow a user to with a few clicks
down the tree find a set of relevant component models.
The categorization tree itself is an aid for remembering
where to find certain components.
Modelica objects can be annotated with a category,
which makes them easier to find with the aid of a category system (also known as classification system, focusing on some aspect). Examples of categories are
“Electrical Components”, “Motors”, “Transistors”,
“Capacitors” etc.
A category system is organized into a tree, where the
root category node contains all Modelica objects that
have that type of category or any of its sub categories.
Sub nodes in the category tree increase the specialization in the categorization. Leaf nodes in the categorization tree usually justify their existence if there are 5-25
component models under this node.
There are many standardized categorization systems
used in industry. Classification trees applied on electrical components are specified by IEC [22], and applied
in succeding industrial standards like RosettaNet Technical Dictionary which contains a much larger library
of classes [18]. ISO-31 [23] categorizes quantities and
units into 13 chapters and is well known from the Modelica SIunits in the standard libraries. There are other
examples of large classifications systems for standard
terms used in e-business.
Commercial design tools for the design processes
immediately before simulation, like process and instrumentation diagrams (P&ID), electrical design and
control system design usually contain a categorization
system for reusable components in their component
library catalogues.
The following use cases examples can be well supported with a classification tree.
• Finding a component model for a certain purpose.
• Finding connectors for a certain purpose.
• Finding equations for a certain purpose.

3.3 Verifying that a component is trustworthy
Simulation results must be accurate in order to provide correct decision support to the product design
process. The following use-cases illustrate ways the
engineer can determine this.
• Finding examples of usage
• Computing statistics of reuse in other models
• Computing statistics of use of certain design pattern
The last use-case applies when the engineer has designed a new simulation component, and wants to
check to what extent others library developers have
used a similar design pattern. Such statistics can indicate if this is a good way to solve the problem, and can
direct more detailed searches for gaining further confidence, or ideas of how to improve a design.

3.4 Finding relevant design patterns
There are many ways to solve a type of problem.
Some of these may prove to be better than others and
tend to re-occcur in many places as design patterns.
The characteristics of components that play a certain
role in the re-occuring interconnection structure of
the design pattern, can be used as search criteria.
3.5

Finding relevant naming conventions and
documentation
Following naming conventions is important for efficient communication in a large community. Naming
conventions usually vary between different engineering disciplines due to the history of their body of
knowledge and decisions made by library authors.
When extending or reusing a library, it is valuable to
follow the relevant conventions to ease reuse within
the community. The use-cases below illustrate how
this could be supported.
• Finding Naming Conventions for Variables and
Parameters

The category method of finding Modelica components
requires a library administrator to manually organize or
load a standardized categorization tree , and then annotate the component models with their classifications,
see section 3.7.
Once the classification tree structure is decided, pattern maching searches in the Modelica repository can
be used to populate the categories. For example, a classification tree for equations that compute a value of a
certain SIunit type, can be organized according to ISO-

The Modelica Association

31 and the standard SI-units library, and populated with
equations whose left hand side variable matches the
corresponding SIunit type category.

Pattern search of sorted listings of variable names for a
certain type of SI-unit variable, which may play a certain role in an equation.
• Finding References to Literature and Documentation
Searching documentation strings of pattern matched
components for references (e.g. brackets or other text
patterns that indicate a reference)

447

Modelica 2005, March 7-8, 2005

O. Johansson, A. Pop, P. Fritzson

3.6

Checking that the New Component Follows
Design Rules
Engineering domains may pose restrictions on simulation models that are not possible to enforce directly
in Modelica. The same applies for company specific
design rules that accumulate from experience, and
quality assurance procedures that reduce the cost for
errors and maintenance.
The following use-cases are simple examples of design rule checking.
3.6.1

Checking Naming
Classes, Components

Conventions

for

Pattern search and listing of Modelica object identifiers
names in a model that do not follow a certain style, or
convention.

3.6.2

Checking Complete Documentation

Checking Use of SIunits

Pattern search for variables whose type is not derived
from SIunits, and are not an array index or similar.

3.7

Managing Product Specific Library Development

Additional Analyses and Metrics

Michael Tiller presented analyses and metrics in [21],
which inspire development of additional reporting applications which can be computed with SQL-queries on
ModelicaDB.

3.9

Automatic Composition and Configuration
of new Models

ModelicaDB augments the work presented in [12] on
automatic composition and configuration of new models. Using ModelicaDB, designers can compose new
models by blending template like models with configuration information stored in other sources (text or XML
files, databases, etc) to create new models which are
configured accordingly.

4

Pattern search that for instance all components in a
class have a comment string etc.

3.6.3

3.8

The ModelicaDB
Architecture

Context

and

Figure 1 shows the role of ModelicaDB amongst some
of its surrounding engineering processes, connected
with major workflow arrows. Engineering tools
(FMDesign, ModelicaDB, ModelicaXML, Modelica
Simulation tool) support some of the processes. Engineering models are stored in files (Simulation program,
Modelica libraries) and in databases (FMDesign database, ModelicaDB database).

While developing a complex product that requires systems engineering, much can be gained by reducing the
number of variants of a certain type of simulation component.
The following use cases show how a library developer
can direct the users to the best components for various
purposes, and identify targets for refactoring amongst
existing components.

3.7.1

Finding Candidate Components for Categorization

Various pattern searches that detect component features
that make them interesting for a certain classification,
and perhaps exclude already classified components

3.7.2

Finding Duplicates or Variants of the
Same Models

Duplicates or variants of the same models can be found
by pattern searches that compares component sets of
variable types and equation patterns within a class
definition. Patterns that detect the same equations,
based on variable types, where the variables themselves
just have different names.

The Modelica Association

Figure 1. ModelicaDB in its context
The ModelicaDB front-end and database are described
in more detail below. We start by briefly describing the
role of the other tools in the integrated framework [15].
FMDesign is a tool for designing product concepts
with the aid of integrated requirement trees, functionmeans trees, product concept trees, and implementation
trees. The implementation tree specifies the product
structure and its interacting components on a level that
is detailed enough so its behaviour can be modeled and
simulated.
The simulation is deferred to one of the existing Modelica Simulation Tools [1][3][10]. All manual editing of
simulation models are performed in one of these tools,

448

Modelica 2005, March 7-8, 2005

ModelicaDB - A Tool for Searching, Analysing, Crossreferencing and Checking of Modelica Libraries

ModelicaXML is a program that converts Modelica
source code into XML-files [1]. Recent additions to
ModelicaXML is functionality for converting a whole
Modelica Library stored in a directory structure into
one XML-file. The size of the created files for the standard Modelica libraries version 1.5 and 2.1 is 16 MB
and 30 MB respectively.

tional procedural or object-oriented program which
navigates the parse tree structures.
The performance benefit of a database is first noticed
when the number of stored language objects exceed a
certain breakpoint.
Writing SQL-queries may be tricky at first, but usually results in little code for a complex task. With a
reusable set of SQL-queries for various types of
searches and analyses, a new query variant can quickly
be written using copy and modify, while verifying that
it produces expected results by executing it with paremeters that match a small but well known example
model.

4.2

5

and the component models are stored in Modelica Libraries. The simulation program is generated from the
configuration information stored in the implementation
tree for the product concept.

4.1

ModelicaXML Files

ModelicaDB Front-End Tool

This tool parses the ModelicaXML file and builds an
object structure in primary memory which can be synchronized or stored into tables in the ModelicaDB database.
The tool also contains a graphical user interface, for
fast navigation of the component model level Modelica
language constructs.
More detailed constructs like expressions are modelled as parse nodes in the database.
Appendix A shows the class diagram for the UMLmodel [6] that serves as design specification of ModelicaDB. [20] documents the whole UML-model that was
used for generating most of the ModelicaDB specific
source code that implements the front end and database.
The core specification for designing the ModelicaDB
UML model was the ModelicaXML DTD [11]. The
reference work used for its documentation was [4] and
[9].
The user interface displays the results of queries specific for the use-cases described in section 3 such that
found Modelica objects can be quickly inspected, and
further navigated, including retrieving and displaying
the original Modelica source code from the files. Section 5 gives an overview of the user interface.

4.3

ModelicaDB Database

This is a relational database that is used for processing
declarative SQL-queries that do complex searching,
compute the analyses, crossreferences, and checks.
The structure of the database is given in the UML
class diagram in Appendix A. The database schema can
be downloaded from [20] .
The benefit of using an SQL-database instead of navigating parse trees, is that the SQL database optimizer in
cooperation with indexes on tables can compute complex queries much faster on a large library, than a tradi-

The Modelica Association

ModelicaDB Functionality

This section gives a walkthrough of ModelicaDB frontend functionality available in its user interface. An
UML class diagram of the user interface design is
given in Appendix B. Tree views have a look and feel
similar to the windows file explorer, where the folder
icons indicate the class restriction or other meta-classes
shown in the UML-diagram in Appendix A. When an
object shown in a tree view is double-clicked, a form
appears which shows the objects attribute values and
direct relationships to other objects.

5.1

ModelicaRepository Main Window

This window allows the user to open a Modelica repository file stored in a fast binary format. The user can
also login to the database, load the complete repository
for caching at the local workstation or synchronize the
cached version with the latest changes in the database.
The main window provides a category tree for finding
suitable Modelica models, and open a Modelica Model
window for these.
Two different types of catalog windows can also be
opened from the Modelica repository window. The
class catalog window shows categorization trees for
Modelica classes, that are organized according to a
suitable standard, which allows engineers to quickly
find relevant component models for a certain type of
product component. Section 3.2 gave a use-case example.

5.2

ModelicaModel Window

The ModelicaModel window provides navigation of all
Modelica objects that are recursively owned by a ModelicaModel object, see Appendix A.
In ModelicaDB, a ModelicaModel object is the root of
all packages and component models that are assembled
within one particular ModelicaXML file. Different versions of the Modelica Standard Libraries, are for exam-

449

Modelica 2005, March 7-8, 2005

O. Johansson, A. Pop, P. Fritzson

ple rooted in different ModelicaModel objects in the
ModelicaRepository.
The window provides import functionality for ModelicaXML files, and various menu commands for searching, analyzing, crossreferencing, and checking selected
Modelica objects.
Below the command menu, the window shows the
package hiearchy tree which can be expanded down to
class definitions, their components, equations and algorithms.
A separate class browser window can be opened for a
selected class, which shows its inheritance hierarchy as
a tree. Classes that have no superclasses are shown as
parallel root node sorted by the identifier name. Classes
that are extended from multiple superclasses, are rooted
in the first declared superclass in the tree. The second
and remaining extended superclasses are listed together
on the level below the class with special object icon,
followed by the subclasses that extend the class. Icon
superclasses can optionally be filtered away, with a
special view setting.
A separate model browser can be opened for a class or
component, and shows its part-of structure as a tree.
When expanding a component node in the tree, its defining class is shown on the level below, and can be
further expanded in a similar way.
The Modelica model window also provides access to
various types of two dimensional diagrams, which lay
out various structures and interconnections of
component models in different views, and are intended
as support for seminar discussions on library design
and refactoring issues. These diagrams are still in their
early design stages, and need some prototype iterations
to become useful.

5.3

Report Window for Result Sets

Result sets from searches, analyses, crossreferences and
checks, are displayed as interactive report listings in a
separate report window with numbered rows. Each row
is associated with one object in the Modelica database.
If the row is double clicked further details about this
object can be inspected in a form. A report row may
optionally contain a short text message that further explains the reasons for including its associated object in
the report.
Examples of result rows, and their text messages for
two use cases is given below.

5.3.1

Finding
Component
Classes
with
Knowledge of the SI-units Their Instances
Will Need

facility in Dymola or evaluating a pattern search expression in a MathModelica document cell. This use
case can be a benchmark for comparing the time it
takes the user to complete the use-case with various
user interface implementations.
An instance of this use-case in the ModelicaDB frontend can be as follows:
1) The user has opened the ModelicaModel window on
the Modelica 2.1 standard library. In one of the treeviews the users selects the Modelica object that represents Modelica.SIunits.Resistance, which is defined as:
type Resistance = Real (
final quantity="Resistance",
final unit="Ohm",
min=0);

2) The user issues the Report command from the windows top menu, and gets a list of all use cases that can
be reported in a dialog box.
3) The user selects “Find component declarations for
predefined types”, which is the short name for this use
case.
4) The ModelicaDB front-end processes the query and
presents the result rows for the found components in
the Report window sorted according to the component
variable name. There they can be clicked for further
inspection in a form, or set in the focus of one of the
available browser window types which better shows a
Modelica objects surrounding context.

5.3.2

Computing Statistics of Use of Certain
Design Patterns

This is a more complex use-case that illustrates the
benefit of storing large Modelica libraries in a relational database.
The use-case instance is checking to what extent other
designers have created component models that uses the
simulation model of Electromotoric force Modelica.Electrical.Analog.Basic.EMF in direct
connection with a current sensor component of Modelica.Electrical.Analog.Sensors.CurrentSen
sor.

1) The user has opened the ModelicaModel window on
the Modelica 2.1 standard library, and opened the
package
hierarchy
tree
down
to
Modelica.Electrical.Analog.Basic. The users selects the EMF class with a first click, and then adds the
CurrentSensor class to the selection by shift-clicking
it in another model browser window showing the
Electrical.Analog package.

This is a simple use-case that also can be executed in
existing Modelica tools, for instance using the Search

The Modelica Association

450

Modelica 2005, March 7-8, 2005

ModelicaDB - A Tool for Searching, Analysing, Crossreferencing and Checking of Modelica Libraries

2) The user issues the Report command from the windows top menu, and selects “Sum connected component
uses.”.
3) The ModelicaDB front-end generates an SQL-query
with attribute value information from the selected objects as restricting search criteria, sends the query to
ModelicaDB and displays the result below in a Report
window.
0001 ModelicaModel Modelica1_5: count=1
0002 ModelicaModel Modelica2_1: count=1

6

SQL-Query Example

The following example show the SQL-queriey for the
use case described in 5.3.2.
select mmFound.name, count(*)
from class cl1,
class cl2,
class clFound,
modelicamodel mmFound,
component co1,
component co2,
equation eqFound,
parsenode pn1,
identifierreference ir1,
identifierreference ir2
where cl1.identifier = 'EMF'
and cl1.lowid = co1.classifier_lowid
and ir1.modelicaobject_lowid = co1.lowid
and ir1.parsenode_lowid = pn1.lowid
and pn1.nodeType='equ_connect'
and ir2.parsenode_lowid = pn1.lowid
and ir2.lowid != ir1.lowid
and ir2.modelicaobject_lowid = co2.lowid
and co2.lowid != co1.lowid
and co2.classifier_lowid = cl2.lowid
and cl2.identifier = 'CurrentSensor'
and pn1.modelicaelement_lowid =
eqFound.lowid
and eqFound.class_lowid = clFound.lowid
and clFound.model_lowid = mmFound.lowid
group by mmFound.name

The query returns the name of the found ModelicaModel objects, and counts the number of connect
equations in the found model, that refers to components
that are declared as classes with the name ‘EMF’ and
‘CurrentSensor’.

7

convert the parsed ModelicaXML elements into connected object structures according to the UML model in
the ModelicaDB front end, so they can be stored in the
database.
The Modelica grammar and ModelicaXML structures
contain many details and requires several passes to resolve all references. This also involves searching the
name spaces according to the static and dynamic
lookup functions (Chapter 3 in [4]), and resolving identifier references to imported classes in libraries that are
not in the current ModelicaXML file.
Other issues that require more work are:
• ModelicaXML-to-ModelicaDB mapping rules,
which are currently initially generated from preprocessing of large representative ModelicaXML
files, and then manually extended with actions that
specify how priority sorted matching patterns of
XML-elements are stored into objects in the ModelicaDB front-end. To get better verification of full
grammar functionality coverage, the rules should be
generated directly from the ModelicaXML DTD, or
another formal Modelica grammar specification, but
such an approach requires more research.
• How to represent modifications in ModelicaDB, so
the users SQL-query pattern searches also hit modified classes, without the need for expensive processing of modification “deltas” in parse node trees.
Some other interesting research results that came out of
this work are
• Identification of semantic equivalent functionality
between the Modelica language and the industry
standard ontology languages UML and Rosettanet
technical Dictionary [13]. Thus it is definitely possible to reuse relevant ontologies originating from
other modeling languages for exchanging existing
product data with Modelica simulation model development tasks. Other more distant future applications can be inferred from [5].
New technical results are:

Results and Experience

A first prototype version of ModelicaDB has been implemented that verified the approach. More work is
required to cover more advanced features of the Modelica language.
Most of the implementation work was rather straitforward, once the UML models in Appendix A, and
underlying detailed specifications [20] were completed.
The exception was the currently 408 mapping rules that

The Modelica Association

451

• Formalized Modelica simulation model interchange
format in the form of a DTD, for Modelica 2.1. This
DTD contains 88 language elements, and is described in [11] and [9]. The latest version has some
small modifications and can be downloaded from
the reference URL at [11].
• Extensions of the ModelicaXML tool for packaging
directory structures containing Modelica source
code libraries into one XML-file.
• UML-model of the Modelica database.
• Implementation of a relational database for searching, analysing, cross-referencing and checking of
Modelica libraries [20].

Modelica 2005, March 7-8, 2005

O. Johansson, A. Pop, P. Fritzson

8

Future work

Future work will be determined after members of the
Modelica Design group and involved researchers at
Linköping University have tested ModelicaDB prototypes and given recommendations for future work.

9

Conclusions

This paper reports work on ModelicaDB – a tool that
provides database storage and query of Modelica models. We believe that given proper integration with engineering product development tools, ModelicaDB will
be of great value on finding related product models,
quick access through categorization, and assisting with
a number of other related tasks.
A first prototype of the tool has been implemented. A
full database schema has been designed and tested
against queries, a Modelica library parser that converts
libraries into XML form has been implemented. The
main remaining task is completing the set of rules that
map ModelicaXML elements to ModelicaDB objects.

Acknowledgements
Swedish Foundation for Strategic Research,
ProViking project Systems Engineering and Computational Design (SECD).

References
[1] Dynasim. Dymola, http://www.dynasim.se/.
[2] INCOSE. International Council on System Engineering, http://www.incose.org.
[3] MathCore.
http://www.mathcore.se/.

MathModelica,

[4] Modelica: A Unified Object-Oriented Language
for Physical Systems Modeling, Language Specification version 2.1, Modelica Association, 2004
[5] Semantic
Web
Community
http://www.semanticweb.org/.
[6] OMG.
Unified
Modeling
http://www.omg.org/uml.

Portal,
Language,

[7] Modelica Community, http://www.modelica.org/
[8] Moldelica
Libraries
http://www.modelica.org/library/

(Ontologies),

[9] Peter Fritzson. Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1,
Wiley-IEEE
Press,
2003,
http://www.mathcore.com/drmodelica.
[10] Peter Fritzson, Peter Aronsson, Peter Bunus,
Vadim Engelson, Levon Saldamli, Henrik

The Modelica Association

452

Johansson and Andreas Karstöm. The Open
Source Modelica Project, in Proceedings of The
2th International Modelica Conference,March 1819, 2002, Munich, Germany.
[11] Adrian Pop, Peter Fritzson. ModelicaXML: A
Modelica XML representation with Applications,
in International Modelica Conference,3-4 November,
2003,
Linköping,
Sweden,
http://www.ida.liu.se/~adrpo/modelica/
[12] Adrian Pop, Ilie Savga, Uwe Assmann and Peter Fritzson. Composition of XML dialects: A
ModelicaXML case study, in Software Composition Workshop 2004, affiliated with ETAPS
2004,3 April, 2004, Barcelona.
[13] Olof Johansson, Adrian Pop, Peter Fritzson, A
functionality Coverage Analysis of Industrially
used Ontology Languages, in Model Driven Architecture: Foundations and Applications
(MDAFA), 2004, 10-11 June, 2004, Linköping,
Sweden.
[14] Pim Borst, Hans Akkermans and Jan Top, Engineering ontologies, in Int. J. Human-Computer
Studies, 1997, no. 46, p 365-406
[15] Adrian Pop, Olof Johansson and Peter
Fritzson, An integrated framework for modeldriven product design and development using
Modelica, in Proceedings of the 45th Conference
on Simulation and Modeling (SIMS), 23-24 September 2004, Copenhagen.
[16] Mogens Myrup Andreasen. Machine Design
Methods Based on a Systematic Approach (Syntesemetoder pa systemgrundlag), Lund Technical
University, Lund, Sweden, 1980
[17]

RosettaNet, http://www.rosettanet.org

[18] RosettaNet, RosettaNet Technical Dictioanry,
http://www.rosettanet.org/technicaldictionary
[19] Word Wide Web Consortium (W3C). Web
Ontology
Language
(OWL),
http://www.w3.org/TR/2003/CR-owl-features20030818/
[20] Olof
Johansson,
ModelicaDB
Project,
http://www.modelica.org/projects/ModelicaDB/
[21] Michael Tiller, Parsing and Semantic Analysis
of Modelica Code for Non-Simulation Applications, in International Modelica Conference,3-4
November, 2003, Linköping, Sweden.
[22] IEC, IEC 61360, http://webstore.iec.ch for a
fee
[23] ISO, ISO 31 Quantities and Units, Part 0-13.
http://www.iso.org for a fee

Modelica 2005, March 7-8, 2005

ModelicaDB - A Tool for Searching, Analysing, Crossreferencing and Checking of Modelica Libraries

ModelicaElement

ModelicaRepository

1..1

repository_modelicaModels

->Element
ordinalPosition
sourceCode
sourceCodeEndColumn
sourceCodeEndLine
sourceCodeFileName
sourceCodeStartColumn
sourceCodeStartLine

->Model

0..*

ModelicaModel
->ModelElement
1..1

1..1

0..1

imported_exports

PredefinedType

model_modelImports
0..*

0..*

->Classifier
quantity

ModelicaModelImport

0..1

classifier_declarations

1..1

->ModelicaElement
identifier
1..1

0..1

->ElementImport

ModelicaObject
0..1

model_classes

modelImport_imports

modelicaObject_annotation

importedClass_classExports
0..1

0..*

Classifier

CommentString

0..1

commentString_annotations

->PredefinedType
fixed
start
maximum
minimum

0..1superclass_specializations
0..*

0..*

Extension

0..1

0..*

IntegerType

0..1

->ModelicaObject
isDerived
visibility

Annotation
->ModelicaElement
isInitial
visibility

subclass_generalizations

0..*

->Element
subNodePosition
subNodeRole

->PredefinedType
displayUnit
fixed
nominal
start
stateSelect
unit
maximum
minimim

Class
1..1

0..*

Section

1..1

->ModelicaElement

0..1

->Classifier
innerouter
isEncapsulated
isPartial
restriction

->ModelicaElement
isInitial
sectionType
0..1

0..*

Modification

class_sections

1..1

1..1

class_importClauses
1..1

0..*

0..1

StringType
->PredefinedType
start

classifier_declarations
partOf_components

0..1

0..*

class_algorithms
section_algorithms

class_equations
0..*

section_components

section_equations
0..*

1..1

ImportClause
->ModelicaObject
externalName
dotStar

1..1

0..*

0..*

0..*

Algorithm

Equation

->ModelicaObject
isInitial

->ModelicaObject
isInitial

0..*

0..1

RealType

1..1

extension_modifications
class_localClasses

ModelicaReference

0..1

Import

superclassImport_specializations

1..1

0..*

0..*

->ElementImport

->ModelicaObject
isFinal
isRedeclaration
isReplaceable
visibility

->ModelicaElement
comment

->PredefinedType
fixed
start

importClause_imports
0..* 0..1

0..*

modelicaObject_commentStrings
0..*

BooleanType

importedClass_componentDeclarations

0..1

EnumerationType
0..*

->PredefinedType
start
maximum
minimum

0..*

Component
->ModelicaObject
innerouter
inputOutputPrefix
isFlow
isRedeclaration
isReplaceable
variabilityPrefix
visibility

1..1

0..1

enumeration_enumerationLiterals
0..*

EnumerationLiteral
->ModelicaObject

modelicaElement_parseNodes
0..*

1..1

ParseNode
->ModelicaElement
each
isFinal
nodeType
operation
subNodeCount
1..1

parseNode_arraySubscripts
enumerationType_arraySubscripts

1..1

mainNode_subNodeReferences
0..*

0..1

0..*

booleanType_arraySubscripts

->ModelicaReference

subNode_mainNodeReferences
0..*

0..*

0..*

0..*

ArraySubscript

1..1

parseNode_literals
modelicaObject_references

0..*

->ModelicaElement
size

Literal
->ModelicaElement
literalType
literalValue

parseNode_identifierReferences
0..*

integerType_arraySubscripts

ParseNodeReference

0..*

IdentifierReference
->ModelicaReference
identifier
languageSpecification

Date Printed
2005-01-31 10:00:01

Domain Model
DM.

ModelicaDB-21-10d

Filename

Date Added

ModelicaDB-21-10d.odm

Date Modified

2003-03-04 08:03:07

2005-01-31 09:40:04

#Cls #Rel #Att
67

64

162

Modelica 2.1 database design for ModelicaXML information exchange. The goal is a repository that can be round-tripped with Modelica source code.

Dgm

2.0) Modelica High-Level Meta Objects

2004-04-27 14:36:52

2005-01-31 09:40:04

30

37

-

Complete UML Model of Modelica 2.1.

The Modelica Association

453

Modelica 2005, March 7-8, 2005

O. Johansson, A. Pop, P. Fritzson

WModelicaRepository
->WFileStorage
name
comment
1..1

1..1

wMain_wModelicaModels
wMain_wDiagramBrowser

0..*

WModelicaModel

1..1

0..1

->WSubWindow

WDiagramBrowser
->WSubDiagramBrowser

1..1

1..1

wMain_wClassBrowsers
0..*

wMain_wClassTreeDiagrams

WClassBrowser
->WSubWindow

WClassTreeDiagram

0..*

wMain_wModelBrowsers
0..*

->WDiagram

WModelBrowser
->WSubWindow

wMain_wModelTreeDiagrams
0..*

wMain_wModelCatalogs

WModelTreeDiagram
->WDiagram

0..*

WModelCatalog
->WSubWindow

wMain_wModelicaDiagrams
0..*

wMain_wClassCatalogs

WModelicaDiagram
->WDiagram

0..*

WClassCatalog
->WSubWindow

Date Printed
2005-01-31 09:59:20

Domain Model

Filename

Date Added

Date Modified

#Cls #Rel #Att

DM.

appmodelicadb-21-10b.od 2004-11-05 21:08:37
m
Prototype application window structure for ModelicaDB
V2.1x, including Profile support.

2005-01-27 09:26:36

18

11

12

Dgm

2.0) AppModelica

2004-11-12 07:45:58

10

9

-

appmodelicadb-21-10b

2004-11-05 21:19:14

Application windows for the Modelica module.

The Modelica Association

454

Modelica 2005, March 7-8, 2005

Session 6a
Automotive Simulation III

The Modelica Association

455

Modelica 2005, March 7-8, 2005

The Modelica Association

456

Modelica 2005, March 7-8, 2005

The PowerTrain Library: New Concepts and New Fields of Application

The PowerTrain Library:
New Concepts and New Fields of Application
Christian Schweiger1
1

Mike Dempsey2

Martin Otter1

German Aerospace Center (DLR), Oberpfaffenhofen, 82234 Weßling, Germany
2
Claytex Services Limited, Warwickshire, CV35 8XB, United Kingdom

Abstract

components and 10 examples, cf. Figure 1. A number of components originally developed for the PowerVersion 2.0 of the PowerTrain library will be released Train library have been incorporated into the Modelica
in March 2005. This article presents the new release, standard library (version 1.5) since they are of general
which is enriched by optional consideration of 3D ef- interest.
fects, a simpler signal bus concept, new components
and example models for flexible drivelines, 4wd drivelines and hybrid vehicles. In addition, various new
driver models have been added.

1

Introduction

The PowerTrain library [6] is a licensed Modelica
package providing components for modelling vehicle
powertrains. It is also used for the modelling of gearboxes with speed and torque dependent losses. The
available components range from simple, easy to use
parts to very sophisticated components. All the components are open and can be extended and modified by
the user.
In December 2002, version 1.0 was finished and since
then several new developments have been incorporated
into the library. In addition, new concepts in the Modelica language have been applied leading to improvements aimed at delivering better interoperability between the different automotive model libraries available. These are described in Section 3. In Section 4,
new fields of application are described and new driver
models are presented in Section 5.

2

Previous library status

In the past, the library provided standard and planetary
gearboxes with speed and torque dependent losses,
table-based engine and simple driver models, and
components required to model the longitudinal dynamics of vehicles, as well as a range of detailed examples. Version 1.0 of the library contained 45 reusable
The Modelica Association

Figure 1: Components of the PowerTrain library and
some sublibraries
A very important property of the PowerTrain library is
the robust and efficient handling of speed and torque
dependent friction [8] as illustrated in Figure 2, which
occurs when considering gear mesh efficiency (due to
gear teeth friction) and bearing friction. This novel
type of friction handling was used in many components in version 1.0, especially for planetary gears,
Ravigneaux gears, Lepelletier gears, extended Simpson gears and differential gears.
Large system models often become difficult to understand as there can be a large number of signals that
need to be passed between the model’s top-level components. To overcome this problem, the PowerTrain
library used a signal bus as shown in Figure 3. The
idea was that all the signals that have to be exchanged
by the components are included on the bus. The com-

457

Modelica 2005, March 7-8, 2005

C. Schweiger, M. Dempsey, M. Otter

∆τ

∆τ

τΑ
ωA = 0

ωA
τΑ

(a) Dependency on speed ωA

∆τmax1, ωA

>0

∆τ(ωΑ=0)
∆τ

τΑ

, ωA < 0

min2

(b) Dependency on torque τA

Figure 4: Animation of 6-speed automatic gearbox of
Lepelletier type

Figure 2: Speed and torque dependent friction ∆τ

systems for automatic transmissions are implemented
ponents are then simply connected to the bus and do
in such a way that they support any number of gears.
not have any signal connections to other components.
The driver interacts with these controllers by setting
Another common modelling problem is that models
the gearbox mode to be used (P, R, N, D, 1, 2, 3, . . . ).
with varying levels of detail are required for different tasks. To reduce the number of different models
that need to be saved a model architecture was implemented that would allow components contained in the
top-level objects to be easily swapped for other compatible models with different levels of detail. The ability to swap the components was realized by making
use of the replaceable model features of Modelica. As
a consequence, only one model, cf. Figure 3, is necessary to model many different driveline configurations.

Figure 5: Control units included in the library
Several sophisticated example models are provided
which serve as a starting point in developing userspecific models. Especially, examples are provided for
power consumption calculation and analysis of shift
strategies based on detailed models of 4- and 6-speed
automatic gearboxes
Figure 3: Model Driveline consists of a typical driveline from which all the main variants provided in the
library can be selected, e.g., three different types of de- 3 New concepts and components
tailed automatic gearbox models but also user-defined
gearboxes. The components need only a single con- Several new concepts and components have been innection to the signal bus in order to exchange signals corporated into version 2.0 of the PowerTrain library.
They are described in the following sections.
among them.
The gearbox and shaft components can be animated,
see Figure 4 for an example, which is useful for plausibility checking and demonstration purposes. Animation can be switched off by a parameter. In this
case, the complete animation code is removed from a
model in order to get efficient simulation code, e.g.,
for hardware-in-the-loop simulations.
A number of control systems as shown in Figure 5
were included in the library. These are used to control the engine and transmission models. The control
The Modelica Association

3.1

Incorporation of 3D effects

In [9], a concept for reproducing the three-dimensional
(3D) mechanical effects of one-dimensionally (1D)
modelled powertrains has been presented. The idea
is to model transmission elements with their mostly
1D rotating behaviour in a convenient way with 1D
model components. Due to the simplicity of the
1D equations, this results in very efficient simulation code. When these 1D components are mounted

458

Modelica 2005, March 7-8, 2005

The PowerTrain Library: New Concepts and New Fields of Application

on systems moving in 3D space using the Modelica.Mechanics.MultiBody [7] library a number of important effects, such as support torques and gyroscopic
torques, are missing. By including adaptor models and
a 3D inertia component it is possible to incorporate
these missing effects.
These 3D effects are incorporated in version 2.0 of
the PowerTrain library. By default, 3D effects are
turned off to get fast simulations, which is especially
important for real-time purposes [3, 10]. The 3D effects can be turned on through the use of a parameter.
This has been implemented using the new Modelica
feature conditional declarations that have been introduced in version 2.2 of the Modelica language specification. The idea is illustrated using the example in
Listing 1 and the object diagram in Figure 6.
Listing 1: Example demonstrating conditional declarations
model DampedInertia
import Modelica.Mechanics.Rotational;
extends Rotational.Interfaces.TwoFlanges;
parameter Boolean damping=true;
Rotational.Inertia inertia;
Rotational.Damper damper(d=10) if damping;
Rotational.Fixed fixed if damping;
equation
connect(inertia.flange_a, flange_a);
connect(inertia.flange_b, flange_b);
connect(damper.flange_a, fixed.flange_b);
connect(damper.flange_b, flange_b);
end DampedInertia;

tiated and the connect statements referring to them are
ignored. The advantage in comparison to simply setting the damping coefficient d of damper to zero is that
the equations of the disabled components are removed
from the model and from the generated code, leading
to more efficient simulations.
This feature is now used to incorporate 3D effects into
the PowerTrain library. To include 3D effects into the
components, a MultiBody connector is required but for
the simple 1D case, it is desirable to remove these connectors. Therefore, the base class shown in Listing 2
was implemented which is inherited by the affected
components of the PowerTrain library.
Listing 2: Base class for components with optional 3D
effects
partial model ThreeD
import Modelica.Mechanics.MultiBody;
parameter Boolean enable3D=true;
MultiBody.Interfaces.Frame_a
frame_a if effectiveEnable3D;
protected
outer MultiBody.World world;
parameter Boolean effectiveEnable3D=
world.enable3D and enable3D;
end ThreeD;

This base class allows the 3D effects to be switched on
or off in two ways:
• The base class provides a Boolean parameter enable3D, which can be used to disable the 3D effects for a particular component.
• It is also possible to enable the 3D effects for
all the components within a model by use of a
single global setting. This is implemented using
the inner-outer concept of Modelica, which is already used in the MultiBody library for providing global settings (e.g. for default animation and
gravity field). These definitions are set in the inner component world which must be added to the
top level of the model. All the components within
a model access the global settings through a respective outer component world. The component
MultiBody.World has been extended by adding a
Boolean parameter enable3D.

Figure 6: Object diagram of model DampedInertia
The declaration of the components damper and fixed is
dependent on the Boolean parameter damping. These
components are instantiated only if damping has the
value true. Otherwise these components are not instanThe Modelica Association

Both parameters have to be true for the 3D behaviour
to be modelled. If either of them is false then the 3D
MultiBody frame_a as well as the additional equations
for modelling the 3D effects are removed and only 1D
behaviour is modelled. The described base class is

459

Modelica 2005, March 7-8, 2005

C. Schweiger, M. Dempsey, M. Otter

used throughout the PowerTrain library when 3D effects might be included. By default, only 1D behaviour is modelled and all the code for the 3D effects is
removed during the code generation phase. By inheriting from this class, it is easy to enable 3D effects and
then place the complete powertrain models onto 3D
moving parts without neglecting any 3D effects.
Figure 7 shows a model which combines components of the PowerTrain and the VehicleDynamics library [2]. The 3D effects are modelled in the powertrain. First investigations, see Figure 8, of such a
model have been performed in [5].

sion 2.2 of the Modelica language specification. In
the simplest case, an expandable connector is merely
an empty connector, see Listing 3. This connector
class can be instantiated in different components, e.g,
Source and Integrator in Listing 3, and it is possible to
connect to components in the expandable connector,
even though they are not defined in the class definition of the bus. The various connect statements are
evaluated at compile time and the union of all referenced variables is used to build the actual bus connector. During translation a check is made to ensure that
every signal read from the bus is defined exactly once.

Listing 3: Example package demonstrating bus realisation using an expandable connector
package BusTest
import Modelica.Blocks;
expandable connector Bus
end Bus;
model Source
Bus bus;
Blocks.Sources.Sine sine;
equation
connect(sine.y, bus.dq);
end Source;

Figure 7: Powertrain model with 3D effects combined
with vehicle dynamics model

Figure 8: Animation of a joint powertrain and vehicle
dynamics model

model Integrator
Bus bus;
Blocks.Continuous.Integrator integrator;
equation
connect(integrator.u, bus.dq);
connect(integrator.y, bus.q);
end Integrator;
model Example
Bus bus;
Source source;
Integrator integrator;
equation
connect(bus, source.bus);
connect(bus, integrator.bus);
end Example;
end BusTest;

A simulation result of model Example in Listing 3 is
shown in Figure 9. Although the bus connector was
defined as empty, the two contained variables can be
The signal bus concept introduced in version 1.0 of
plotted.
the PowerTrain library was not easy to extend to userspecific needs. The recommended method for chang- The concept of expandable connectors leads to an
ing the signal bus was to extend from the library and enormous gain in flexibility. The bus definition in the
simultaneously replace the bus with a user-defined bus, PowerTrain library has been changed to that shown in
ending up in a complicated structure.
Listing 3. This allows a user to extend the bus in a
For the Vehicle Model Architecture described in Sec- very convenient way: Just a connection must be drawn
tion 3.4 an improved bus concept — expandable con- between a signal port and the bus, see Figure 10. In
nectors — has been developed and included in ver- addition a variable name on the bus must be provided.

3.2

Expandable connectors

The Modelica Association

460

Modelica 2005, March 7-8, 2005

The PowerTrain Library: New Concepts and New Fields of Application

teeth contact) are known.

Figure 9: Simulation result of model BusTest.Example

Figure 12: Object diagram of test model to determine
gear ratio and gear efficiency between axis A and B of
the Wolfrom planetary gearbox
The gear ratio and the gear efficiency between axis A
Figure 10: Example model PowerTrain.ControlUnits.and B are computed as follows:
ShiftSchedule

3.3

• At the output (axis B) a unit torque is applied as
a load.

New gears with losses

In the previous version of the PowerTrain library, the two components Gears.PlanetPlanet and
Gears.PlanetRing were provided so that any type of
planetary gearbox could be constructed. These elements have been improved so that speed and torque
dependent losses are now taken into account. An example is shown in Figure 11 where a planetary gear of
the Wolfrom type, with losses, is constructed using the
PlanetPlanet and PlanetRing components.

• At the input (axis A) a unit acceleration is applied
for 1 s. This means that the speed of axis A starts
at zero, and rises linearly to 1 rad/s during the
first 1 s of the simulation and then remains constant at 1 rad/s. Since the speed is constant, the
inertias inside the gear do not have an effect for
the power distribution.
• To avoid possible problems with the nonuniqueness of solutions of friction elements when
forcing the wheel to rotate according to the desired acceleration, the forced movement of the
flange is not directly required. Instead, the acceleration component drives a very stiff spring
which in turn drives the gear flange.
• The gear ratio is the ratio of the angular velocities of flange_A and flange_B at the end of the
simulation (say at 2 s).

Figure 11: Object diagram of Wolfrom type planetary
gearbox with losses implemented using the improved
PlanetPlanet and PlanetRing components

• The gear efficiency is the ratio of the cut-torques
of flange_A and flange_B divided by the gear ratio.

The overall gear ratio and efficiency of a planetary gearbox constructed using these basic elements can be calculated using the model PowerTrain.Examples.WolfromEfficiency shown in Figure 12, provided that the number of teeth on each of
the gearwheels and the efficiencies of each mesh (gear

• The above two numbers can most easily be determined from the simulation, in Dymola, by clicking in the plot window on Advanced and then setting t = 2 in the input field Time. This displays the
values of all variables in the variable browser at
t = 2.

The Modelica Association

461

Modelica 2005, March 7-8, 2005

C. Schweiger, M. Dempsey, M. Otter

Figure 13: Screenshot of Dymola showing example model on Vehicle Model Architecture basis
It would not be possible to determine these values using a static model where the gear shafts are not rotating. This is because the friction between the teeth
would be in the stuck mode and the friction torques
are then computed implicitly from the requirement
that the shaft accelerations are zero. This is correctly
described by the Modelica model and therefore does
not allow the efficiency to be calculated using a static
model.

3.4

Vehicle Model Architecture

Within Ford Motor Company’s Powertrain Research
Department an architecture for modelling of vehicles
has been developed and reimplemented in Modelica.
The resulting Modelica package was presented in [11]
and is freely redistributable in source code form. In
order to promote interoperability with other libraries
in the automotive area, this architecture will be used in
the PowerTrain library. An example model following
this architecture is shown in Figure 13.

4

New fields of application

Version 2.0 of the PowerTrain library has been extended by including a wider range of driver models
and new components in a number of new application
areas. Example models demonstrating the usage of the
new components have also been included in the library
and these are described below.
The Modelica Association

4.1

Flexible driveline models

An area of increasing interest is the modelling of vibrations and oscillatory responses within the whole
powertrain. These effects are required when attempting to simulate driveability, shift quality or other similar effects that are likely to introduce oscillatory
torques into the powertrain system. The study of
these effects has required the development of additional driveline component models that include additional effects such as stiffness, damping and backlash.
The first key component required was the flexible
shaft, which introduces the ability to model the twisting of a shaft, such as the propshaft or driveshafts. In
it’s simplest form the flexible shaft consists of two rotational inertias connected by a linear spring-damper.
In this form the shaft can be used to model low frequency effects such as shuffle, which occurs in the
2..10 Hz range.
The flexible shaft can easily be adjusted to model
higher frequency effects as it can contain a variable
number of spring-dampers and inertia components.
This is possible through the use of a parameter n to
specify how many spring-damper blocks the flexible
shaft model should contain. The effective stiffness
and damping of each spring-damper block is adjusted
based on the parameter n. The flexible shaft contains
n + 1 inertias and the total inertia of the shaft is evenly
distributed across these. The implementation of the
flexible shaft is shown in Listing 4.
When developing a model to simulate driveability or
shift quality it is important to include the reaction of
the powertrain within the vehicle. As the entire pow-

462

Modelica 2005, March 7-8, 2005

The PowerTrain Library: New Concepts and New Fields of Application

Listing 4: Flexible shaft implementation
model FlexibleShaft
extends Modelica.Mechanics.Rotational.Interfaces.TwoFlanges;
parameter
parameter
parameter
parameter

PowerTrain.Types.TorsionalStiffness c=1 "Stiffness";
PowerTrain.Types.TorsionalDamping d=0 "Damping";
Modelica.SIunits.Inertia J=1 "Inertia";
Integer n(min=1) = 1 "Number of spring-dampers";

Modelica.Mechanics.Rotational.Inertia inertia[n + 1](each J=J/(n + 1));
Modelica.Mechanics.Rotational.SpringDamper springDamper[n](each c=c*n, each d=d);
equation
connect(flange_a, inertia[1].flange_a);
for i in 1:n loop
connect(springDamper[i].flange_a, inertia[i].flange_b);
connect(springDamper[i].flange_b, inertia[i + 1].flange_a);
end for;
connect(inertia[n + 1].flange_b, flange_b);
end FlexibleShaft;

ertrain is suspended within the vehicle by a number of
mounts it can move within the vehicle and have a significant impact on the overall vehicle response. Previously the PowerTrain library did not consider these
effects and a number of components have been developed specifically for this task.
Within the PowerTrain library an example has been included showing how to model the reaction of a differential on its mounts for a rear-wheel drive vehicle. In this example the driveline is modelled using
the 1D flexible shaft for the propshaft and driveshafts,
the differential is modelled using MultiBody components and is connected to the appropriate shafts via the
Shaft1D_MBS, see Figure 14.
The Shaft1D_MBS model is used to couple 1D rotating components directly to components in the MultiBody library. This component relates the rotational
speed and torque in the 1D connector to the speed and
torque on the specified axis in the MultiBody connector.
The differential component is modelled using the
MultiBody library and reacts the torques in the driveline onto the differential mount points. The actual
differential mounts form part of the chassis subsystem
and are discussed below. The differential includes the
rotating inertias of the various internal components,
backlash referred to the diff input and the mass, inertia
and geometry of the complete differential assembly.
The type of mounts typically used to suspend the powertrain within the vehicle are designed to react forces
in the x, y and z directions and they leave the powertrain free to rotate. These have been modelled using a
series of three ActuatedPrismatic joints that are used
to react the forces applied to the mount in three directions. A spherical joint is used at the side of the mount
The Modelica Association

Figure 14: Driveline model that includes the movement of the differential on its mounts
that should be connected to the driveline component
being suspended.
A number of tyre slip models have been included in
the new version of the PowerTrain library. The available slip models include a simple linear slip model, a
Pacejka slip model and the Rill slip model. These have
been implemented for longitudinal slip only and consider the vertical load acting on the tyre.

4.2

4wd drivelines

A growing number of vehicles are being developed
with all-wheel drive, e.g. sports utility vehicles (SUV)
and commercial vehicles. There are a wide-range of

463

Modelica 2005, March 7-8, 2005

C. Schweiger, M. Dempsey, M. Otter

Figure 15: Some of the differential models available in the PowerTrain library. Clockwise from the top-left,
conventional differential, simple active differential, torque vectoring differential, viscous differential
possible ways to deliver an all-wheel drive vehicle and
components have been included to enable the modelling of the most common types and some of the most
advanced. Available models include simple open differentials, viscous differentials, and two types of active
differential. The various differential models have all
been implemented as 1D rotational systems with only
the conventional differential described previously using a MultiBody approach.
All the differential models provided are based around
the use of an epicyclic differential unit. The different configurations of active and passive locking mechanisms are then placed around this core epicyclic unit
and work in different ways to control the behaviour of
the differential. Figure 15 shows four of the differenThe Modelica Association

tial models available.
For the simple active differential and the torque vectoring differential control systems have also been provided. An example of a four-wheel drive vehicle, that
uses three of these simple active differentials, has been
added to the library. In this case, the control system
has been designed to control each differential separately with the sole objective being to maximise traction. Each differential controller looks at the output
shaft speeds from its differential and acts to reduce the
difference in speed. It should be possible for some slip
to occur between the shafts to allow for cornering and
this can be defined through the controller parameters.
In addition to the range of differential models, a power
take-off (PTO) style transfer box has been provided. In

464

Modelica 2005, March 7-8, 2005

The PowerTrain Library: New Concepts and New Fields of Application

some four wheel drive applications this type of transfer elled and this would limit the suitability of the library
box is used instead of a centre differential. The key for concept studies.
difference between using a differential and a PTO style
transfer box is that the ratio between the input and each
output shaft is fixed in the PTO style box whereas this 5 Other enhancements
ratio can vary when a differential is used.
This section describes the driver models, which have
been added to the library, and changes concerning ta4.3 Hybrid vehicles
bles.
With several automotive manufacturers and suppliers
working on hybrid vehicles, there was a necessity to
provide corresponding models in order to support concept studies in this area. Models have been included
for batteries, motors and the associated controllers to
meet this need.
The objective is to deliver models suitable for concept
study work so that minimal data is required to develop
a working model of a hybrid concept and to test out
the functionality. Two hybrid vehicle examples have
been included, one based on a vehicle using an Integrated Starter-Generator (ISG) and another based on a
series-parallel hybrid style vehicle similar to the Toyota Prius. Both examples have been configured to run
drive cycle simulations.
The battery model included in the PowerTrain library
is based on the Saft capacitance model, which was
originally developed in P-Spice [4] and has also been
used in the Advisor [1] simulation tool. Figure 16
shows the circuit diagram used for the battery model.
Capacitor Cb is very large and represents the ability of
the battery to store charge chemically, the capacitor Cc
is small and represents the surface effects of a spiralwound cell. The three resistances represent the terminal resistance (Rt), end resistance (Re) and capacitor
resistance (Rc).

Figure 16: Circuit diagram of the battery model
The power electronics required to transfer energy from
the battery to the electric motor have been simplified
so that the simulation performance is maintained. An
accurate model of the power electronics would require
a large number of high frequency effects to be modThe Modelica Association

5.1

New driver models

The range of driver models provided with the PowerTrain library has been expanded to cover a wider
range of tests. In addition to the existing cycle driver
there are now driver models designed to carry out performance tests and driveability tests. There are also
variants for use with both manual and automatic gearboxes.
The cycle driver models are based around the use of a
PI controller that actuates either the brake or accelerator pedal to control the vehicle speed so that it follows
a defined speed-time profile. A number of drive cycles
are included by default such as the NEDC, EPA City
and Highway cycles. It is possible to define your own
additional drive cycles for use with the driver model.
By varying the PI gains, the behaviour of the driver
can be altered allowing the driver model to be tuned
to match a range of different driving styles. The version of the cycle driver used with manual gearboxes
also controls the clutch pedal and gear lever. The shift
points are usually defined in the drive cycle to occur
at particular points in time and driver starts to change
gear at these points.
The driveability driver models are used to perform tipin and tip-out tests in fixed gears, or fixed gearbox
mode in the case of automatic transmissions. The tests
start with the driver controlling the vehicle speed to an
initial value and then accelerating and decelerating the
vehicle between defined speeds using only the throttle.
The brakes will not be used to decelerate the vehicle.
For manual gearbox vehicles it is normal to define the
tip-in and tip-out speeds as engine speeds. Due to the
effect of the torque converter, it is more usual to define the tip-in and tip-out speeds using vehicle speed
for automatic gearbox equipped vehicles.
The performance driver is used to perform standing
start acceleration tests. The version used with automatic gearboxes can perform both an idle start or stall
start acceleration test. In both versions the accelerator pedal position for the acceleration test can be defined so it is possible to assess the part-throttle accel-

465

Modelica 2005, March 7-8, 2005

C. Schweiger, M. Dempsey, M. Otter

eration performance as well as the wide open throttle (WOT) performance. The version used with manual gearboxes will change gear when a defined engine
speed is reached. If in-gear acceleration times are required the driveability driver model should be used and
the tip-in and tip-out speeds set to be the minimum and
maximum speeds for the given gear.

5.2 Replaceable tables
All tables in the library have now been declared as replaceable. This change was made as many customers
do not often have data in a form that is compatible with
the tables in the Modelica standard library. Instead,
they are forced to use their own, proprietary data format and their own table implementations. It was difficult for them to use these in combination with the
PowerTrain library in the past.

6 Conclusions and Outlook
Version 2.0 of the PowerTrain library offers several
new features, which open many new applications.
New Modelica language elements allow a clean implementation of the new features and make it easier for
users to adapt the library to their own specific needs.

Acknowledgements

[3] H. E LMQVIST, S. E. M ATTSSON , H. O LSSON ,
J. A NDREASSON , M. OTTER , C. S CHWEIGER , AND
D. B RÜCK, Realtime Simulation of Detailed Vehicle
and Powertrain Dynamics, in Electronics Simulation
and Optimization (SAE 2004 World Congress), Detroit, USA, March 8–11, 2004, SAE International.
Document Number: 2004-01-0768.
[4] V. H. J OHNSON , A. A. P ESARAN , AND T. S ACK,
Temperature-Dependent Battery Models for HighPower Lithium-Ion Batteries, in 17th Electric Vehicle
Symposium, Montreal, Canada, October 16–18, 2000.
[5] D. M AUERMANN, Echtzeitsimulation detaillierter
Fahr- und Antriebsstrangdynamik, diploma thesis,
Hochschule für Technik, Wirtschaft und Kultur
Leipzig (FH), Fachbereich Elektrotechnik und Informationstechnik, July 2004. Compiled at Deutsches
Zentrum für Luft- und Raumfahrt e. V.
[6] M. OTTER , M. D EMPSEY, AND C. S CHLEGEL, Package PowerTrain. A Modelica Library for Modeling
and Simulation of Vehicle Power Trains, in Proceedings of the 1st Modelica Workshop, Lund, Sweden,
October 2000, Modelica Association, pp. 23–32.
[7] M. OTTER , H. E LMQVIST, AND S. E. M ATTSSON,
The New Modelica MultiBody Library, in Proceedings of the 3rd International Modelica Conference,
Linköping, Sweden, November 2003, Modelica Association and Linköping University, pp. 311–330.
[8] C. P ELCHEN , C. S CHWEIGER , AND M. OTTER,
Modeling and Simulating the Efficiency of Gearboxes
and of Planetary Gearboxes, in Proceedings of the
2nd International Modelica Conference, Oberpfaffenhofen, Germany, March 2002, Modelica Association and Institute of Robotics and Mechatronics,
Deutsches Zentrum für Luft- und Raumfahrt e. V.,
pp. 257–266.

For fruitful discussions, the authors would like to
thank Jochen Köhler and his colleagues from ZF
Friedrichshafen AG.
In addition, thanks to Michael Tiller from Ford Motor [9] C. S CHWEIGER AND M. OTTER, Modelling 3D
Mechanical Effects of 1D Powertrains, in ProceedCompany for pushing forward the concept of expandings of the 3rd International Modelica Conference,
able connectors.
Linköping, Sweden, November 2003, Modelica AsThis work was in parts supported by Bayerisches
sociation and Linköping University, pp. 149–158.
Staatsministerium für Wirtschaft, Infrastruktur, Verkehr und Technologie under contract AZ300-3245.2- [10] C. S CHWEIGER , M. OTTER , AND G. C IMAN DER , Objektorientierte Modellierung mit Modelica
3/01 for the project Test und Optimierung elektrozur
Echtzeitsimulation und Optimierung von Antriebsnischer Fahrzeug-Steuergeräte mit Hardware-in-thesträngen, in Steuerung und Regelung von Fahrzeugen
Loop-Simulation in the years 2001–2003.
und Motoren – AUTOREG 2004, VDI/VDE-GMA,
ed., no. 1828 in VDI-Berichte, Düsseldorf, Germany,
März 2004, VDI-Verlag, pp. 639–650.

References

[11] M. T ILLER , P. B OWLES , AND M. D EMPSEY, Development of a Vehicle Model Architecture in Modelica,
in Proceedings of the 3rd International Modelica Conference, Linköping, Sweden, November 2003, Model[2] J. A NDREASSON, VehicleDynamics library, in Proica Association and Linköping University, pp. 75–86.
ceedings of the 3rd International Modelica Conference, Linköping, Sweden, November 2003, Modelica
Association and Linköping University, pp. 11–18.

[1] ADVISOR. URI http://www.ctts.nrel.gov/
analysis/advisor.html.

The Modelica Association

466

Modelica 2005, March 7-8, 2005

Development of a Modelica Heavy Vehicle Modeling Library

Development of a Modelica Heavy Vehicle Modeling Library
Per Bengtsson

Henrik Jansson Niklas Pettersson
Scania CV AB
151 32 Södertälje, SWEDEN

2

Abstract
Physical modeling for simulation of fuel consumption
and other dynamic behavior in heavy vehicles can be
useful in many areas from concept design to sales support. Similar models of vehicle subsystems are needed
in many applications, it would thus be beneficial to
have access to a library of reusable vehicle subsystem and component models to avoid repeated implementation. A solution based on a model architecture
and a supporting Modelica library for structured storage of models and components is proposed. The work
has been focused on promoting modeling practices enabling reuse, but we have also tried to maintain as
much freedom as possible for the modeler.

2.1

Tony Sandberg

Architecture Concerns
Multi-domain Library

One much hailed property of the Modelica language
is its multi-domain modeling capability. Components
from model libraries describing different domains can
be used together in the same model. However, the
majority of available libraries are focused on one domain. In most cases this is a natural partitioning. In
this project the common denominator has not been the
engineering domain, but rather the system to be described. The purpose of the library is to store component models, defined through the partitioning of the
described system into physical sub-systems.
A design goal has been to keep all available models in one central location, easily accessible to everyone. Existing models use an in-house media library to
represent air- and coolant flows. This domain specific
1 Introduction
library is thus also needed by users of the new model
library. It was decided to place it within the new liThere exist a number of different proposals for vehi- brary. This issue is further discussed in section 4.2.3
cle modeling architectures in Modelica (for example
[5] and [2]. The aim of this project has been to create a complete system with both a hierarchical model
structure defining the interfaces between subsystems
on several levels, and a model library. The library is
used to store sub-system interfaces along with available implementations and required supporting components such as connector definitions. The system is intended to be used for various research and development efforts within Scania CV AB. Since development
projects may have very different aims, and be focused
on different subsystems, it is unlikely that the library
will provide a final model for the task. Hopefully, existing versions of most sub-systems can be used together with new models specific to the current problem. A key consideration in the work has been to build
a system which is suitable for use by both experienced
Figure 1: Heavy truck model in DymolaTM .
and novice modelers. The project is rather applied in
its nature, and the article is intended to describe our
experiences.
The Modelica Association

467

Modelica 2005, March 7-8, 2005

P. Bengtsson, H. Jansson, N. Pettersson, T. Sandberg

2.2 Heavy Vehicles
Most existing vehicle model libraries are designed primarily for cars. Heavy vehicles have a number of subsystems which are not present in passenger cars. Particularly the engine/transmission system includes devices like an exhaust brake and possibly a retarder.
Further, the cooling system also has a more prominent
role than in cars, and coolant is often used both by the
engine and the transmission.

2.3 Model Variants
Since this library is designed to be used in many different projects, there is a need to handle different variants of component models. Supporting different model
variants, while attempting to preserve compatibility
and avoid hidden interdependences has been one of
the greatest challenges in this work. In some cases it
will be necessary to create an entirely new model to be
used instead of one already in the library, but substantial changes in behavior can be achieved without going
that far. The library supports three ways of changing
model behavior, listed in the order they should be considered.
Some models depend on data found in external parameter files or lookup tables. Theses can easily be
changed at run-time without any need to modify or recompile the actual model. When models are added,
this approach should be considered for any data that
needs to be changed frequently. Recompilation between simulation runs is not only time consuming, it
also assumes the presence of a licensed installation of
the compiler.
Numerical parameters which are not set through
data files can still be influenced at run-time. The simulation reads an initial state file, where values different
from the default ones can be specified for real, integer
and Boolean model parameters. This solution requires
less complex source code than the data file approach,
and is advantageous when only a few parameters need
to be accessible. This approach would mainly be useful in creating an end-user application where the user
should for example be allowed to choose between different tire models in an external GUI.
When a new model structure is needed, and even
redeclaration of submodels is not enough, an entirely
new model should be created. To make the new model
usable in other projects, the existing base classes
should be used to define the interfaces. If it is necessary, additional base classes can be created to supply
extra connectors. The new model should of course be
The Modelica Association

documented and made as flexible as possible with parameters and replaceable components used appropriately.
We have designed the library with fundamental
base classes as blueprints for the physical subsystems
and their major components. Only the interfaces required for simple implementations of the models are
included. Additional base classes can be used to add
more connectors if required by more advanced models. We have opted not to define a completely fixed
architecture where all connections are always identical, but rather a supporting framework for developers
intending to create reusable models. See also section
3.2.

2.4

Signaling Bus

A key issue in an architecture which contains both
physical plant and controller models is the handling
of electrical signals. The controllers need to exchange
data among themselves and they need to exchange
signals with sensors and actuators. For our applications the actual signaling behavior is not that important, an ideal communications model is sufficient. For
the communication between a plant and its controller,
standard library inports and outports are used. The
communication between the controllers was a tougher
case. Two implementations of the same controller may
not have the same signaling needs, thus it must be possible to change the set of signals sent between control
units.
Separate input and output ports for all links between control units in the vehicle would create an undecipherable graphical mess. Some type of signaling bus is needed. Both the standard library bus connectors and the type of bus used in the vehicle modeling architecture proposal by Tiller et. al [5] were
evaluated. We did not find enough information about
the inter-controller communication in the Tiller paper
to implement that system. Our main problem was
to find a way of having compatible connectors in all
controllers, without modifying the code of every controller when a signal was added to the bus. The Modelica standard library bus does not solve that problem,
since it requires all signals to be declared in the connector. Eventually we chose a simpler solution based
on a common connector called ”CAN” with a replaceable variable, called ”protocol”, which contains all the
signals. The protocol variable can easily be redeclared
into a type which contains exactly the signals broadcast on the bus in a particular model. Different implementations of the CAN connector are used for differ-

468

Modelica 2005, March 7-8, 2005

Development of a Modelica Heavy Vehicle Modeling Library

ent signal buses in the vehicle.
Most of our control units are implemented through
external function calls, thus the drawback of having no
convenient graphical way of converting a signal from
inport/outport to bus format is minor. See listing 4 for
an example of how the electronic control unit models
use the CAN bus. The connected control unit model is
shown in figure 2.
Listing 1: The CAN connector base class.
partial connector CANBase
"Basic connector for modelling CAN
comunincation"
replaceable Protocols.Interfaces
.ProtocolBase protocol
"Protocol to be used";
end CANBase;

Figure 2: Engine management system electronic control unit.

Listing 2: Implementation of the general CAN bus
connector.
connector CAN_s
"General control system
communication bus connector"
extends CANBase;
annotation (...);
end CAN_s;

Listing 3: A part of the definition of a CAN protocol.
record ProtocolStd
extends Interfaces.ProtocolBase;
Real EngineSpeed
"Speed of engine in rpm";
Real EngineTemp
"Engine temperature in deg C";
...
end ProtocolStd;

Listing 4: Sample usage of the CAN bus in the engine
control unit.
...
/* I/O mapping (sensors/actuators)*/
engineSpeed = inport[ENGINE_SPEED];
outport[FUELING] = fueling;
outport[EXHAUST_BRAKE_ON] =
CAN.protocol.ReqExhaustBrake;
...
/* Write CAN values */
CAN.protocol.EngineSpeed = engineSpeed;
CAN.protocol.EngineTemp = engineTemp;
CAN.protocol.ActualEngineTorque =
inport[ACTUAL_ENGINE_TORQUE];
CAN.protocol.ActualExhaustBrakeTorque =
inport[EXHAUST_BRAKE_TORQUE];
...

The Modelica Association

Figure 3: Directory structure for non-model files.

469

Modelica 2005, March 7-8, 2005

P. Bengtsson, H. Jansson, N. Pettersson, T. Sandberg

3 Usability Concerns

components as parts in simulink models is one example where non-standard shortcuts have been very effi3.1 Non-model Files
cient. Strict adherence to the interfaces is certainly optimal from a reusability perspective, but we have not
The model library itself is relatively easy to distrib- yet found a set of interfaces which have been practical
ute to the users. It is sufficient to copy the directory to use in every application. Further work may bring us
structure containing all the models to an appropriate ever closer to that goal.
place in the file system and load the library into Dymola. To get a nice working environment, where all
external files are found by the system and the library is 3.3 Concurrent development
included in the Dymola GUI, takes a little more effort. Traditionally one of the main obstacles to reuse of
In addition to the library directory tree our completed Modelica models created in previous projects has been
system consists of a directory structure on a higher that new functionality has been spread through many
level in the file system. This tree contains the model subsystems, rather than contained in one. When delibrary itself and all external function source code and velopers in two projects have enhanced different submodel data files for the. A work directory for the user systems they also have modified many others in the
is also provided. Data file paths and external source process, making it difficult to incorporate enhanced
code links (through include annotations in functions) components from different projects in the same model.
in the model library are given with relative paths, mak- Hopefully, the new library will promote solutions
ing sure that the files are found if the work directory is where components to a higher degree are created as
used.
self contained units.
If the user starts Dymola with the script provided
A version control repository is used to make sure
with the library, an included configuration file is used that two different groups do not accidentally make sito make sure that the heavy vehicle library automati- multaneous conflicting changes. If only a particular
cally is included in the model browser.
sub-tree is checked out with write privileges the devel-

3.2 Top Level Model
It is anticipated that a significant part of the work done
with the library will be carried out in project form by
people with little or no previous Modelica and/or modeling experience. As a result overly complicated and
abstract language constructs have been avoided. The
suggested method of putting together a vehicle for a
particular task is to select those sub-system models
which are most suited and add them to a new model.
A ”master” model with most components declared as
replaceable would enable new versions to be created
with fewer lines of code, but the added abstraction has
been deemed to be more difficult to handle than the
extra coding. Future enhanced modeling tools may reverse this decision, but today we think that the ability
for the novice modeler to fully understand his or her
source code is warrants some code duplication.
The master model approach is best suited when it
is anticipated that all implementations of a sub-system
will be absolutely compatible. While this is a nice assumption we don’t think that it will be valid in our
case. The range of intended applications for the vehicle library is so broad that some modifications also to
the structure and interfaces certain components will be
necessary in many projects. Real-time simulation of
The Modelica Association

oper is encouraged to find solutions within that subsystem. The version control repository also supports
named versions of the library to be created, which is
useful to make sure that the exact model versions used
in a project or application will always be available.
The model library code is managed and provided to
users in the same way as other source code in the organization. Users across various departments and groups
can thus use a code management system which they
are already accustomed to.

3.4

Choice Annotations

A number of Modelica entities can have choice annotations, which allow the model user to select appropriate parameter values easily in a modeling GUI. This
feature has been used in many places where the parameter is not a physical quantity. For examples file
name parameters used to specify data files are declared
to be of a certain filetype. Each filetype has an associated list of suggested file names. In figure 4 the dropdown box for retarder model selection is shown.
The signal bus protocol used throughout the vehicle is determined by the type of a replaceable variable.
The final setting of the type is propagated to the vehicle level, making it easy to change the type of every
bus connector. Available protocols are presented in a

470

Modelica 2005, March 7-8, 2005

Development of a Modelica Heavy Vehicle Modeling Library

the subsystems modules themselves, to reduce the required number of components and connections in the
top level model. In most cases one controller model
and one or more interconnected plant models make up
a subsystem. The top level subsystems cover the same
areas as corresponding groups in the research and deFigure 4: The result of a choice annotation to aid in velopment organization. Local development of models
the selection of a retarder model
by experts in various fields is thus simplified.
list, but it is still up to the user to choose one which 4.2 Library Structure
contains exactly the set of signals that is being broad- 4.2.1 Color Coding
cast by the currently used set of control units.
The vehicle library has been created with the same basic structure and package naming conventions as the
4 Model and Library Structure
Modelica standard library. Additionally the various
package types have been color coded to make navigation in the package tree easier. Packages containing interfaces, sensors, icons and examples are made
green. Data records are kept in red subpackages, and
test models in yellow. Ordinary packages are a slightly
darker shade of blue than the standard package icon.
4.2.2

Packages

Figure 6: The ”axle” package with subpackages in the
library browser.
Figure 5: Top level packages in the vehicle library

4.1

Hierarchical levels

The created vehicle model structure defines multiple
levels. The vehicle is built from physical components
which also have a defined substructure. The supporting library mimics that same substructure. For example control units for subsystems are included in
The Modelica Association

Each physical subsystem has its own top level
package for all its components, interfaces, etc. Additionally there are packages for examples, interfaces,
icons, examples and tests on the top level. For an
example of a top-level package see figure 6. Complete vehicle models, which can be used as components together with environment models from the ambient package, have a category of their own. To avoid a
very deep tree structure these various types have been
put at the same level in the hierarchy.

471

Modelica 2005, March 7-8, 2005

P. Bengtsson, H. Jansson, N. Pettersson, T. Sandberg

one input connector which is used to communicate the
position of the vehicle. A vehicle and ambient combiThere are a number of models required for the modelnation can be seen in figure 7.
ing of a complete vehicle which do not clearly belong
in any particular subsystem. Base classes for electronic control units, the signal bus connectors and the 4.3.2 Auxiliaries
media library used for coolant and air modeling are a
few examples. These functions are kept under a subtree called ”Common”. While it may seem more natural to create a separate library at least for the media
components we prioritized keeping the entire model library self contained. The only external dependencies
are the Modelica Standard Library and accompanying
ModelicaAdditions library.
4.2.3

The Common Sub-tree

4.3 Physical Subsystems
The physical subsystems with the interfaces described
are used in the current models. As it is impossible to
foresee exactly what applications the vehicle library
will be used for in the future, unused connectors are
not included on speculation. More connectors are
likely to be added in the future. To preserve current
base classes this can be done through additional base
classes as described in section 2.3.
4.3.1

Figure 8: A model representing the auxiliary units.

Auxiliaries are components like the cooling fan,
AC compressor, electric generator etc. These are generally mounted somewhere on the front side of the
engine, and traditionally obtain their operating power
through a mechanical link. It is recommended that any
generator model is placed among the auxiliaries, and
not in the electrical system. Separate models for each
auxiliary unit are placed within this container. Subtrees in the library contain models related to the various units. The auxiliaries are connected to the electrical system and the engine, an implementation can be
seen in figure 8.

Ambient

Figure 7: A vehicle model with the ambient component.
4.3.3

Axle

The ambient category is used to represents the environment around the vehicle. Models of this type
supply data about surrounding temperature, air pressure and other environment constants. These models
are also used to keep track of the road parameters such
as slope and speed limit. Through the Modelica inner/outer construct one ambient component is accessible to all the other components in a model, which
makes this the ideal place for any data that needs to
be globally shared. Each model should have exactly Figure 9: Truck model with full trailer and four axles.
one ambient component. The ambient interface has
The Modelica Association

472

Modelica 2005, March 7-8, 2005

Development of a Modelica Heavy Vehicle Modeling Library

The axle models contain tires, brake actuators and
a final gear for driven axles. They are always connected to the chassis and the brake CAN bus. The
axles generate a retardation force due to the rolling resistance in the wheels, and possibly due to the wheel
brakes. Driven axles have an additional connector
which allows the power train to transfer torque to the
axle, and propel the vehicle. The number of axles in a
vehicle configuration varies; it has to match the number of axle connectors on the chassis and all trailer
models used. The vehicle shown in figure 9 thus requires four axles. An air interface could be added to
simulate air-powered brake actuators.

driver interface. The driver model would then take the
commands received from the external input and convert them to appropriate CAN signal values. The resulting action of the truck would be sent back through
the output port.
4.3.7

Electrical System

The electrical system is included to enable studies of
electrical energy flows. It could for instance be used to
study battery operating conditions or effects of using
electrically powered accessories instead of mechanically powered ones. The electrical system package
is primarily intended for components without a simulated direct mechanical connection to the vehicle. The
4.3.4 Brake System
interface specifies a single special connector, see secThe brake system is a container for the brake man- tion 4.4
agement system and any related plants except for the
brake actuator, which are represented at their physi- 4.3.8 Engine
cal location in the axle modules. The brake system is
attached to the vehicle signaling bus and the brake signaling bus. Additional connections are likely in future
more developed brake system models.
4.3.5

Chassis

The chassis models represent the frame of the truck.
Cargo, axles and trailers attach to the chassis. The base
class has the connectors for wheel axles and a draw
bar. Derived classes add either a fifth-wheel (where
the semi-trailer is attached) for tractor configurations,
or a cargo attachment point for rigid trucks.
4.3.6

Driver

The driver model is responsible for overall control of
the vehicle. Decisions to accelerate or decelerate depending on the surroundings are made by the driver.
Depending on the vehicle, different control signals
may be required. A manual transmission requires the
driver to select an appropriate gear, while the GMS
handles that duty for an automatic or automated manual transmission. In cruise control mode, the EMS
controls the fueling, in driver demand mode the throttle is controlled directly by the driver. The driver logic
depends on the control units used in other parts of the
vehicle. The driver interface is very simple with only
one connector, which is used to attach it to the CAN
bus.
To control a vehicle from an external model (e.g. in
Simulink) input and output ports are needed. In such
a case input and output ports could be added to the
The Modelica Association

Figure 10: Engine with cooling system.

The engine (figure 10) is one of the larger subsystems, particularly when cooling system behavior is
taken into account. The engine model contains submodels for both the power plant itself and any radiators and other cooling system components found in
close proximity to it. The power plant model often
includes an exhaust brake. The engine connectors required differ depending on the aspects considered. The
base interface defines rotational mechanical connections to the auxiliaries and the transmission. The engine is connected to the vehicle signaling bus and the
electrical system. An additional base class provides
coolant hoses which allow coolant to flow in a circuit
through other vehicle systems.

473

Modelica 2005, March 7-8, 2005

P. Bengtsson, H. Jansson, N. Pettersson, T. Sandberg

4.3.9

Trailer

The trailer is in many ways rather similar to the chassis. They are both rigid bodies represented as point
masses with forces acting on them through translational connectors. The base model is a semi-trailer
which can be attached to the back of a tractor. Through
the use of a dolly, the semi-trailer gets a second axle
and can be used as an independent full-trailer, this
configuration is shown in figure 9. A trailer connects
to two axles, a towing vehicle and possibly another
trailer. A semi-trailer connects to one axle, a tractor or
dolly, and can be used to pull a trailer.
4.3.10

Transmission

however we have seen the need to use special connectors which can carry all the information of a certain
type between two components with only one connect
statement. This has been the case for the signal bus
and the electrical connectors. The electrical connector contains two electrical pins. All components connected to the electrical bus are connected in parallel,
and adapters are used between the standard electrical
pin connectors and our electrical connector. In the future it is envisioned that the electrical system model
may contain multiple circuits and voltage levels in the
electrical connector, making the advantages of using it
higher. The single voltage electrical bus connector is
shown in listing 5.
Listing 5: Electrical bus connector with single voltage
level.
connector ElectricalSingleVoltage
"Connector class for a single voltage
electrical system"
extends Interfaces.ElectricalBase;
Modelica.Electrical.Analog.Interfaces
.PositivePin p;
Modelica.Electrical.Analog.Interfaces
.negativePin n;
end ElectricalSingleVoltage;

The signal bus connector (also described in section
2.4) allows for relatively simple transfer of many (currently around 20) control signals between the various
electronic control units in the vehicle. There is a second signal bus, using another identical connector except for the color and protocol, used to connect the
brake system to the actuators on the axles. The media
library used for the cooling system contains general
hose connectors which can carry the simulated media.

Figure 11: Transmission model with coolant flow.

The transmission includes a gearbox, which can be
of any type. There is also a gear management system
which has to be compatible with the gearbox used. A
retarder, a type of hydraulic brake which acts on the
drive shaft, is often included as well. The retarder generates a lot of heat, and a complete cooling system representation needs a connection to it. A transmission
model with coolant flow is shown in figure 11. The
Transmission has rotational mechanical connections to
the engine and any driven axles. It is also connected
to the vehicle signaling bus. An optional base class
provides coolant hoses.

5

Sample Vehicle Models

To validate the new architecture two slightly different vehicle models were used in the new framework.
Both models share the same overall structure, but one
version contains a thermodynamic cooling system representation (this model is seen in figure 1), while the
other has no cooling system model at all (figure 12).
The two models require different controllers and plant
models for the engine and transmission. These are the
systems which are affected by the inclusion of coolant
flow. All other controllers and plant models are identical in the two versions.
4.4 Special Connectors
The two sample models illustrate the idea of this
Whenever it has been possible standard library con- vehicle model architecture very well. It isn’t possinectors have been used in the models. In some places ble to generate the two versions from the same readyThe Modelica Association

474

Modelica 2005, March 7-8, 2005

Development of a Modelica Heavy Vehicle Modeling Library

sign. Phenomena may in themselves lead to varoius
solver requirements (such as the cooling system case).
Existing PID controllers in external code often have
strict sample time needs. Each of these special considerations needs to be explicitly stated in documentation. Documenting every important aspect is a real
challenge.
Novice users of Modelica and Dymola often have
trouble deciphering the error messages that are output.
A nearby expert who can guide through the minefield
of rookie mistakes is an invaluable asset for anyone
new to the field. Similarly it is anticipated that our
library will require some previous knowledge of the
tools, despite our intentions to make it simple to use.
Figure 12: Heavy truck model without any cooling
system.

made template only through redeclare statements. On
the other hand, the same base classes and connectors
are used for all common interconnects. In this way
vastly differing projects can still use some of the same
components. We hope that this middle ground between a completely rigid architecture and a collection
of independently created models with some similarities but many differences will prove useful.
In this particular case it would of course be rather
easy to create a common vehicle model, which through
replaceable subsystems could be used to generate either model. However, we do not know enough today
about what will be required tomorrow to incorporate
all possible variations. Thus we have chosen to let the
modelers of the next project and the one after that decide how to best handle their particular challenges.
The vehicle model with cooling system representation give rise to a non-linear equation system which
needs to be solved iteratively at every time step. This
makes simulation very slow, a performance hit of
about 100 times compared to the simpler model was
observed. The vehicle without a cooling system can be
simulated four hundred times faster than real time on
a standard laptop (PentiumTM M, 1.6 GHz, 1 Gb ram).
The performance difference alone is ample justification to have two vehicle model variants.

7 Conclusion
Our proposed library imposes less rigid structural control than most other vehicle architectures. Generally it
does not include connector which are not used. An effort has been made at creating something which works
well in the local situation. The system is not primarily
intended for exchange of models with external developers. Attention has also been given to a number of
practical issues related to working (updating, installing
etc.) with the system.
There are many similarities between this work and
the vehicle model architecture (VMA) project [6].
With some modifications many of our components
could be used in VMA utilising appropriate wrappers.
One key difference is the localisation of control units.
We have chosen to place them inside the subsystems
they control, while the VMA places them at the top
level. The future development of the VMA project will
be observed with great interest.

8 Future Work

We foresee a continued study of the actual use of the
new models to find areas where the architecture can be
improved. Inclusion of a wider range of component
models is also a likely continuation. More documentation and tutorials to aid users would be beneficial.
The work described was carried out with Dymola
5.1b, but the project has since been upgraded to version 5.3b and Modelica Standard Library 2.1. Certain components have also found use in real-time
6 Limitations
hardware-in-the loop simulations using Simulink.
The recently proposed relaxations of the connector
During our work we have faced many compatibility
issues which cannot be directly attributed to model de- equivalency requirements in Modelica opens up interThe Modelica Association

475

Modelica 2005, March 7-8, 2005

P. Bengtsson, H. Jansson, N. Pettersson, T. Sandberg

esting options for improved handling of the CAN communication.

http://www.modelica.org/projects/vma.
01-31.

2005-

9 Acknowledgements
The described model and library architecture has been
developed based on experiences from the usage of a
previous Modelica complete vehicle modeling effort
aimed at fuel consumption estimation. This effort is
described in a licentiate Thesis by Tony Sandberg [4].
Experiences from the work on modeling auxiliary systems by Niklas Pettersson have also been valuable [3].
Many of the subsystem models in the reference vehicle model have been converted from versions used in
those projects. The work on the new library and model
has been carried out as a M.Sc. thesis project by Per
Bengtsson under the supervision of Niklas Pettersson
[1].

References
[1] Bengtsson P. Structuring of Models Intended for
Complete Vehicle Simulation. Uppsala, Sweden:
Master’s thesis, Division of Systems and Control, Dept. of Information Technology, Uppsala
University, Dec 2004.
[2] Laine L. and Andreasson J. Modelling of generic
hybrid vehicles. Proceedings of the 3rd International Modelica Conference, pages 87–93. The
Modelica Association, 2003.
[3] Pettersson N. Modelling and Control of Auxiliary Loads in Heavy Vehicles. Stockholm, Sweden: Licentiate thesis, Dept. of Signals, Sensors and Systems Royal Institute of Technology,
2004.
[4] Sandberg T. Heavy Truck Modeling for Fuel
Consumption: Simulations and Measurements.
Linköping, Sweden: Licentiate thesis, Dept.
of Electrical Engineering, Linköping University,
2001.
[5] Tiller M., Bowles P., and Dempsey M. Development of a vehicle model architecture in Modelica. Proceedings of the 3rd International Modelica Conference, pages 75–85. The Modelica Association, 2003.
[6] Vehicle
veloped

Model
Architecture,
deat
Ford
Motor
Company,

The Modelica Association

476

Modelica 2005, March 7-8, 2005

Evaluation of Motor and Battery Requirements for Hybrid-Electric Powertrains during Cranking

Evaluation of Motor and Battery Requirements for Hybrid-Electric
Powertrains during Cranking
Michael M. Tiller
Research and Advanced Engineering, Ford Motor Company
mtiller@ford.com

Abstract
Hybrid electric vehicles (HEVs) are an emerging technology for improving fuel economy and
emissions. However, hybrid powertrains are expensive to manufacture because of the sophisticated
electronics required. In particular, the motor and
battery requirements must be carefully considered
because of the cost and weight of these components.
For this reason, it is important to conduct an upfront analysis to determine the minimum requirements for the motor and battery [1]. Such an analysis ensures that the requirements for the vehicle (acceleration, fuel economy, etc) can be met while minimizing the incremental cost to the consumer.
This paper describes the development of engine
and transmission models used to perform such an
analysis for a research vehicle project. The model
must take into account several important effects such
as crankshaft position, engine damper design, motor
design, control strategies and so on. The multidomain modeling capabilities of Modelica allow us
to formulate a model with which all these important
effects can be captured [2].
This paper will show that such a model is not
only capable of helping hardware designers evaluate
the performance of different electrical components
but also allows experimentation with various control
strategies for controlling the launch clutch and drive
motor.

specified, there is a complex relationship between
the design specifications for individual components
and the performance of the entire vehicle system.
For this reason, system engineering principles
are used to formalize the design process [3]. As part
of this process, requirements are identified during the
early stages of development. These requirements are
then used to define performance targets for each of
the vehicle subsystems (and, in turn, their constituent
components). The process is often represented by
the system engineering “V” shown in Figure 1.
For the application described in this paper, we
are concerned with the initial requirements cascading. Based on fuel economy analysis, we know what
size motor and battery are required and how much
power they need to handle. However, fuel economy
is only one attribute to be considered. Because we
would like to eliminate the cost and weight associated with a dedicated starter motor, we also need to
verify that the motor and battery combination we
have chosen will be sufficient for starting the engine.

Keywords: System engineering, hybrid electric,
VMA
Figure 1: System Engineering Process

1

System Engineering Process

Development of a complete vehicle is a daunting task. There are numerous regulations and constraints on the development process. In addition,
while the attributes of the vehicle as a whole (performance, fuel economy, emissions, etc) may be

The Modelica Association

While it is possible to rely on “rules of thumb”
or knowledge-based engineering solutions to determine requirements for conventional vehicles, it is
nearly impossible to apply these to research projects.
In such cases, physically-based models of the underlying systems with sufficient levels of detail and fidelity can be created that reasonably approximates

477

Modelica 2005, March 7-8, 2005

M. Tiller

the response of a physical incarnation of the design.
Because design specification details should result
from this process, such models need to be detailed
enough to capture the effects of design changes. We
term such models “design-oriented” models. In order to capture such effects it is typically necessary to
make first-principles based models of the various
components and use constitutive relationships based
on design parameters (e.g. compliance, inertia, mechanical limits, etc) to characterize these components.

2

Powertrain Architecture

This section describes some of the relevant details about the powertrain architecture. This analysis
was conducted for a research vehicle. Many of the
components were relatively new and they had never
been used in this particular configuration before. For
this reason, models were necessary to analyze the
requirements and determine component specifications.
The overall vehicle model used the Modelica
Vehicle Model Architecture library [4]. Starting
with the conventional vehicle architecture (shown in
Figure 2), specific models for the engine and transmission were supplied that captured the physical effects required for the analysis of engine cranking.
The remainder of this section will discuss each
model in detail.

injecting fuel, we do not need to be concerned with
the combustion dynamics of the engine. Instead, we
focus on only those dynamics that are present before
fueling begins. The engine model used is shown in
Figure 3 and includes typical crank-angle based dynamics. For our analysis, two effects are particularly
important.
The first effect involves the engine design itself. In particular, the compression ratio of the engine and the valve timing will determine exactly how
much “resistance” is felt as we try to crank the engine. The engine configuration we are studying is a
V-6 configuration so for every 720 degrees of motion in the crankshaft we will go through 6 compression events. These events normally correspond to
the compression of the air-fuel mixture in preparation for combustion and the amount of work that
must be done in order to perform such compression
is strongly influenced by the compression ratio and
valve timing of the engine.
The other effect we consider is friction. Friction is very sensitive to both engine speed and ambient thermal conditions. Friction is extremely hard to
quantify because of the various non-linear effects
involved (viscosity, thermal expansion, wear) and
the fact that it is typically only calculated under
steady state conditions for normal operating points.
Because our analysis was conducted for an engine
that was still in a prototype stage (without complete
friction data), we will assume a conservative friction
relationship and show how sensitive our results are
with respect to this estimate.

Figure 2: Vehicle Model Architecture

2.1

Engine Model

Modeling engines can be quite complicated
because many factors contribute to the dynamics of
the engine [5]. Because, in this application, our goal
is to reach a critical engine speed in order to begin

The Modelica Association

478

Figure 3: Engine Model

Modelica 2005, March 7-8, 2005

Evaluation of Motor and Battery Requirements for Hybrid-Electric Powertrains during Cranking

2.2

Damper Model

While the damper model is technically part of
the transmission model, its design and behavior can
be described independently of the other transmission
components. The purpose of the “damper” is to prevent engine torque fluctuations from being propagated into the transmission and driveline. In addition
to preventing these vibrations from being “felt” by
the driver of the vehicle, the isolation also protects
downstream components from experiencing torque
reversals between combustion events leading to gear
rattle and other NVH phenomena.
The damper design must be concerned with
two kinds of dynamics. The first is the normal engine “torque signature” under steady operating conditions. In these cases, the damper should be as efficient as possible in transmitting energy to the transmission (to avoid a fuel economy penalty) but still
isolate the fluctuations of the engine so they do not
lead to downstream disturbances. The other mode
involves damping of large scale disturbances (i.e.
those that might occur as a result of pressing the accelerator pedal). It is desirable that in such circumstances the damper should “extract” energy so that
these disturbances are quickly damped out.
These two, seemingly contradictory, goals are
accomplished by a design, shown in Figure 4, that
combines a compliant (typically multi-stage) spring
in parallel with a hysteretic element surrounded by
inertia elements on either side. Because of the backlash deliberately designed into the damper, the hysteresis is only triggered for large deflections (determined by the magnitude of torque carried by the element and the compliance of the spring). As a result
when large disturbances are generated by the engine,
the hysteresis loop removes the energy, via friction,
as heat.
The damper must be tuned so that the natural
frequency of the driveline is below the idle speed of
the engine to avoid excitation of resonances in the
driveline. However, there is also a dynamic aspect
to this tuning. Because of the multi-stage design of
the spring, large deflections result in the stiffer stage
of the spring being involved. This increases the “effective stiffness” of the device and, as a result, raises
the effective natural frequency. This leads to an interesting phenomenon. As you approach the natural
frequency of the spring (for small deflections) from
below, the spring will start to resonate. If this resonance leads to deflections that are large enough, the
stiffer stage of the spring will begin to participate
and the natural frequency will increase. If the natural frequency increases that means that a greater por-

The Modelica Association

tion of the engine cranking will occur below the
natural frequency and more resonance will occur. If
this process is gradual enough, the resulting dynamics can become quite violent. To avoid this, it is desirable to move through the resonance as quickly as
possible.

Figure 4: Damper Model

2.3

Transmission Model

Ultimately, the purpose of this analysis is to
establish the power and torque requirements to crank
the engine in this vehicle. Because the electric motor
used for this process is contained in the transmission
[6], the transmission plays an unusually key role in
the starting process for this vehicle. A schematic of
the transmission is shown in Figure 5.

Figure 5: Transmission Model

The design of the gearbox itself is not particular important here because the transmission will not
be engaged during our analysis (although it would be

479

Modelica 2005, March 7-8, 2005

M. Tiller

in a further assessment of “rolling starts”). What is
important is the engagement of the motor clutch (i.e.
the clutch that connects the motor to the engine).
Another important factor is the additional inertia of
the motor rotor. Although it would be nice to choose
how much inertia to include in the rotor, this is
largely determined by packaging constraints and the
performance targets of the motor.
It is important to note that all torque used to
start the engine must come from the electric motor in
the transmission. There is no starting motor on the
accessory side of the engine as there is in a conventional powertrain. This means that the motor design
must be able to deliver tractive torque (when driving
the vehicle) or cranking torque (when starting the
engine). Because the peak power requirements are
different, these two goals do not necessarily lead to
similar designs for the motor.
2.4

Using the information about the motor and
engine speed, the control strategy can use two actuators, the electric motor and the launch clutch. The
control strategy can specify the torque to be generated by the motor and the pressure applied to the
launch clutch. Physically, this clutch pressure translates into a “clutch capacity” (i.e. how much torque
can be transmitted through the clutch). As a result,
the clutch is also effectively a torque actuator.

Control

Starting the engine involves several discrete
phases [7]. These stages are shown at the top of
Figure 6. For our analysis we assume that before the
engine is started the electric motor is disconnected
from the engine (i.e. the motor clutch is disengaged)
and the engine is completely at rest (phase 1). Before this motor clutch is engaged, the controller uses
a PID strategy to bring the motor speed up to a specified value (phases 2 and 3). Once that setpoint has
been achieved, the motor clutch is engaged (phase
4). As the clutch is engaged, torque is transmitted to
the engine. The critical issue is making sure that the
engine “turns over”. In practice, this means that sufficient starting torque must be delivered to the engine
to overcome the resistance caused by the first compression event in the engine (phase 5). The PID
strategy attempts to hold the motor speed at the same
setpoint during this process (phases 2-5). Once the
engine has reached the desired speed (phase 6 and 7),
the motor torque requirement is considerably reduced because it only needs to maintain the desired
speed.
The control strategy relies on sensing two different speeds, the motor speed and the engine speed.
The motor speed is known to a great degree of accuracy with very little delay. Unfortunately, the same
cannot be said of the engine speed. The engine
speed sensing relies on a traditional engine speed
sensor which is relatively low resolution (as compared to the motor speed), is unreliable at low
speeds, and is subject to considerable lag due to its
design and implementation.

The Modelica Association

Figure 6: Baseline Analysis Results

3

Validation and Interpretation

While the use of models in system engineering
to assist with target cascading and requirements
analysis is useful, establishing the validity of the
models used in the process is difficult. This is because, by the nature of the process, the system being
engineered has not been built yet. Because designoriented models are built using first principles, they
do not rely heavily on empirical data. Instead, design data can be used to directly characterize the
model.
In our case, there was existing data showing
how similar hardware and control strategies functioned on a research prototype [7]. As a result, our
validation focused on making sure that the response
from our models matched, qualitatively, the response
from actual hardware (albeit different hardware).
Figure 6 shows a typical result. Interesting
qualitative features shared with in-vehicle test results:
• Saturation of motor torque during phase 2
• Magnitude of ‘parasitic’ loses during phase 3
• Motor torque limited to clutch capacity in
phase 4 and 5
• “Brake” torque required in phases 6 and 7
A key feature of Figure 6 is the transition from
phase 4 to phase 5. The boundary between these

480

Modelica 2005, March 7-8, 2005

Evaluation of Motor and Battery Requirements for Hybrid-Electric Powertrains during Cranking

phases is defined as the point where the engine
crosses the first compression event. Of particular
importance during this event is the deceleration of
the engine. If the engine speed approaches zero, the
engine may stall (i.e. the vehicle will fail to start).

4
4.1

Analysis
Baseline results

Figure 6 shows a baseline response for our
system. We can see the various phases of the control
strategy and the results clearly indicate a successful
starting of the engine (i.e. the engine achieved the
critical speed necessary to begin fueling). We also
see no evidence of any serious resonance in the
driveline during cranking.
While such results highlight the important features of the experiment, there are other results that
are available to us in our design-oriented model that
are also useful. For example, these results confirmed
that response of our damper did not exceed any of its
design constraints (i.e. maximum deflections, maximum torque, energy dissipated, etc).
Another interesting feature of the simulation is
the deflection of and torque transmitted through the
engine mounts. While not particularly interesting for
target setting and requirements analysis of the electric motor and battery, the model could be used for
an additional analysis involving target setting and
requirements analysis for the engine mounts.
4.2

friction estimate. For this reason, it is useful to understand the sensitivity of our baseline response to
different amounts of friction. From Figure 7, we see
results of several different simulated experiments
with different amounts of friction. All conditions are
identical between Figure 6 and Figure 7 except the
amount of friction. As the amount of friction is increased, the important feature to notice in Figure 7 is
the dip in engine speed during the first compression
event. Although the baseline case shows a successful start, an increase in friction of only 25% leads to
an unsuccessful result. From this we can see that
there is significant sensitivity to friction. This analysis can help us establish an upper bound on acceptable friction.
4.3

Crankshaft Position Sensitivity

Another important factor in cranking an engine is the initial position of the crankshaft. Ideally,
the engine should be given as much time as possible
to build up momentum as it approaches the first
compression event. As shown in Figure 8, by taking
our baseline case and “backing up” the starting position of the crankshaft we can significantly increase
our tolerance to friction (and thereby improve our
robustness to friction).

Friction Sensitivity

Figure 8: Crankshaft Position Sensitivity

The difficulty in this approach is that we cannot directly control the crankshaft position prior to
starting the engine. So this analysis only gives us
information about the fact that the results are sensitive to initial crankshaft position and highlights a
need to understand the statistical variation in engine
shutdown patterns (something we could also use the
model to study in detail).

Figure 7: Friction Sensitivity

As mentioned previously, friction is a complex quantity to measure and it changes as a function
of engine operating conditions. As such, we would
like our analysis to be as robust as possible to our

The Modelica Association

481

Modelica 2005, March 7-8, 2005

M. Tiller

4.4

Performance Limits

Sections 4.2 and 4.3 addressed noise factors in
the engine starting process and established sensitivities to help us gage the robustness of the procedure.
Now we will turn our attention to the control strategy
itself to see what we can achieve with the sensors
and actuators we have available.
We will focus on two cases which we will label “Best Case” and “Worst Case”. The “Best Case”
scenario is important because it shows us how much
excess capability we have in our electric motor under
the best circumstances. This excess capacity gives
us some metric by which we can gage the potential
of the system to implement rolling starts (i.e. starting
the engine while the vehicle is moving). The “Worst
Case” scenario helps us to gage the limits of our design by trying to start the engine under very difficult
circumstances.
Let us first consider results from the “Worst
Case” analysis shown in Figure 9. For this analysis
we have specified that the setpoint for motor speed
control during phase 3 (see Figure 6) should be twice
the speed at which the engine should be started. This
“overspeed” gives us additional momentum (built up
during phases 2 and 3) that we can use to generate
additional torque. Our “Worst Case” corresponds to
the green line in Figure 9. What this result shows us
is that by using a clutch with a torque capacity of
350 N.m., we can still start the engine in the face of
200% more friction than the baseline case. Note that
the additional torque used to crank the engine comes
from sacrificing momentum in the motor rotor as
exhibited by the deceleration of the motor rotor during motor clutch engagement.

Figure 9: Worst Case Scenario

Figure 10: Best Case Scenario

5

Conclusions

The analysis in this paper supports the idea that
this particular system is relatively robust with respect
to the motor and battery requirements. While the
response of the system is sensitive to friction and
crankshaft position, the control strategy and the actuators available to it can handle the most extreme
cases with enough of a safety margin.
From the analysis presented in this paper, we
can see how design-oriented models can be used to
guide the development of both hardware and software in the vehicle development process. Although
this paper shows how this process was applied to a
hybrid electric vehicle, the principle holds not only
for other types of vehicles but for many product development activities in general. The key is the ability to quickly develop design-oriented models to help
with upfront evaluations. This not only saves time in
the development process but can save a considerable
amount money by reducing or even eliminating the
1

Looking at Figure 10, we see the results of
our “Best Case” scenario. In this case we assume
that the amount of friction to be overcome has been
reduced by 40% (due, for example, to engine warm
The Modelica Association

up). In such a case we see that we no longer need to
use all of our motor torque to start the engine (as
demonstrated by the difference in the two traces at
the bottom of Figure 10). This is important because
it means that we could provide some drive torque to
the wheels (through the transmission gearbox) and
still have enough torque left over to crank the engine.
This analysis gives us some indication of how much
excess is available (i.e. that could be used to move
the vehicle forward)1.

Of course, there are significant issues with starting the
engine under such circumstances without causing significant (i.e. driver perceptible) driveline disturbances. However, this is beyond the scope of this paper (although not
beyond the scope of this model).

482

Modelica 2005, March 7-8, 2005

Evaluation of Motor and Battery Requirements for Hybrid-Electric Powertrains during Cranking

need for prototype hardware that might have to be
fabricated to support real-world testing aimed at answering the same questions.

References
[1]

[2]

[3]
[4]

[5]

[6]

[7]

“Advanced Hybrid Vehicle Powertrains
2003”, SAE World Congress, 2003. Detroit,
Michigan. SAE-SP-1750.
Tiller M., Tobler, W. E., Kunag, M., "Evaluating Engine Contributions to HEV Driveline
Vibrations”, Proceedings of the 2nd International Modelica Conference, Oberpfaffenhofen, Germany, 2002.
Ford Design Institute, “Systems Engineering
Fundamentals”, 1999.
Tiller M., Bowles P., and Dempsey M., “Development of a Vehicle Model Architecture
in Modelica”. Proceedings of the 3rd International Modelica Conference, Nov. 3-4, 2003.
Linköping, Sweden.
Batteh, J., Tiller M., Newman, C. E., “Simulation of Engine Systems in Modelica”. Proceedings of the 3rd International Modelica
Conference, Nov. 3-4, 2003. Linköping,
Sweden.
Ortmann W., Colvin D., Fozo S. R.,
Encelewski M., Kraska M., “Incorporating an
Electric Machine into the Transmission Control of Ford’s Modular Hybrid Transmission”, SAE2004-01-0069. Society of Automotive Engineers, Inc. Warrendale, PA.
Colvin D., Masterson B., “Challenges of Engine Starts and Drivability in a Parallel Hybrid-Electric System”, SAE2004-01-0063.
Society of Automotive Engineers, Inc. Warrendale, PA.

The Modelica Association

483

Modelica 2005, March 7-8, 2005

The Modelica Association

484

Modelica 2005, March 7-8, 2005

Session 6b
Thermodynamic Systems V

The Modelica Association

485

Modelica 2005, March 7-8, 2005

The Modelica Association

486

Modelica 2005, March 7-8, 2005

Modeling of Desiccant Assisted Air Conditioning Systems

Modeling of Desiccant Assisted
Air Conditioning Systems
Wilson Casas∗, Katrin Proelss and Gerhard Schmitz
Technische Universität Hamburg-Harburg
Denickestr. 17, 21075 Hamburg, Germany

Abstract
In desiccant air conditioning systems, moist air is dehumidified by means of a desiccant wheel. Water
vapour is absorbed by desiccant material as humid air
passes through the wheel. Using this technology, considerable energy savings can be obtained compared to
conventional air conditioning systems. To evaluate the
performance of the desiccant assisted air conditioning
process, a model library has been developed. In this
paper, control volume models for humid air and desiccant material are implemented and finally the operation of the desiccant wheel is simulated. Comparison
of the dynamic and steady state results to open literature, manufacturer data as well as experimental result
is used to validate the model.
Keywords: air conditioning; desiccant wheel; sorption; rotating heat exchanger, modelica

1

Introduction

In a desiccant assisted system, moist air is first dehumidified using a desiccant wheel, see figure 1. The
wheel consists of a honeycomb structure, which is
coated with desiccant materials such as silica gel or
lithium chloride. Water vapour is absorbed by the desiccant material as humid air passes through the wheel.
The moisture is released when the desiccant is regenerated by heating. For regenerating the desiccant wheel,
heat input at relatively low temperatures (e.g. 6070◦ C) is required, depending on the desiccant material. Using desiccant technology, the cooling demand
can be reduced to 30% of that of a conventional system [2]. The energy demand for air conditioning is
thus shifted from electrical to thermal energy, primary
energy consumption is reduced as well and waste heat
can be used.
The performance of the desiccant wheel depends on
∗ email:

casas@tu-harburg.de, Tel:+40 4042878 3079

The Modelica Association

Figure 1: Desiccant wheel for air conditioning systems
several parameters, like ambient air condition (temperature and humidity), regeneration air, volume flow
rates and rotation speed. Other wheel specific parameters are geometry structure and sorption properties of
the material.
In order to predict heat and moisture transfer in the
desiccant wheel, conservation equations for energy
and mass need to be postulated. Convective heat and
mass transfer are described by lumped coefficients,
whereby heat and moisture transfer are coupled by the
equilibrium condition of the desiccant material, the
so called sorption isotherm. Conservation equations,
heat and mass transfer, the sorption isotherm as well
as thermodynamic state equations for air and desiccant
material result in a complex, non-linear, differential algebraic system of equations (DAE).
Several solutions for such DAEs have been provided in
different works. [6] introduces the concept of characteristic potentials, whereby the DAE is rewritten based
on these new independant variables. Using heat and
mass transfer analogy, a numerical solution for the
DAE can be provided. Other authors solved the DAE
by linearization and Laplace-Transformation [7], using a finite difference method [14], or finite volume
method with a Gauss-Seidel iteration algorithm [13].

487

Modelica 2005, March 7-8, 2005

W. Casas, K. Prölß, G. Schmitz

As this short literature review shows, providing a solution for the combined heat and mass transfer problem
in the desiccant wheel requires expert knowledge of
the applied numerical methods as well as good programming skills. In addition, governing equations
have to be rewritten in a very abstract form (for example using dimensionless variables).
A limitation of most of the methods available in the
open literature is, that they can not be used for desiccant materials with discontinuities in their sorption
isotherms (e.g. lithium chloride), unless the solver algorithm is extended or rewritten [9]. Hence, in case of
lithium chloride as desiccant material, numerical soluFigure 2: Air control volume
tion methods based on heat and mass transfer analogy
mentioned above can not be applied.
In this work Modelica/Dymola was used to overcome to dry air mass. Water content or absolute humidity of
these limitations and to provide a component oriented air x is defined as the ratio of water to dry air mass,
modeling approach which offers a high level of flexiMw,i
bility with respect to boundary settings.
(1)
xi =
Mi

2

The energy balance for an i control volume can be
written as

Physical Model

In air conditioning systems, or thermodynamics systems in general, a working fluid (e.g. air, water) flows
through several components (e.g. ventilators, heating
or cooling coils). Components can be modeled by algebraic equations or by partial differential equations.
In this case, a distributed approach with higher discretization may be necessary. A control volume for
humid air is therefore needed.

2.1

∂Ui
∂t

= Q̇con,i + ṁi−1 · hi−1 − ṁi · hi
+ṁw,con,i · hw,con,i

(2)

Q̇con,i is the sensible heat flux and hw,con,i denotes the
enthalpy of the exchanged moisture. Consequently the
term ṁw,con,i · hw,con,i equals the latent heat flux. The
dry air mass balance is given by the simple equation
∂Mi
= ṁi − ṁi−1
∂t

Humid air

.

(3)

The model for humid air described here is based on Water balance results in the relationship
following assumptions:
∂Mw,i ∂xi
=
· Mi = ṁw,con,i + ṁi−1 · xi−1 − ṁi · xi .
(1) Humid air is an ideal mixture, Dalton’s Law of
∂t
∂t
(4)
Partial Pressures is valid.
The dynamic caloric state equation can be obtained
(2) Air flow is incompressible.
from the ideal gas equations,
∂ui ∂hi
∂ϑi
=
−R·
∂t
∂t
∂t

(3) Constant specific heat capacities for dry air, water
vapour and liquid water.
(4) Heat conduction in flow direction is neglected.

.

Thereby, enthalpy of humid air is

Balance and state equations will be postulated for a
hi = c p,a · ϑi + xi · (c p,wv · ϑi + ∆hV )
control volume according to figure 2. The control
volume model is assumed to be connected to other and its derivative
models, whereby heat and humidity or air can be ex∂ϑi
∂hi
= c p,a ·
+ (c p,wv · ϑi + ∆hV )
changed.
∂t
∂t
Specific values (e.g. enthalpy h, internal energy u)
∂xi
∂ϑi
·
+ xi · c p,wv ·
.
used in the equations below are defined with respect
∂t
∂t
The Modelica Association

(5)

488

(6)

(7)

Modelica 2005, March 7-8, 2005

Modeling of Desiccant Assisted Air Conditioning Systems

The mass of the matrix material in a control volume V
follows from
Mi = Vi · ρr ,
(10)

From this follows
∂ui
∂t

= (c p,a − Ra + xi · (c p,wv − Rw )) ·

∂ϑi
∂t

where ρr is the density of the supporting structure.
(8) The humidity ratio in the desiccant material is defined
as
Mw,i
Dynamic equations for air states may not be needed for
qi =
.
(11)
χ
· Mi
every final component model. Hence, it makes sence
to implement steady equations
The change of water in control volume can be calculated from
∂xi
∂ui
= 0 and
=0
(9)
∂qi
∂Mw,i
∂t
∂t
= Mi · χ ·
= ṁw,con,i ,
(12)
∂t
∂t
to be used instead. With an appropriate parameter, the
developer may be able to decide if dynamic or steady whereby ṁw,con,i equals the sorbed or desorbed water.
The energy balance results in
state equations are to be used.
+(c p,wv · ϑi + ∆hV ) ·

2.2

∂xi
∂t

.

Desiccant material and supporting structure

First, a control volume for the supporting structure according to figure 3 is defined. Since the wheel has to
be discretized in axial and eventually also in tangential
direction, it is advantageous to choose a “pie piece” of
the wheel. The control volume will be connected later
to the humid air model using the heat flux and moisture
connectors. Following assumptions are made:
(1) The homogeneous, uniform wheel consists of
supporting material (e.g. cellulose) and desiccant
material (mass fraction χ) both with constant specific heat capacities cr and cs .

∂Ui
= Q̇con,i + ṁw,con,i · hw,con,i
∂t

.

(13)

As for the air side, Q̇con,i is the sensible heat, ṁw,con,i ·
hw,con,i the latent heat transferred with the moisture.
Enthalpy of sorbed water vapour comprises heat of
sorption, which consists of heat of vaporization and
binding enthalpy,
hw,con,i

= ∆hS,i + c p,wv · ϑa,i
= ∆hB,i + ∆hV + c p,wv · ϑa,i

.

(14)

Binding enthalpy ∆hB,i depends on the desiccant material properties and is supposed to be known from experimental data.
From the enthalpy of wet material
hi = (cr + cs · χ + χ · qi · cw ) · ϑi

(2) Axial heat conduction is neglected.

(3) Humidity transport and diffusion in the wheel is follows the dynamic state equation
neglected.
∂ϑi
∂ui
= (cr + cs · χ + χ · qi · cw )
∂t
∂t
(4) Heat and mass transfer between air and matrix
∂qi
can be described by lumped transfer coefficients.
.
+ χ · q i · cw · ϑi ·
∂t

(15)

(16)

The convective heat transfer between air and desiccant
material (see figure 4) can be described using Newton’s Law of Cooling,
Q̇con,i = αi · Ae,i · (ϑa,i − ϑi )

(17)

Ae,i denotes the effective heat transfer area, ϑ a,i is the
fluid temperature and αi the local heat transfer coefficient. The effective heat transfer area can be written as
the ratio of Volume to specific surface
Ae,i =

Figure 3: Convective heat and moisture transfer
The Modelica Association

489

V
ω

,

(18)

Modelica 2005, March 7-8, 2005

W. Casas, K. Prölß, G. Schmitz

denoting the equilibrium partial pressure for a known
moisture content and temperature.
For most solid desiccants (e.g. silicagel), the sorption isotherm is continuous. For lithium chloride,
depending on water content, sorption isotherm slope
changes discontinuously due to phase changes of the
system (LiCl hydrate formation). As figure 5 shows,
for the interesting temperature range of 20 − 90 ◦ C, the
LiCl-water system can consist of dilute solution, saturated solution with monohydrates or anhydrous LiCl
and monohydrates. Figure 6 shows sorption isotherms
from experimental data [5] and the developed correlation used in this work, as well as other correlations
[3].

Figure 4: Convective heat and moisture transfer
Table 1: Geometry data for desiccant wheel
2b
2a
c
U
A
Dh
ω
ρr

2,0 mm
3,4 mm
0,125 mm
8,84 mm
3,4 mm2
1,539 mm
2600 m2 /m3
129,5 kg/m3

whereby specific surface can be calculated from rotor
geometry, refer to table 1.
The Nusselt-Number Nu = α · Dh /λ and thus also the
heat transfer coefficient for laminar flow in sinusoidal
ducts can be obtained from numerical work [8, 12, 1,
11].
In analogy to (17), convective mass transfer could be
Figure 5: Phase diagram for the system LiCl-water
described by
(based on [10])
ṁw,con,i = βi · ρa,i · Ae,i · (xa,i − x|y∗ =0 ) .
(19)

qeq = q(pwv , ϑ)

100

60

de

gC

80

60
gC

50

egC

d
40

20

peq = p(q, ϑ)
The Modelica Association

de

40

(20)

describing the equilibrium moisture content of desiccant for a constant temperature depending on vapour
partial pressure. The function q(p wv , ϑ) is usually
given as a correlation of measurement data. Another
equivalent formulation is

70

Johnson 30 degC
Johnson 50 degC
Johnson 70 degC
this work
Gutermuth

de
gC

120

partial vapour pressure pw in mbar

βi denotes thereby the mass transfer coefficient and
x|y∗ =0 is the moisture content of the boundary layer
at the surface of the desiccant material. Hence concentration difference (xa,i − x|y∗ =0 ) is the driving force
for convective moisture transfer. It has to be assumed,
that the boundary layer is in equilibrium with the wall
with respect to temperature and moisture content, for
instance water content of the boundary layer x| y∗ =0
equals xeq := f (q, ϑw ), namely the water content of
air at equilibrium with desiccant of water load q and
temperature of matrix ϑ.
Sorption equilibrium is given by the sorption isotherm

egC

30 d

20 degC

0

0.5

1
1.5
2
water content q in kg(licl)/kg

2.5

3

Figure 6: Sorption isotherms for the system LiCl(21) water
490

Modelica 2005, March 7-8, 2005

Modeling of Desiccant Assisted Air Conditioning Systems

It should be noticed, that for implementation in Modelica, appropiate crossing functions should be used to
avoid numerical instabilities during simulation and to
reduce computation time.
If the sorption equilibrium equation (21) is known, xeq
in (19) follows to
xeq,i =

peq,i (q, ϑi )
Ra
·
Rw (p − peq,i (q, ϑi ))

(22)

To determine the convective mass transfer coefficient
in (19), the Lewis number Le = a/D12 may be used to
relate the two convective transfer coefficients [4]
α
λ
=
= ρ · c p · Le(1−n)
β D12 · Len

.

(23)

temperature ϑ in ° C

Figure 7: RotPair Desiccant wheel base model (diIt has to be pointed out, that the relationship given
agramm layer)
above can only be used, if convective mass transfer
at the surface dominates the overall mass transfer resistance. Other moisture transport mechanisms in the rapidly. In that case, outlet conditions have to be computed as a mean value from m pie elements. If only
material (e.g. pore diffusion) are thus neglected.
one pie element is simulated, and inlet conditions are
constant, air outlet conditions result as mean value for
3 Modelica implementation
half a revolution and is therefore integrated over time,
e.g. for temperature
The humid air and desiccant models were impleZ
mented in a Modelica library. The base model of the
1 t+∆t
¯
ϑ dt
(24)
ϑout =
desiccant wheel RotPair is built up from two pairs
∆t t
of each one air and desiccant wall model instances,
Figure 8 plots the temperature of both pie piece consee figure 7. Each air and desiccant wall component
trol volumes at the process air outlet side and the calis divided into n elements (control volumes). The two
culated time mean value according to equation above.
model pairs represent two opposites “pie pieces” of the
Concerning axial discretisation, best compromise is
desiccant wheel (see figure 3), so one model pair is in
obtained with n = 10 . . . 15 for a wheel width of 250
the regeneration and the other in the process air stream.
mm.
After half a revolution, the boundary conditions (air
inlet) changes, since the pie piece goes from process
60
to regeneration side. Therefore, auxiliary models have
55
to be used and outer connectors can not be joined directly to air models. In addition, during regeneration,
50
the first element (i = 1) of the desiccant wall model
is connected to the last element of the correspond45
ing air model (i = n). Boolean signal connectors are
40
used to change the connection order in the desiccant
air_A[n]
air_B[1]
wall model according to the angular position of the pie
35
process air
piece in the wheel.
mean value
30
Higher discretisation in tangential direction (more “pie
850
900
950
1000 1050
time in s
pieces”) can be used, but computation time increases
drastically. In addition to increased number of equations in the system, more state events are gener- Figure 8: Mean value computation for rotating speed
ated during simulation each time boundary conditions 1/3 rpm (∆t = 90 s)
change. Discretisation in tangential direction makes
hence only sence, if inlet conditions change with time Figure 9 shows the structure of the RotPair model.
The Modelica Association

491

Modelica 2005, March 7-8, 2005

W. Casas, K. Prölß, G. Schmitz

Figure 10: Test model for dynamic simulation

Figure 9: Structure of the model
The DesiccantWall model consists of several
classes containing balance equations and material
properties. In order to use the same model with other
desiccant materials (e.g. Silicagel) or for simulation of rotary heat exchangers (no mass transfer at
all), some classes are replaceable. For instance, the
MassEquilibriumModel containing the description of the sorption isotherm can easily be exchanged,
as well as the latent (sorption) heat model.

4

Simulation results

In this section, first dynamic simulation results will be
shown and compared to open literature. Subsequently,
results from steady state simulation will be discussed
and a total system simulation will be presented.

4.1

Dynamic simulation

The Modelica model described in this paper was used
to simulate the dynamic behaviour of a rotary LiCl
dehumidifier, see figure 10. The matrix is assumed
to be at a regenerated state with uniform temperature
ϑinit = 75◦ C and water load of qinit = 0.3 kg/kg. The
air flows through the matrix with an inlet temperature
ϑa,in = 25◦ C and humidity xa,in = 15 g/kg. Initial conditions and other parameters chosen here correspond
to those used in [9], so simulation results can be compared.
The temperature and water content profile of the matrix with respect to the axial coordinate are shown in
figure 11a,b. Each curve corresponds to one time snapshot. Figure 11c,d shows the temperature and moisture
content of outlet air during the process.
The Modelica Association

At the beginning of the process, the hot matrix is
cooled down very fast, since sensible heat exchange
due to high temperature differences between matrix
and air dominates. It can be seen that outlet temperature of air rises very quickly (inlet 25 ◦ C, outlet 73◦ C).
But after a few seconds, the temperature in the matrix
remains at 56◦ C. At this temperature, a phase change
in LiCl-water system from hydrate to saturated solution occurs. Equilibrium condition changes and sorption rate decreases, resulting in a rising outlet moisture
content of the air. The next phase change from saturated solution to unsaturated solution occurs at 46 ◦ C.
During this process, outlet air states stay nearly constant. When only unsaturated solution remains, the
sorption rate drops and air outlet states approach the
inlet conditions rapidly.
Simulation results show good agreement with theoretical simulations in [9]. Differences in temperature and
moisture content appear, which could be due to different equations for the description of sorption isotherms
between [9] and the present work.

4.2 Steady state simulation
Figure 12 shows the air outlet moisture content of the
air for a LiCl rotary dehumidifier (diameter 895 mm,
V̇ = 2300 m3 /h) at constant process air inlet temperature ϑa,in = 32◦ C and rotation speed 1/3 rpm depending on inlet humidity and regeneration temperature.
For comparison, manufacturer data is plotted in dashed
lines.
As can be seen, outlet humidity decreases at higher
regeneration temperatures, but there is a deviation of
approximately 0,5 g/kg between simulation and manufacturer data. Besides of that, outlet humidity according to manufacturer appears to decrease linearly
with respect to regeneration temperature, whereas sim-

492

Modelica 2005, March 7-8, 2005

Modeling of Desiccant Assisted Air Conditioning Systems

11

a)

Manufactorer, xin=12 g/kg

80

Simulation xin=12 g/kg

t=0 sec

70

water content x in g/kg

temperature t in ° C

10

10

60

15

50
40

20

30

100

20
0

Simulation xin=14 g/kg
9

8

7

200

30

Manufactorer, xin=14 g/kg

0.5
axial length z∗

6
50

1

55
60
65
inlet regeneration temp. ϑ in °C

70

54

b)

Manufactorer, x =12 g/kg
in

52

3

outlet temperature ϑ in °C

water content q in kg/kg

4
200
100

2
30
20
1 15
10

0
0

Manufactorer, xin=14 g/kg
50

Simulation x =14 g/kg
in

48
46
44
42

t=0 sec

0.5
∗
axial length z

1
40
50

c)
70
temperature t in ° C

Simulation xin=12 g/kg

60

this work
Rau et al.

55

60

65

inlet regeneration temp. ϑ in °C

70

Figure 12: Air outlet water content and temperature
for different regeneration temperatures, comparison
between simulation and manufacturer data

50

water content x in g/kg

ulated humidity approaches a limiting value at ϑ a,reg =
68◦ C and decreases again for higher temperatures.
40
This behaviour is in full agreement with the sorption isotherm: for temperatures at around 60 . . . 65 ◦ C
30
0
100
200
300
400
LiCl saturated solution forms at the regeneration side.
time in s
Lower matrix water load does not result in higher sorpd)
tion potential according to sorption isotherm. Only if
16
water load is reduced under a certain value, anyhdrous
this work
LiCl can form and sorption potential is higher. Al14
Rau et al.
though there is a limit for outlet humidity – if regen12
eration temperature is high enough, so that the whole
10
matrix can be dryed (q → 0), increasing regeneration
8
temperature does not affect outlet humidity. This be6
haviour is in agreement with simulation results for
higher temperatures (e.g. 80◦ C, not shown in figure
4
12). Manufacturer data seems not to comply with this
2
0
100
200
300
400
limit and there is no data available for higher regenertime in s
ation temperatures.
In terms of outlet temperature, simulation results show
Figure 11: Dynamic simulation results: a) matrix temgood agreement with manufacturer data. Deviation
perature and b) water content, c) air outlet temperature
averages to 1◦ C and is even lower for high regenerand d) water content
ation temperatures. Simulated temperature is higher
The Modelica Association

493

Modelica 2005, March 7-8, 2005

W. Casas, K. Prölß, G. Schmitz

than reference data, which can be explained due to
higher dehumidification in the simulation. This leads
to higher latent heat flux and therefore to the increased
outlet temperature.
Figure 13 shows air outlet humidity for different rotating speeds at constant process and regeneration air
inlet conditions. For low speeds, the matrix remains a
long time on process air side and dehumidification capacity is exhausted before the drying period ends. At
increasing speeds and shorter time periods, air dehumidification is higher and reaches a maximum value
(lowest outlet humidity). For higher speeds, the process is dominated by heat transfer, thus dehumidification rate sinks. From figure 13 follows, that optimal
rotating speed should be u ≈ 0.3 − 0.5 rpm for this inlet conditions.
Figure 14: Air state changes for dehumidification and
enthalpy exchange

10
9.5
9

Temperatur ϑ in °C

70

8.5
8
7.5
7
0

1
2
3
4
rotating speed u in rpm

5

Figure 13: Air outlet water content for different desiccant wheel rotating speeds
As figure 14 shows, process air state changes change
from adiabatic dehumidification (h ≈ const) to simultaneous mass and heat recovery from regeneration air
at higher rotating speeds (u ≥ 5 rpm). This effect is
also known as enthalpy recovery and is used in practice in winter operation mode, to recover heat and humidity at different temperature and humidity levels between process and regeneration air. Hence, in winter,
dry outside air can be humidified and heated by enthalpy recovery. Enthalpy recovery can be controlled
by changing rotating speed.

4.3

Comparison to experimental data

Within the scope of a research project, experiments
have been carried out at TUHH. Measured process and
regeneration air states were used as input for the simulation. Figure 15 shows the inlet temperatures and
simulated outlet water content and experimental results. Deviation between experiment and simulation
ammounts approx. to 1 g/kg.
The Modelica Association

60
50
40
30
20
0

water content x in g/kg

water content x in g/kg

10.5

500

1000

ϑpro,in

ϑreg,in

1500

2000 2500
time in s

ϑpro,out (sim)
3000

3500

4000

4500

4000

4500

14
12
10
8
6
4
0

xpro,in
500

1000

1500

xpro,out (sim)
2000 2500
time in s

xpro,out (exp)
3000

3500

Figure 15: Simulation of LiCl desiccant wheel and
comparison to experimental data

It has to be taken into account, that experimental results for outlet water content are calculated from relative humidity measurement and temperature. But at
higher temperatures, e.g. for outlet process air, the accuracy for humidity measurement (±3% r.H.) results
in an absolute error ∆x = 0.8 g/kg. Simulation’s deviation from experimental results is thus nearly between
accuracy range. Furthermore, air flow measurement
used as input for the simulation contains also approx.
5 − 10% error. In addition, there is actually air carry
over effect and air leakages which are not taken into
account in the model. For high pressure differences
between regeneration and process air, air flows directly
from one side to the other making it difficult to deter-

494

Modelica 2005, March 7-8, 2005

Modeling of Desiccant Assisted Air Conditioning Systems

Figure 16: Desiccant assisted air conditioning plant
mine actual air state changes. Time delay in process
outlet response for the simulation is an effect of mean
value computation (90 s mean value). As stated above
in section 3, tangential discretization should be used
for changing inlet conditions.

water content x in g/kg

°

temperature ϑ in C

calculated temperature of regeneration air remains under 60◦ C. This is advantageous, since low temperature
heat sources can be used for the dehumidification process. Supply air humidity can be maintained within
desired humidity level (8-9 g/kg). The resulting heating and cooling capacity can be seen in figure 18. The
regeneration
air heater has a heating capacity of 15
4.4 Desiccant AC plant simulation
kW, whereas for cooling 7 kW are needed. Integrating
The presented Modelica models were used to simu- capacity results in heating and cooling energy demand
late the performance of a desiccant air conditioning for the simulated period, e.g. 843 kWh heating, 434
plant, see schematics in figure 16. The plant model in- kWh cooling demand.
cludes models for reading climate data, heat exchanger
(heater and cooler) and fan models as black box mod60
els, as well as models for temperature and humidity
50
control.
40
Outside air first flows through the desiccant wheel,
beeing subsequently pre-cooled using a rotating heat
30
exchanger and finally cooled to supply air temperature.
20
Air leaving the room passes first the rotating heat exoutside
supply
reg. air
changer and is heated to regeneration air temperature
10
0
20
40
60
80
100
120
in order to take the moisture out of the wheel. Temtime in h
16
perature sequence controller regulates first the rotating
speed of the rotating heat exchanger and secondly the
14
cooling capacity of the cooler. Humidity control in12
creases heat input in regeneration air heater if actual
humidity higher than set value.
10
Figure 17 shows results for supply temperature and
8
regeneration air temperature needed for dehumidificaoutside
supply air
tion during a week in summer operation mode. Supply
6
0
20
40
60
80
100
120
◦
set value (19 C) can be mantained for the operation
time in h
hours of the plant. As expected, regeneration air temperature varies with outside air humidity due to higher Figure 17: System simulation: temperatures and water
dehumidification load. For the simulation period, the content
The Modelica Association

495

Modelica 2005, March 7-8, 2005

20

1000

15

800

10

600

5

400

0

200
0

−5
−10

−200

−15

[5] E.F. Johnson and M.C. Molstad. Thermodynamic properties of aqueous lithium chloride solutions. Journal of Physical Chemistry, American Chemical Society, 55(2):257–281, 1951.

−400
capacity

−20

[4] Frank P. Incropera and David P. DeWitt. Fundamentals of Heat and Mass Transfer. John Wiley
& Sons, 4 edition, 1996.

heat/cooling demand in kWh

heat/cooling capacity in kW

W. Casas, K. Prölß, G. Schmitz

0

20

demand
40

60
time in h

80

100

[6] I.L. MacLaine-cross and P.J. Banks. Coupled
heat and mass transfer in regenerators – prediction using an analogy with heat transfer. International Journal of Heat and Mass Transfer,
15:1225–1242, 1972.

−600
120

Figure 18: System simulation: heating/cooling capacity and demand

5

[7] B. Mathiprakasam and Z. Lavan. Performance
predictions for adiabatic desiccant dehumidifiers
using linear solutions. Journal Solar Energy Engineering, 102:73–79, 1980.

Conclusions

In this paper, a Modelica model for the simulation of
air dehumidification by means of a desiccant wheel has [8] J.L. Niu and L.Z. Zhang. Heat transfer and friction coefficients in corrugated ducts confined by
been presented. The model is based on a finite volsinusoidal arc curves. Int. Journal of Heat and
ume approach for air and desiccant material. Heat and
Mass Transfer, 45:571–578, 2002.
mass transfer are described by lumped convective coefficients. The model was tested for LiCl as desiccant, [9] J.J. Rau, S.A. Klein, and J.W. Mitchell. Charbut can be used for other availabe desiccants, if equiacteristics of lithium chloride in rotary heat and
librium equations (sorption isotherm) are provided.
mass exchangers. Int. Journal of Heat and Mass
Transient simulation results are in good agreement
Transfer, 34(11):2703–2713, 1991.
with open literature. A comparison to manufacturer
data was carried out. It turned out that available man- [10] K.W. Röben and J. Hupe. Zur kontinuierlichen gasentfeuchtung durch absorption und
ufacturer data is not plausible for higher regeneration
chemisorption. Chemie-Technik, 11(7):866–873,
temperatures, whereas simulation returns a plausible
1982.
behaviour according to desicant material properties.
Other components have also been modeled and used [11] R.K. Shah and A.L. London. Laminar Flow
to calculate heating and cooling demand of a desiccant
Forced Convection in Ducts. Academic Press,
assisted air conditioning system.
New York, 1978.
[12] D.F. Sherony and C.W. Solbrig. Analytical investigation of heat or mass transfer and friction facReferences
tors in a corrugated duct heat or mass exchanger.
[1] A. Campo, J.C. Morales, and A.E. Larreteguy.
Int. Journal of Heat and Mass Transfer, 13:145–
159, 1969.
Pressure drop and heat transfer associated with
flows moving laminarly in straight ducts of irreg[13] C.J. Simonson and Robert W. Besant. Heat
ular, singly connected cross-sections. Heat and
and moisture transfer in desiccant coated roMass Transfer, 32:193–197, 1997.
tary energy exhangers: Part i. numerical model.
ASHRAE International Journal of Heating, Ven[2] W. Casas and G. Schmitz. Experiences with a gas
tilating, Air Conditioning and Refrigeration,
driven, desiccant assisted air conditioning system
HVAC& Research, 3(4):325–350, 1997.
with geothermal energy for an office building.
Energy and Buildings, 37(5):493–501, 2005.
[3] W. Gutermuth. Untersuchung der gekoppelten
Wärme- und Stoffübertragung in Sorptionsregeneratoren. PhD thesis, TH Darmstadt, 1980.
The Modelica Association

[14] W. Zheng and W.M. Worek. Numerical simulation of combined heat and mass transfer processes in a rotary dehumidifier. Numerical Heat
Transfer, Part A, 23:221–232, 1993.

496

Modelica 2005, March 7-8, 2005

Modeling and Simulation of Global Thermal and Fluid Effects in an Aircraft Fuselage

Modeling and Simulation of Global Thermal and Fluid Effects in an
Aircraft Fuselage

Dipl.-Ing. Bettina Oehler
Air Systems Technology and Processes
Airbus Deutschland GmbH

Abstract
This paper presents a model to determine pressure,
temperature and humidity in designated compartments of an aircraft fuselage based on the evaluation
of mass and heat flow balances under various environmental and operational boundary conditions. A
library has been developed, containing all necessary
modules and aircraft templates for modeling different aircraft types. Based on an aircraft template the
end-user establishes a customer cabin layout, specifies simulation and operation conditions and evaluates the results. The program code, the library and
the application of the template is easily understandable and structured to minimize errors.
This paper briefly describes how the Modelica modeling language was used for the calculation of the
fluid properties and the solution of the mass and energy balances. Furthermore the implementation of an
aircraft system is shown with a focus on data management. Improvement potential for the use of Dymola/Modelica for this type of application is identified.
Keywords: Thermal and Fluid Effects; Aircraft Fuselage Model; Thermodynamic Library.

1

Introduction

This model will support the work being carried out
in the subproject Individual Seat Climatisation (ISC)
of the research project Friendly Aircraft Cabin Environment (FACE). For the ISC subproject realistic
boundary conditions are needed. The aim of ISC is to
optimize the percentage of people that are satisfied
with thermal comfort in aircraft cabins.
The simulation model is intended to provide boundary conditions for detailed CFD simulations.
The tool ultimately selected, Dymola/Modelica, best
fulfills the tool requirements, such as connecting
elements to networks, managing a high number of
components without increasing complexity, available
flow and heat libraries and accessibility to source
code. For the simulation Modelica version 2.1 and
Dymola version 5.3a are used.

2

Consideration of the comfort felt by passengers and
crew is of great importance in the design phase of
air-conditioning system for an aircraft. Currently
there are no agreed common standards for thermal
comfort in the aircraft cabin, due to insufficient
knowledge of the interaction of several parameters
such as temperature, air speed and air humidity.
These parameters all influence thermal comfort.
In addition, customers increasingly demand variety
and flexibility of cabin layouts. Special compartments for example crew rest compartments or special

The Modelica Association

customized installations in the cabin, such as coffee
bars, stair-houses and beauty salons, can be installed
at various locations in the aircraft cabin.
In order to obtain a better understanding of the thermal and fluid effects in the whole fuselage a highly
detailed simulation model has been developed by
Airbus, named Overall Fuselage Flow Model
(OFFM).

Model Description

The modeled fuselage consists of all compartments
inside the pressurized fuselage. The model boundaries related to the mass flows are the total air inlet
into the mixer unit and the total air outlet flow of the
fuselage. The temperature boundaries are the air
temperature at the compartments’ air outlets i.e. in
the cabin, flight deck, forward and aft cargo compartment and temperatures for all adjacent, unpressurized compartments, for example main and nose
landing gear, wing box and the skin temperature.

497

Modelica 2005, March 7-8, 2005

B. Oehler

2.1

Description of Aircraft Air-Conditioning
Systems

The environmental control system (ECS) supplies
conditioned air to maintain the desired temperatures,
ventilation rates and pressurization within the cabin
zones and flight deck.

2.2

Conceptual Model Design

The overall fuselage flow model (OFFM) determines
air mass flows, pressures, heat flows, temperatures
and humidity of the entire aircraft fuselage for different ground and flight conditions.
For the one dimensional mass and heat flow calculation, the fuselage volume is divided into individual
control volumes, such as flight deck, cabin, crown,
E/E bay, cargo compartment, etc., see figure 2 and
figure 3.

Figure 1: General Design of Environmental Control
System

The ECS consists of the air-conditioning packs, the
mixer unit, the air distribution/recirculation system
and the pressurization system, including the associated fans. These different systems are shown in figure 1 for the A340-500/600.
The pneumatic system provides hot, pressure regulated bleed air from the engines (or Auxiliary Power
Unit APU or external sources) to the air-conditioning
packs.
Two air-conditioning packs, consisting of heat exchangers, compressor, water extraction and turbine,
located in the unpressurized area below the center
wing box provide conditioned air to the mixer unit.
In the mixer unit, installed under the cabin floor in
front of the center wing box, the conditioned air is
mixed with recirculated and filtered cabin air (extracted out of the cabin at floor level through dado
panels), which is fed by recirculation fans to the
mixer unit.
The air from the mixer unit is distributed to the cabin
temperature control zones (for the A340-500/600
eight cabin areas are defined), the flight deck and
cargo compartments. The independent temperatures
for the different compartments can be achieved by
directing hot trim air from the hot air manifold to the
distribution ducts. In addition ventilation is provided
for the electrical and electronic racks (E/E).
The cabin pressure is regulated automatically by the
outflow valve position depending on the required
cabin pressure change rate and differential pressure
between cabin and ambient.

The Modelica Association

Figure 2: Aircraft Compartments in the Fuselage –
Cross Section Overview

The modules include different thermo-fluid components, which cover the physical/mathematical description for the mass and heat flow within the fuselage.
The fuselage airflows are simulated by calculating
the condition of the air within, and the pressure loss
between these discrete volumes. For the heat flows
all relevant heat sources and sinks, the heat exchange
with adjacent control volumes and enthalpy flows
are considered.
The release of humidity through metabolic processes
is considered depending on the passenger load and in
relation to the outside air flow per occupant provided
to the cabin.
The simulated aircraft model consists of a federation
of aircraft modules and overlaying system modules.
The aircraft modules are divided into fuselage standard modules and layout modules. Fuselage standard
modules consider all aircraft modules, which are
layout-independent. For example the following modules do not differ for one aircraft type with different
system and cabin layouts: crown, triangle area, E/E
bay, bilge, etc.
The cabin area is subject to various layouts such as
different galley/lavatory positions and seat layouts
(first, business and economy class). Nevertheless

498

Modelica 2005, March 7-8, 2005

Modeling and Simulation of Global Thermal and Fluid Effects in an Aircraft Fuselage

several cabin area modules or parameters are layoutindependent such as ceiling air outlets, cabin length,
fuselage diameter, doors and the zone classification.
Consequently the specific layout modules are cabin
installations such as galley, lavatories, seat rows,
staircases and the utilization of the lower deck compartments. The whole or partial volume of the cargo
compartments can be occupied e.g. with crew rest
compartments.
The system modules contain the air supply and air
extraction system, the cabin pressurization system
and several individual fans. An example for the system implementation is given in detail for the air supply system in chapter 5.
The interaction between the system and the aircraft
standard modules or specific layout modules is considered in two different ways; either by port connections or by a value assignment via variable names.
No additional inputs in the system modules by the
user are necessary.
With the aircraft standard modules, layout specific
modules and the system modules a specific aircraft
layout can be built, as shown in figure 3.

input values and boundary conditions for the simulation for different cabin, system and environmental
conditions. The data management of the model in
detail is described in chapter 4.
The simulation model offers the possibility of calculating
isothermal or non-isothermal conditions,
with dry or humid air and
with different flow resistance laws.
For this application only the steady state results are
of interest.
The implementation of the above described system
and compartment modules results in a large and
complex model, so that the model must be modular,
adaptable and user-friendly. It is therefore important
that the developer and the end-users can easily handle the model.
2.3

Library Structure

A special library is developed to establish a model of
the fuselage. It consists of the control volume, the
basic components for flow and heat such as flow and
heat resistances, constant pressure sources/sinks and
the property models for dry and humid air. Derived
from these general basic elements a specific library
section was created containing the aircraft modules.
One of the most important principles for the development of the library was simplicity, comprehensibility and reusability. In this respect the ThermoFluid
[1] library was proofed to be too complicated. Moreover the Modelica_Fluid and Modelica_Media were
not available when starting this project.
The OFFM library contains 6 main packages. Each
package contains sub-packages, as described below.
1. General
-

2. Icons - Icon Definitions
3. Interfaces - Flow and Heat Ports
4. Components

Figure 3: Principle Aircraft Template – Top View

Therefore a template is provided by the model developer containing all fuselage standard modules,
system modules and an User Input Parameter Window (parameter dialog). This aircraft template is the
basis for the user to create a new layout by implementing the layout specific modules and entering the
The Modelica Association

Additional Units,
Functions,
Parameter,
Constant and
General Material Properties.

499

-

-

Control Volume,
Mass Flow Source,
Pressure Source,
Pressure Loss,
Heat Source,
Const. Temperature and
Heat Resistances.

Modelica 2005, March 7-8, 2005

B. Oehler

5. Media – Dry Air and Humid Air
6. Aircraft_Models - contains packages for
each aircraft type with the following subpackages:
-

-

3
3.1

false, depending on whether the energy balance is
used or not. The Modelica implementation is as follows:
———————————————————————————————————————————

…
if (includeEnergyBalance) then
der (H)= FlowPort.H_dot + Heat
Port.Q_dot;
H = if (includeHumidAir) then
humidAir.cp*m*T)
else (dryAir.cp*m*T);
else
der(H) = 0;
T = T_0;
end if;
…

aircraft specific Data (Flow/Heat/Boundary
Conditions),
layout-independent modules (aircraft standard modules and the corresponding assemblies),
aircraft complete (aircraft template) and
layout-dependent modules (Cabin, Lower
Deck and System).

Implementation
of
PhysicalMathematical Description

———————————————————————————————————————————

3.2

Mass and Energy Balances

For the mass balance all internal mass flow sources
and mass flows resulting from the control volumes
differential pressures must be identified. Each control volume contains one definite flow port at which
the sum-to-zero equations for all incoming and outgoing masses are automatically generated, due to the
flow prefix. In the same flow port the enthalpy
flows are determined correspondingly.
Additionally each control volume contains one definite heat port, where all heat flows resulting from
internal heat sources and all heat flows transferred
across the borders of the control volume are summated.
In the control volume the average value of pressure
and temperature is calculated by solving the mass
and energy balances, as depicted in figure 4 (the
equations in the control volume are completed by
humidity here not shown).

The pressure loss between the control volumes is
described by the following equation:
& + k2 ⋅ m
& ⋅m
& ,
∆p = k1 ⋅ m

(3.1)

k1 = Linear Flow Coefficient,
k2 = Quadratic Flow Coefficient.
k1 and k2 are calculated values based on flight test
evaluation.
For the calculation of the mass flow the following
equation is implemented:
with

2


Thermo
 
& = fdir ⋅  1  ⋅ − k1 ⋅ RootFct.  k1  + k 2 ⋅ ∆p 
m
k   2

2
 2 


(3.2)
with fdir as an indicator of the flow direction, it
can reach the value 1 for design flow and –1
reversal flow,
the thermo root function from the free
library ThermoFluid [1], with a linear interpolation near 0.
The scale of the parameters is given in the following:
The flow resistance values varies between 102-105
Pas2/kg2 depending on there location, whereas the
pressure difference between the control volumes is in
a range of 0.1 Pa up to 10 Pa which results to mass
flows from 0.001 kg/s up to 0.01 kg/s.
The leakage flow from aircraft fuselage to ambient is
calculated by the pressure vessel equation:

Figure 4: Mass and Energy Balances

The models are developed in such a way that it is
possible to run a simulation under isothermal or nonisothermal conditions. The variable includeEnergyBalance is Boolean and can be set to true or

The Modelica Association

Pressure Loss

500

.

mij = A eff ⋅

2pi2
⋅
R ⋅ Ti

2/ κ
( κ +1) / κ 
 pj 
κ  p j 

 
 
−
p 
κ − 1  pi 

i 




(3.3)

Modelica 2005, March 7-8, 2005

Modeling and Simulation of Global Thermal and Fluid Effects in an Aircraft Fuselage

Fluid Properties

In the following section the calculation principle of
the fluid properties for dry and humid air is described. The package Media contains the following
classes separated for dry and humid air:
- Declaration and initialization of the fluid property
variables such as specific enthalpy, thermal conductivity, dynamic viscosity, gas constant and
specific heat capacity in a record and
- a block containing inputs and outputs and an
equation part. The input of the block for dry air is
the temperature and for humid air additionally the
pressure and water content. The outputs are the
property values. The equation part contains the
empirical correlation based on [2] to calculate the
fluid properties as a function of inputs.
The block class is used instead of a function in
order to avoid differentiation of functions.
In the following paragraphs the interaction of the
above referenced block and record class is described for dry air. Each model, where the fluid
properties are needed, contains an instance of the
record and block in the declaration part in the following way:
———————————————————————————————————————————

OFFM.Media.Dry_Air.DryAirProp
Dry_air(T=T);
OFFM.Media.Dry_Air.DryAirRec dryAir=
DryAir.DryAirRec;
———————————————————————————————————————————

In the block class DryAir the values of the fluid
property variables are calculated, depending on the
temperature and are written to the record dryAir.
For humid air the fluid properties are calculated in
the same way, but as a mixture of two ideal gases, air
and water vapor.
The equations, which must be considered in a descriptive physical-mathematical model, for example
in the flow resistance model, are the following:

For the inputs of the block class the upstream values are used.
The variable includeHumidAir is Boolean and
can be set to true or false, depending on whether dry
or humid air is called for. The fluid properties are
called up from the corresponding record by means of
an if-expression, as shown in the following:
———————————————————————————————————————————

cp = if (includeHumidAir) then
(humidAir.cp) else (dryAir.cp);
———————————————————————————————————————————

Additionally for the calculation of humid air the
equations for the water content of saturated air and
for the pressure of saturated water vapor in air are
relevant (Antoine Equation). The pressure of saturated water vapor in air is described by two different
equations, one for the vaporization and the other for
sublimation. At a temperature of ϑ=0.01°C [3] solid,
liquid, and vapor phases of water coexist in equilibrium and a discontinuity occurs between these two
curves. To establish a continuous function for the
pressure of saturated water vapor in air the curve for
vaporization is extended up to a temperature of
ϑ=0.0045°C and the curve for sublimation is only
valid up to this point.
The following approaches are used for improvement
and to avoid numerical problems:
1. The Horner Scheme is applied to the polynomial for the fluid properties calculation.
This has the advantage that in the converted
representation no exponentials are used, only
multiplications and summations.
2. if-expression is used in preference to ifclause for conditional statements.

4

Data Management

The data is divided into internal parameters and user
inputs, as shown in figure 5.

———————————————————————————————————————————

Internal Parameter

…
OFFM.Media.HumidAir.HumidAirProp
HumidAir(T=T,x=
if (includeHumidAir) then
x
else 0,p=p_upstream);
OFFM.Media.HumidAir.HumidAirRec
humidair=HumidAir.HumidAirRec;
OFFM.Media.DryAir.DryAirProp
DryAir(T=T);
OFFM.Media.DryAir.DryAirRec dryair=
DryAir.DryAirRec;
…

Fluid / Material
Properties
• Geometry Data
• Flow Resistance Values
• ...

User Input

•

--------- GUI ---------

Flight Condition
• System. Operating
Cond.
• Simulation Cond.
• ...
•

Simulation
Model

Model Output

3.3

------ Results ------

Temperature
Pressure
Mass/Heat Flows
• Humidity
•
•
•

Figure 5: Input and Output Parameters

———————————————————————————————————————————

The Modelica Association

501

Modelica 2005, March 7-8, 2005

B. Oehler

&
Q
rad,energy = ω ⋅ G 0 ⋅ A proj

with

G0 = f (altitude ) ,
A proj =

1 ϕ2
∫ r (ϕ)dϕ ⋅ A s .
∆Φ ϕ1

The Modelica Association

(4.1)
(4.2)
(4.3)

The surface area, which can be calculated for the
aircraft
skin,
is
A s = 21 ⋅ D ⋅ L ⋅ ∆Φ ,
with
∆Φ = ϕ 2 − ϕ1 . For r(ϕ) two different functions are

defined for the shady (1) and sunny (2) side of the
fuselage, depending on the polar coordinate and irradiation angle.
(1) For ϕ > (β+90°) and ϕ < (β-90°)

r(ϕ)= 0.

(2) For (β-90°) ≤ j ≤ (β+90°)

r(ϕ)=cos(β-ϕ).

ϕ
Ma
x

G0

5°
β=5

Crown

G=
G

The first section in this chapter will discuss the data
management of the internal parameters and is followed by the user inputs. The model outputs are not
further discussed.
Internal Parameters: The internal parameters are
classified into parameters, which are valid in general
or only for a specific aircraft type. General parameters are e.g. the fluid and material properties and are
structured in the library in the package General (see
section 2.3). Specific aircraft type data are for example geometry data and flow resistance values and are
contained in the package Aircraft Specific Data. All
these data are stored in a record.
In addition the aircraft environmental parameters,
such as ambient pressure, temperature, humidity or
the external heat transfer coefficient, as well as the
boundary temperatures, such as the skin temperature
or the temperature of the unpressurized compartments, belong to the internal parameters. All of them
are functions and mostly depend on the flight condition, for example on Mach number and altitude.
The calculation of the aircraft skin temperature depending on the absorbed solar radiation and hence on
the location of the fuselage surface is described here.
There are six skin temperatures, three for the upper
fuselage (crown, cabin left side and right side) and
three for the lower fuselage (bilge, triangle area left
side and right side) whereby the calculation distinguishes between ground and flight condition. Depending on the angle β of solar radiation the absorbed radiative heat on the aircraft skin is a function
of the polar coordinate ϕ. The direct sunbeams irradiate one half of the skin surface of the fuselage, the
other half is irradiated by diffuse sunbeams. The diffuse radiation can be neglected. In figure 6 the absorbed radiative heat by solar radiation collected per
projected surface area is shown. This radiative energy curve is a cosine function, which is at its maximum where it meets the irradiation angle and its
minimum at the point where the solar radiation contacts the aircraft skin tangential. In case of a cloudy
day solar radiation energy is attenuated by clouds.
This is taken into consideration by the factor
ω, below altitudes of 22000ft. The average radiative
energy G for each area can be depicted (see figure
6) and determined by following equations:

Area between Aircraft
Skin and Lining - GAP

GGAP

Triangle Area

G=0
Bilge

Figure 6: Aircraft Skin Temperature

The implementation in Modelica is difficult, because
the integral is not varying with time but with the polar coordinate ϕ. So, for each range the integral is
solved manually depending on the angle of solar radiation.
User Inputs: The parameter input of the user takes
place in the parameter dialog, as shown in figure 7. It
is contained in the aircraft template. The content of
the parameter dialog is stored in a record. The
statements in Modelica are set by dialogannotations and can be found in [4].

Figure 7: Parameter Dialog for User Inputs

User inputs are all operating conditions such as flight
conditions, environmental control conditions and the
simulation conditions, where the user has the possibility to choose whether the simulation shall run under isothermal or non-isothermal conditions and with
or without the consideration of humidity.

502

Modelica 2005, March 7-8, 2005

Modeling and Simulation of Global Thermal and Fluid Effects in an Aircraft Fuselage

In the parameter dialog the user has different possibilities to make his inputs. For example for the tab
Flight Conditions, the user can choose, whether he
wants to specify the ISA day or the temperature as an
input. Depending on the setting of the parameter
ISA, the corresponding input field is enabled.
It is also possible to enter a value directly in a field.
To avoid errors, these input values are checked for
example against minimum and maximum values.
Another possibility consists in the selection of an
input in the context menu from a set of predefined
values or replaceable models. For this a pull down
menu is available. Figure 7 shows replaceable models for the solar constant, which is a function of altitude and depends on the different climatic zones.
The user can choose whether the calculation shall
run with a solar constant for tropic, temperate or for
north temperatures.
The default values are predefined values for a cruise
flight under normal operation conditions, with the
maximum number of passengers and non-isothermal
simulation conditions.

5

System Implementation

The different aircraft systems as mentioned in chapter 2.1 are implemented in the aircraft template. It is
arranged in such a way that only those system modules are visible, where the user is required to give
inputs. As an example the air supply system is chosen. Figure 8 depicts the air supply system for the
A340-500/600, which consists of the mixer and the
cabin air supply calibration module.

be set in the parameter dialog (tab Environmental
Control System).
The air supply system supplies the air to the cabin
along the whole length of each zone by four air outlets per two frame bays. On the right and left hand
side of the aircraft fuselage one ceiling air outlet and
one lateral air outlet position are defined, see figure
9. The ceiling outlets are not affected by any installations in the cabin; however the number and position
of the lateral outlets depends on the cabin interior
layout.

Figure 9: General Ventilation in the Cabin Cross Section Overview

Depending on a customer layout the simulation
model will be established by dragging and dropping
the layout specific modules from the library into the
aircraft template. The installations in the forward/aft
cargo areas must be connected to the mixer unit. If a
port of the mixer unit is unconnected e.g. the Lower
Deck Facility (LDF) port, this means that the LDF is
not installed in the cargo compartment by the user.
If a port of the mixer module is not connected the
mass flow in the flow resistance model of the mixer
unit shall be considered to be zero. To achieve a zero
mass flow the variables at the not connected port of
the mixer unit must have the same values as the variables at the port from the mixer control volume.
The modeling of such a condition in Modelica reveals to be difficult, and a complex solution has been
chosen as presented hereafter.
The DeadEndPipe, see figure 10, represents a
pressure source with the following Modelica
code.

Figure 8: Air Supply System

The recirculation mass flow and the outside supply
mass flow [depending on the source - ram air, APU
or Engine (Pack Flow)] are input mass flows to determine over the flow resistance values the mass
flows into the cabin, flight deck and forward/aft
cargo compartments. The flow resistance values can

The Modelica Association

503

Figure 10: Unconnected Port

Modelica 2005, March 7-8, 2005

B. Oehler

———————————————————————————————————————————

need to be considered. In a first step the number of
air outlets is not considered so that the supply mass
flow per seat row is assumed to be constant.
The determined total supply mass flow for each area
is written in an array, in the air supply system model,
as follows:

model DeadEndPipe
extends OFFM.Icons.Flow.DeadEndPipe;
import SI = Modelica.SIunits;
SI.Pressure p;
SI.Temperature T;
SI.MassFraction x;
parameter Boolean asSource=false;
equation
if asSource then
a.T = T;
a.p = p;
a.x = x;
else
a.H_dot =0;
a.m_dot =0;
a.m_dot_x=0;
end if;
end DeadEndPipe;

Then the mass flow per seat row can be calculated as
follows:

———————————————————————————————————————————

———————————————————————————————————————————

———————————————————————————————————————————

inner Real m_dot_supply[8]=
{m_dot[area1],
m_dot[area2], …, m_dot[area8]};
———————————————————————————————————————————

The number of connections of the flow port X is
checked in the DeadEndPipe model by the following
class parameter statement: DeadEndPipe1 (as
Source=cardinality(PortX==1). If there is no
additional connection at the flow port X, the temperature T, pressure p and the water content x of the
DeadEndPipe model are set to the values from the
flow port a of the flow resistance model. From there
they will be transmitted to the flow port b of the flow
resistance model.
The cabin area is established with the specific cabin
layout modules, such as galleys, lavatories, seat rows
and special crew rest compartments. The individual
supply mass flows for each cabin area is assigned by
variables and not by a graphical connection. The reasons for that are the high number of connections, that
have to be done by the end-user and the calculation
of the mass flow supplied to each seat row as part of
the total supplied airflow for one area. Each seat row
module contains a specific number of air outlets,
which varies from layout to layout, so the total number of air outlets in one area is depending on the
number of installed seat rows within this area. The
interface from the air supply system to the cabin is
shown in figure 11.

Figure 11: Interface to Cabin (I)

The implementation in Modelica proves to be quite
complicated. For calculation of the total supply mass
flow to an area, the number of seat rows in this area
The Modelica Association

model SeatRow
outer Real m_dot_supply [8];
outer Integer no_SeatRow[8];
parameter Integer area;
Real m_dot;
equation
m_dot=m_dot_supply[area]/
no_SeatRow[area],
end SeatRow;
The mass flow m_dot must be divided and forwarded to the
two internal mass flow sources in one seat row.
———————————————————————————————————————————

The number of seat rows per area is currently an user
input parameter in the main parameter dialog. After
establishing the layout, the user must manually count
the seat rows per area and the resulting number must
be set in the parameter dialog. This can easily lead to
the error that the entered numbers and the numbers
of inserted seat rows are not equal. At the moment
there is no possibility known how to count models
with the same attribute, e.g. the seat rows in one
area.
In order to identify the area in which a seat row is
positioned, the seat row module receives the attribute
Area, e.g. a seat row in area 2: Area=2. This parameter must be entered by the user in a parameter
dialog, which appears by double-clicking on the
component SeatRow. An improvement for the user
is the graphical position in the diagram layer, defined
by a component, which can be used to set parameters. So the parameter Area could be set automatically to one, two etc. if the seat row is in a defined
position range on the diagram layer.
If in the second step additionally the number of air
outlets shall be considered it is necessary to enter the
total number of air outlets per area in the parameter
dialog and additional the numbers of the individual
air outlets in each seat row (double clicking on the
component SeatRow).

504

Modelica 2005, March 7-8, 2005

Modeling and Simulation of Global Thermal and Fluid Effects in an Aircraft Fuselage

The mass flow per air outlet for all seat rows in one
area then can be calculated in the supply system
model:

6
6.1

Model Application
Typical Application Procedure

———————————————————————————————————————————

m_dot_perAirOutlet=m_dot_supply[area]/
no_SeatRow[area]/no_AirOutlets;
———————————————————————————————————————————

The mass flow for each seat row can then be determined by the multiplication of the mass flow per air
outlet and the number of air outlets of each seat row.
Up to now it is insufficiently solved, how to forward
the parameter no_AirOutlets from the Seat
Row to the air supply system. The problem is that
the parameter must accessed by dot-notation – ComponentName.Parameter. The automatically given
component name, by dragging it into the model, is
not known, alternatively if the user enters a given
component name and the programmer links all, errors may occur when translating the model, if a
component name of a seat row is used, where no seat
row is installed, for example if a toilet or galley is
inserted instead of a seat row. An ideal solution
would be if Modelica language provides the possibility to access parameters or variables by a wild card
as “class name.*.parameter/variable”.
Currently the found solution consists in additional
modules which are implemented into the aircraft
template - in this way the name of the new module is
known - where the number of air outlets and the calculation of the mass flow for each seat row will be
done. For the user this results in an additional expense of establishing connections. The additional
modules are shown in figure 12.

The package Aircraft Model is the basis for the
user. It contains for each aircraft type a specific library and the corresponding aircraft template, see
figure 13. For the user only the layout specific components and the aircraft templates are of interest. For
investigation of a new aircraft layout the user can
select the template of the desired aircraft type out of
the library.
The layout specific components need to be implemented into the aircraft template by the user, corresponding to a specific customer layout. For each
dropped layout specific module in the cabin area the
user has to set the following parameters: Area, in
which the module is located, number of passengers
in the module and the number of air outlets. The layout dependent connections to the standard fuselage
modules, the connections between the layout specific
modules and the connections to the system modules
need to be established.

Figure 13: Aircraft Template with Cabin Layout
Modules

Afterwards the main parameter dialog has to be filled
out and the system configuration has to be entered
and checked. Therefore the user has to work very
carefully und systematically so that no inputs will be
forgotten.
If this procedure has been done the user can check
the model and run a simulation. The post processing
is done in Matlab.
6.2
Figure 12: Interface to Cabin (II)

Improvement Potential

The capability of the tool Dymola/Modelica to simulate even complex systems is given. In section 4 and
5 some examples for improvement are already given.
In general there are the following suggestions for
improvements based on the experience gained by
developing this model.

The Modelica Association

505

Modelica 2005, March 7-8, 2005

B. Oehler

1) Read Only
In this application case a large number of packages
and sub-packages in the library shall be protected
against changes by the users. They shall not be hidden in order to allow transparency and completeness,
so ideally it would be possible to declare parts of the
code as ‘read only’.
2) Auto Connect
Another point is the number of connections that have
to be done by the end-user. For each seat row the
user has to make several connections. The possibility
of auto connecting would make sense. An idea was
to insert a new variable AutoConnect and the demand to specify each seat row with a predefined
name. All connection statements are now written in
the source code, inside an if-clause, which shall be
valid if the AutoConnect is set to true. This approach
is only possible if all seat rows are inserted, for
which the connect statements are defined. Even if
in one case instead of a seat row, a toilet/galley combination is inserted, and although the AutoConnect is
set to false, when translating the model an error message appears. The reason for that is, that the compiler
recognizes the connect statement in the if-clause.
3) Check-Possibility
Finally the need for a check-possibility shall be
pointed out. There are several cases, where the user
is required to give input values in the parameter dialog e.g. for the calculation of the supplied mass flow
the parameter total no_ofPassengers is needed.
Also when dragging a seat row in the aircraft template, for each seat row the number of passengers to
consider the heat dissipation. There is at the moment
no possibility to check at the end, if the values of
total number of passengers (parameter dialog) is
identical to the sum of passenger declared for each
seat row by the user.
6.3

Model Numerical Characteristics

Since the Dassl-Solver seems not to be able to solve
such a system, first attempts were made with the
RadauIIa-Solver out of Godess (Generic Ordinary
Differential Equation Solver System), which is leading to an improvement.

7

A short overview of the aircraft systems and the concept of the model and its library are given in this paper.
The emphasis of this paper is to demonstrate the
challenges of providing a complex, user-friendly
simulation model and potential solutions.
The additional requirement of providing a template
to an end-user for his applications causes problems
as described in section 6.2. The difficulty appears
due to the fact, that the programmer does not know,
which kind of library component the end-user needs
at which place in the provided template and that the
activities of the end-user shall be reduced to a minimum.
The development of the library and the models is an
on-going process. It is planned to extend the library
to consider effects for advanced modeling, such as
the consideration of a human body with environment
dependent heat release rather then as a constant heat
source or the consideration of radiation from surfaces.
One of the next steps of modeling is to establish the
complete aircraft based on a customer layout. Up to
now there are several components and partial fuselage models, which have been verified. The whole
development of the aircraft simulation model is subject of the validation and verification process.

References

Several models of the aircraft fuselage with a different level of discretization have been established, to
run simulations using the Dassl-Solver. The least
coarse level of discretization without occurring numerical problems was the discretization of the cabin
in its eight areas.
The first approach for a more detailed discretization
was a cross section of the fuselage over two seat
rows. Depending on the simulation time this results
to numerical oscillations or it is not possible to reach
steady state results. One of the reasons is that the
system is stiff, due to the large difference between
time constants.

The Modelica Association

Conclusions & Future Work

506

[1]

[2]
[3]
[4]

Tummescheit H., Eborn J:
ThermoFluid Modelica Library
http://www.control.lth.se/hubertus/
~ThermoFluid, 2001
Verein Deutscher Ingenieure: VDI
Wärmeatlas. VDI-Verlag, Düsseldorf,
7th Edition, 1994
Baehr, H.D.: Thermodynamik. 11th
Edition, Springer Verlag, Berlin, 2004
Modelica Language Specification,
Version 2.1, http://www.modelica.org

Modelica 2005, March 7-8, 2005

Session 6c
Modelica Language

The Modelica Association

507

Modelica 2005, March 7-8, 2005

The Modelica Association

508

Modelica 2005, March 7-8, 2005

Modelica Instance Creation

Modelica Instance Creation
Jakob Mauss
jakob.mauss@dcx.com

DaimlerChrysler Research & Technology
Alt-Moabit 96a, 10559 Berlin, Germany

Abstract
This paper is about instance creation in Modelica.
Despite the conceptual simplicity of Modelica's object-oriented framework, instance creation in Modelica requires surprisingly complicated procedures.
Hence, it takes considerable effort to develop a
Modelica processor for extracting all variables, equations and algorithms from a given Modelica class.
This paper is meant to reduce this effort by presenting key representations and algorithms for instance
creation. To ease reading and verification, instance
creation is developed for a fragment of Modelica,
called SimpleModelica. Building on the representations and procedures given here, the implementation
of instance creation (flattening) for full Modelica
should be straightforward. However, that ultimate
procedure is not given here, since it is loaded with
technical details, described in the (100 pages) Modelica language specification.

1

class Ele1000 = Ele(Resistor.r=1000);
class Ele
class Resistor
Real r = 1;
end Resistor;
class Circuit
Resistor r1;
Ele.Resistor r2;
end Circuit;
end Ele;

These class definitions will be used throughout the
paper as illustrating example.

SimpleModelica

2

The syntax of SimpleModelica is defined as follows

Representations

The procedure for instance creation operates on data
structures as defined by the UML diagram shown in
Fig 1. An instance of the shown classes is called
term here, while an instance of a Modelica class is
simply called instance.

class_definition : [ encapsulated ] class IDENT class_specifier
class_specifier : { element ";" } end IDENT |
"=" name [ class_modification ]
element : import_clause | extends_clause |
class_definition | component_declaration
import_clause : import ( IDENT "=" name | name ["." "*"] )
extends_clause : extends name [ class_modification ]
component_declaration : name IDENT [ modification ]
modification : class_modification [ "=" expression ] | "=" expression
class_modification : "(" [ argument { "," argument } ] ")"
argument : element_modification | element_redeclaration
element_modification : name [ modification ]
element_redeclaration : redeclare
(class_definition | component_declaration)
expression : NUMBER | STRING | true | false | name
name : IDENT [ "." name ]

2.1

As usual, [x] stands for zero or one, and {x} for zero
or more occurences of x, while | denotes alternatives.

The Modelica Association

SimpleModelica is a proper subset of Modelica.
Omissions w.r.t. Modelica are: arrays, most prefixes,
equation and algorithm section, class categories, expressions involving functions, comments, and annotations. An example of SimpleModelica is

Abstract syntax tree

A Modelica parser may use the classes shown in
double-framed boxes to create an abstract syntax tree
(AST) from a given SimpleModelica class definition.
Fig 2 shows the AST that such a parser creates for
the class definitions Ele and Ele1000 given above.
In the algorithm for instance creation, the Modelica
class tree is represented by the constant ROOT, which
is a ClassDefinition with no id and no parent that
contains all top-level class definitions (typically
packages).

509

Modelica 2005, March 7-8, 2005

J. Mauss

Moreover, the constant GLOBAL is a ClassDefinition
with no id and no parent that contains following
built-in ClassDefinitions

ClassDefinition Ele1000

mod

(1) primitive types RealType, IntegerType, StringType, BooleanType, e.g.

elements

?
1
Instance
String id host

1

QRef

1
mod

Element

Modification

redeclarations

∗

∗

Named
Element
String id

mod

modifications

?

?

Element
Modification

?

Component
Declaration

1

1
?
∗

type

Class

def

elements

ref

type

Extends
parent

Class
Definition

IClass
imports

points to super class
points to field with
exactly one value
0 or 1 value
0 or more values

∗

Import
String id

name

C

class: instance is a term

C

abstract class: no instance

C

class for representing AST

Fig 1: Classes used to implement instance creation

The Modelica Association

value

Expression 1000

type

Modification

Reference Real
value

Expression 1

elements

Component
Declaration r1

type

Component
Declaration r2

type

Reference Resistor

Reference Ele
next
Reference Resistor

Reference
String id

ref

Component
Declaration r
mod

elements

Component

∗

Modification

ClassDefinition Circuit

Expression

next

Reference r

ClassDefinition Resistor

class Real
RealType value;//accessed without dot-notation
StringType unit;
RealType min;
RealType max;
end Real;

parts

next

ref

ClassDefinition Ele

(2) predefined types defined using these primitive
types, e.g.

?

Reference Resistor

Modification

mod

value

Reference Ele

Element
Modification

class RealType
end RealType;
class StringType
end StringType;

∗

type

Extends

Fig 2: AST for classes Ele1000 and Ele

2.2

Implicit classes: IClass

An implicit class is a class that has no explicit definition in the Modelica class tree. In the example above,
class Ele1000.Circuit is implicit, because the AST of
Ele1000 does not contain a ClassDefinition named
Circuit. Class Circuit is only inherited to Ele1000
through its base class Ele. Nevertheless, class
Ele1000.Circuit can be instantiated, and the resulting
instance differs from the result of instantiating class
Ele.Circuit: Ele1000.Circuit.r1.r = 1000 while
Ele.Circuit.r1.r = 1.
In other words: Ele1000.Circuit and Ele.Circuit are
two different classes. In general, a class A may modify its base classes, which may modify all elements
inherited by A from these base classes, including
inherited classes.
To deal with implicit classes, a Modelica class is
represented here by a tuple <ClassDefinition def,
Modification mod, Class parent>, see Class in Fig 1.
A ClassDefinition def from the Modelica class tree is
complemented with a Modification mod that modifies this definition and a parent class that overrides
the definition's parent. Subclasses of Class are
ClassDefinition (for which mod is always null, and
def refers to the ClassDefinition itself) to represent
classes from the Modelica class tree, and IClass to
represent implicit classes. The example Modelica
classes are hence represented by the following terms

510

Modelica 2005, March 7-8, 2005

Modelica Instance Creation

Qualified references: QRef

Modelica supports a use before declare policy for the
components of a class. Moreover, there may be cyclic dependencies between components: to instantiate component a, we may need access to component
b, and vice versa. This raises the question what kind
of object the lookup of a component reference should
return during instance creation. The referenced component (an instance) may not yet exist. To cope with
this, we decide that lookup of a component may also
return a pair <host, ref> where host is an Instance,
and ref is a Reference, such that ref.id is the id of an
instance in host.parts. This pair is called qualified
reference, QRef for short. A QRef asserts that the
host contains - or will contain - the referenced instance, and it represents this referenced instance. The
host may still be under construction at the time the
QRef is created, i.e. may not yet actually contain the
referenced instance. Using QRefs, we can represent
an instance before it actually exists. In contrast to a
Reference, the meaning of a QRef does not depend
on its context, but only on the host. This is why
QRef s are called 'qualified'.
2.4

2.5

The objective of instance creation is to derive an object - called instance - that contains all inherited and
locally declared components of a given Modelica
class, with all occurring modifications applied. Fig 3
shows an instance of class Ele1000.Circuit.
Instance
Instance r1
Instance r

value

Expression 1000

Instance min
Instance max
Instance unit
Instance r2
Instance r

value

Expression 1

Instance min

Qualified and unqualified modifications

Instance max
Instance unit

A Modification is called qualified, if all its References have been replaced by QRefs. A qualified
modification does not depend on its context, because
all references have been looked up in some scope. In
other words, the meaning of an unqualified modification depends on its context, while the meaning of a
qualified modification does not.
ComponentDeclaration and Extends have unqualified modifications, while the modification of IClass
is qualified or null, and the modification of ClassDefinition is always null. Example
class P
class Ele2000 =Ele(Resistor.r=r2k);
Real r2k(unit="Ohm")=2000;
end P

The extends clause "=Ele(Resistor.r=r2k)" of
the short class definition Ele2000 is not qualified, i.e.
The Modelica Association

Instances

parts

2.3

parts

A ClassDefinition is created by the Modelica parser,
while an IClass is created by the procedure for class
name lookup during instance creation.

the Modelica parser returns an Extends that contains
the Reference "r2k".
The same holds for Modifications occurring in component declarations, such as (unit="Ohm")=2000.
In contrast, the Class returned by class lookup of
P.Ele2000.Resistor is an IClass with parent
P.Ele2000 and with the qualified modification
(r = QRef(host = x, ref = "r2k")), where x is an instance of class P. Recall that a short class definition
such as P.Ele2000 does not define its own scope, and
hence "r2k" has to be looked up in the scope of P.

parts

def, mod, parent
Ele, null, ROOT
Ele.Resistor, null, Ele
Ele.Circuit, null, Ele
Ele1000, null, ROOT
Ele.Resistor, (r =1000), Ele1000
Ele.Circuit, null, Ele1000

parts

term is a
ClassDef.
ClassDef.
ClassDef.
ClassDef.
IClass
IClass

parts

Modelica class
Ele
Ele.Resistor
Ele.Circuit
Ele1000
Ele1000.Resistor
Ele1000.Circuit

Fig 3: Instance of Modelica class Ele1000.Circuit

3

Algorithm for Instance Creation

Informally, instance creation as implemented below
proceeds as follows
• take the term representing the class to be instantiated, e.g. class definition Ele.Circuit
shown in Fig 2,
• replace each extends clause found in the class
by the parts of an instance of the specified base
class,
• replace each component declaration found in
the class by an instance of the component type.
• The term resulting from all these replacements
is called instance, see e.g. Fig 3.

511

Modelica 2005, March 7-8, 2005

J. Mauss

In this context, a key algorithm is the procedure to
lookup (resolve) a reference such as 'Resistor'.
Lookup retrieves or computes the referenced component (a named instance) or class.
3.1

Name lookup

The following two procedures show how lookup
works in principle, roughly on the level of detail as
in the Modelica specification [1]. However, the procedure for instance creation given in section 3.2 uses
an extended version, that (1) collects and merges
class modifications encountered during lookup to
support implicit classes (IClass) and (2) returns a
Component (QRef) instead of a ComponentDeclaration, in case the reference refers to a component. Unfortunately, these extensions make the code for
lookup less easy to understand. Therefore we also
present a simplified version of name lookup here.
lookupName(Class c, Reference ref, Boolean
isFirst) → NamedElement
1. x ← lookupIdent(c, ref.id)
2. if (x = null and isFirst)
3.
x ← import(c.def, ref.id)
4. end if
5. if (x ≠ null)
6.
if (ref.next = null) return x
7.
else if (x isa Class)
8.
return lookupName(x, ref.next, false)
9.
else
10.
assert x isa ComponentDeclaration
11.
xc ← the ClassDefinition that contains x
12.
type ← lookupName(xc, x.type, true)
13.
return lookupName(type, ref.next, false)
14. end if
15. else if (isFirst)
16.
if (c.def is encapsulated or c = ROOT)
17.
return lookupName(GLOBAL, ref, true)
18.
else if (c.parent ≠ null)
19.
return lookupName(c.parent, ref, true)
20.
end if
21. end if
22. error "ref not found"

This procedure looks up the given reference in the
scope of the given class, and either returns the first
named element (class definition or component declaration) found, or signals a "ref not found" error.
The procedure searches the sequence of parents, until
an encapsulated class or the unnamed root class of
the Modelica class tree is reached. In both cases,
search is continued (line 17) in the global scope that
contains the predefined elements, such as Real,
String, and time. Only the first identifier (as indicated by the isFirst argument) of a name is looked up
using the import clauses of the class, see lines 2, 3, 4.
The Modelica Association

E.g. when looking up reference A.B in the scope of
class C, then A may be imported by C, but import
clauses of A are ignored when looking for B in the
scope of A in line 8.
lookupIdent(Class c, String id) → NamedElement
1. if (c.def.elements contains
2.
a NamedElement e with e.id = id)
3.
return e
4. else
5.
for each Extends ext in c.def.elements
6.
if (ext.type.id = id) return null
7.
end if
8.
base ← lookupName(c, ext.type, true)
9.
e ← lookupIdent(base, id)
10.
if (e ≠ null) return e
11.
end if
12. end for
13. return null
14. end if

Searches class c and its base classes for a named element with the given id. If id names a local or inherited named element of c, returns that element, returns
null otherwise. This search does neither use imports
nor parent classes. A tricky part of the algorithm is
the test in line 6, which terminates a circular attempt
to lookup a base class of c.
3.2

Instance creation for SimpleModelica

This section presents a set of procedures that implement instance creation for SimpleModelica.
instantiate(Reference name) → Instance
1. c ← lookupClass(ROOT, name, null)
2. ic ← elaborate(c, new Instance())
3. ic ← replaceQRefs(ic)
4. ic ← removeDuplicates(ic)
5. return ic

This procedure instantiates the given class and returns the resulting instance. The class is specified by
name. This way, also an implicit class (such as
Ele1000.Circuit) can be instantiated. In line 1., the
class name is looked up in the scope of the unnamed
root of the Modelica class tree. In line 2., the entire
instance tree is created. However, component references occurring in modifications are replaced by
QRefs, not by the referenced instances, see section
2.3. In line 3., ic is the root of the completed instance
tree. All referenced instances should have been created by then. Consequently, all QRefs can now be
replaced by the referenced instances. In line 4., duplicate instances added through multiple inheritance
are removed from the instance.

512

Modelica 2005, March 7-8, 2005

Modelica Instance Creation

elaborate(Class c, Instance host) → Instance
1. for each Extends ext in c.def.elements
2.
base ← getClass(c, ext, c.mod, host)
3.
host ← elaborate(base, host)
4. end for
5. for each ComponentDeclaration decl
6. in c.def.elements
7.
if (redeclare(c.mod, decl.id) ≠ null)
8.
decl ← redeclare(c.mod, decl.id)
9.
end if
10. qmod ← select(c.mod, decl.id)
11. type ← getClass(c, decl, qmod, host)
12. comp ← elaborate(type, new Instance())
13. comp.id ← decl.id
14. add comp to host.parts
15. end for
16. host.value ← c.mod.value
17. return host

Look for the given class name in the scope of class c.
The host is either null, or an elaborated instance of c.
The given host may be under construction, i.e. not
yet completely elaborated. If lookup should require
to instantiate c (e.g. to access a component of c that
occurs in a modification, see r2k in the example in
section 2.4) the host, if given, is used. Otherwise, c is
elaborated on demand.

This procedure adds for each inherited or locally declared component of the given class c an elaborated
instance to the given host. In an elaborated instance,
each component reference is represented by a QRef
(see section 2.3), but not yet by the referenced instance. During elaboration, modifications are merged
in the correct order. Redeclaration of a component is
processed in lines 7 - 9.
getClass(Class c, Element e, Modification qm,
Instance host) → Class
1. type ← lookupClass(c, e.type, host)
2. qmod ← qualify(c, e.mod, host)
3. qmod ← merge(qm, qmod)
4. return createClass(type, qmod)

This auxilliary procedure returns a base class (if e is
an Extends) or component type (if e is a ComponentDeclaration) used during elaboration or lookup.
createClass(Class c, Modification qmod) → Class
1. qmod ← merge(qmod, c.mod)
2. if (qmod = c.mod) return c
3. else return new IClass(c.def, qmod, c.parent)
4. end if

This auxilliary procedure merges the qualified modification of the given class with the given qualified
modification qmod, where elements of qmod override elements of c.mod. Returns either the given
class (e.g. if qmod = null), or a new IClass (see 2.2).
lookupClass(Class c, Reference name, Instance
host) → Class
1. x ← lookup(c, name, true, host)
2. if (x isa Class) return x
3. else error "not a class"
4. end if

The Modelica Association

lookup(Class c, Reference ref, Boolean isFirst,
Instance host) → Class or Component
1. x ← lookup(c, ref.id, host)
2. if (x = null and isFirst)
3.
x ← import(c.def, ref.id)
4. end if
5. if (x ≠ null)
6.
if (ref.next = null) return x
7.
else if (x isa Class)
8.
return lookup(x, ref.next, false, null)
9.
else
10.
assert x isa QRef
11.
return new QRef(x.host, ref)
12. end if
13. else if (isFirst)
14.
if (c.def is encapsulated or c = ROOT)
15.
return lookup(GLOBAL, ref, true, null)
16.
else if (c.parent ≠ null)
17.
return lookup(c.parent, ref, true, null)
18.
end if
19. end if
20. error "ref not found"

Similar to procedure lookupName, defined in section
3.1. However, if ref names a component, the component is returned (as QRef), not its declaration.
Again, if isFirst is false, then only locally declared or
inherited elements are found, i.e. import clauses, the
parent of c as well as the global scope are ignored.
The next procedure looks up in class c for a local,
inherited or redeclared class or component with the
given id. Returns null, if no such class or component
is found. This does not use imports or c's parent. If id
names a component, the component is returned (represented by a QRef), and not (like procedure lookupIdent defined in section 3.1) the corresponding
component declaration.
Lines 5 and 25 handle the case that id names a class
that is redeclared by the qualified modification
c.mod. If id names a component which is redeclared
by c.mod, this redeclaration is either treated during
elaboration of c in line 11, or in lines 19-20 in case
the component is inherited from a base.
If id names a class inherited to c, then c becomes the
new parent of this class (line 24).

513

Modelica 2005, March 7-8, 2005

J. Mauss

lookup(Class c, String id, Instance host) → Class
or Component
1. if (c.def.elements contains
2.
a NamedElement e with e.id=id)
3.
if (e isa ClassDefinition)
4.
if (redeclare(c.mod, id) ≠ null)
5.
e ← redeclare(c.mod, id)
6.
end if
7.
return createClass(e, select(c.mod, id))
8.
else
9.
assert e isa ComponentDeclaration
10.
if (host = null)
11.
host ← elaborate(c, new Instance())
12.
end if
13.
return new QRef(host, new Reference(id))
14. end if
15. else
16. for each Extends ext in c.def.elements
17.
if (ext.type.id=id) return null
18.
end if
19.
base ← getClass(c, ext, c.mod, host)
20.
e ← lookup(base, id, host)
21.
if (e ≠ null)
22.
if (e isa Class)
23.
if (redeclare(c.mod, id) = null)
24.
e ← new IClass(e.def, e.mod, c)
25.
else e ← redeclare(c.mod, id)
26.
end if
27.
return createClass(e, select(c.mod, id))
28.
else return e
29.
end if
30.
end if
31. end for
32. return null
33. end if

A tricky part of this procedure is the test in line 17
which terminates a circular attempt to lookup a base
class of c.
import(ClassDefinition c, String id) → Class or
Component
1. for each Import imp in c.imports
2.
if (imp matches "import A.B.C" and id="C")
3.
return lookup(ROOT, "A.B.C", true, null) else
4.
if (imp matches "import C = A.B" and id="C")
5.
return lookup(ROOT, "A.B", true, null) else
6.
if (imp matches "import A.B.*")
7.
ab ← lookupClass(ROOT, "A.B", null)
8.
e ← lookup(ab, id, null)
9.
if (e ≠ null) return e
10.
end if
11. end if
12. end for
13. return null

Searches the import clauses of the given class definition for a named element with the given id. Returns
the first matching class or component, or null if no
match was found.
The Modelica Association

removeDuplicates(Instance host) → Instance

Remove all duplicate instances (instances with same
id) from the given instance and return the resulting
instance. Duplicates are caused by multiple inheritance. It is an error if two duplicate elements are not
equivalent. Example:
class A Real x = 1; end A;
class B Real x = 2; end B;
class C
extends A;
extends B; // error
end C;
class D
extends A;
extends B(x = 1); // ok
end D;

Before application of removeDuplicates, instances of
C and D contain a duplicate component x. The procedure removes x from D, but signals an error for C,
because components x = 1 and x = 2 are not equivalent.
qualify(Class c, Modification mod, Instance host)
→ Modification

Lookup each Reference contained in the given unqualified modification in the scope of the given
class, replace it with the resulting Class or QRef, and
return the resulting qualified modification. See 2.4.
The given host is either null or, if available, an
elaborated instance of class c to be used as argument
for name lookup in the scope of class c.
replaceQRefs(Instance host) → Instance

Replace each QRef contained in the given instance
by the referenced Instance and return the resulting
instance. It is an error if an instance referenced by a
QRef is not found in the QRef's host. (For unrestricted Modelica, this method also performs dynamic lookup of the inner component, in case a
QRef references an outer component.)
redeclare(Modification env, String id) →
NamedElement
1. if (env.redeclarations contains x with x.id = id)
2.
return x
3. else return null
4. end if

If the given modification redeclares an element with
the given id, return the element. In the AST generated by a parser, the parent of a redeclared class is
the class that contains the redeclaration.
Example:
class A = B(redeclare class C = D);
In the corresponding AST, the parent of C is A.

514

Modelica 2005, March 7-8, 2005

Modelica Instance Creation

select(Modification env, String id) → Modification
1. if (env.modifications contains x with x.ref.id = id)
2.
if (x.ref.next = null)
3.
return x.mod
4.
else
5.
mod ← new Modification()
6.
em ← new
7.
ElementModification(x.ref.next, x.mod))
8.
add em to mod.modifications
9.
return mod
10. end if
11. else return null
12. end if

If the given modification modifies an element with
the given id, this procedure returns the corresponding
modification. Otherwise returns null.
Examples:
• select( (R.r =10), "r") returns null
• select( (R.r =10), "R") returns (r =10)
• select( (r =10), "r") returns =10
• select( (r), "r") returns null
merge(Modification env, Modification mod) →
Modification
1. if (env=null) return mod
2. else if (mod=null) return env
3. else
4.
result ← copy of env
5.
for each ElementModification em
6.
in mod.modifications
7.
if (select(env, em.ref.id) = null)
8.
add em to result.modifications
9.
end if
10. end for
11. for each NamedElement e
12. in mod.redeclarations
13.
if (redeclare(env, e.id) = null)
14.
add e to result.redeclarations
15.
end if
16. end for
17. if (env.value = null)
18.
result.value ← mod.value
19. end if
20. return result
21. end if

Merge the given modifications, where elements in
env beat (override, replace, update) elements in mod,
and return the resulting merged modification.
The merge operation is associative, not commutative,
and merge(null, m) = merge(m, null) = m for every
Modification m. See [1] for a more detailed specification of the merge operation.
Examples:
• merge( (x=1,y=2), (x(min=6)=3, z=4)=5 )
returns the modification (x=1, y=2, z=4)=5
• merge( (x), (x=1) ) returns (x=1)
The Modelica Association

3.3

Extension to Arrays

SimpleModelica can be extended to arrays by adding
(updating resp.) the follwing syntactic definitions.
class_specifier : { element ";" } end IDENT |
"=" name [ subscripts ] [ class_modification ]
component_declaration : name [ subscripts ] IDENT [ modification ]
element_modification : [ each ] reference [ modification ]
expression : NUMBER | STRING | true | false | reference |
"{" expression { "," expression } "}"
reference : IDENT [ subscripts ] [ "." reference ]
subscripts : "[" (":" | expression) { "," (":" | expression) } "]"

Example:
class P =Real[2](unit={"x","y"});
class A
Real[n,n+1] a;
Real[:] b(each min=1)={2,n,4};
Integer n = 3;
end A

A challenge introduced by arrays is the need to
evaluate expressions during instance creation.
• The parameter expressions that specify array size
must be evaluated, and return positive integer
sizes. E.g. to instantiate component a in class A,
expressions n and n+1 must be evaluated.
• The modifier of an array must be split in order to
get one single modifier for each array element.
E.g., to instantiate b in class A, b's modification
is split into three modifiers (min=1)=2,
(min=1)=n, and min(=1)=4.
To represent arrays, we use a new class Array, which
extends Instance (see Fig 1) and defines the fields
elementType, subs, and mod where
• elementType is a Class
• subs is a qualified subscripts expression defining
the array size, e.g. [3, 4]
• mod is an optional qualified array modification,
e.g. (unit = {"r", "g", "b"}) = {1, 2, 3}.
Expansion of arrays is delayed until the class being
instantiated has been elaborated and hence array size
expressions can be evaluated. After expansion of an
array a, the field a.parts (inherited to Array from Instance) contains the array elements.
A notable feature introduced by arrays are component references that cannot be resolved to a unique
component during instance creation.
Example:
Real a[:] = {10, 20};
Real b = a[if (time<1) then 1 else 2];

The value of b cannot be identified with a unique
array element during instance creation.

515

Modelica 2005, March 7-8, 2005

J. Mauss

The following procedures extend instance creation as
presented so far to arrays.
instantiate(Reference name) → Instance
1. c ← lookupClass(ROOT, name, null)
2. ic ← elaborate(c, new Instance())
3. ic ← expandArrays(ic)
4. ic ← replaceQRefs(ic)
5. ic ← removeDuplicates(ic)
6. return ic

The only difference to the procedure given in 3.2 is
the inserted line 3, which expands arrays contained
in ic by evaluating array size expressions and creating and inserting the corresponding array elements.
elaborate(Class c, Instance host) → Instance
1. for each Extends ext in c.def.elements
2.
if (ext.subs ≠ null)
3.
return createArray(c, ext, c.mod, host)
4.
else
5.
base ← getClass(c, ext, c.mod, host)
6.
host ← elaborate(base, host)
7.
end if
8. end for
9. for each ComponentDeclaration decl
10. in c.def.elements
11. if (redeclare(c.mod, decl.id) ≠ null)
12.
decl ← redeclare(c.mod, decl.id)
13. end if
14. qmod ← select(c.mod, decl.id)
15. if (decl.subs ≠ null)
16.
comp ← createArray(c, decl, qmod, host)
17. else
18.
type ← getClass(c, decl, qmod, host)
19.
comp ← elaborate(type, new Instance())
20. end if
21. comp.id ← decl.id
22. add comp to host.parts
23. end for
24. host.value ← c.mod.value
25. return host

This procedure expands all arrays contained in the
given host, and returns the resulting expanded instance.
split(Modification qmod, Integer i, Integer n) →
Modification

Splits the given qualified modification into n parts
and returns the ith part of it. Example:
• split( (each unit="V"), 7, 10) returns (unit="V")
• split( ={x, x+y, y}, 2, 3) returns = x+y
Note that Modelica arrays have a 1-based index, i.e.
the first array index is 1 and not 0.
vectorSize(Expression qexpr, Modification qmod)
→ Integer

The only difference to the elaboration procedure
given in 3.2 are lines 2-5 and 15-17, which treat the
case that a short class definition or component declaration contains subscripts.
createArray(Class c, Element e, Modification qm,
Instance host) → Array
1. elementType ← lookupClass(c, e.type, host)
2. qsubs ← qualify(c, e.subs, host)
3. qmod ← merge(qm, qualify(c, e.mod, host))
4. return new Array(elementType, qsubs, qmod)

This auxilliary procedure creates an array with the
given fields. The returned array is not yet expanded,
but it represents (is equivalent to) an expanded array.

The Modelica Association

expandArrays(Instance host) → Instance
1. if (host isa Array)
2.
expr ← left-most expression in host.subs
3.
next ← host.subs without left-most expression
4.
n ← vectorSize(expr, host.mod)
5.
for i in 1 to n
6.
modi ← split(host.mod, i, n)
7.
if (next = null)
8.
ci ← createClass(host.c, modi)
9.
xi ← elaborate(ci, new Instance())
10.
else
11.
xi ← new Array(ci, next, modi)
12.
end if
13.
add expandArrays(xi) to host.parts
14. end for
15. else
16. for each Instance comp in host.parts
17.
replace comp by expandArrays(comp)
18. end for
19. end if
20. return host

Determine vector size based on the given qualified
integer-valued expression and the given qualified
vector modification. This requires evaluation of
qexpr, as well as evaluation of expressions occuring
in qmod. Returns a positive integer, or signals an
error. The following examples assume that parameter
n evaluates to 3
• vectorSize(2, null) returns 2
• vectorSize(n, null) returns 3
• vectorSize(:, { x }) returns 1 without eval of x
• vectorSize(:, null) signals an error
3.4

Extension to unrestricted Modelica

To extend instance creation to full Modelica, the following remains to be done
• match outer references with the corresponding
inner reference in the instance tree

516

Modelica 2005, March 7-8, 2005

Modelica Instance Creation

•

add qualified equations and algorithms to an
instance, expand for clauses in equation sections and connect predicates i.e. generate the
corresponding equations
• validate semantic constraints, e.g. (1) assertions associated with a class category,
(2) type constraints of the Modelica type system, (3) constraining clause for redeclaration,
(4) restrict modification to public and nonfinal elements of a class
The extension of the above algorithms to most of
these features should be straightforward.

4

Application

Modelica's object-oriented approach to modeling
opens new ways for systematically validating (models of) engineered systems, e.g. with respect to behavior in the presence of component faults and for
alternative input scenarios. We have implemented
instance creation as presented here for a large fragment of Modelica. This Java implementation (based
on JavaCC, see [5]) is part of a bigger effort to develop a tool for automated simulation which, in a
nutshell,
• instantiates a given annotated Modelica model
• extracts for each component of the system the
corresponding fault modes (e.g. ok, stuckOpen,
stuckClose) as indicated by specific annotations
• extracts information about the intended use of
the system (inputs of the model)
• extracts information about specified, i.e. desired
behavior of the system
• uses the extracted information to autonomously
drive a large number of simulation runs, during
which component faults are dynamically inserted
and resulting behavior is classified w.r.t. specified behavior. The executable used for simulation is generated by Dymola.
Modelica applications like this one require access to
instantiated Modelica classes. Modelica simulators
such as Dymola do not currently offer an API to access instances, which currently forces application
developers to implement instance creation on their
own. This paper may help to reduce the required effort in the future.

5

that it defines the static semantics of Modelica in
terms of a procedure for instance creation. Unfortunately, this is done in a quite informal way. No
pseudo code is given, and no auxiliary representations (such as Instance, QRef, IClass) are explicitly
defined. It would be helpful to complement the
specification with a precise procedural definition of
instance creation in the future. This paper may be a
starting point.
Pelab at Linköping University has developed a RML
specification [3] for a fragment of Modelica, which
can be used to automatically generate [4] a procedure
for instance creation. However, for a human reader
interested in a procedural view on Modelica, e.g. to
understand name lookup or to implement flattening,
the RML specification (several thousand lines of declarative rules) is less helpful.
The design of Modelica was influenced by the Theory of Objects by Abadi and Cardelli [2]. This book
defines various calculi (similar to Lambda-calculus)
to model object-oriented languages. The calculi are
composed from equational theories, called fragments. Based on these calculi, a procedure for instance creation in Modelica could perhaps be derived
on formal grounds as follows
• define an equational theory E of objects
• direct the equations to convert E into a term
rewrite system such that a term may be a Modelica class definition, and the irreducible term
derived from that by a finite number or reductions is an instance of that class.
This is basically the idea underlying Pelab's RML
specification. In this paper, we have chosen a less
formal approach.

References

Related Work

[2]
[3]

[4]

[5]

The Modelica specification [1] is available for free
from www.modelica.org. The specification states
The Modelica Association

[1]

517

Modelica Language Specification 2.1,
www.modelica.org, 2004.
Martin Abadi, Luca Cardelli: A Theory of
Objects, Springer 1996.
David Kågedal: A Natural Semantics Specification for the Equation-based Modeling
Language Modelica. Master Thesis LiTHIDA-Ex-98/48, Linköping University, 1998.
David Kågedal and Peter Fritzson: Generating a Modelica compiler from natural semantics specifications. Proceedings of Summer
Computer Simulation Conf. SCSC'98, 1998.
JavaCC - Java Compiler Compiler, a Java
Parser Generator, https://javacc.dev.java.net/

Modelica 2005, March 7-8, 2005

The Modelica Association

518

Modelica 2005, March 7-8, 2005

Towards Comprehensive Meta-Modeling and Meta-Programming Capabilities in Modelica

Towards Comprehensive Meta-Modeling and Meta-Programming
Capabilities in Modelica
Peter Fritzson, Adrian Pop, Peter Aronsson
PELAB – Programming Environment Lab, Dept. Computer Science
Linköping University, S-581 83 Linköping, Sweden
{petfr,adrpo,petar}@ida.liu.se

The need for integrating system modeling with tool
capabilities is becoming increasingly pronounced. For
example, a set of simulation experiments may give rise
to new data that are used to systematically construct a
series of new models, e.g. for further simulation and
design optimization. Using models to construct other
models is called meta-modeling or meta-programming.
In this paper we present extensions to the Modelica
language for comprehensive meta-programming, involving transformations of abstract syntax tree representations of models and programs. The extensions
have been implemented and used in several applications, are and currently being integrated into the
OpenModelica environment.

approach has the benefit of ensuring correct syntax of
object programs. It is used in for instance Java reflection where the class java.lang.Class is the data
type for a Java class. The class has methods to query a
Java class for its methods, members, interfaces, etc.
In a previous paper (Aronsson et.al., 2003) we presented an approach of quoted Modelica code combined
with built-in predefined Modelica types to handle certain syntax classes, like for instance TypeName for a
Modelica type name or VariableName for a Modelica
variable name. However, this does not give full flexibility and meta-programming power, since the abstract
syntax tree representation cannot be fully manipulated
in the meta-programming language itself. That work
should be seen as a precursor and initial stage for the
work presented in this paper.

1

2

Abstract

Introduction

Meta-programming (meta-modeling) is writing programs (models) having other programs (so called object-programs) as inputs or results. A program can for
instance take another program as input data, perform
computations on the program by traversing its internal
structure (the abstract syntax of the program) and return
a modified program as output data.
Often, the object program language and the metaprogramming language are the same, like for instance
in LISP, in Mathematica, or in the Java reflection
mechanism. This is also the approach we have taken for
Modelica. Thus, a language needs some way of representing the object program as data.
A simple approach is to use text strings as program
representation. However, this has the disadvantage that
not even simple structural (syntactic) correctness can be
guaranteed. Another problem is low performance.
Thus, this approach is only suitable for simple and less
demanding tasks.
Another solution is to encode the object program using structured data types of the meta-programming language. This basically means that data types for the abstract syntax are defined in the language itself. This

The Modelica Association

Tree Data Structures

What are then the needs for data structures and operations for full meta-programming capabilities? One of
the most common examples of programs that manipulate and produce other programs are compilers, which
translate programs in some language into the same or
another language.
The most common data type representation for programs in compilers are tree structures, and typical operations are transformations of such trees into trees during the translation process. Lists are a special case of
tree data types, but are typically given special support
in many symbolic programming languages..
Tree data types have two interesting properties:
• Union type – a tree data type is typically the union
of a number of node types, each representing a tree
node.
• Recursive type – the children of a tree node may a
type which is the tree data type itself.
A small expression tree, of the expression 12+5*13, is
depicted in Figure 1. Using the record constructors
PLUS, MUL, RCONST, this tree can be constructed by the

519

Modelica 2005, March 7-8, 2005

P. Fritzson, A. Pop, P. Aronsson

expression PLUS(RCONST(12), MUL( RCONST(5),
RCONST(13)))
PLUS

RCONST
12

matching and transformation construct. Therefore we
propose the introduction of match-expressions in the
Modelica language. A trivial example of matchexpression is presented below:
String str;
Real
x;
algorithm
x :=
match str
case "one"
then 1;
case "two"
then 2;
case "three" then 3;
else
0;
end match;

MUL
RCONST

RCONST

5

13

Figure 1. Abstract syntax tree of the expression 12+5*13.

Union types and recursive types are currently missing
from the Modelica language, which so far has been a
conscious decision in order to avoid heap-allocated
objects.
However, with the increased relevance of metamodeling, the time may now be ripe for a possible extension such as the introduction of the uniontype restricted class construct. The example below declares a
small expression tree type Exp containing 6 different
node types represented as ordinary Modelica record
types.
uniontype Exp
record RCONST Real x1; end INT;
record PLUS Exp x1; Exp x2; end
record SUB
Exp x1; Exp x2; end
record MUL
Exp x1; Exp x2; end
record DIV
Exp x1; Exp x2; end
record NEG
Exp x1;
end
end Exp;

The string variable str is matched against the constant
patterns "one", "two", etc., returning the corresponding value from each branch in the match-expression. A
default value can be returned from the optional elsebranch if no other branch matches.
The general form of the proposed match-expression
is as follows:
match <expr> <opt-local-decl>
case <pat-expr> <opt-local-decl>
<opt-local-equations>
then <value-expr>;
case <pat-expr> <opt-local-decl>
<opt-local-equations>
then <value-expr>;
...
else <opt-local-decl>
<opt-local-equations>
then <value-expr>;
end match;

PLUS;
SUB;
MUL;
DIV;
NEG;

The uniontype restricted class construct currently has
the following properties:
• Union types can be recursive, i.e., reference themselves. The is the case in the above Exp example,
where Exp is referenced inside its member record
types.
• Union types are currently restricted to contain only
record types. This restriction may be removed in the
future.
• Record declarations declared within a union type
are automatically inherited into the enclosing scope
of the union type declaration.
• A record type may only belong to one union type.
This restriction may be removed in the future.

The then keyword precedes the value to be returned in
each branch.. The local declarations started by the local keyword, as well as the equations started by the
equation keyword are optional.There should be at
least one case...then branch, but the else-branch is
optional.
The match-expression introduces several new concepts in Modelica:

This is a preliminary union type design, which however
is very close to (just different syntax) similar constructs
in functional languages such as Haskell, Standard ML,
OCaml, and RML.

3

Tree Transformation Operations

• Pattern expressions, <pat-expr>, which may reference unbound local pattern variables declared
within the match-expression.
• Optional local variable declarations, <opt-localdecl>. These variables are local and have a scope
within the match-expression or within a specific
branch of the match-expression if they are declared
within such a branch.
• Optional
local
equations,
<opt-localequations>, which are solved locally within the
match-expression, and where the unbound unknowns to be solved for have been declared in local
variable declarations.

Regarding operations on trees, most languages supporting tree transformations provide a kind of pattern

The Modelica Association

520

Modelica 2005, March 7-8, 2005

Towards Comprehensive Meta-Modeling and Meta-Programming Capabilities in Modelica

An example of a match-expression within the function
eval shows its usage in a simple expression tree
evaluator. The local variables v1,v2,e1,e2 have scope
throughout the whole match-expression. Pattern variables such as e1 and e2 are belong to pattern expressions that are matched against tree expressions. For
PLUS(e1,e2) is matched against
example,
PLUS(RCONST(12),
MUL(
RCONST(5),
RCONST(13))) depicted in Figure 1, thereby binding

e1 and e2 to the children of the PLUS node, in this
match e1 to RCONST(12) and e2 to MUL(
RCONST(5), RCONST(13)).

•

function eval
input Exp
exp_1;
output Real rval_1;
algorithm
rval_1 :=
match exp_1
local Integer v1,v2;
Exp
e1,e2;
case RCONST(v1) then v1;

•

case PLUS(e1,e2) equation
v1 = eval(e1; eval(e2) = v2;
then v1+v2;

•

case SUB(e1,e2) equation
v1 = eval(e1); v2 = eval(e2;
then v1-v2;
case MUL(e1,e2) equation
v1 = eval(e1); v2 = eval(e2);
then v1*v2;
case DIV(e1,e2) equation
v1 = eval(e1); v2 = eval(e2);
then v1/v2;

•

case NEG(e1) equation
v1 = eval(e1);
then -v1;
end match;
end eval;

Note that the match-expression just like other expressions can be used in three contexts: inside equations,
inside algorithm sections, and inside functions.
As usual in Modelica the equations are not directional, e.g. the two equations v1 = eval(e1) and eval(e1) = v1 are equivalent.
There are some design considerations behind the
above match-expression construct that may need some
motivation.

Local equations in match-expressions have the following semantics:

• Why do we have local variable declarations within
the match-expression? The main reason is clear and
understandable semantics. In all three usage contexts (equations, algorithm sections, functions) it
should be easy to understand for the user and for the
compiler which variables are unknowns (i.e., unbound local variables) in pattern expressions or in

The Modelica Association

local equations.
Other variables that are bound to values might
have been declared in some class, or be protected
variables in a function. Without the simple rule that
local unknowns must be declared locally, it would
be hard to discover the difference between variables
that are unknowns and still can receive values, and
other variables which already have values.
Another reason for declaring the types of local
variables is better documentation of the code – the
modeler/programmer is relieved of the burden of
doing manual type-inference to understand the code.
Why local equations instead of assignment statements? The match-expression is an expression construct that can be used in the three contexts, including expressions in equations which are declarative.
Having non-local assignments inside expressions
would make the expressions nondeclarative.
Why match-expressions and not match-statements?
The match-expression is more important since it can
be used in all three contexts, and therefore has been
designed first. An analogous match-statement without local equations can be designed at a later stage.
Why the keywords match ... case instead of
switch ... case as in Java? The current choice of
keywords is inspired by the languages Modelica,
Java, and Mathematica, and is just a matter of taste
– it is easy to change to other keywords. However, it
is probably good style to indicate the increase power
of the match-expression compared to the switchstatement by a different keyword.
Why the then keyword before the returned value?
We have experimented with various syntax designs,
and the code becomes easier to read if there is a
keyword before the returned value-expression, especially when it is preceded by local equations. The
keyword cannot be return since that means return
from a function. The then keyword is used in a
similar way in Modelica if-then-else expressions. Note that most functional languages use the
in keyword instead in this context, which is less intuitive. However, the in keyword has more of a set
or array element membership meaning in Modelica.

521

• Only algebraic equations are allowed, no differential equations
• Only locally declared variables (local unknowns)
declared by local declarations within the matchexpression are solved for.

Modelica 2005, March 7-8, 2005

P. Fritzson, A. Pop, P. Aronsson

• Equations are solved one by one in the order they
are declared. (This restriction may be removed in
the future).
• If an equation or an expression in a case-branch
fails, all local variables become unbound, and the
next branch is tried. (There is some discussion
whether the semantics of trying the next casebranch after a fail should be kept).

3.1

Example of Symbolic Differentiation

To make the following example of symbolic differentiation more realistic, we add a few expression nodes to
the Exp data type, including a function call node CALL
whose argument list has the type list<Exp>, see Section 4.1.
record IDENT String name; end IDENT;
record CALL Exp id; list<Exp> args;
end CALL;
record AND
Exp x1; Exp x2; end AND;
record OR
Exp x1; Exp x2; end OR;
record LESS Exp x1; Exp x2; end LESS;
record GREATER Exp x1; Exp x2;
end GREATER;

An example function difft performs symbolic differentiation of the expression expr with respect to the
variable time, returning a differentiated expression. In
the patterns, _ underscore is a reserved word that can be
used as a placeholder instead of a pattern variable when
the particular value in that place is not needed later as a
variable value. The as-construct: id as IDENT(_)
in the third of-branch is used to bind the additional
identifier id to the relevant expression. Both tuples
with syntax (expr1,expr2,....), see Section 4.2,
and lists are used in the example.
We can recognize the following well-known derivative rules represented in the match-expression code:
• The time-derivative of a constant (RCONST()) is
zero.
• The time-derivative of the time variable is one.
• The time-derivative of a time dependent variable id
is der(id), but is zero if the variable is not time
dependent, i.e., not in the list tvars/timevars.
• The time-derivative of the sum (add(e1,e2)) of
two expressions is the sum of the expression derivatives.
• The time-derivative of sin(x) is cos(x)*x' if x
is a function of time.
• etc...
We have excluded some operators in the difft example because of limitations of space in this paper.
function difft "Symbolic differentiation
of expression with respect to time"
input Exp expr;

The Modelica Association

input list <IDENT> timevars;
output Exp diffexpr;
algorithm
diffexpr :=
match (expr, timevars)
local Exp e1prim,e2prim,tvars;
Exp e1,e2,id;
// der of constant
case(RCONST(_), _) then RCONST(0.0);
// der of time variable
case(IDENT("time"), _) then
RCONST(1.0);
// der of any variable id
case difft(id as IDENT(_), tvars) then
if list_member(id,tvars) then
CALL(IDENT("der"),list(id))
else
RCONST(0.0);
// (e1+e2)’ => e1'+e2'
case (ADD(e1,e2),tvars) equation
e1prim = difft(e1,tvars);
e2prim = difft(e2,tvars);
then ADD(e1prim,e2prim);
// (e1-e2)’ => e1'-e2'
case (SUB(e1,e2),tvars) equation
e1prim = difft(e1,tvars);
e2prim = difft(e2,tvars);
then SUB(e1prim,e2prim);
// (e1*e2)’ => e1'*e2 + e1*e2'
case (MUL(e1,e2),tvars) equation
e1prim = difft(e1,tvars);
e2prim = difft(e2,tvars);
then PLUS(MUL(e1prim,e2),
MUL(e1,e2prim));
// (e1/e2)’ => (e1'*e2 - e1*e2')/e2*e2
case (DIV(e1,e2),tvars) equation
e1prim = difft(e1,tvars);
e2prim = difft(e2,tvars);
then DIV(SUB(MUL(e1prim,e2),
MUL(e1,e2prim)),
MUL(e2,e2));
// (-e1)' => -e1'
case (NEG(e1),tvars) equation
e1prim = difft(e1,tvars);
then NEG(e1prim);
// sin(e1)' => cos(e1)*e1'
case CALL(IDENT("sin"),list(e1)),tvars)
equation e1prim = difft(e1,tvars);
then MUL(CALL(IDENT("cos"),list(e1)),
e1prim);
// (e1 and e2)’ => e1'and e2'
case (AND(e1,e2),tvars) equation
e1prim = difft(e1,tvars);
e2prim = difft(e2,tvars);
then AND(e1prim,e2prim);
// (e1 or e2)’ => e1' or e2'
case (OR(e1,e2),tvars) equation
e1prim = difft(e1,tvars);
e2prim = difft(e2,tvars);
then OR(e1prim,e2prim);
// (e1<e2)’ => e1'<e2'
case (LESS(e1,e2),tvars) equation
e1prim = difft(e1,tvars);
e2prim = difft(e2,tvars);
then LESS(e1prim,e2prim);
// (e1>e2)’ => e1'>e2'
case (GREATER(e1,e2),tvars) equation
e1prim = difft(e1,tvars);

522

Modelica 2005, March 7-8, 2005

Towards Comprehensive Meta-Modeling and Meta-Programming Capabilities in Modelica

e2prim = difft(e2,tvars);
then GREATER(e1prim,e2prim);
// etc...
end match;

recvalue.fieldname for ordinary record values.
For example, accessing the second value in tup:
tup.2

end difft;

4

Lists and Tuples

List and tuple data types are common in many languages used for meta-programming and symbolic programming.

The main reason to introduce tuples is for convenience
of notation. You can use them directly without explicit
declaration. Tuples using this syntax are already present in the major functional programming languages.
A tuple will of course also have a type. When tuple
variable types are needed, they can for example be declared using the following notation:
type VarBND

4.1

Lists

or directly in a declaration of a variable bnd:

The following operations allows creation of lists and
addition of new elements in front of lists in a declarative way. Extracting elements is done through patternmatching in match-expressions shown earlier.
• list – list(el1,el2,el3, ...) creates a list
of elements of identical type. Examples: list()–
the empty list, list(2,3,4) – a list of integers.
• nil – denotes an empty reference to a list or tree.
• cons – the call cons(element, lst) adds an element in front of the list lst and returns the resulting list. Also available as a new built-in operator ::
(coloncolon), e.g. used as in: element::lst.
Types of lists and list variables can be specified as follows:
• list – list<type-expr> is also a list type constructor, e.g. :
type RealList = list<Real>;

• Direct declaration of a variable rlist that denotes
a list of real numbers:
list<Real>

record<Ident, Integer>

bnd;

The tuple type used in the match-expression of the previous simple eval function is record<Exp,Exp>.

5

Positional Type Parameters

Class definitions in Modelica allow type parameters,
declared as replaceable local types, e.g.:
class C2 = C(redeclare class
ColoredClass = BlueClass);

Using a shorter angle-bracket syntax for positional type
parameters similar to what is used in other objectoriented languages such as C++ or Java, this can be
expressed as:
class C2 = C<BlueClass>;

We have used this syntax in several places throughout
this paper, including a call to a polymorphic function in
Section 7.

rlist;

6
4.2

= record<Ident, Integer>;

Tuples

Tuples can be viewed as instances of anonymous records. The syntax is a parenthesized list. The same syntax is used in extended Modelica presented here, and is
in fact already present in standard Modelica as a receiver of values for functions returning multiple results.
• An example of a tuple literal:
(a, b, "cc")

• A tuple with a single element has a comma in order
to have different syntax compared to a parenthesized expression: (a,)
• A tuple can be seen as being returned from a function with multiple results in standard Modelica:

The previous small expression evaluator presented in
Section 3 could only handle constant expressions. The
following example can handle expressions with variables. It demonstrates a different representation of expression trees, with BINARY nodes that are parameterized in terms of the operator, and thereby can handle
several binary operators in a single of-branch in the
match-expression. First we give the type declarations:

(a,b,c) := foo(x, 2, 3, 5);
• Access of field values in tuples is achieved via dotnotation, tupvalue.fieldnr, analogous to

The Modelica Association

Expression Evaluator with Environments

523

type Ident

= String;

uniontype Exp
record RCONST
record IDENT
record BINARY
end BINARY;
record UNARY
record ASSIGN

Real x1; end RCONST;
Ident x1; end IDENT;
Exp x1; BinOp op; Exp x2;
UnOp x1; end UNARY;
Ident x1; Exp x2;

Modelica 2005, March 7-8, 2005

P. Fritzson, A. Pop, P. Aronsson

end ASSIGN;
end Exp;
uniontype BinOp
record ADD end
record SUB end
record MUL end
record DIV end
end BinOp;

7

A common and rather useful language feature not yet
present in standard Modelica is the ability to pass function parameters. For example, passing the add1 function to a mapping function that applies it to each element:

ADD;
SUB;
MUL;
DIV;

arr2 := arr_map_int(add1, {2,3,5,8})

uniontype UnOp
record NEG end NEG;
end UnOp;
uniontype Value
record REALval Real x1;
end Value;

returns:
{2,4,6,9}
end REALval;

The following eval function can handle evaluation of
expressions with variable references. It calls the
lookup function for access of variable references, and
apply_binop for evaluation of binary operators.
type Ident

We propose the following style of declaring a function
that accepts a function formal parameter, exemplified
through an example. The only syntax extension is to
allow the declaration of a function without body, here
Functype, which allows us to declare the type signature of the function formal parameter func.

= String;

function eval
// Evaluation of expression exp
// in an environment env
input Env
env_1;
input Exp
exp_1;
output Value value_1;
algorithm
value_1 :=
match (env_1,exp_1)
local Real v,v1,v2;
String
id;
Env
env;
Exp
e1,e2;
Boolean v3;
BinOp
relop;
// Real constant
case (_,REALval(v)) then REALval(v);
// variable identifier id
case (env,IDENT(id)) equation
v = lookup(env,id);
then REALval(v);
// If id not declared, give an error
// message and fail through error
case (env,IDENT(id)) equation
v = not lookup(env,id);
print("Error - undef variable: ");
print(id); print("\n");
then fail()

function arr_map_int
"Map over an array of integers"
function Functype
input Integer x1; output Integer x2;
end FuncType;
input replaceable function func
extends FuncType;
input Integer[:] inarr;
output Integer[size(inarr,1)] outarr;
algorithm
for i in 1:size(inarr,1) loop
outarr[i] := func(inarr[i]);
end for;
end arr_map_int;

The next example is polymorphic since the array element type Type_a is not fixed. It is a replaceable type,
which makes it possible to apply arr_map to arrays of
any element type. For example, applied to an array of
strings, with the addA function that adds "A" to the end
of a string:
arr3 :=
arr_map<String>(addA, {"foo","fie"})

returns:
{"fooA","fieA"}

The definition of the arr_map function:
function arr_map
"Map over an array of elements of Type_a"
replaceable type Type_a;
function Functype
input Type_a x1; output Type_a x2;
end Functype;
input replaceable function func
extends FuncType;
input Type_a[:] inarr;
output Type_a[size(inarr,1)] outarr;
algorithm
for i in 1:size(inarr,1) loop
outarr[i] := func(inarr[i]);
end for;

// expr1 binop expr2
case (env, BINARY(e1,binop,e2))
equation
eval(env,e1) = REALval(v1);
eval(env,e2) = REALval(v2);
v3 = apply_binop(env,binop,v1,v2);
then REALval(v3);
end match;
end eval;

The Modelica Association

Function Parameters

524

Modelica 2005, March 7-8, 2005

Towards Comprehensive Meta-Modeling and Meta-Programming Capabilities in Modelica

end arr_map;

The semantics of function parameters include the following:
• Functions can be passed as actual arguments at
function calls.
• Type checking done on the function formal parameter type signature, not including the actual names of
inputs and outputs to the passed function.

8

Exception Handling

pabilities of the new extensions, will make Modelica
into a very powerful meta-modeling and metaprogramming language for the future.

10 Acknowledgements
This work has been supported by Swedish Foundation
for Strategic Research (SSF), in the RISE project, and
by Vinnova in the SWEBPROD project.

References

The design of exception handling capabilities in Modelica is currently in a preliminary phase. The following
constructs are being discussed:
• A try...catch statement or expression.
• A raise(...) call for raising exceptions.
The statement variant has approximately the following
syntax:
try
<statements>
...
catch <x> then
<statements>
...
end try;

try
<expression>
catch <x> then
<expression>
end try;

[4] Peter Fritzson. Principles of Object-Oriented
Modeling and Simulation with Modelica. 940 pp.
Wiley-IEEE Press, 2004.

This design is still very preliminary, several issues need
to be determined, and no implementation has yet been
produced.

Conclusions

It has been demonstrated how Modelica can be extended with data structures and operations that are typically needed for comprehensive meta-programming and
symbolic transformations. The extensions are declarative and preserve the declarative and equation-based
style of Modelica. Recursive data types, lists, and tree
pattern matching in match-expressions with local equations can be naturally integrated into the current Modelica 2.1 language. A implementation of most of this
functionality has been tested on a number of examples,
including those in this paper, and is currently being
integrated into the OpenModelica compiler.
We believe that the combination of the modeling
power and numeric capabilities of the current Modelica
language, combined with symbolic transformation ca-

The Modelica Association

[2] Peter Aronsson, Peter Fritzson, Levon Saldamli,
Peter Bunus and Kaj Nyström. Meta Programming and Function Overloading in OpenModelica. In proceedings of the 3rd International
Modelica Conference, Linköping, Sweden, Nov
2003.
[3] Peter Fritzson, et al. The Open Source Modelica
Project. In Proceedings of The 2nd International
Modelica Conference, 18-19 March, 2002. Munich,
Germany
http://www.ida.liu.se/
~pelab/modelica/ OpenModelica.html.

The syntax of the expression variant is as follows:

9

[1] Peter Aronsson, Peter Fritzson, Levon Saldamli,
and Peter Bunus. Incremental declaration handling in Open Source Modelica. In SIMS - 43rd
Conference on Simulation and Modeling on September 26-27, Oulu, Finland, 2002.

525

[5] Paul Hudak. The Haskell School of Expression.
Cambridge University Press, 2000.
[6] The Modelica Association. The Modelica Language Specification Version 2.1, June 2003.
http://www.modelica.org.
[7] Mikael Pettersson. Compiling Natural Semantics.
PhD thesis, Linköping Studies in Science and
Technology, 1995.
[8] Peter van Roy and Seif Haridi. Concepts, Techniques, and Models of Computer Programming.
MIT Press, 2004.
[9] Tim Sheard. Accomplishments and Research
Challenges in Meta-Programming. Lecture Notes
in Computer Science, 2196:2–.., 2001

Modelica 2005, March 7-8, 2005

The Modelica Association

526

Modelica 2005, March 7-8, 2005

MOSILAB: Development of a Modelica based generic simulation tool supporting model structural dynamics

MOSILAB: Development of a Modelica based generic simulation tool
supporting model structural dynamics
Christoph Nytsch-Geusen1
Thilo Ernst1
André Nordwig1
2
Peter Schneider
Peter Schwarz2
Matthias Vetter3
Christof Wittwer3
4
Andreas Holm
Thierry Nouidui4
Jürgen Leopold5
Gerhard Schmidt5
6
Ulrich Doll
Alexander Mattes6
1

Fraunhofer Institute for Computer Architecture and Software Technology
Kekuléstr. 7, D-12489 Berlin, christoph.nytsch@first.fhg.de

Fraunhofer IIS/EAS2, Fraunhofer ISE3, Fraunhofer IBP4, Fraunhofer IWU5, Fraunhofer IPK6

Abstract
The current GENSIM project, which is being conducted by a consortium of six Fraunhofer Institutes,
is developing the generic simulation tool MOSILAB
for the analysis of mixed time-continuous / timediscrete (hybrid) models of heterogeneous technical
systems. One major innovation here in terms of
simulation technology is the mapping of statedependent changes in the model structure (model
structural dynamics). This enables, for example,
simulation experiments to be conducted with models
of variable modelling depth. The modelling description language in the project MOSILA is based on
Modelica, which was extended syntactically in terms
of an adequate description of the model structural
dynamics. The simulation tool is composed of a kernel and an integrated development environment and
will be available in spring 2005 as a first prototypical
implementation. The usability of the simulation tool
is tested and evaluated in the GENSIM project by
means of three use cases in the application areas fuel
cell systems, hygrothermal building analysis and cutting tool systems.
Keywords: MOSILAB; Generic simulation tool;
Model structural dynamics; object-oriented

1

2

Introduction

A heterogeneous technical system shows in dependency of its state a different physical behaviour. For
example the physical behaviour of a starting plane in
the different phases of rolling, taking off and flying

The Modelica Association

can be described with different sets of physical effects, like the air and roll friction on the earth and the
aerodynamic laws in the sky. An adequate simulation
model for such a technical system needs also a high
level of flexibility and adaptation in its model structure and in its equation system.
The innovative goal of the GENSIM project is to
develop a new generic simulation tool for hybrid
models, which supports model structural dynamics.
Model structural dynamics in this context means, the
model structure (the number and types of equations)
can change during the simulation experiment in dependency of events, which are triggered from the
state of the model self or its environment.
The object- and equation-oriented simulation language Modelica (http://www.modelica.org) offers in
principal a good language concept for modelling
technical systems with structural dynamics. For this
reason Modelica was chosen as the language basis
for the GENSIM simulation tool. Because the actual
specification of Modelica is limited to fixed model
structures during the simulation experiment, some
syntactical extensions were made in GENSIM to obtain the possibility for describing model structural
dynamics in a compact form.

Modelica Language Extension

The modelling description language MOSILA
(Modelling and Simulation Language), which is
specified and used in the GENSIM project, is based
on Modelica. From the view of the modeller
MOSILA is mainly an extension of Modelica.

527

Modelica 2005, March 7-8, 2005

C. Nytsch-Geusen et. al.

Thereby existing models and also the disposable
Modelica standard library can be reused within the
GENSIM simulation tool directly or with a small
effort of adaptation.
However the means of expressions of Modelica, particular for the description of variable model structures, are not powerful enough yet for using special
simulation technologies, e.g. variable modelling
depth. Therefore some syntactical extensions are
added in MOSILA. These extensions where influenced by the UMLH [1], an adaptation of the UML
[2] for the context of hybrid systems.
2.1

Dynamical object structures

Dynamical object structures were introduced to represent variable models during the simulation experiment. Thus, it becomes possible to extend the static
model tree with dynamical objects during discrete
phases of an experiment, which them self can spawn
complex model trees. Since objects represent state
attributes and behaviour in form of equations, the
underlying equation system can be changed in size
and quality when a structural change takes place.
After such changes a new equation system will be
derived for the following continuous phase.
2.2

To simplify the modelling process direct support for
these statechart descriptions was introduced in
MOSILA as a special section of a model class. This
extension is based on the Modelica type system:
Each state is introduced by a state declaration.
Within such declarations sub-states and transitions
between these sub-states can be specified. Depending on the base type of a state two kinds of state
compositions can be declared: Within an active XOR
state only one direct sub-state is active at each time
instant. Within an active AND state all its direct substates are active. Therefore, parallel and sequential
processes can be comfortably modelled. Actions
which have to take place during switching transitions
are defined within the associated transition definition. Figure 2 shows the MOSILA implementation of
the above introduced statechart:
model System
...
statechart
state SystemSC extends State;
state Moving extends State;
state SlowDown extends State;
exit action
body.remove(boost);
end exit;
end SlowDown;
State falling, start(isInitial=true);
SlowDown slowDown;

Object-oriented Statecharts

transition start -> falling end transition;
transition t2 : falling -> slowDown

To ease the description of structural changes, an
adequate syntax for the control of discrete model
switches were realised on the base of object oriented
statecharts. Figure 1 shows a statechart controlling
the mode switches of a landing device:

event sw guard sw==1 action
body.add(boost);
end transition;
transition t3 : slowDown -> falling
event sw guard sw==0
end transition;
end Moving;
State stop,start(isInitial=true);
Moving moving;
transition t1 : start -> moving action
body.add(gr);
end transition;
transition t4 : moving -> stop
event landed action
body.remove(gr);
end transition;
end SystemSC;
end System;

Figure 1: Statechart of a landing device
At the beginning the device enters the mode “moving” and within its sub-mode “falling”. If the booster
is enabled (depending on the decend speed), than it
enters the “slowDown” mode until the booster is disabled. When the device reaches the ground the
“moving” mode is left and “stop” is entered.

The Modelica Association

Figure 2: Implementation of a statechart for the control system of the landing device
The state space for action statements, e.g. assignment, is given by the surrounding type definitions,
and thus the statechart acts on the attributes of the
associated class.

528

Modelica 2005, March 7-8, 2005

MOSILAB: Development of a Modelica based generic simulation tool supporting model structural dynamics

2.3

Dynamical behaviour

Further, the extended language concept offers an
infrastructure, which enables the extension of (basic)
model by effects in form of behavioural objects. For
this purpose the action language is extended by the
operations “add()” and “remove()”, which connect/disconnect the given argument (behaviour object) to the target object (base object). To extend underlying balance equations, a new connector type
“sum” is introduced. The semantics of this connector
type is like zero sum (“flow”), but with a negatively
signed base attribute. Thus, balance equations can be
extended by terms, which are encapsulated by objects. The following implementation (Figure 3)
shows the environment of the landing device:
connector FPort
sum Real F=0;
Real m=0;
end FPort;
partial model BodyInterface
FPort p;
end BodyInterface;
model Body extends BodyInterface(p.m=100);
Real a=0, v=0, s=100;
equation
der(v) = a; der(s) = v; a = p.F / p.m;
end Body;

The base model “Body” and the effects “Gravity”
and “Boost” have the same interface “BodyInterface”, which introduces the variables to connect/disconnect during add/remove operations. The
attribute “F” has “sum” quality since it is used to
model a (dynamically changed) balance equation.
The events “sw” and “landed”, which drive the
above introduced statechart, are modelled within the
top level class “System” as special discrete variables.

3
3.1

The MOSILAB Simulator
MOSILAB Architecture

The GENSIM simulation tool MOSILAB (Modeling
and Simulation Laboratory) includes the simulation
kernel (consisting of a model compiler, a runtime
system and a numerical solver framework) and an
IDE (Interactive Development Environment), the
interface to the user of the simulation system. It supports him both in the modelling process with the help
of graphical UML and text editors and during the
simulation experiment.
C++
Experiment
C++ Model
Classes

model Gravity
extends BodyInterface;
parameter Real g=9.81;
equation
p.F = - p.m * g;
end Gravity;

MOSILACompiler

010110101
O10100101
111010101

Executable
Simulator

model Boost
extends BodyInterface;
discrete Boolean empty=false;
Real m;
equation
p.m = m;
empty = (not m>20); // = if m>20 then false else
true;
der(m) = if empty then 0 else -10;
p.F = if empty then 0 else 1200;
end Boost;
model System
Body body;
Gravity gr;
Boost boost;
event discrete Integer sw=0;
event discrete Boolean landed=false;
equation
sw = if body.v < -5 then 1 else if body.v >= 0
then 0 else pre(sw);

MOSILA
Model Classes
MOSILAB- IDE

Figure 3: Implementation of the dynamical behaviour of the landing device

MOSILA
StandardLibrary

C++ SimulatorKernel Classes

MOSILAB-Simulator

Figure 4: Data flow within MOSILAB
Figure 4 shows the data flow within the MOSILAB
tools: Beside experiment definitions, the models also
developed within the IDE are stored as MOSILA
model classes. Together with the MOSILA standard
library, these MOSILA models are compiled to C++
classes by the MOSILA compiler. Using the GNU
gcc/g++ compiler, the executable simulator is built
from these C++ representations and the simulator
kernel classes.
3.2

landed = ( body.s <= 0 ); // = if body.s <=0
then true else false;
...
end System;

The Modelica Association

gcc/g++
Compiler

Numerical solver framework

The numerical solver framework of MOSILAB features general functions such as the construction of
the numerical model based on the modelling description, the main simulation control loop and is able to
integrate different numerical algorithms.
The simulator kernel library contains some basic algorithms for solving nonlinear implicit differential-

529

Modelica 2005, March 7-8, 2005

C. Nytsch-Geusen et. al.

its central mechanism for experiment control. The simulator is loaded as an “extension” into the interpreter, and “experiment
scripts”, written in Python, access the simulator API via a Python-level interface.
c) The simulator acts as a service. In this mode,
the simulator is linked with appropriate libraries to publish its API via standard
TCP/IP-based protocols such as SOAP [5] in
a web or grid services framework (e.g. the
upcoming release 4 of the Globus Toolkit
[6]). In this mode, the simulator can easily
be controlled in protocol-based, platformindependent manner, and it is easy to deploy
multiple (and potentially large numbers of)
“simulator service instances” in a coordinated way in a heterogeneous network or
Grid, for instance to solve an optimization
problem. Python-based experiment control
support is available in this mode as well – a
(Python) client library is used to talk to the
simulator’s API over the network in this
case. The simulator maintains a run-time
representation of the model object hierarchy
(as defined in the source and evolving according to the structural variability of the
model). This run-time model can be inquired
via introspection features of the simulator
API, so (using the synchronisation features
offered by this API, too) experiment scripts
are able to follow the structural changes over
the entire course of a simulation run. This
way, if special reactions to model structure
changes are needed, which cannot be formulated in the model itself due to their complexity, such reactions can easily be implemented in the experiment script.

algebraic equations (DAE): the EULER backward
formula and trapezoidal rule as simple methods from
standard textbooks, and IDA, a powerful publicdomain DAE solver for sequential and parallel computers [3]. IDA is a successor of DASSL, a well established DAE solver [4, 5]. IDA provides a routine
that computes consistent initial conditions from a
user's initial guess for a class of problems - a very
important feature for simulating systems with model
structural dynamics. The integration method in IDA
is a variable-order, variable-coefficient BDF method
(backward differentiation formula). The nonlinear
systems are solved with some form of NEWTON
iteration.
But the library is an open one: according to the requirements of a dedicated MOSILAB implementation or of special problem requirements, additional
solvers may be implemented, e.g. data-flow or eventoriented methods, or simplified solvers for linear
state-space equations in explicit form.
Such a tailored algorithm, which is implemented in
the GENSIM project, is the Plug-Flow method [6, 9]:
A so called plug flow model uses finite mass elements ∆m=m’·∆t and finite energy elements
∆Q=Q’·∆t with a fixed time step, allowing the mass
flow through closed and opened networks to be
traced. This guarantees a fast calculation of the object chain. The plug is initiated in a “pump” or “ventilator”-object, then shifted through the branched
network and is returned to the origin (pump or ventilator). This mechanism allows simple modelling of
flow delay effects and mass balance at the second
call of the pump/ventilator in one time step. Due to
the decentralised solver method the state equations
of each object are calculated with the updated mass
flow of the previous object.
3.3

MOSILAB Configurations

3.4

MOSILAB can be configured in to act in three
modes:
a) The generated simulator is represented by a
single, monolithic C/C++ application. This
option has the smallest memory footprint
and only few dependencies on the underlying platform, so it is most useful e.g. for embedded applications. However, the functionality w.r.t. dynamic parameterization at runtime is limited.
b) The simulator is represented by a shared object file which can be dynamically linked to
a main program which controls the simulation. MOSILAB uses the Python language
and interpreter (http://www.python.org) as

The Modelica Association

Simulator Coupling

Besides the service-oriented approach to coarsegrained coupling of simulation components described in item c) above, MOSILAB also supports
simulator coupling on a fine-granular level. In addition to implementing the standard external function
interface defined in Modelica, special interface support is being developed to support coupling with the
widely used simulator MATLAB/Simulink and certain specialized simulators relevant to the pilot applications (e.g. CFD and FEM tools). These developments, too, build on the flexible simulator API offered by MOSILAB’S simulation kernel.

530

Modelica 2005, March 7-8, 2005

MOSILAB: Development of a Modelica based generic simulation tool supporting model structural dynamics

4

The MOSILAB Development Environment

The MOSILAB Development Environment (MOSILAB-IDE) supports the user during the modelling
process and the simulation experiment.
In the modelling mode the user can choose between
three graphical UMLH-editors (class diagrams, collaboration diagrams and statecharts) and a text editor. While the graphical views give the user an intuitive overview about the structure and the logic of a
complex model, the text editor offers the user features like syntax highlighting for implementing the
MOSILA/Modelica models.
In the experiment mode of the MOSILAB-IDE the
user can define the root model for the simulation experiment, can parameterize model variables and can
choose and configure a suitable numerical solver.
Furthermore he can define a subset of model variables, which should be observed during the simulation experiment. The observed variables are the basis
for different types of post-processing. Figure 5
shows a screenshot of the prototypical implementation of the MOSILAB-IDE.

dependency of the system state during the simulation
experiment (e.g. contact between the tool and the
working piece exists or not).
5.1

Fuel cell systems

The future structure of power grids will consist of a
huge fraction of decentralised power generators. Especially the low voltage grid will be penetrated by
small and medium photovoltaic systems, medium
combined heat and power units based on natural gas
or bio fuels as well as residential fuel cell cogeneration power systems. Dynamic simulation of
the entire low voltage grid offers the possibility of
analysis and optimisation of the grid in terms of dimensioning and system management.
If cogeneration systems (e.g. residential fuel cell systems) are regarded, thermal aspects have to be considered. The ecologic and economic evaluation of
these innovative energy supply systems needs efficient models due to seasonal effects and the necessity of simulation runs in the range of one year [9,
10].
Model structural dynamics allows the investigation
of a huge number of grid connected residential fuel
cell cogeneration systems in combination with other
decentralised energy systems such as photovoltaic,
small wind turbines, bio mass systems, etc. in a very
efficient way. In this approach the model depth is
defined by the operating point and the operating behaviour respectively.

Figure 5: MOSILAB-IDE in the modelling mode

5

Applications

In the GENSIM project model libraries for the three
technical application areas fuel cell systems, hygrothermal building analysis and cutting tool systems
are developed. On their basis different use cases
should be analysed. In each use case the methodological possibilities of the model structural dynamics
will be evaluated: For example cutting tool system
models are developed, which can activate different
physical sub models for tools und working pieces in

The Modelica Association

Figure 6: Definition of the single layers of the residential fuel cell system representing the model depth.
The current model depth will be switched in dependence of boundary conditions and control actions.
As showcase the model structural dynamics of a fuel
cell system is described in the following section. In a

531

Modelica 2005, March 7-8, 2005

C. Nytsch-Geusen et. al.

first approach four layers of abstraction are defined,
shown in figure 6. The current layer will be
switched, if discrete events (e.g. caused by a state
variable crossing a threshold) require the change of
the model depth. In case of a stationary operating
point of the fuel cell system, it is sufficient to represent this device with a simple characteristic curve.
As soon as boundary conditions (e.g. cooling temperature) are changing or the operating point is
changed by a controller, more detailed models are
needed to reproduce the transient behaviour in an
accurate way.
Furthermore, critical system states can require detailed models, with which even single cells can be
investigated. As an example flooding effects at low
operating temperatures or at high load currents shall
be mentioned. If a system simulation tool is able to
reproduce even such effects, efficient control strategies can be developed to reduce or even avoid system failure. In this project the coupling with external
FEM tools are planned to fulfil these demands.
5.2

Hygrothermal building analysis

In the area of Building Physics hygrothermal models
of building envelopes to compute coupled transport
processes of heat and moisture for one- or multidimensional cases are widely used. In those models
however the boundary conditions of heat and moisture have to be user-defined before starting the simulation.

non buffering surfaces of the components in combination with different ventilation strategies can be
investigated to consider the efficiency of thermal
drying and ventilation strategies to keep the indoor
climate (especially the humidity) in a favourable
range.
For this reason Fraunhofer IBP and FIRST started
the development of such a new hygrothermal building model within the GENSIM project. Fraunhofer
IBP can make use of its extensive experiences with
the development and experimental validation of the
simulation tool WUFI [11] for the detailed simulation of hygrothermal behaviour of building components. Fraunhofer FIRST has long-year modelling
experience in the area of thermal building simulation
with the generic and object-oriented simulation environment SMILE [12].
The goal in GENSIM is the development of a Modelica /MOSILA model library, which will contain
models of one- and of two-dimensional coupled heat
and moisture transport within wall constructions, a
thermal/optical window model, a hygrothermal air
volume model, a thermal/optical room model, an
environment model for the climatic boundary conditions as well as an inhabitant model. From these
models it is possible to set up configurations of
rooms or whole buildings in a very flexible way by
using the object-oriented modelling method. For example figure 8 shows UMLH-class diagram for an
outside thermal wall model, which is a part of the
model library building for hygrothermal building
simulation.

Figure 7: Coupled hygrothermal physical effects in
the building envelope
A model that would take into account a multizonal
building or even only a single room and the building
envelope in detail – thus rendering the definition of
the inner boundary conditions for the envelope unnecessary – is still to be defined. Such a model
would allow analysing cases with strong reciprocal
effects between the climate in the room and the behaviour of the building components (see figure 7).
For example the influence of moisture buffering and
The Modelica Association

Figure 8: UMLH-Class diagram for an outside thermal wall model
The efficiency of the model structural dynamics
should be evaluated for the coupled transport processes of heat and moisture in wall constructions: For
example, if the gradient of temperature or moisture
becomes greater then a limit-value, the level of dis-

532

Modelica 2005, March 7-8, 2005

MOSILAB: Development of a Modelica based generic simulation tool supporting model structural dynamics

cretisation of the wall model will be set on a higher
value or the other way around.
During the project the hygrothermal building model
will be validated on test houses. Two rooms which
are identical both geometrically and in respect of
solar gain and outdoor climate, however differ extremely in the sorption behaviour of their wall surfaces are used to validate the building model (see
figure 9).

Figure 9: Test rooms for validating the hygrothermal
building model
This is to be done by measurements of the energy
and moisture balance in both rooms during cycles of
heating and cooling as well as humidification and
dehumidification.
5.3

The complexity of requested models depends on
workpiece and the shaped elements and also from the
type of the tool and its loading. Complex cutting
tools consist of several components. Due to relative
motions of the components under high centrifugal
force load, cutting forces and clamping stresses, the
tool models are highly non-linear and heterogeneous.
Different stages of the loading by clamping, centrifugal and cutting forces cause structural dynamic
model behaviour and require corresponding changes
of model parameters or even switching between different types of models (Figure 10). In the GENSIM
project analytical models of complex cutting tools
will be developed to be integrated in MOSILAB.
FEA will deliver the parameters of these models.
Respecting the complex structural dynamics different sets of sub-models are required to compile adequate cutting tool models. In addition to this, a special interface for FEA and MOSILAB data transfer
will be developed for these types of cutting tools,
which can not be simulated by a homogenous analytical model.

Cutting tool systems

The development of high performance cutting processes requires, along with suitable machine tools and
clamping devices also specially balanced and designed cutting tools. Safety and precision are the essential criteria at the judgment of tools for the high
speed processing. Numerical simulations offer the
possibility to evaluate different variants already in
the outline process without existing samples. A
proved method is the analysis of the tool behaviour
under operating conditions with the finite element
analysis (FEA).

Figure 11: Example of a complex cutting tool

Figure 10: Cutting tool modelling in the framework
of MOSILAB

The simulation of cutting tool behaviour in the GENSIM project covers the complex tool – starting from
the cutting edge up to the spindle interface (see figure 11). The behaviour of the cutting tool in use is
determined by the statically and dynamical components of the cutting force. These loads are essential
boundary conditions to investigate the structural dynamics of the cutting tool itself.
To get these loads, the cutting process itself is simulated using another FE-model. Here a small section
of the cutting process is represented in which the
chip formation happens. As seen in figure 12 the
outer edge of the cutting tool and the upper layer of
the workpiece are modelled.

The Modelica Association

533

Modelica 2005, March 7-8, 2005

C. Nytsch-Geusen et. al.

Figure 12: Simulation of the machining process
Through the simulation continuous or segmented
chip formation can be described and the distribution
of the resulting cutting forces can be calculated connected to the simulation time. Here from a threedimensional load vector is determined, which acts on
the cutting edge of the tool.
Within MOSILAB the simulation models should be
combined to a simulation tool which describes the
model structural dynamic of the interaction between
cutting process and tool holder. For that a library
with different combinations of tool holder, cutting
tool material and workpiece material will be provided by MOSILAB. If in the cutting process the
cutting force reaches limits, which indicate a meaningful influence on the tool holder (vibrations for
example) the simulation depth can be changed [13].
This enables analysing changes in behaviour of the
tool holder caused by microscope events happening
in the region of chip formation. Also the results of
the tool holder simulation are useful to include
changes in the boundary conditions of cutting process caused by displacement of the tool holder itself.

6

Conclusions

The important results of the GENSIM project are the
Modelica language extension for an adequate description of model structural dynamics, the new generic simulation tool MOSILAB and three model
libraries of different technical applications:
a) Modelica language extension MOSILA:
The new modelling description language
MOSILA, which is mainly an extension of
Modelica, is able to describe simulation
The Modelica Association

534

models with a time depending model structure during the simulation experiment. This
was realised by using dynamical object
structures together with object-oriented
statecharts for the language specification. An
example for this new simulation technology
in MOSILA is an adaptive simulation model
containing a set of physical sub-models,
from these some are activated or not in dependency of the state of the model self.
b) Simulation tool MOSILAB: The new developed generic simulation tool for hybrid
systems, which includes a model compiler, a
runtime system and a numerical solver
framework, is able to translate MOSILA or
Modelica models to an executable simulation program. Hereby the user is supported
by the MOSILAB development environment, which offers possibilities for the
graphical and textual modelling process, for
simulation experiments and for postprocessing. On the one hand the scalable
software architecture of MOSILAB can generate small simulators as monolithic C/C++
applications. On the other hand simulator
configurations with more flexibility for the
simulation experiment are possible by loading MOSILAB and the compiled model libraries as an extension in a python interpreter, while the simulation experiment is
formulated in the script language Python.
Current research activities in the GENSIM
project will show that MOSILAB can also
act as a service in web or grid frameworks
and can by coupled with other simulation
tools like MATLAB/Simulink.
c) Model Libraries: Three model libraries for
the technical applications fuel cell systems,
hygrothermal building analysis and cutting
tool systems are developed and validated in
GENSIM. In each application area the efficiency of the model structural dynamics are
analysed. In relation to its time dynamics,
the analysed systems in GENSIM overlap
the millisecond- to second-scale (cutting tool
systems), the second to hour-scale (fuel cell
systems) and the hour to year-scale (hygrothermal building analysis). For these reasons these application areas together are also
a suitable test bed for the numerical basis of
the simulation tool MOSILAB.

Modelica 2005, March 7-8, 2005

MOSILAB: Development of a Modelica based generic simulation tool supporting model structural dynamics

[12]

References
[1]

[2]
[3]

[4]

[5]

[6]

[7]
[8]
[9]

[10]

[11]

Nordwig, A.: Integration von Sichten
für die objektorientierte Modellierung hybrider Systeme, Verlag dissertation.de, ISBN 3-89825-692-8,
2003.
Rational: Unified Modeling Language, Version 1.3, 1999.
Hindmarsh, A. C. et al.: "SUNDIALS: Suite of Nonlinear and
Differential/Algebraic
Equation
Solvers," ACM Transactions on
Mathematical Software, 2005. Also
available as LLNL technical report
UCRL-JP-200037,
http://www.llnl.gov/CASC/sundials/
Petzold, L.R.: A description of
DASSL: A differential/algebraic system solver, in IMACS Trans. Scientific Computing Vol. 1 (1993), pp.
65-68.
Gear, C.W.; Petzold, L.R.: ODE
methods for the solution of differential/algebraic systems, SIAM Journal
on Numerical Analysis, 21 (1984) 4,
716 – 728
Wittwer, C.: ColSim – Simulation
von Regelungssystemen in aktiven
solarthermischen Anlagen. Dissertation Universität Karlsruhe (TH),
1999. www.ubka.uni-karlsruhe.de.
http://www.w3.org/TR/soap
http://www.globus.org
Vetter, M.: Modellbildung und Regelstrategien für erdgasbetriebene
Brennstoffzellen-Blockheizkraftwerke, Dissertation Universität
Karlsruhe (TH), erscheint Anfang
2005.
Muche, L.; Schneider, P..; Vetter,
M.; Wittwer, C.: Modellierung und
Simulation der Energieversorgung
von Gebäuden mittels Brennstoffzellensystem. Proc. 5. GMM/ITG/GIWorkshop "Multi-Nature Systems",
18. Februar 2005, Dresden, 2005.
Künzel, H.M.: Simultaneous Heat
and Moisture Transport in Building
Components. - One- and twodimensional calculation using simple
parameters. IRB Verlag, 1995.

The Modelica Association

535

[13]

Nytsch-Geusen, C.; Bartsch, G.: An
Object Oriented Multizone Thermal
Building Model based on the Simulation Environment SMILE. Proceedings of Building Simulation
2001, International Building Performance Simulation Association,
Rio de Janeiro, 2001.
Nytsch-Geusen, C.; Doll, U.; Leopold, J.: Anwendung generischer
Simulationstools zum Werkzeugdesign, Chemnitzer Produktionstechnisches Kolloquium, 2004.

Modelica 2005, March 7-8, 2005

The Modelica Association

536

Modelica 2005, March 7-8, 2005

Session 7a
Electrical Systems

The Modelica Association

537

Modelica 2005, March 7-8, 2005

The Modelica Association

538

Modelica 2005, March 7-8, 2005

Standard Package Modelica.Electrical.Digital

Standard Package Modelica.Electrical.Digital
Christoph Clauß1), Ulrich Donath1), André Schneider1), Enrico Weber2)
1) Fraunhofer Institute for Integrated Circuits, Branch Lab Design Automation
Zeunerstraße 38, D-01069 Dresden, Germany
2) University of Applied Sciences, Technikumplatz 17, D-09648 Mittweida
{clauss, donath, schneider}@eas.iis.fraunhofer.de

Abstract

2

According to the IEEE 1164 standard the Modelica.Electrical.Digital library was developed which uses
nine-valued logical signals. The first stage of extension
contains basic gate devices, sources, delay devices, and
convertes. The main principles of implementation are
demonstrated as well as some examples which show
some possibilities of usage. Using converters, the electrical digital components are capable of interacting
with the components of other Modelica libraries.

The nine digital signal values are 'U' (uninitialized), 'X'
(forcing unknown), '0' (forcing 0), '1' (forcing 1), 'Z'
(high impedance), 'W' (weak unknown), 'L' (weak 0),
'H' (weak 1), '-' (don’t care).

1

Overview

The library is devided into:
• delay models (transport, inertial, sensitive inertial)
• basic gates without delay (Not, And, Nand,
Or, Nor, Xor, Xnor)
• basic gates including intertial delay (InvGate,
AndGate, NandGate, OrGate, NorGate, XorGate,
Xnorgate, BufGate)
• sources (Set, Step, Table, Pulse, Clock)
• converters (for connections with Boolean, and with
Real, and for the restriction of the digital logic values to ’X01’ or to ’X01Z’ or to ’UX01’)
• auxiliary subpackages of interface definitions and
tables
• examples

Introduction

The Modelica language [1], [2] already allows the formulation of logic behaviour using both the predefined
Boolean variable type (true, false) and Boolean operators (or, and, not). For many applications these
possibilities are sufficient. However, the description of
complex digital electronic behaviour requires a very
extension of the simple Boolean logic. The reason is
that some of the properties of electronic circuits have
to be transmitted to the logic approach, e.g. the existence of an unknown signal state, of different signal
strengths etc..

The model definition can be seen in the library. Some
of the models are explained in detail within the next
paragraph. The icons of some models can be seen in
Fig. 1. Most of the icons correspond to the European
standard [8].

Considering the VHDL language, the IEEE 1164
standard [3], [4], [5], [6], [7] is generally accepted and
widely used for the description of digital electronic devices. It is based on nine-valued logical signals and
defines the behaviour of simple and more general digital devices including time-dependencies. Due to the
importance of this standard the digital electronic library should be developed in accordance with it.

The digital library will be developed in at least two
steps. The first step contains the devices mentioned
above. Components like flip-flops, transfer gates,
memories (RAM, ROM), and multiplexers are still
missing. The behavioural models of these components
will be added within the second step of library development. At the present stage such devices must be
composed using the available gates. Examples of such
compositions can be found in the example subpackage.

In this paper an overview is given on the devices availiable. Details of the implementation are presented as
well as some questions of the usage in combination
with other libraries. Many examples give an impression
of the actual state of the library.

3

Details of Implementation

The basic idea was to offer a library of digital logic devices which can be placed and connected by the user to
model a digital logic scheme. Otherwise, Modelica also
allows to create models in a netlist like way by instan-

The Modelica Association

539

Modelica 2005, March 7-8, 2005

C. Clauß, U. Donath, A. Schneider, E. Weber

SET
Tra...
Del...

Ine...
Del...

Ine...
Del...
se...
Trans portDela... InertialD elay1 InertialDelayS...

Set1

Step1

Table1

Puls e1

1

&

&

>=1

>=1

=1

=

N ot1

And1

N and1

Or1

N or1

Xor1

Xnor1

1

&

&

>=1

>=1

=1

=

InvGate1

AndGate1

N andGate1

OrGate1

N orGate1

XorGate1

XnorGate1

LogicToXO1_1 Logic ToXO1Z1 Logic ToUX01_1 BooleanToLo... LogicToBoole... R ealToLogic1 LogicToR eal1

Figure 1: Components of the Modelica package Modelica.Electrical.Digital.
tiating and connecting devices on a text level. In both
cases, a network of digital devices can be described on
its connections where digital logic signals are transmitted. In this paragraph the behavioural modelling of
some devices is shown exemplarily.

constant Logic
constant Logic
constant Logic
constant Logic
end LogicValue;

"Weak
Unknown";
"Weak
0";
"Weak
1";
"Don't care";

The sequence coded in this record corresponds to the
IEEE 1164 sequence. This way simplifies the adaptation of logic value tables from the standard. Later on
this record definition could be replaced by an enumeration type definition.

Since the number of logic values is limited signals do
not change continuously but at discrete event times.
Furthermore, nothing has to be differentiated. To calculate the output of digital devices an intensive usage of
the algorithm section is necessary in the models. The
simulator’s task is not to solve a DAE but a system of
algebraic equations at discrete event time, whose dimension is normally high and which contains lots of
conditional clauses.

3.1

'W'=6
'L'=7
'H'=8
'-'=9

At the connections (ports) of the devices logic values
are transmitted. Therefore, connectors are defined
which only need a logic value signal. Since in most cases the signal flow direction is well defined, input and
output connectors are specified:

Signals and Connectors

connector DigitalSignal=Logic
"Digital port (both input/output
possible)";
connector DigitalInput=input DigitalSignal;
connector DigitalOutput=
output DigitalSignal;

The nine logic values are coded using an integer logic
type:
type Logic = Integer

The signals at the connectors are scalar ones. If vectors
of signals are needed vectors of connectors have to be
defined. This idea is taken over from the Modelica.Blocks library. The usage of both scalar and vector
connectors can be seen at the following partial model
for multiple input - single output devices which is used
for modeling of Basics and Gates:

record LogicValue
constant Integer min=1;
constant Integer max=9;
constant Logic 'U'=1 "Uninitialized";
constant Logic 'X'=2 "Forcing Unknown";
constant Logic '0'=3 "Forcing 0";
constant Logic '1'=4 "Forcing 1";
constant Logic 'Z'=5 "High Impedance";

The Modelica Association

540

Modelica 2005, March 7-8, 2005

Standard Package Modelica.Electrical.Digital

for i in 1:n - 1 loop
auxiliary[i + 1] =
D.Tables.AndTable[auxiliary[i],x[i + 1]];
end for;
y = pre(auxiliary[n]);
end And;

partial block MISO
import D = Modelica.Electrical.Digital;
parameter Integer n(final min=2) = 2
"Number of inputs";
D.Interfaces.DigitalInput x[n];
D.Interfaces.DigitalOutput y;
end MISO;

3.2

The And model inherits the MISO partial model (c.f.
3.1). Within a loop to the first two input signals the and
operation is applied. To the result and the next input
signal the and operation is applied again, until all inputs are combined. Like in the Not model the preoperator is used . The and-operator is realised using the
AndTable. The code numbers of the input signals define the position (both row and line number) in the
matrix where the result can be found. Written in an abbreviated form the AndTable is:

Basics

In the Basics subpackage the simple logic operations
Not, And, Nand, Or, Nor, Xor, and Xnor are modeled.
The Not model is a single-input-single-output model.
The logic input value, which is an integer between 1
and 9, specifies the row in the NotTable in which the
output value can be found that negates the input value.
The Modelica text of the Not device is:
model Not
import D = Modelica.Electrical.Digital;
import L = D.Interfaces.LogicValue;
extends D.Interfaces.SISO;
protected
D.Interfaces.Logic
auxiliary(start=L.'0');
equation
auxiliary = D.Tables.NotTable[x];
y = pre(auxiliary);
end Not;

U
U

X
X

0
1

1
0

Z
X

W
X

L
1

H
0

X

X

0

1

Z

W

L

H

-

i
n
p
u
t
2

U
U
0
U
U
U
0
U
U

U
X
0
X
X
X
0
X
X

0
0
0
0
0
0
0
0
0

U
X
0
1
X
X
0
1
X

U
X
0
X
X
X
0
X
X

U
X
0
X
X
X
0
X
X

0
0
0
0
0
0
0
0
0

U
X
0
1
X
X
0
1
X

U
X
0
X
X
X
0
X
X

U
X
0
1
Z
W
L
H
-

3.3

Regarding that the input code is used as index in the
NotTable array, this is described in Modelica:

Delays

In the library there are three delay models. The transport delay model is an application of the Modelica
delay operator. The input signal is delayed by delayTime exactly as it is. The output of the model can be
specified for the time interval between zero and delayTime. The algorithm section of the TransportDelay
model is:

constant D.Interfaces.Logic
NotTable[L.max]=
{L.'U',L.'X',L.'1',L.'0',L.'X',
L.'X',L.'1',L.'0',L.'X'};

In the model the result is not put to the output directly
but the pre-operator is applied to an intermediate variable. This is necessary to avoid algebraic loops which
can appear in some cases. Therefore, the pre-operator
is generally used.

algorithm
x_delayed := integer(delay(x, delayTime));
y := if delayTime > 0 then
if time >= delayTime then x_delayed
else y0
else x;

As an example with multiple inputs the And model is
explained. The source code is without any annotations:

Another type of delay models is the inertial delay. In
the InertialDelay model the input value must keep constant for the delayTime interval before it is passed on
the output. The Modelica code of the inertial delay is:

model And
import D = Modelica.Electrical.Digital;
import L = D.Interfaces.LogicValue;
extends D.Interfaces.MISO;
protected
D.Interfaces.Logic
auxiliary[n](each start=L.'U');
equation
auxiliary[1] = x[1];

The Modelica Association

U

In the models Nand, Nor, and Xnor the NotTable is applied to the result of the And-, Or-, and Xor-tables
respectively.

The NotTable is defined in the IEEE 1164 standard:
input:
output:

input1

block InertialDelay
import D = Modelica.Electrical.Digital;
import I = D.Interfaces;
import L = D.Interfaces.LogicValue;
extends DI.SISO;

541

Modelica 2005, March 7-8, 2005

C. Clauß, U. Donath, A. Schneider, E. Weber

r
e

parameter Modelica.SIunits.Time
delayTime=0 ;
parameter DI.Logic y0=L.'U';
protected
DI.Logic y_auxiliary(start=y0, fixed=true);
DI.Logic x_old(start=y0, fixed=true);
discrete Modelica.SIunits.Time
t_next(start=delayTime, fixed=true);
algorithm
when delayTime > 0 and change(x) then
x_old := x;
t_next := time + delayTime;
elsewhen time >= t_next then
y_auxiliary := x;
end when;
y := if delayTime > 0 then y_auxiliary
else x;
end InertialDelay;

Z
W
L
H
-

3.4

0 0 -1
0 0 -1
1 1 0
-1 -1 -1
0 0 -1

1 0 0 -1
1 0 0 -1
1 1 1 0
0 -1 -1 -1
1 0 0 -1

1 0
1 0
1 1
0 -1
1 0

Gates

In the Gates subpackage there are collected the InvGate, AndGate, NandGate, OrGate, NorGate, XorGate,
XnorGate, and the BufGate. Each of the gates is graphically composed by a basic logic model whose output
is delayed by a sensitive inertial delay. The InvGate
consists of a Not model with delayed output. As a special case the BufGate consists only of a sensitive
inertial delay. For the sake of completeness the BufGate should belong to that subpackage. In Fig. 3 the
composition of Gates is demonstrated considering the
AndGate as an example. The strange connecor at the
left hand site is an interim solution of painting vectors
of connectors.

If the input signal x changes its value, the variable
t_next is set to that time at which the output should
change, that means at time + delayTime. If the time
reaches t_next without another input change then the
input change becomes active at the output. Otherwise if
x changes before t_next, t_next is increased due to the
new input change. In Fig. 2 an example of an inertial
delay with delayTime=1s is shown. Input changes
smaller than 1s are neglected.

&
Inertial
Delay
sens itive

G1

G2

Figure 3: AndGate

3.5

The sources Set, Step, Table, Pulse, and Clock are not
borrowed from the standard but written as nice-to-have
sources. The Set source simply sets a logic value. Step
steps one-time from one value to a second value at a
given time. The Table source follows a user specified
value-time-table. The essential part of the Modelica
code of the Table model is (after checking the acceptance of parameters):

Figure 2: Inertial delay example
A generalization of the inertial delay is the sensitive intertial delay InertialDelaySensitive. For rising and
falling edges different delay times can be specified.
With a delay table it is decided whether a signal changing is regarded as rising (1) or falling (-1) or indifferent
(0). Indifferent changes are not delayed. The delay table used in this library is:
after
b
e
f
o

U
X
0
1

U

X

0

0 0 -1
0 0 -1
1 1 0
-1 -1 -1

1

Z

W

L

1 0 0 -1
1 0 0 -1
1 1 1 0
0 -1 -1 -1

The Modelica Association

H

Sources

algorithm
y := y0;
for i in 1:n loop
if time >= t[i] then
y := x[i];
end if;
end for;
end Table;

-

1 0
1 0
1 1
0 -1

542

Modelica 2005, March 7-8, 2005

Standard Package Modelica.Electrical.Digital

With the Pulse source arbitrary pulsing between two
values can be created. The Pulse parameters are shown
in Fig. 4.

input:
output:

U
f

X
f

0
f

1
t

Z
f

W
f

L
f

H
t

f

Further conversions are possible between Real and
Logic values. In the LogicToReal converter the Real
output jumps to a real number wich can be defined by
the user for each of the nine logic values. The default
values are:
input:
output:

U X
.5 .5

0
0

1 Z W
1 .5 .5

L
0

H 1 .5

The RealToLogic converter has two limits: an upper
limit, and a lower limit. If the input x is x > upper limit,
an upper_value is chosen, If x < lower limit, a lower
value is chosen, otherwise the middle_value is chosen.
The limits and the values are parameters of the converter. In Figure Fig. 5 a sine curve is converted to logic
using the default parameters (lower_limit=0,
upper_limit=1, lower_value=’0’, upper_value=’1’,
middle_value =’X’).

Figure 4: Pulse Source Parameters
The Clock source is a simplified Pulse source without
counting the number of periods which pulses between
’0’ and ’1’. The code for generating the pulsing behaviour of Clock is:
Modelica.SIunits.Time t_i
(final start=startTime)
"Start time of current period";
Modelica.SIunits.Time
t_width=period*width/100;
algorithm
when sample(startTime, period) then
t_i := time;
end when;
y := if time < startTime or
time >= t_i + t_width
then L.'0' else L.'1';
end Clock;

3.6

Converters

Figure 5: Default Real to Logic Conversion

The IEEE 1164 like converters LogicToUX01,
LogicToX01Z, and LogicToX01 map the nine-valued
digital logic to the limited sets of values {’U’, ’X’, ’0’,
’1’}, {’X’, ’0’, ’1’, ’Z’}, or {’X’, ’0’, ’1’} respectively.
The mapping is done with conversion tables. E.g. the
conversion table for LogicToX01 is:
input:
output:

U
X

X
X

0
0

1
1

Z
X

W
X

L
0

H
1

4

The components of the electrical digital library can be
combined to form more complex models. This is possible on the text level, or in a graphical way.
Since complex devices like flipflops, multiplexers,
memories, ... are still missing, such components have
to be composed using the set of basic gates. In the example package some of these components are
available.
Furthermore, the user can modify the models by
changing the description, adding pins, introducing parameters, fixing parameters...
The signal strengh according to the IEEE 1164 strength
table is not modeled yet, since no resolution function is
implemented. This will be added in a later version of
that library.

X

The following converters are not from the IEEE 1164
standard.
The BooleanToLogic converter maps the Boolean input
to Logic according to the following table (t - true, f false):
input:
output:

t
1

Usage

f
0

The LogicToBoolean converter maps the Logic input
to the Boolean output according to the following table
(t - true, f - false):

The Modelica Association

543

Modelica 2005, March 7-8, 2005

C. Clauß, U. Donath, A. Schneider, E. Weber

Sometimes it is possible that algebraic loops occur
which can be not solved by the simulator. In such cases
often the inclusion of additional delay components
helps.
The whole variety of the possibilities of the library usage is not presented. Some aspects of the library usage
are demonstrated in the examples.

5

connect(And2.y, Or1.x[1]);
connect(AndB3.y, Or2.x[1]);
connect(Not.y, And2.x[2]);
X = Or2.y; Y = Or1.y;
end LogicEquivalence;

More instructive is the graphical representation like
Fig. 6 which is normally used to model digital circuits:

A

Examples

>=1

TabA

B

The examples are part of a validation suite, some of
them are furthermore part of the library example subpackage. They show some of the possibilities of the
library. Since the library is developed recently further
tests e.g. with ’large’ logic designs are necessary. Test
examples were developed using wellknown textbooks
[9], [10], [11]. All examples presented here were simulated using the simulator Dymola5.3a [12].

TabB

And1
1

Y

Or1

&

>=1

And2

Or2

X

Not

C
TabC

5.1

&

&

Logic Equivalence

This simple example tests the logic equivalence
AB ∨ AC ∨ BC = AB ∨ AC by modeling both sides
X = AB ∨ AC ∨ BC and Y = AB ∨ AC of the logic
equation with basic components.

And3
Figure 6: Logic Equivalence Circuit
The simulation result are the outputs X and Y of both
Or components which are equivalent. Furthermore the
input values of TabA, TabB, and TabC are shown
which correspond to A, B, and C:

The following Modelica text shows the circuit description without graphical instructions. The instantiation of
library components can be seen as well as the usage of
parameters. Once instantiated the devices are connected in the equation part.
model LogicEquivalence
import DD=Modelica.Electrical.Digital;
DD.Basic.And And1, And2, And3;
DD.Basic.Or Or1, Or2(n=3);
DD.Basic.Not Not;
DD.Sources.Table TabB
(x={3,3,4,4,3,3,3,3,3,4,4,4,4,3,3},
t={0,1,2,3,4,5,6,7,8,9,10,11,12,13,14});
DD.Sources.Table TabA
(x={3,3,4,4,4,4,4,3,3},
t={0,1,2,3,4,5,6,7,8},);
DD.Sources.Table TabC
(x={3,3,4,3,3,4,3,3,3,3,4,3,3,3,4,3,3},
t={0,1,2,3,4,5,6,7,8,9,10,11,
12,13,14,15,16});
DD.Interfaces.Logic X, Y;
equation
connect(TabA.y, And1.x[2]);
connect(TabA.y, Not.x);
connect(TabB.y, And1.x[1]);
connect(TabB.y, And3.x[2]);
connect(TabC.y, And2.x[1]);
connect(TabC.y, And3.x[1]);
connect(And1.y, Or1.x[2]);
connect(And1.y, Or2.x[3]);
connect(And2.y, Or2.x[2]);

The Modelica Association

Figure 7: Simulation results of the
equivalence circuit

544

Modelica 2005, March 7-8, 2005

Standard Package Modelica.Electrical.Digital

5.2

Half-Adder

The results in Fig. 12 show the behaviour of the JKFlip-Flop: If J is ’0’ (coded by 3), the output q follows
K, if both inputs are ’1’ (coded by 4), the output is
clocked, if J is ’1’ and K is ’0’ the output becomes ’0’.

A half-adder can be found in the Examples.Utility
package. It is composed according to Fig. 8 using gates
with a delay of 0.5s.

=1

G...

XOR

&
S

RS

Q

And1

&
S

RS

Q

And3

&

&

R

R

RS2

And2

&

And4

RS1

1

G...

Not1

AND

Figure 10: JK-Flip-Flop

Figure 8: Half-Adder
Starting with ’Unknown’ at the signal inputs a and b,
and testing all combinations with ’0’ and ’1’ the behaviour is as expected, c.f. Fig. 9.

>=1

Nor1

>=1
Tra...
Del...

TD1

Nor2

Figure 11: RS-Flip-Flop

Figure 9: Half-Adder, Results

5.3

JK-Flip-Flop

A JK-Flip-Flop (with inputs j, k, and clock) is composed according to Fig. 10. It uses a static RS-FlipFlop which is shown in Fig. 11. Both components are
in the Examples.Utitlies package of the Digital library.

The Modelica Association

545

Modelica 2005, March 7-8, 2005

C. Clauß, U. Donath, A. Schneider, E. Weber

The JK-Flip-Flop described in Fig. 10 can be combined to a counter. Depending on the number of FlipFlops the number of digits can be chosen. Figure
Fig. 13 shows the schematic of a three-bit-counter.

J

JK

Q

K

JK

J

Q

J

K

FF1

JK

Q

K

FF2

FF3

Figure 13: Three-Bit-Counter
Within the schematic of Fig. 14 the three-bit-counter
output is taken as input of a full-adder. The full-adder
sums up the three outputs of the counter. The result can
be found in Fig. 15.

Figure 12: Results of the JK-Flip-Flop

SET

5.4

Adder with Counter
Enable

Two half-adders described in 5.2 and an or gate can be
combined to a full-adder which is able to add two digits
including a carry bit from a preceding full-adder. In
Fig. 12 the schematic of the full-adder is shown.
a

b

+

s

a

c

b

Adder1

+

+

a
E...

Counter3

b

s

C...

CLK

Counter

c...

c_...

Adder1

Figure 14: Counter with Adder

s

c

Adder2

>=1

OR

Figure 12: Full-Adder Schematic

The Modelica Association

546

Modelica 2005, March 7-8, 2005

Standard Package Modelica.Electrical.Digital

7

References

[1]

Elmqvist, H. et al.: Modelica - A Unified
Object-Oriented Language for Physical Systems Modeling. Version 2.1, January 2004.
http://www.Modelica.org
Otter, M.; Elmqvist, H.; Mattsson, S.E.: Objektorientierte Modellierung physikalischer Systeme, Teil 8. at Automatisierungstechnik
47(1999)9
IEEE Standard Multivalue Logic System for
VHDL Model Interoperability.
http://www.ieee.org
IEEE 1076-1993: IEEE Standard VHDL Language Reference Manual (ANSI). 288 p. ISBN
1-55937-376-8. IEEE Ref. SH16840-NYF.
IEEE 1164-1993: IEEE Standard Multivalue
Logic System for VHDL Model Interoperability (Std_logic_1164). 24 p. ISBN 1-55937-2990. IEEE Ref. SH16097-NYF.
Lipsett, R.; Schaefer, C.; Ussery, C.: VHDL:
Hardware Description and Design. Boston:
Kluwer, 1989, 299 p. ISBN 079239030X.
Navabi, Z: VHDL: Analysis and Modeling of
Digital Systems. New York: McGraw-Hill,
1993, 375 p. ISBN 0070464723.
Normen über graphische Symbole für die
Elektrotechnik, Schaltzeichen. DIN-Taschenbuch 514, Beuth Berlin, Wien, Zürich, 1994
Ashenden, P. J.: The Designer's Guide to
VHDL. San Francisco: Morgan Kaufmann,
1995, 688 p. ISBN 1-55860-270-4.
Horowitz, P.; Hill, W.: The Art of Electronics.
Cambridge University Press, 1989,
ISBN 0-521-37095-7
Tietze, U.; Schenk, C.: Halbleiter-Schaltungstechnik. Springer-Verlag Berlin, Heidelberg,
New York, 1980, ISBN 3-540-09848-8
Dymola: http://www.Dynasim.se

[2]

[3]

[4]

[5]

[6]

[7]

[8]
Figure 15: Results of the Counter with Adder
[9]

6

Summary

[10]

The digital electric library presented is part of the Modelica standard library. In this paper the devices and
their principles of implementation are explained. Some
examples show the usage of this library.

[11]

[12]

Although tested during development a wide usage is
desirable to get extensive experiences. Especially large
designes are needed as well as mixed applications with
other physical domains.
Once the first version of the digital library is accepted
it will be extended by behavioural models of flip-flops,
latches, transfer gates, tristate devices, multiplexers,
and memories. A discussion on principles will be expected concerning the introduction of a resolution
function at general nodes.
This work was supported by the Sonderforschungsbereich 358, Teilprojekt D4 of the Deutsche
Forschungsgemeinschaft. We are grateful to Dr. Peter
Schwarz, and Dr. Martin Otter for encouraging this
work, and to our students Teresa Schlegel, Liane Jacobi, and Hagen Staemmler for implementing and testing.

The Modelica Association

547

Modelica 2005, March 7-8, 2005

The Modelica Association

548

Modelica 2005, March 7-8, 2005

Modelica libraries for dc machines, three phase and polyphase machines

Modelica libraries for dc machines, three phase and
polyphase machines
C. Kral, A. Haumer
Arsenal Research, Faradaygasse 3, 1030 Vienna, Austria

Abstract
This paper presents two libraries, the basic Machines library which is released with Modelica
standard library 2.1 as well as an ExtendedMachines library, both for modelling electric machines. The basic library provides the basic machines types such as dc machines, three phase induction machines, three phase permanent magnet
synchronous machines and three phase reluctance
machines. The three phase machine models are
implemented on basis of space phasor theory. By
contrast, the extended machines library models
the winding topology of polyphase induction and
permanent magnet synchronous machines. Such
machine models can be used to simulate machines
with arbitrary phase number such as large six
phase induction machines or machines with winding asymmetries or even winding faults. The used
winding models of the ExtendedMachines library
are flexible enough to consider even higher field
harmonics in future impementations.

1

General

Each of the presented machine models considers
linear inductors. This means that neither saturation effects nor skin effects are considered yet.
Iron losses such as eddy current and hysteresis
losses are not taken into account. All resistive
parameters are assumed to be constant, therefore machines are modeled without thermal behavior. Friction and ventilation losses are not considered. For the basic Machines library symmetrical
three phase windings are assumed for induction
machines, synchronous machines and reluctance
machines. The extended library supports an arbitrary number of stator and rotor phases including
possible asymmetries.
Any leakage inductances and ohmic resistors of the
windings are modelled as discrete elements. These
The Modelica Association

elements are connected between machine terminals (MultiPhase plugs or regular pins) and the
air gap model.
All quantities accessible at the electrical and mechanical connectors are shown in physical units,
not as p.u. values. This allows the coexistence of
different machines in a complex system model.

2

Basic Machines Library

The basic elements of the Machines libraries are
the air gap models. These elements model the
magnetic main flux in the air gap including induced voltages and the electromagnetic torque
generation. This torque is directed to a mechanical flange connector representing the shaft as
well as to a second mechanical support connector,
representing the housing respectively the machine
legs or flange where the reaction torque is noticeable. The airgap’s flange is connected to the rotor’s inertia, which is connected to the machine’s
flange (i.e. shaft). The airgap’s support now is
implicitly fixed but allows to add a support connector for the whole machine in the next release.
Adding a support connector for the whole machine, besides the rotor’s inertia also the stator’s
inertia will be needed as a parameter.
The Basic Machines library is structured as follows:

549

• BasicMachines.AsynchronousInductionMachines containing machine models
• BasicMachines.SynchronousInductionMachines containing machine models
• BasicMachines.DCMachines containing machine models
• BasicMachines.Components contains elements like air gaps, squirrel cage and permanent magnet
Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer

• the voltage drop of the excitation winding due
• Sensors provides voltage and current RMS
to the time derivative of the magnetic main
sensors (using space phasor functions), elecflux, and
trical and mechanical power sensor, as well as
a sensor calculating the phase angle between
• the electromagnetic torque which is directed
the rotor and the rotating field. Voltage and
to flange and support.
current RMS sensors actually calculate the
1
√ -fold of the magnitude of the current and
The armature voltage equation reads:
2
voltage space phasor, respectively. The outdia
puts of these sensors equal the RMS values of
va = Ra ia + La
+ va.i
(1)
dt
the currents and voltages for sinusoidal and
stationary operation (only).
where Ra ia and La didta are modelled as discrete elements and va.i is calculated by the air gap model.
• SpacePhasors.Components provides the baThe excitation voltage equation reads:
sic transformation element between three
phase instantaneous voltages and currents
ve = Re ie + ve.i
(2)
and their space phasor representation, includwhere Re ie is modelled as discrete element and the
ing zero sequence system
induced (inner) voltage ve.i is calculated by the air
• SpacePhasors.Blocks implements space gap model. Excitation voltage equation (2) is used
phasor transformation blocks to support the for electrically excited dc machines, only.
design of controllers
The air gap model uses the following voltage equations:
• SpacePhasors.Functions provides the same
functionality as blocks but implemented as
functions for use in initial equations
va,i = TurnsRatio · ψe ω
(3)
dψe
• Interfaces defines the space phasor connecve,i =
(4)
dt
tor as described later as well as some partial
machine models, defining the common me- as well as the flux linkage equation:
chanical connectors
ψe = Le ie
• Examples demonstrate the usage of the machine models as well as some utilities (used and the torque equation:
for the examples)
τ = TurnsRatio · ψe ia

(5)

(6)

All machine models ensure correct initialization Parameter TurnsRatio (between armature and
and efficient integration by using appropriate excitation winding) is calculated internally from
stateSelect-modifiers.
rating plate values. For an electrically excited dc
machine the defining equation is:

2.1

DC Machines

For the dc machines an air gap model is used which
evaluates the (perpendicular) two axis equations
of the armature and field excitation circuit. The
air gap model has two electric pins, for the armature and the field excitation circuit each. The
mechanical connectors flange and support are
connected with the rotor’s inertia and the implicitly fixed housing, respectively. The equations of
the air gap model considers

va,nom − Ra ia,nom =TurnsRatio
· (Le ie,nom ) ωnom

(7)

Therefore the electrical parameters of the dc machine models are the armature resistance Ra and
field excitation resistance Re (except permanent
magnet machine), armature inductance La , field
inductance Le (except permanent magnet machine) as well as nominal values from the rating
plate: va,nom , ia,nom , ωnom and ie,nom (only for
• the induced voltage of the armature (electro- electrically excited dc machines).
motive force and emf va.i , respectively) due The Machines library provides the following types
to magnetic field and rotor movement,
of dc machines:

The Modelica Association

550

Modelica 2005, March 7-8, 2005

Modelica libraries for dc machines, three phase and polyphase machines

The mathematically correct formalism of space
phasor theory requires a third transformed quantity, because the three original quantities (index
1,2 and 3) have to be linearly transformed into
three transformed quantities. The third quantity
• DC SeriesExcited: model of an electrically
is the zero sequence component:
excited dc machine with series excitation; the
1
only to difference to DC ElectricalExcited
v0 = (v1 + v2 + v3 )
(9)
is a modified assignment of parameters due to
3
different rating plate data.
Any zero sequence quantity does not contribute
• DC PermanentExcited: the magnetic field to the fundamental of the main field due to the
is provided by a permanent magnet which symmetry of the windings.
is modelled internally as a constant current From (8) and (9) we determine the equations for
back transformation:
source in the field excitation circuit.
• DC ElectricalExcited: model of an electrically excited dc machine which can either be
connected as separate excited or shunt excited machine.

2.2

v1 = v0 + Re (v)


v2 = v0 + Re e−j2π/3 v


v3 = v0 + Re ej2π/3 v

Induction Machines

All three phase machines of the basic Machines
library rely on space phasor theory [1]. For each
system of three instantaneous voltages v1 , v2 and
v3 a space phasor (indicated by underline) can be
defined:
2
v = (v1 + ej2π/3 v2 + e−j2π/3 v3 )
(8)
3
The factor 32 in this equation is an arbitrary factor
which is due to normalization reasons. Similar to
(8) a space phasor of three instantaneous currents
can be defined. The current space phasor can be
interpreted as a vector representing the fundamental harmonic of the magnetomotive force (mmf) of
the three phase currents. The direction of the phasor represents the phase angle, the length of the
phasor represents the peak value of the fundamental mmf.
Therefore a space phasor connector is defined in
the library. Both the voltage and the current space
phasors are combined in the SpacePhasor connector. Real and imaginary part of voltage and
current are stored in two elements of an array, respectively.
Space phasor theory is not restricted to any waveforms of voltages and currents in the time domain.
Due to a given winding topology mainly the fundamental space harmonics of the electromagnetic
quantities such as flux density and the mmf are
physically present [2]. The harmonics of the electromagnetic quantities refer to the spatial domain
along the tangential direction in the air gap. The
restriction of space phasor theory is, that it only
takes the fundamentals of these quantities into account. Higher harmonic components cannot be
considered.
The Modelica Association

(10)
(11)
(12)

Transformations
(8)
and
(9)
and
(10)–(12)
are
modelled
in
element
SpacePhasors.Components.SpacePhasor.
To describe the machine’s behavior, first we need
an equation for the stator voltages of the three
phases (i ∈ [1, 2, 3]):
vSi = RS iSi +

dψSi
dt

(13)

Applying transformation (8) – neglecting the zero
sequence system at the moment – on (13), we obtain the stator voltage space phasor equation in
a stator fixed reference (coordinate) system (indicated by index (S)):
v S(S) = RS iS(S) +

dψ S(S)

(14)

dt

It is possible to split the stator flux linkage ψ S(S)
into main flux ψ m(S) and leakage flux:
ψ Sσ(S) = Lsσ iS(S)

(15)

This leads to:
v S(S) = RS iS(S) + LSσ

diS(S)
dt

+

dψ m(S)
dt

(16)

Similarly we obtain the rotor voltage equation using space phasors in a fixed rotor reference (coordinate) system (indicated by index (R)):

551

v R(R) = RR iR(R) + LRσ

diR(R)
dt

+

dψ m(R)
dt

(17)

Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer

The main flux linkage depends on the sum of stator and rotor phase current, formulated in a common reference (coordinate) system:
 

ψ m = Lm (iS + iR )

(18)


	

At last we need an equation for the electromagnetic torque; this may be done by setting up power
balance:




	

 !"

S

#
$

	 




pel = vS1 iS1 + vS2 iS2 + vS3 iS3
+ vR1 iR1 + vR2 iR2 + vR3 iR3

 


(19)

%&'()*

After some transformations we obtain:
pm = mel ωm


3
τel = p Im iS ψ ∗m
2

(20)
(21)

In the latter equation p represents the number
of pole pairs. This equation is valid in any arbitrary reference frame. To avoid transformation
of (16) to the rotor fixed reference frame, or, alternatively to transform (17) to the stator fixed
reference frame – obeying the product rule of differentiation – the ohmic resistors RS and RR as
well as the leakage inductances LSσ and LRσ are
modelled as discrete three phase elements outside
the air gap. The next element of the modelled
voltage equation transforms the three phase system into space phasors which are connected with
the air gap model (fig. 1).
The air gap model using the stator fixed reference frame BasicMachines.Components.AirgapS
transforms the rotor current space phasor iR(R)
to the stator fixed reference frame and calculates
main flux linkage ψ m(S) from (18). Then it is pos-

 
 

Figure 1: Asynchronous induction machine with
squirrel cage; basic Machines library
The angular displacement between the rotor and
the stator reference frame is:
Z
γ = ωm dt
(22)
The transformation of a space phasor from a rotor
fixed coordinate system to a stator fixed reference
frame is performed by:
ψ m(S) = ψ m(R) ejγ

(23)

The inverse transformation therefore is:

dψ

m(S)
sible to calculate dt
and – after the transformation of ψ m(S) to the rotor fixed reference frame

ψ m(R) = ψ m(S) e−jγ

(24)

Although the zero system quantities do not contribute to the fundamental of the main field,
they may give rise to additional leakage flux linkage components, though. Therefore, zero sequence connector zero is also provided in the
SpacePhasor transformation model. If the zero
sequence component connector is grounded, which
dψ m(R)
to calculate dt and – after transformation of is the regular case, no additional leakage flux linkψ m(R) to the stator fixed reference frame – the ages are taken into account [3].
Standard machine parameters are stator and rotor
dψ m(S)
term dt
.
resistance Rs and Rr , stator and rotor leakage inAdditionally, both air gap models calculate the ductance Lsσ and Lrσ , the main inductance Lm
electromagnetic torque from (21).
as well as the number of pole pairs p and rotor
dψ

– the term m(R)
dt .
The air gap model using the rotor fixed reference frame BasicMachines.Components.AirgapR
transforms the stator current space phasor iS(S) to
the rotor fixed reference frame and calculates main
flux linkage ψ m(R) from (18). Then it is possible

The Modelica Association

552

Modelica 2005, March 7-8, 2005

Modelica libraries for dc machines, three phase and polyphase machines

inertia J. The following models of asynchronous
induction machines are provided in the Machines
library:
• AIM SquirrelCage (asynchronous induction
machine with squirrel cage): The squirrel
cage is modelled as equivalent two axis winding model in the rotor circuit; the rotor is not
accessible.
• AIM SlipRing (asynchronous induction machine with wound rotor winding and slip
rings): The rotor is equipped with a symmetrical rotor winding; this winding topology
requires an additional parameter TurnsRatio
which represents the effective ratio of stator
to rotor turns of the respective three phase
windings.

2.3

34

34

5678

:99+;<0

.9

3
4
23

3
4
23

5677

=>

=>

5688
+,-./+0
=>

BCDE

121

9/0.

3
2=>

;.?@,A

F+G-AH?@9+,;IJ

Permanent Magnet Synchronous Figure 2: Extended model of a squirrel cage inMachine
duction machine

The permanent magnet synchronous machine has
the same stator winding topology as an asynchronous induction machine. Since the developed
models are equipped with a damper winding, rotor winding topology is comparable with a squirrel
cage induction machine. Synchronous machines
without damper cage have to have control in order to work stable; they are therefore not provided
in the current basic Machines library.
Saliencies of the rotor are considered through different main field inductances in the d- and q-axis
(direct and quadrature axis) Lmd and Lmq . We
have to use the rotor fixed reference frame to consider these saliencies correctly.
Currently there are only two models provided:

The focus of this library is polyphase asynchronous and synchronous induction machines. The
provided types of machines are squirrel cage and
slip ring asynchronous induction machines as well
as permanent magnet synchronous machines. For
each of these models two implementations are provided. The symmetrical implementation assumes
symmetrical windings in the stator and rotor of
the polyphase induction machines. The winding
topology implementation models the topology of
each stator and rotor winding including possible
asymmetries and winding faults. For these reasons, space phasor theory is not applicable to the
• SM PermanentMagnetDamperCage: The per- ExtendedMachines library models any more.
manent magnet is modelled by means of a
superimposed constant current source in the
direct axis.
• SM ReluctanceRotorDamperCage (synchro3.1 Voltage Equations
nous induction machine with reluctance rotor): The rotor has a squirrel cage; electromagnetic torque in synchronism is generated It is assumed that neither the number of phases
of the stator ms nor the number of phases of the
due to saliencies of the rotor only.
rotor mr is restricted to three.

The voltage equations of the machines are modelled graphically. The used models which repreThe ExtendedMachines library models are not re- sent the partial voltage drops are based on equastricted to three phases and symmetrical windings. tions, though. Stator voltage equation for each of

3

Extended Machines Library

The Modelica Association

553

Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer

the i ∈ [1, 2, ..., ms ] stator phases is:
diSi
dt
mS
mR
X
diSj
d X
LSi,Sj
LSi,Rj iRj
+
+
dt
dt

vSi = RSi iSi + LSσi

j=1

(25)

j=1

In this equation LSi,Sj represents the mutual
inductance between the stator phases i and j.
For i = j this term equals the self inductance of stator phase i.
The voltage drops
across the inductances LSi,Sj are modeled through
VoltageEquations.SelfInductance. The syllable Self was chosen due to the fact the linkage
refers to only one machine side (either stator or
rotor), although mutual linkages are taken into
account. The instance viss of such model is implemented in the graphical model of the squirrel
cage induction machine, which shown in fig. 2.
The mutual inductance LSi,Rj between a stator
phase i and a rotor phase j is dependent of the
rotor angle (22). The voltage drops across this inductances with respect to the stator and rotor side
(linkage) are processed in the instant visr (fig. 2)
of VoltageEquation.MutualInductance. This
model computes torque and is connected with the
mechanical shaft (flange) and the support which is
currently fixed. Once the basic Machines library
provides a support connector of the machine, the
ExtendedMachines library will provide such a connector, too.
Rotor voltage equation has basically the same
structure as (25):
diRi
dt
mS
mR
X
diRj
d X
+
+
LRi,Rj
LRi,Sj iSj
dt
dt

vRi = RRi iRi + LRσi

j=1

∗
LSi,Sj = LwSi wSj ξpSi ξpSj Re(ξzSi ξzSj
)

(27)

In this equation L represents a base inductance,
wSi is the number of turns of phase i, ξpSi is the
pitch factor of phase i and ξzSi is a complex winding factor which considers the topology of phase
winding i with respect the stator reference frame.
The inductances of the rotor side are based on
equivalent equations. The mutual inductances of
the stator and rotor inductances have to take the
rotor angle (22) into account:
∗
LSi,Rj = LwSi wRj ξpSi ξpRj Re(ξzSi ξzRj
e−jγ ) (28)

The only difference between this equations and
(27) is the rotational phasor e−jγ . The inductances of (28) depend on the rotor angle (22) and
are therefore time dependent. Rotor skewing is
not considered. In (28) the rotor or stator skewing is not considered.
So far only the first order space harmonics waves
(fundamental) are taken into account. The machine models are going to be extended for higher
space harmonics; this will be implemented in the
near future.

(26)

j=1

3.2

This equations have to be applied to each
phase of the rotor winding. The voltage drop
across mutual inductances is processed in instant visr, the voltage drops across the mutual
and self inductances LRi,Rj of the rotor side are
processed in virr, which is also an instant of
VoltageEquations.SelfInductance.
The air gap model of the basic Machines library
is equivalent to the models viss, visr and virr
in fig. 2.
For a slip ring induction machine the voltage drop
across the rotor resistances RRi and the rotor
The Modelica Association

leakage inductances LRσi can be modeled in accordance with the stator model. For the squirrel cage asynchronous induction machine of fig. 2
these voltage drops are replaced by a sophisticated
model of the cage with mr = Nr rotor bars. This
model takes the connection of the bars and end
rings of the real squirrel cage into account.
The effort of the ExtendedMachines models is the
determination of parameters. In accordance to [4]
each inductance of the stator side is designed in
the fashion of:

Symmetrical Winding Models

The pitch factors of the symmetrical winding models are set to one without having any restrictions.
The symmetrical topology is considered by
ξzSi = e−j2πi/mS ,

(29)

the product of the number of turns and the base
inductance is derived from the magnetizing inductance Lm which is a (symmetrical) machine parameter.
The implemented models with respect to a symmetric winding are:

554

Modelica 2005, March 7-8, 2005

Modelica libraries for dc machines, three phase and polyphase machines
K

L

M

N

O

P

Q

R

S

KT KK KL

K

KM

KN KO KP KQ

KR KS LT LK LL LM LN LO LP LQ LR LS MT MK ML MM MN MO MP

KS
L

LT
M

LK

KT

LR
KK

LS
KL

MT

Figure 3: Topology of 7/9-pitch symmetrical three phase stator winding, phase 1

• AIM SlipRing: Same parameters as basic
Machines library; arbitrary numbers of stator and rotor phases are supported; symmetric winding
• AIM SquirrelCage: Same parameters as basic Machines library; arbitrary number of stator phases and rotor bars is provided; symmetric stator winding; rotor may be modelled
asymmetrically by overwriting rotor parameters
• SM PermanentMagnetDamperCage:
Same
parameters
as
SM PermanentMagnetDamperCage of the basic Machines
library; arbitrary number of stator phases
is supported; stator inductances are not
constant due to the saliency of the rotor,
which is considered; the rotor is equipped
with a damper cage with an arbitrary
number of bars; damper cage may be modelled asymmetrically by overwriting rotor
parameters

Structure wise there is no difference between the
symmetrical implementation the topology implementation. Just the handling and pre-calculation
of machine parameters is different. An example
of the topology of one phase winding (phase 1)
of a symmetrical three phase machine is shown
in fig. 3. The location of each coil of the phases
in terms of multiples of stator slots is indicated
by matrix yS [i, j]. The first index i indicates the
phase, the second index j represents the of the
number of the coil. The first row (phase 1) of
this matrix with respect to the depicted winding
in fig. 3 is:
yS [1, :] = [1, 2, 3, 19, 20, 21, 10,
11, 12, 28, 29, 30]
Since the orientations of the coils are not equal,
matrix e is defined, which defines the orientation
of each coil. In our example the first row (phase
1) of this matrix is:
e[1, :] = [ + 1, +1, +1, +1, +1, +1,

• SM PermanentMagnet:
Same parameters
as SM PermanentMagnetDamperCage, without
parameters of the damper cage, though

3.3

Winding Topology Models

The winding topology models can handle
polyphase machines and even stator asymmetries
and stator faults. For now, the only assumption
with respect to winding topologies is, that the coil
pitch of each winding has to be equal. Further developments will consider coils with unequal coil
pitches, too. However, the coil pitches of stator and rotor windings do not have to be equal,
though.
The Modelica Association

− 1, −1, −1, −1, −1, −1]
The orientation e[i, j] of a certain coil corresponds
with the location ys [i, j] and the respective number of turns (each coil has 12 turns):
wcS [1, :] = [12, 12, 12, 12, 12, 12,
12, 12, 12, 12, 12, 12]
If the magnetic field caused by any coil is oriented
up, the respective element in e equals +1, otherwise it equals −1. Parameter ycs = 7 means that
the coil pitch is seven slots. The total number of
stator slots Ns is a model parameter, too.

555

Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer

|
zuyY

For phase i the winding factors are:
ycs ms
)
Ns
2π
1 X
e[i, j]e−jpyS [i,j] Ns
=
wSi

ξcSi = sin(p

(30)

ξzSi

(31)

`
c_
d[\a^e]f
]

}
vY
yt~
w

`
Z
a]b
n
[[\]^_

j

gh]^\i
\[j]kf
op
oqron
l
]\a^f

The number of turns of i ∈ [1, 2, ..., ms ] is:
X
wSi =
wcS [i, j]

(32)

s
vVw
tu
xyz{u

j

Depending on the machine type, winding factors
and the numbers of turns for the polyphase stator and rotor winding are derived in the initial
sections of the machine models. These parameters are passed to the graphically modelled voltage
equations as shown in fig. 2.
Currently the following machines with winding
topology are modelled:

UVW
X
Y


 
q


v

~
uvs
tu
ty~
xY

l
]\a^m

s
vVw
tu
xyz{u

UVW
X

Y


 
q


v
~
uvs
tu
ty~
x

Figure 4: Direct start on line of squirrel cage in• AIM SlipRingWinding: Same parameters as
duction machines; AIMC1 from basic Machines
AIM SlipRing; additionally, winding topollibrary, AIMCE1 from ExtendedMachines library
ogy of stator and rotor winding has to be
provided through data vectors which determine the exact orientation and arrangement
and rotor phases are supported; additionally
of each coil.
winding topology of stator has to be provided
• AIM SquirrelCageWinding: Same paramethrough data vectors which determine the
ters as AIM SquirrelCage; additionally windexact orientation and arrangement of each
ing topology of stator has to be provided
coil; the machine has a damper cage; a
through data vectors which determine the exsymmetrical cage is predefined, certain paraact orientation and arrangement of each coil;
meters can be overwritten in the parameter
rotor topology has to be provided by the numwindow, though, in order to simulate an
ber of bars and the ratio of bar to end ring
asymmetrical damper cage.
resistance as well as the ratio of bar to end
ring leakage reactance; a symmetrical cage is
predefined, certain parameters can be over4 Example
written in the parameter window, though.
To show the usage of the libraries, we will demonstrate simulation of starting an asynchronous induction machine with squirrel cage direct on line.
Figure 4 presents the model using the basic Machines library as well as the ExtendedMachines library:
Each AIM SquirrelCage-model connected in delta
is electrically connected through one three phase
switch to a three phase sinusoidal voltage source
from the MultiPhase library. Mechanically each
machine is connected to an individual load, con• SM PermanentMagnetDamperCageWinding:
sisting of an inertia and a load torque which is
Same parameters as SM PermanentMag- quadratic dependent on speed. Standard machine
netWinding; arbitrary numbers of stator parameters are used. Load inertia is the same

• SM PermanentMagnetWinding: Same parameters as SM PermanentMagnet of the basic
Machines library; arbitrary numbers of stator phases are supported; stator inductances
are not constant due to the saliency of the rotor, which is considered; additionally winding
topology of stator has to be provided through
data vectors which determine the exact orientation and arrangement of each coil; the machine has no damper cage.

The Modelica Association

556

Modelica 2005, March 7-8, 2005

Modelica libraries for dc machines, three phase and polyphase machines





 





¡¢£



























 


¤



as the machine’s inertia, and nominal load torque
and speed are the same as the machine’s rated values. After 0.1 seconds the switch is closed, high
starting currents build up the magnetic field and
each motor is able to develop starting torque, accelerating the inertias. The extended machines
models was simulated with symmetrical stator
windings and 28 rotor bars. The resulting currents
of each machine are shown in fig. 5, the electrical
torques are shown in fig. 6. These results demonstrate that both machine models have the same
operational behavior.





5

Conclusions



The structure and basic equations of the basic Machines library using space phasors as well as the
ExtendedMachines were presented. The ExtendedMachines library deals also with polyphase maFigure 5: √12 -fold of the magnitude of the cur- chines with arbitrary numbers of stator and rorent space phasor of the modelled squirrel cage tor phases as well as asymmetrical or even faulty
machines (a) Machines library, (b) ExtendedMa- windings. The simulation results of both models
chines library
were compared and match qualitatively and quantitatively.
Further developments will focus on:








­¥¥




¹
¶
ªº¯» ½¾½¿ºÀÁ¿¯¾
²³´
µ·¸
¦
¦
¼










• Implementation of a mechanical support connector representing the housing

²³´
µ
¦

• Additional machine types like electrically excited synchronous machines

¬¥¥

§¥¥

• Modelling of iron, friction and stray losses

¥

§¥¥
«

• Modelling of saturation effects of main and
leakage inductances

®¯°
¬¥¥
«
¥¥¥
¦

­¥¥

¥§¨
¦

¥¨¥
¦

¥©¨
¦

ª¥¥
¦

• Modelling of skin effect in deep rotor bars

¹
¶·¸
Â
ªº¯» ½¾½¿ºÀÁ¿¯¾
¦
¼

• Coupling of the electromagnetic models with
thermal models [5]

¬¥¥

§¥¥

¥

• Modelling of higher field harmonics in space

§¥¥
«
®±
°
¬¥¥
«
¥¥¥
¦

¥§¨
¦

¥¨¥
¦

¥©¨
¦

ª¥¥
¦

References

Figure 6: Electrical torque of the modelled squir- [1] H. Kleinrath, Stromrichtergespeiste Drehfeldrel cage machines (a) Machines library, (b) Exmaschinen. Wien: Springer Verlag, 1980.
tendedMachines library
[2] C. Kral, “Derivation of the space phasor equations and the required parameters of a squirrel cage induction machine with faulty rotor
The Modelica Association

557

Modelica 2005, March 7-8, 2005

C. Kral, A. Haumer

bars,” Conference Proceedings of the International Symposium on Diagnostics for Electrical Machines, Power Electronics and Drives,
SDEMPED, pp. 395–400, 1999.
[3] H. Späth, Elektrische Maschinen.
Springer Verlag, 1973.

Berlin:

[4] C. Kral, Model and Behavior of an Induction
Machine with a Faulty Rotor Bar, Including
Detection by Means of the Vienna Monitoring
Method (in German). PhD thesis, Vienna University of Technology, 1999.
[5] C. Kral, A. Haumer, and M. Plainer, “Simulation of a thermal model of a surface cooled
squirrel cage induction machine by means of
the SimpleFlow-library,” Modelica Conference,
2005.

The Modelica Association

558

Modelica 2005, March 7-8, 2005

A Magnetic Library for Modelica

A Magnetic Library for Modelica
Thomas Bödrich
Dresden University of Technology, Institute
of Electromechanical and Electronic Design
01062 Dresden, Germany

Thomas Roschke
Saia-Burgess Dresden GmbH
Wilhelm-Liebknecht-Strasse 6,
01257 Dresden, Germany

Thomas.Boedrich@mailbox.tu-dresden.de

Thomas.Roschke@saia-burgess.com

Abstract
A Modelica library for modeling of electro-magnetomechanical actuators and drives is presented in this
paper. The model components in this library are
suited for actuator design itself as well as for
dynamic simulation of complete drive systems. For
modeling of the magnetic subsystem of actuators and
drives, the concept of magnetic flux tubes is used in
this library, leading to a network model of the
actuators magnetic subsystem. Both the method of
magnetic flux tubes and the developed library will be
presented below. As an example, modeling of an
industrial solenoid actuator will be explained.
Keywords: Magnetic library; Magnetic flux tube;
Magnetic network; Solenoid Actuator

1

Introduction

Electromagnetic motors and actuators convert
electrical energy via a magnetic field into
mechanical work (or vice versa for generators).
Different physical effects are utilized for this energy
conversion, depending on the structure of the
electromagnetic device. It is necessary to arrange the
interactions in the electro-magneto-mechanical
energy conversion process carefully during actuator
design in order to achieve an optimal solution. Also,
not only the actuator itself but also the environment
of the system to be developed must be considered
during design, too. For example, the efficiency of
electromagnetic actuators and drives can be
significantly increased by means of electronic
circuits for excitation and control. The complexity of
the above design task requires utilization of
computer-based modeling and simulation techniques

The Modelica Association

for both:
• design of the distribution of the magnetic field
inside the actuator, and
• dynamic simulation of the complete drive
system.
Latter task can be accomplished e. g. with the multidomain model description language Modelica and
accompanying simulation environments, where the
system to be simulated is described with a set of
differential and algebraic equations (DAE).
The problem for the design of magnetic actuators is,
however, that the distribution of the magnetic field is
described by partial differential equations
(Maxwell’s equations). Calculation and optimization
of such field distributions and resulting integral
quantities such as magnetic forces is necessary
during actuator design. Finite Element Analysis
(FEA) is a valuable tool for this task. However, the
high computational effort of FEA restricts its use in
most cases to stationary field calculations. Dynamic
simulation of a complete system incorporating a
detailed model of the actuators magnetic field and
detailed models of the feeding electronics and the
mechanical load to be moved is not possible with
reasonable effort using FEA.
To overcome the difficulties described above, the
method of magnetic flux tubes can be used for
actuator and system design [1]-[4]. This method
allows a simplified description of the magnetic field
inside a magnetic device so that the field distribution
can be described with a set of algebraic equations
rather than with the precise partial differential
equations. With this approach, the field distribution
in a magnetic actuator can be simulated together with
neighboring subsystems in one DAE system with
little computational effort. The accuracy is
reasonable for coarse design of actuators and for
system simulation.

559

Modelica 2005, March 7-8, 2005

Th. Bödrich, Th. Roschke

2

Magnetic Flux Tubes

A magnetic flux tube is a defined volume inside a
magnetic field with homogenous distribution of the
magnetic field strength H and the magnetic flux
density B within this region (Fig. 1).

describes the material properties (µ0 - permeability
of vacuum, µr - relative permeability, see
section 3.2). With the equations (3)-(5), the general
formula for a magnetic reluctance of any shape can
be given:

Rmag =

Vmag

Φ

A(s)

Φ

Rmag =

H, B

Fig. 1 Magnetic flux tube
Presuming that the principal distribution of the
magnetic field inside a magnetic device is known,
the magnetic field in the complete device can be
divided into a network of flux tubes. For each flux
tube element, a magnetic potential difference Vmag is
defined as an across variable:

Vmag = ∫ H ds = H l

(1).

s

The magnetic flux Φ through each cross sectional
area A of a flux tube is calculated as follows:

Φ = ∫ B dA

(2)

A

With the above across variable Vmag and the flow
variable Φ, a magnetic reluctance Rmag can be
defined analogue to resistive network elements in
other physical domains:

Rmag =

Vmag
Φ

=

∫ H ds
s

∫ BdA

(3).

A

Homogenous distribution of B and H through each
cross section inside a flux tube is one of the
assumptions of the flux tube approach. Hence,
equation (2) simplifies to

Φ = B( s ) A( s )

(4).

Maxwell’s constitutive equation

B = µo µr H

The Modelica Association

Φ

=∫
s

ds
µ 0 µ r ( s) A( s )

(6).

For a prismatic or a cylindrical volume of length l
and cross sectional area A with the magnetic flux
entering and leaving the region through its end
planes, equation (6) simplifies to

s
l

Vmag

(5)

l
µ 0 µ r ( B) A

(7).

As for the above example, equations for the
magnetic reluctance of other common geometries
can be found.
Similar lumped elements with the same magnetic
flow and across variables can be defined for sources
of a magnetic potential difference Vmag (see
section 3.3) or for sources of a magnetic flux Φ, if
needed. For a magnetic network consisting of at least
one source and one reluctance element, the field
distribution in a magnetic device can be calculated
with little computational effort according to
Kirchhoff’s laws.

3

Structure of the Magnetic Library

Based on the concept of magnetic flux tubes, a
Modelica library for modeling of magnetic
components and devices has been developed. The
structure of this library is shown in Fig. 2. Its
sublibraries and model components are described
only in short in this section; a more detailed
description of selected model components can be
found in section 4, where usage of the library
elements is explained with an example.
3.1

Interfaces Sublibrary

A domain specific magnetic connector was defined:
connector MagneticPort
Modelica.SIunits.MagneticPotentialDifference V_mag
"Magnetic potential at the port";
flow Modelica.SIunits.MagneticFlux Phi
"Magnetic flux flowing into the port";
end MagneticPort;

560

Modelica 2005, March 7-8, 2005

A Magnetic Library for Modelica

3.2

Basic Sublibrary

Most magnetic devices contain ferromagnetic
components that carry the magnetic flux imposed by
one or more coils or permanent magnets to a
working air gap where the desired magnetic force (or
torque for rotating machines) is generated. This is
because of the high relative permeability of
ferromagnetic material compared to that of vacuum
or air (µr = 1). However, the relative permeability for
each point of a ferromagnetic material is not constant
but depends on the actual magnetic field strength H
respectively the actual magnetic flux density B of
this point [2], [4]. The so called commutation curve
B(H) of a steel commonly used in magnetic devices
is shown in Fig. 3 as an example. According to
equation (5) this results in the characteristic shape
µr(H) of Fig. 3. Proper modeling of this nonlinear
relationship is crucial for the accuracy of flux
calculations and hence for the resulting magnetic
forces. In engineering practice, the relationship µr(B)
is often used instead of µr(H).

250

2.0

200

B(H)

1.5

150

1.0

100

µr(H)
50

0.5

0.0
0

Fig. 2 Structure and sublibraries of the Modelica
Magnetic library

20000

30000

40000

0
50000

Magnetic field strength in A/m

Based on the connector definition above, a base
model for all reluctance elements and selected source
elements is used throughout the library:
partial model MagneticFluxTube
"Component with two magnetic ports p and n and
magnetic flux Phi from p to n"
PositiveMagneticPort p "Positive magnetic port";
NegativeMagneticPort n "Negative magnetic port";
Modelica.SIunits.MagneticPotentialDifference V_mag
"Magnetic potential difference between the two ports";
Modelica.SIunits.MagneticFlux Phi
"Magnetic flux flowing from pin p to pin n";
equation
V_mag = p.V_mag - n.V_mag;
0 = p.Phi + n.Phi;
Phi = p.Phi;
end MagneticFluxTube;

The Modelica Association

10000

Relative permeability µr

Magnetic flux density B in T

2.5

Fig. 3 Magnetic flux density B vs. magnetic field
strength H and corresponding relative permeability µr for steel 1.0715 (9SMn28)
For the nonlinear reluctance elements in the Basic
sublibrary, the relationship µr(B) is approximated
with a function [4]. The Material sublibrary contains
the coefficients of this function for different
ferromagnetic materials. It is planned to implement
additional possibilities to describe the relationship
µr(B), e. g. spline interpolation.
3.3

Sources Sublibrary

The source elements ConstantMagnetomotiveForce
and SignalMagnetomotiveForce both are ideal
sources of a magnetic potential difference Vmag. They

561

Modelica 2005, March 7-8, 2005

Th. Bödrich, Th. Roschke

are intended for use in stationary flux calculations
where no coupling between the feeding electrical and
the magnetic subsystem is needed and where
dynamic effects of this coupling need not to be
considered.
The source element ElectroMagneticConverter
couples the electrical subsystem of a electromagnetic
drive system with the magnetic subsystem, i. e. with
the network of magnetic flux tubes. Two equations
are needed to describe this coupling [4]: Faraday’s
law

uind = − w

dΦ
dt

The principal structure of an electromagnetic
actuator is shown in Fig. 4. Depicted is an industrial
DC solenoid for applications throughout automation.
The cross-sectional view above shows a solenoid of
the Saia-Burgess STA series that will be used as
modeling example [5]. In contrast to the depicted
actuator with a conical pole shape, the modeled
solenoid STA 195205-129 has a plane pole face as
shown in the schematic view below.

(8)

and

Vmag = i ⋅ w

(9).

Armature

Equation (8) describes the voltage uind induced in a
coil due to a change of the flux linkage wΦ inside
this coil with respect to time (w – number of coil
windings). In most electromagnetic devices, the coil
flux Φ is a nonlinear function of both the coil
current i (due to saturation effects in ferromagnetic
components) and the position x respectively ϕ of the
device’s moving component: Φ = f(i, x) for
translational actuators and Φ = f(i, ϕ) for rotating
electrical machines. The dependencies of the coil
flux Φ on both current and position are intrinsically
accounted for in actuator models according to the
flux tube approach as will be obvious from the
example in section 4.
Equation (9) describes the magnetic potential
difference Vmag fed into a network of flux tubes due
to the coil current. This equation is derived from
Ampere’s law.
The Sources sublibrary is completed by a model of a
permanent magnet. It is made up of a series
connection of an ideal source of a magnetic potential
difference Vmag and the linear (µr = const.) reluctance
of the permanent magnet [2], [3].

4

A Solenoid Actuator as an Example

Solenoid actuators offer a very robust and simple
structure, a good force to mass ratio with respect to
dynamic behavior and stroke and a low price. For
that reasons they are widely used as drive element in
a huge diversity of applications, e.g. in locking
mechanisms throughout automation and automotive
engineering, in fluidic valves or in relays and
switchgear.

The Modelica Association

Yoke

Coil

Air gap

Fmag

Stroke xarm

FLoad

0

Magnetic flux path

Fig. 4 Cross-sectional view and principal structure
of a typical solenoid actuator [5]
The working principle of solenoid actuators is based
on reluctance forces [2], [4]: The magnetic flux Φ
generated by a current in the coil goes through a
working air gap where a magnetic force is developed
due to the gradient in relative permeability µr on the
boundaries between the ferromagnetic parts with
µr >> 1 and the air with µr = 1.
The force-stroke characteristics of electromagnetic
actuators can be widely influenced and shaped
according to applications needs by variation of the
geometry of pole and armature. Typically however
for most electromagnetic actuators is a highly
nonlinear force-stroke characteristic Fmag(xarm) with a
minimum force at the armature rest position
(maximum air gap length) and a strong increase in
magnetic force towards minimum air gap length [2].
4.1

Model of the Solenoid

The graphical representation of the Modelica model
of the actuator is shown in Fig. 5. It consists of the
electrical subsystem (coil) on the left side with the
electro-magnetic converter, the magnetic network
based on the method of flux tubes in the middle, and

562

Modelica 2005, March 7-8, 2005

A Magnetic Library for Modelica

the mechanical subsystem that models the armature
dynamics on the right side. At the right flange
connector, additional models from the Translational
library of the Modelica Standard library can be
attached, e.g. a mass to be moved, a return spring or
process forces.
Coil terminal
Magnetic network

Coil terminal

Translational
armature
flange

Armature mass with stoppers
(differential equation of motion)

Fig. 5 Graphical representation of the Modelica
model of the solenoid
The electrical subsystem with the current i, the
voltage across the coil terminals vcoil, the magnetic
flux Φ enclosed by each of the w windings, and the
winding resistance Rcoil is described with the
following equation (see also equation (8)):

vcoil = i Rcoil + w

dΦ
dt

(10).

For voltage controlled operation of the solenoid, vcoil
is the voltage of the driving voltage source.
The magnetic network of Fig. 5 is intentionally kept
simple in this example. In Fig. 6 the network is
shown over a field plot of the actuators magnetic
field obtained from FEA.
RmAirParasitic

RmFeArm(i)

RmStray

Θ = iw

RmFeYoke(i)

RmAirGap(x)

Fig. 6 Magnetic network over a FEA field plot of
the sample actuator (line of symmetry at the
bottom)

The Modelica Association

The magnetomotive force Θ is fed into the network
by the electro-magnetic converter. It is an ideal
source of a magnetic potential difference Vmag
according to equation (9). The two ferromagnetic
reluctance elements RmFeArm(i) and RmFeYoke(i)
represent the ferromagnetic components of the
actuator. They are calculated from the actuators main
dimensions with equation (7). Due to the nonlinear
B(H)-relationship of ferromagnetic materials, they
depend on the solenoid current i. The steel 1.0715
with the B(H)-characteristic of Fig. 3 is used in both
reluctance elements. An approximated function µr(B)
derived from that material data is used for
calculation of both reluctance values with
equation (7).
Three reluctance elements through air are present in
this magnetic network model: RmStray is a simple but
yet effective description of the stray flux of the
solenoid. Despite the simple structure of the
actuators magnetic network it should not be omitted
in the model. This is because of the large ratio of
total actuator length to outer diameter of the sample
actuator. Typical for solenoids with such a geometry
is that part of the magnetic field lines close without
going through the working air gap RmAirGap.
The reluctance of the working air gap is calculated
with equation (7), where air gap length l is identical
with the armature position xarm. The magnetic or
reluctance force Fmag that is generated at the
boundaries between the ferromagnetic armature
respectively the pole and the air is calculated with
Maxwell’s formula [2], [4]:

Fmag =

Φ2
2µ 0 A

(11),

where A is the cross sectional area of the air gap
respectively the area of the pole face. The developed
force Fmag is fed as driving force for the armature
mass into the mechanical subsystem of the actuator
model, where acceleration, velocity and armature
position xarm are calculated from the differential
equation of motion.
The magnetic network is completed with the
reluctance RmAirParasitic. This element describes the
parasitic air gap in the non-ferromagnetic slide
guiding for the armature.
4.2

Force-Stroke Characteristics

An important criterion that characterises an actuator
is its force-stroke characteristics. For the solenoid
model, this characteristic Fmag(xarm) was calculated
with a quasi-static enforced movement of the

563

Modelica 2005, March 7-8, 2005

Th. Bödrich, Th. Roschke

armature (Fig. 7). This is in accordance to real forcestroke measurements on actuators.

Fig. 7 Quasi-static enforced armature movement
for calculation of the force-stroke
characteristics
Simulated and measured curves for the sample
actuator are compared in Fig. 8. Simulation was done
with the magnetic network model of Fig. 5.
Measured data was taken from the catalogue of the
manufacturer. For comparison, the force-stroke
characteristic obtained from FEA at different
armature positions is included in this diagram, too.
Sample actuator: Saia-Burgess STA 195205-129
Supply voltage Usupply = 13.2 V, Duty cycle 50 %
32

Finite Element Analysis (FEA)

24

Simulated with magnetic network model

20

4.3

Simulation of a Pull-in Movement

The main advantage of a modeling approach based
on magnetic flux tubes compared to a design
approach using FEA is the little computational effort
of flux tube models that allows for extensive
dynamic simulations during both actuator and system
design. To illustrate the capabilities of magnetic
network models for dynamic simulation, a pull-in
stroke of the armature was simulated with the
network model of the sample solenoid of Fig. 5. In
Fig. 9, simulated coil current i and armature position
xarm are shown together with measured data after a
voltage step from 0 to 13.2 VDC at time t = 0 was
applied. The armature was in horizontal position, no
additional mechanical load was attached to it.

Measurement at Temperature T = 20 °C

16

Sample actuator: Saia-Burgess STA 195205-129
Supply voltage step Ustep = 13.2 V at time t = 0

12

8

1.2

Current i in A

Actuator Force Fmag in N

28

• neglect of additional parasitic air gaps
especially in the FEA model, e. g. between yoke
lid and yoke,
• differences between the simulated and the real
material characteristics µr(B) for the
ferromagnetic yoke and the armature.
Despite the differences between measurement and
simulation with the magnetic network model, the
flux tube approach is well suited for coarse design of
magnetic devices and estimation of force-stroke
characteristics
respectively
torque-angle
characteristics for rotational devices prior to further
design steps.

4

0
0.000

0.001

0.002

0.003
0.004
0.005
STA_195205_129_1.x_arm

0.006

0.007

0.008

Armature position xarm in m

0.8
0.6
0.4
0.2
0.0

Reasons for the differences between the three curves
are:
• limited accuracy of the force-stroke measurement especially at small air gaps due to deflection of the load cell and the mounting rack,
• simple structure of the magnetic flux tube
model in this example (e. g. no additional stray
reluctance around the working air gap),

Position xarm in m

-0.2
0.00

Fig. 8 Comparison of measured and simulated
force-stroke characteristics of the sample
actuator

The Modelica Association

1.0

Simulation

Measurement
0.01

0.02

0.03

0.04

0.03

0.04

0.006

Measurement

0.005
0.004
0.003

Simulation

0.002
0.001
0.000
-0.001
0.00

0.01

0.02

Time t in s

Fig. 9 Comparison of simulated and measured
solenoid current i and armature position xarm
after a voltage step at time t = 0

564

Modelica 2005, March 7-8, 2005

A Magnetic Library for Modelica

The characteristic current drop during the pull-in
stroke of the armature results from the increase of
the solenoids inductance as the armature moves into
the solenoid. This is due to the decrease of the air
gap reluctance and the increase of the total magnetic
flux during the movement.
Differences between the measured and the simulated
curves can be explained with the simple structure of
the network model. Higher accuracy of the solenoid
model can be achieved with a more detailed
magnetic network, if needed.

each product within a product family with different
sizes. On the other hand, system engineers can use
these models for simulation of complex mechatronic
systems, e.g. in automation industry or in automotive
applications.

References
[1]
[2]

5

Conclusions

Basic magnetic network elements in Modelica were
already presented in [6]. The model elements
described in this paper are intended for modeling of
rotating electrical machines. The magnetic elements
(e.g. linear magnetic resistance, electro-magnetic
converter) are described in terms of integral machine
parameters. Differently from the approach in [6], the
model components of the newly developed Magnetic
library are defined in terms of their geometric
dimensions and their material properties. They are
hence suited for modeling of the geometry of
magnetic components during actuator design, but for
system simulation of the actuator together with its
neighboring subsystems, too.
A dynamic model of a general purpose solenoid was
presented to illustrate the concept of magnetic flux
tubes as well as usage of the library. Modeling of the
dynamic properties of solenoids during actuator
design is of vital importance in many sectors. For
example, electromagnetic injection valves in
automotive applications must actuate in as little as
1 ms, and proportional solenoids that drive valves in
fluidic applications operate at frequencies above
100 Hz.
Future work on the Magnetic library will focus on
the following issues:

[3]

[4]

[5]
[6]

Roters, H.: Electromagnetic Devices.
New York: John Wiley & Sons 1941
Kallenbach, E.; Eick, R.; Quendt, P.;
Ströhla, T.; Feindt, K.; Kallenbach,
M.: Elektromagnete: Grundlagen,
Berechnung, Entwurf und Anwendung. 2. Aufl. Wiesbaden:
B.G. Teubner 2003
Hendershot, J.R. Jr.; Miller, T.J.E.:
Design of Brushless PermanentMagnet Motors. Magna Physics
Publishing and Oxford University
Press 1994
Roschke, Th.: Entwurf geregelter
elektromagnetischer Antriebe für
Luftschütze. Düsseldorf: VDIVerlag 2000
Saia-Burgess Solenoid Catalogue.
Internet: www.saia-burgess.com
Beuschel, M.: A Uniform Approach
for Modeling Electrical Machines.
Proceedings of the Modelica 2000
Workshop, Lund, Sweden,
Oct. 23-24, 2000, pp. 101-108

• refinement of implementation details, e. g. the
description of material properties with tables
and spline interpolation,
• estimation of eddy current losses for flux tube
elements with electrical conductivity,
• implementation of additional models for
magnetic devices, e.g. for solenoids with
different pole shapes, electrodynamic drives or
small rotating motors.
Preferably, the latter models shall be scalable, so that
device manufacturers can easily build models for

The Modelica Association

565

Modelica 2005, March 7-8, 2005

The Modelica Association

566

Modelica 2005, March 7-8, 2005

Session 7b
Real-Time and Reactive Systems

The Modelica Association

567

Modelica 2005, March 7-8, 2005

The Modelica Association

568

Modelica 2005, March 7-8, 2005

StateGraph-A Modelica Library for Hierarchical State Machines

StateGraph – A Modelica Library for Hierarchical State Machines
1

Martin Otter1, Karl-Erik Årzén2, and Isolde Dressler2
DLR Institute of Robotics and Mechatronics, Oberpfaffenhofen, Germany, Martin.Otter@dlr.de
2
Lund Institute of Technology, Lund, Sweden, {karlerik, Isolde.Dressler}@control.lth.se

Abstract
The new library Modelica.StateGraph is a free
Modelica package providing components to model
discrete event and reactive systems in a convenient
way. It has a similar modeling power as Statecharts,
but avoids some deficiencies of Statecharts by using
elements of JGrafchart and by using Modelica as an
“action” language. An overview of the StateGraph
library is given, the available components and an
application example. The implementation of the
library in Modelica is sketched, especially the
needed extension to Modelica that will be available
in release 2.2 of the Modelica language.

1

Introduction

This section shortly discusses discrete event formalisms and the relationship to the StateGraph library.
Grafcet [3], or the industrial alias Sequential
Function Charts (SFC), is a state-transition based
computational model that has been widely accepted
in the industrial automation industry for representing
sequential control logic. It is defined in the standards
IEC 848 and IEC 61131-3. States are represented by
steps to which actions can be associated, and the
steps are interconnected by transitions with associated Boolean conditions or event expressions. The
activity in a Grafcet diagram flows downwards from
the top of the diagram. It supports alternative
branches, parallel branches, and repetition. Hierarchies are supported in the form of macro steps.
Although Grafcet has the same formal power of
expression as an ordinary state machine, it is cumbersome to use for representing larger state-machine
oriented models. For these applications the Statecharts formalism is better suited [6]. Statecharts use
a syntax that is similar to ordinary state machines
and supports hierarchical states through the concept
of superstates, a considerably more powerful concept
than the macro steps of Grafcet.

The Modelica Association

Grafchart is the name of a graphical language
aimed at supervisory control applications developed
at Lund University [1]. It combines the function
chart formalism of Grafcet with the hierarchical
states of Statecharts. It also supports parameterized
function chart procedures. Through this the best concepts from both Grafcet and Statecharts are combined. JGrafchart is the name of a Java implementation of Grafchart [2]. It is a combined graphical editor and run-time system, and can be viewed as a softPLC. It is also possible to use JGrafchart only as a
graphical editor generating executable code. In [4]
code generation from JGrafchart to Modelica is presented. Code generation has also been provided to C
and Java.
The StateGraph library is based on a subset of
JGrafchart. Besides minor modifications to arrive at
a suitable Modelica implementation, the essential
difference is to use Modelica as an “action” language. The “single assignment rule” of Modelica
makes it completely different to the action languages
used in the formalisms from above. It will be shown
that this has significant advantages.

2

Users View

In this section the components of the StateGraph library are introduced by examples to show how it can
be used in applications.
2.1

Steps and Transitions

The basic elements of StateGraphs are steps and
transitions as shown in the next figure. Steps represent the possible states a StateGraph can have. If a
step is active the Boolean variable active of the step
is true. If it is deactivated, active = false. At the initial time, all ordinary steps are deactivated. The InitialStep objects are steps that are activated at the
initial time. They are characterized by a double box
(see next figure at the left).

569

Modelica 2005, March 7-8, 2005

M. Otter, K.-E. Årzén, I. Dressler

Transitions are used to change
the state of a StateGraph. When
the step connected to the input of
a transition is active, the step
connected to the output of this
transition is deactivated and
when the transition condition becomes true, then the transition
fires. This means that the step
connected to the input to the transition is deactivated and the step
connected to the output of the
transition is activated. The transition condition is defined via the
parameter menu of the transition
object. Clicking on object "transition1" in the above figure, results in the following
menu:

In the input field "condition", any type of time varying Boolean expression can be given (in Modelica
notation, this is a modification of the time varying
variable condition). Whenever this condition is true,
the transition can fire. Additionally, it is possible to
activate a timer, via enableTimer (see menu above)
and provide a waitTime. In this case the firing of the
transition is delayed according to the defined waitTime. The transition only fires if the condition remains true during the waitTime. The transition condition and the waitTime are displayed in the transition icon.
In the above example, the simulation starts at initialStep. After 1 second, transition1 fires and step1
becomes active. After another second transition2
fires and initialStep becomes again active. After a
further second step1 becomes active, and so on.
In Grafchart, Grafcet and SFC the network of steps
and transitions is drawn from top to bottom. In
StateGraphs, no particular direction is defined, since
Modelica models do not depend on the placement of
components and connection lines. Usually, it is more
practical to define the network from left to right,

The Modelica Association

since it is easier to read the labels on the icons. The
example from above has then the following layout:

2.2

Conditions and Actions

With the block TransitionWithSignal, the firing
condition can be provided as Boolean input signal,
instead as entry in the menu of the transition with
block Transition, see example in the next figure:

Component "step" is an instance of "StepWithSignal" that is a usual step where the active flag is available as Boolean output signal. To this output, component "Timer" from library "Modelica.Blocks.Logical" is connected. It measures the time from the
time instant where the Boolean input (i.e., the active
flag of the step) became true up to the current time
instant. The timer is connected to a comparison
component. The output is true, once the timer
reaches 1 second. This signal is used as condition
input of the transition. As a result, "transition2" fires,
once step "step" has been active for 1 second. Of
course, any other Modelica block with a Boolean
output signal can be connected to the condition input
as well, especially blocks of the Modelica.Blocks.Logical library, see next figure. The Logical library
will be extended in the future. It is also easy for a
user to define his own, specialized logical blocks.

570

Modelica 2005, March 7-8, 2005

StateGraph-A Modelica Library for Hierarchical State Machines

Instead of using logical blocks, via the Modelica.Blocks.Sources.SetBoolean component any type
of logical expression can be defined in textual form,
as shown in the next figure:

With the block "SetBoolean", a time varying expression can be provided as modification to the output
signal y (see block with icon text "timer.y > 1" in the
figure above). The output signal can be in turn connected to the condition input of a TransitionWithSignal block.
The "SetBoolean" block can also be used to compute
a Boolean signal depending on the active step. In the
figure above, the output of the block with the icon
text "step.active" is true, when "step" is active, otherwise it is false (note, the icon text of "SetBoolean"
displays the modification of the output signal "y").
This signal can then be used to compute desired actions in the physical systems model. For example, if
a valve shall be open, when the StateGraph is in
"step1" or in "step4", a "SetBoolean" block may be
connected to the valve model using the following
condition:
step1.active or step2.active

Via the Modelica operators edge(..) and change(..),
conditions depending on rising and falling edges of
Boolean expressions can be used when needed.
In Grafchart, Grafcet, SFC and Statecharts, actions
are formulated within a step. Such actions are distinguished as entry, normal, exit and abort actions.
For example, a valve might be opened by an entry
action of a step and might be closed by an exit action
of the same step. In StateGraphs this is not possible
due to Modelicas "single assignment rule" that requires that every variable is defined by exactly one
equation. Instead, the approach explained above is
used. For example, via the "SetBoolean" component,
the valve variable is set to true when the StateGraph
is in particular steps.
This feature of a StateGraph is very useful, since it
allows a Modelica translator to guarantee that a
given StateGraph has always deterministic behaviour without conflicts. In the other methodologies
this is much more cumbersome. As an example, in
the next figure a critical situation in Stateflow is
shown (Mathworks Stateflow is similar to a StateThe Modelica Association

graph but has, e.g., a slightly different visual appearance, and is integrated in Mathworks Simulink):

The two substates “fill1” and “fill2” are executed in
parallel. In both states the variable “openValve” is
set as entry action. The question is whether openValve will have value 0 or 1 after execution of the
steps. Stateflow changes this non-deterministic behaviour to a formally deterministic one by defining
an execution sequence of the states that depends on
their graphical position. The light number on the
right of the states shows in which order the states are
executed. In the figure above this means that “openValve=0” after leaving the two states. If the second
state “fill2” is changed a little bit graphically

“openValve=1” after “fill1” and “fill2” have been
executed. This is a dangerous situation because (a)
slight changes in the placement of states might
change the simulation result and (b) if the parallel
execution of actions depends on the evaluation order,
errors are very difficult to detect.
Note, similar problems occur in other StateGraph
variants, SFC, Grafcet and Graphcharts: Variables
are changed according to an evaluation sequence of
the simulator. It seems not possible to provide an
easy-to-grasp rule about evaluation order of actions
that are executed in parallel. Therefore, either the
simulator just uses an internal evaluation order, or
non-obvious rules are present as in Stateflow that do
not solve the underlying problem.
In a StateGraph, such a situation is detected by the
translator resulting in an error, since there are two
equations to compute one variable. The user is
forced to reformulate the network by explicitly defining priorities. For example, if “fill1” and “fill2”
are steps that are executed in parallel, there might be
a “SetBoolean” block that defines:
openValve =
if fill1.active then 1 else
if fill2.active then 0 else 2

Therefore step fill1 has a higher priority as step fill2.

571

Modelica 2005, March 7-8, 2005

M. Otter, K.-E. Årzén, I. Dressler

In a Stategraph or Graphchart it is difficult to modularize a sub chart if the used actions reference variables in an outer scope: Assume, for example, that a
state machine “control” has the following hierarchy:
control.superstate1.step1

Within "step1" a Statechart would, e.g., access variable "control.openValve", say as "entry action:
openValve = true". This typical usage has the drawback that it is difficult to use the hierarchical state
"superstate1" as component in another context, because "step1" references a particular name outside of
this component.
In a StateGraph, there would be typically a "SetBoolean" component in the "control" component stating:
openValve = superstate1.step1.active;

As a result, the "superstate1" component can be used
in another context, because it does not depend on the
environment where it is used.
The disadvantage of the StateGraph approach is that
the user might not be able to formulate the network
directly as desired. For example, in order to fill a
tank usually several actions are necessary, e.g., to
close one valve and to open another one. In a SFC all
actions to “fill a tank” would be defined as actions to
a “fill_a_tank” step and this might be more convenient for the user. For example, copying or deleting a
“fill_a_tank” step would require only a change at one
place in a SFC whereas it would require changes at
several places in a StateGraph.
2.3

fire, the corresponding component is marked in
green color.
The three branches within "step2" to "step5" are executed alternatively, depending which transition condition of "transition3", "transition4", "transition4a"
fires first. Since all three transitions fire after 1 second, they are all candidates for the active branch. If
two or more transitions would fire at the same time
instant, a priority selection is made: The alternative
and parallel components have a vector of connectors.
Every branch has to be connected to exactly one entry of the connector vector. The entry with the lowest
number has the highest priority.
Parallel, Alternative and Step components have vectors of connectors. The dimensions of these vectors
are set in the corresponding parameter menu. E.g. in
a "Parallel" component:

Currently in the Modelica tool Dymola the following
menu pops up when a branch is connected to a vector
of components in order to define the vector index to

Parallel and Alternative Execution

Parallel activities can be defined by component
StateGraph.Parallel and alternative activities can be
defined by component StateGraph.Alternative. An
example for both components is given in the next
figure. Here, the branch from "step2" to "step5" is
executed in parallel to "step1". A transition
which the component shall be connected. There are
discussions to improve the Modelica language to
handle such situations more conveniently.
Note, alternative branches can also be defined without the “Alternative” component by just connecting
several transitions to the outputs of the same step as
shown in the next figure:

connected to the output of a parallel branch component can only fire if the final steps in all parallel
branches are active simultaneously. The figure above
is a screen-shot from the animation of the StateGraph: Whenever a step is active or a transition can
The Modelica Association

572

Modelica 2005, March 7-8, 2005

StateGraph-A Modelica Library for Hierarchical State Machines

2.4

Composite Steps

A StateGraph can be hierarchically structured by
using a component that inherits from StateGraph.PartialCompositeStep. An example is given
in the next figure:

The CompositeStep component contains a local
StateGraph that is entered by one or more input transitions and that is left by one or more output transitions. Also, other needed signals may enter a CompositeStep. The CompositeStep has similiar properties as a "usual" step: The CompositeStep is active
once at least one step within the CompositeStep is
active. Variable active defines the state of the CompositeStep.
Additionally, a CompositeStep has a suspend port.
Whenever the transition connected to this port fires,
the CompositeStep is left at once. When leaving the
CompositeStep via the suspend port, the internal
state of the CompositeStep is saved, i.e., the active
flags of all steps within the CompositeStep. The
CompositeStep might be entered via its resume port.
In this case the internal state from the suspend transition is reconstructed and the CompositeStep continues the execution that it had before the suspend transition fired (this corresponds to the history ports of
Statecharts or JGrafcharts).
A CompositeStep may contain other CompositeSteps. At every level, a CompositeStep and all of
its content can be left via its suspend ports (actually,
there is a vector of suspend connectors, i.e., a CompositeStep might be aborted due to different transitions).
The CompositeStep can be used in the same way as a
superstate in Statecharts. In a superstate it is possible
to enter the state in different ways ending up in different internal states. This can be modeled in a
StateGraph or a Graphchart by having multiple input
transitions, each leading to a different internal step.

The Modelica Association

In a superstate it is possible to exit a superstate in
different ways depending on which internal state that
is active. This is modeled in a StateGraph or Graphchart by associating different output transitions to the
different internal steps. In a superstate it is, finally,
also possible to exit the state independently from
which internal state that is active. This is achieved
with the suspend port here. The conditions connected
to the transitions attached to the suspend port can
also be conditioned by the status of the internal steps
of the CompositeStep. In this way it is possible to
suspend the step if a certain condition holds and
unless a certain internal step is active. The history
arcs in Statecharts correspond to the resume port.
Superstates with parallel subparts, so called XOR
superstates, can be modeled using parallel constructs
inside the CompositeStep.
In addition to using CompositeSteps for modeling
hierarchical states they can also be used to simply
aggregate a part of a larger StateGraph. This can be
useful to improve the structure
2.5

Execution Model

The execution model of a StateGraph follows from
its Modelica implementation: Given the states of all
steps, i.e., whether a step is active or not active, the
equations of all steps, transitions, transition conditions, actions etc. are sorted resulting in an execution
sequence to compute essentially the new values of
the steps. If conflicts occur, e.g., if there are more
equations as variables, of if there are algebraic loops
between Boolean variables, an error occurs. Once all
equations have been processed, the active variables
of all steps are updated to the newly calculated values. Afterwards, the equations are again evaluated.
The iteration stops, once no step changes its state
anymore, i.e., once no transition fires anymore.
Then, simulation continuous until a new event is
triggered, i.e., when a relation changes its value.
With the Modelica "sampled(..)" operator, a StateGraph might also be executed within a discrete controller that is called at regular time instants. In a future version of the StateGraph library, this might be
more directly supported.

3

Example of a Tank Controller

In this section a more realistic, still simple, application example is given, to demonstrate various features of the StateGraph library. This example shows
the control of a two tank system from [4]. In the following figure the top level of the model is shown.

573

Modelica 2005, March 7-8, 2005

M. Otter, K.-E. Årzén, I. Dressler

•

This model is available as Modelica.StateGraph.Examples.ControlledTanks. In the right part of the
figure, two tanks are shown. At the top part, a large
fluid source is present from which fluid can be filled
in tank1 when valve1 is open. Tank1 can be emptied
via valve2 that is located in the bottom of tank2 and
fills a second tank2 which in turn is emptied via
valve3. The actual levels of the tanks are measured
and are provided as signals level1 and level2 to the
tankController.
The tankController is controlled by three buttons,
start, stop and shut (for shutdown) that are mutually
exclusive. This means that whenever one button is
pressed (i.e., its state is true) then the other two buttons are not pressed (i.e., their states are false). The
buttons could be implemented as dynamic elements
that react when clicking on them. In the example,
they are implemented with logical tables, i.e., block
Modelica.StateGraph.Temporary.RadioButton,
in
order that the result of the simulation is reproducible.
When button start is pressed, the "normal" operation
to fill and to empty the two tanks is processed:
1. Valve 1 is opened and tank 1 is filled.
2. When tank 1 reaches its fill level limit, valve 1 is
closed.
3. After a waiting time, valve 2 is opened and the
fluid flows from tank 1 into tank 2.
4. When tank 1 is empty, valve 2 is closed.
5. After a waiting time, valve 3 is opened and the
fluid flows out of tank 2
6. When tank 2 is empty, valve 3 is closed
The above "normal" process can be influenced by the
following buttons:

The Modelica Association

Button start starts the above process. When this
button is pressed after a "stop" or "shut" operation, the process operation continues.
• Button stop stops the above process by closing
all valves. Then, the controller waits for further
input (either "start" or "shut" operation).
• Button shut is used to shutdown the process, by
emptying at once both tanks. When this is
achieved, the process goes back to its start configuration. Clicking on "start", restarts the process.
The implementation of the tankController is shown
in the next figure. When the "start" button is
pressed, the stateGraph is within the CompositeStep
"makeProduct". During normal operation this
CompositeStep is only left, once tank2 is empty. Afterwards, the CompositeStep is at once re-entered.
When the "stop" button is pressed, the "makeProduct" CompositeStep is at once terminated via the
"suspend" port and the stateGraph waits in step "s2"
for further commands. When the "start" button is
pressed, the CompositeStep is re-entered via its resume port and the "normal" operation continues at
the state where it was aborted by the suspend transition. If the "shut" button is pressed, the stateGraph
waits in the "emptyTanks" step, until both tanks are
empty and then waits at the initial step "s1" for further input.

The opening and closing of valves is not directly
defined in the StateGraph. Instead via the "setValveX" components, the Boolean state of the
valves are determined. For example, the output y of
"setValve2" is computed as:

574

y = makeProduct.fillTank2.active
or emptyTanks.active

Modelica 2005, March 7-8, 2005

StateGraph-A Modelica Library for Hierarchical State Machines

i.e., valve2 is open, when step "makeProduct.fillTank2 or when step "emptyTanks" is active.
Otherwise, valve2 is closed. The main part of the
composite step “makeProduct” is shown in the next
figure. Step “fillTank1” is left, once the highest level

true if a transition fires). The step remains active if it
was active and no transition connected to the outPort
connectors fires (reset = true, if a transition fires).
A step reports its active flag to the transition connected to its first outPort by the equation:
outPort[1].available = active;

In order to make sure that only one of the transitions
connected to the outPorts can fire, the active flag is
hidden to the second outPort transition if the first
transition decides to fire and sends a reset condition:
outPort[2].available =
outPort[1].available and not
outPort[1].reset;

for the tank is reached (level1 > limit). The StateGraph remains in step “wait1” during the defined
“waitTime”. Afterwards, step “fillTank2” remains
active until tank1 is empty (level1 < 0.001). After a
waiting phase, the “emptyTank2” step is entered.

4

Implementation

In this section the implementation of the most important parts of the library is sketched.
4.1

The general case can be written in Modelica as
for i in 1:size(outPort,1) loop
outPort[i].available =
if i == 1 then active else
outPort[i-1].available and not
outPort[i-1].reset;
end for;

A step needs to signal to its inPort transitions
whether it is possible to activate it or whether it is
about to become active via transitions with higher
priorities. This is described as
for i in 1:size(inPort,1) loop
inPort[i].occupied =
if i == 1 then active else
inPort[i-1].occupied or
inPort[i-1].set;
end for;

Steps and Transitions

Steps and transitions are implemented according to
the method described in [7][5] to define Petri nets
with an equation based language.
A transition has one inPort and one outPort connector and is basically defined by the following equations (if no timer is present):
fire = condition and
inPort.available and not
outPort.occupied;
inPort.reset = fire;
outPort.set = fire;

Note, that the inPort connector of a transition consists of the Boolean variables “available” and “reset”
and the outPort connector consists of the Boolean
variables “occupied” and “set”. The above equation
states that “fire = true”, if (1) the firing condition is
true, (2) the inPort step is active and (3) the outPort
step is not active. The “fire” value is reported to the
two steps to which the transition is connected.
A step has a vector of input and a vector of output
connectors. It is basically defined as:
active = pre(newActive);
newActive = anyTrue(inPort.set) or active
and not anyTrue(outPort.reset)

The function “anyTrue(..)” returns true, if any element of the input vector is true. The step becomes
active in the next iteration when one of the transitions connected to the inPort connectors fires (set =
The Modelica Association

The inPort and outPort connectors contain appropriate “input” and “output” prefixes of the connector
variables, in order that steps can only be connected
to transitions and vice versa. Furthermore, the annotation “Hide = true” is set on all connector variables,
in order that these variables do not show up in the
plot browser, because these are internal variables that
are of no interest for the user of the StateGraph library.
In a parameter menu of a component usually only
variables are displayed that are declared as parameters. In the parameter menu of a transition, additionally the time varying variable “condition” is displayed as shown in section 2.1. This is implemented
by adding the annotation “Dialog” to the variable
declaration:
Boolean condition annotation(Dialog);

Usually, the “Dialog” annotation has additional subentries, such as “group” or “tab”. However, if no
subentries are present, this annotation just means to
include the variable in the parameter menu.
In a JGraphchart there is a timer associated with
every step by providing the time difference between
the actual time and the time when the step became
active via variable “t”. In a StateGraph no time vari-

575

Modelica 2005, March 7-8, 2005

M. Otter, K.-E. Årzén, I. Dressler

able is associated with a step, but an optional timer is
provided in a transition and via the connector “active” of a step a timer from the Logical library can be
attached to the step. This provides similar functionality as for a JGraphchart. One reason for this change
was to improve the efficiency. For example, in a
transition the following code fragment to define a
timer is present:
if enableTimer then
when enableFire then
t_start = time;
end when;
t_dummy = time - t_start;
t = if enableFire then t_dummy else 0;
fire = enableFire and
time >= t_start + waitTime
else
...
end if;

A Modelica translator triggers an event when time
reaches “t_start + waitTime”. Since “t_start” is a
variable that is set in the same scope in a when
clause and “waitTime” is a parameter, a Modelica
translator can easily trigger a time event.
The situation is different, if the when clause “when
enableFire then t_start = time; end when” is present
within a step and the relation “time >= t_start +
waitTime” is present in another component, e.g., in a
“condition” of a transition. A Modelica translator
will then usually trigger a state event because in the
scope of the relation it is not known that “t_start” can
change its value only at event instants.
4.2

Besides appropriate “assert” statements to guarantee
the desired connection structure, the Parallel component consists of the following equations only:
n = size(split,1);
split.set = fill(inPort.set, n);
join.reset = fill(outPort.reset,n);
inPort.occupied =anyTrue(split.occupied);
outPort.available=allTrue(join.available);

The second and third equation report the “set” and
“reset” flags of the inPort and outPort connectors to
the “split” and “join” connectors. The two last equations perform the synchronization of the parallel
branches: Via function “anyTrue(..)” it is defined
that the input transition can only fire if none of the
steps connected directly to the “split” connector array is active. Via function “allTrue(..)” it is defined
that the output transition can only fire if all steps
connected directly to the “join” connector array are
active.
The implementation of the “Alternative” component
is performed in a similar way.
Both the Parallel and the Alternative component
have the (slight) disadvantage that they can be misused. For example, in a Parallel Component it is possible to connect from a step in the parallel branches
to a transition that is connected to a step outside of
the Parallel component, see the example in the next
figure:

Parallel and Alternative Execution

The parallel component has the following icon
split

inPort

join

outPort

and consists of 4 connectors. The “inPort” and outPort” connectors allow only a connection to transitions. The “split” and “join” connectors are vectors
of connectors that are drawn in a quite “lenghty”
format to resemble the usual visual layout of parallel
execution in SFC. They allow only a connection to
steps. After dragging this icon in a model, it is usually enlarged until the desired elements can be placed
between the “split” and the “join” connectors.

The Modelica Association

It would be desirable to prevent such types of networks in a StateGraph. However, it seems not possible to formulate a corresponding restriction with the
Modelica language. There are currently Modelica
scripting functions under development that allow to
traverse a Modelica model and extract information
about the model. It might be that such functionality
will allow to detect such undesirable networks.
These types of function charts are also known as unsafe or unreachable. In commercial SFC editors it is
common that the editor makes it impossible to enter
these types of charts, rather than including these
global constraints in the language itself.

576

Modelica 2005, March 7-8, 2005

StateGraph-A Modelica Library for Hierarchical State Machines

4.3

Composite Steps

A composite step is a model that extends from PartialCompositeStep. The icon and diagram layer of
this superclass is shown in the next figure:

True(suspend.reset)”) or a transition at one of the
“resume” connectors fires. The information about the
“suspend” and “resume” connector settings are reported to the steps inside the composite step again
via the inner root connector.
In a step, a corresponding “outer” declaration of
connector “root” is present and the code of section
4.1 of a step is slightly changed to:
protected
outer CompositeStepStatePort root;
CompositeStepStatePort localRoot;
equation
connect(localRoot, root);

icon layer

There is one default “inPort” and “outPort” connector on the left and right side. More connectors to enter and leave a composite step may be added. In the
icon layer a vector of “suspend” and a vector of “resume” connectors is present. These connectors are
not visible in the diagram layer and therefore it is in
the graphical editor not possible to connect a component in a composite step to them. The “suspend” and
“resume” connector instances are not visible in the
diagram layer of a composite step, because the underlying connector classes have an empty diagram
layer.
A composite step is active, if at least one step in the
composite step is active, and a composite step is deactivated, and also all steps in the composite step, if
a transition fires that is connected to one of the “suspend” connectors. This means a communication
channel between a composite step and all steps
within a composite step is necessary. This is implemented by having a connector
connector CompositeStepStatePort
Boolean suspend;
Boolean resume;
flow Real activeSteps;
end CompositeStepStatePort;

and use an inner definition of this connector in PartialCompositeStep:
inner CompositeStepStatePort root;
...
activeSteps = -integer(root.activeSteps);
root.suspend = anyTrue(suspend.reset);
root.resume = anyTrue(resume.set);
newActive = activeSteps > 0 and not
anyTrue(suspend.reset) or
anyTrue(resume.set);
active
= pre(newActive);

when localRoot.suspend then
oldActive = active;
end when;

Via outer flow variable activeSteps, the active setting
is reported to the composite step. Additionally, a
memory is introduced via variable “oldActive” to
remember the current value of the “active” flag when
the composite step is terminated via its “suspend”
port (“when localRoot.suspend then ...”). The assignment to “newActive” is slightly changed to include the transitions via the “suspend” and “resume”
connectors in the composite step.
A composite step may contain not only steps but
other composite steps. The implementation above
does not handle this case. In fact, with the Modelica
language version 2.1 it is not possible to provide a
proper implementation. Therefore, an extension was
needed that is defined in the coming version 2.2 of
the Modelica language (it is already supported in
Dymola):
In a composite step a construct of the following form
would be needed:
// wrong Modelica code
inner CompositeStepStatePort root;
outer CompositeStepStatePort root;

Via flow variable “activeSteps in the inner root connector, the number of active steps is reported from
the steps to the composite step. The composite step is
active if this number is greater than zero and no transition at the suspend connector fires (“any-

The Modelica Association

localRoot.activeSteps =
if active then 1 else 0;
active
= pre(newActive);
newActive =
if localRoot.resume then oldActive
else (anyTrue(inPort.set) or
active and not
anyTrue(outPort.reset))
and not root.suspend;

diagram layer

where the “inner root” connector is used in all steps
inside the current composite step and the “outer root”
connector refers to the composite step outside of the
current scope in order to have a communication
channel to the outside scope. However, this is wrong
Modelica code because there are two declarations
with the same name. Note, the names must be the
same, because in a step a communication channel to

577

Modelica 2005, March 7-8, 2005

M. Otter, K.-E. Årzén, I. Dressler

the “nearest” composite step is needed and the name
used in the “outer” declaration of a step must be
identical to the name used in the “inner” declaration
of a composite step.
In the Modelica language version 2.2 the following
extension was introduced:
// Modelica 2.2 code
inner outer CompositeStepStatePort root(..)

to define actually a new “inner” variable “root” and
at the same time reference an “outer” variable “root”.
References to “root” inside the current scope, references the “outer” variable. Modifications to “root”
are not allowed for “outer” variables and therefore
apply to the “inner” variable. In other words, inside
a composite step the “outer root” is accessed by variable “root” and settings for the “inner root” have to
be performed via a modification in the declaration of
“root”.
The previous code fragments must be slightly modified to include the new “inner outer” declaration, and
to handle the case of composite steps that are inside
and/or outside the current one.

5

Summary

The free Modelica.StateGraph library offers new
features to conveniently define discrete event and
reactive systems in Modelica models. Since Modelica is used as an action language, a Modelica translator can guarantee that a StateGraph has deterministic behaviour. StateGraph models can be combined
with components of any other Modelica library and
can therefore be very easily used to control a continuous plant.
StateGraph is based on Grafchart, which contains
several features that not, so far, have been implemented in StateGraph. Some of these features, such
as function chart procedures, assume support for dispatching at run-time, which does not match well with
the philosophy of Modelica. Other features such as
lists could very well be included in StateGraph.
It is also planned to improve the graphical handling
of StateGraphs in the future and to add more functionality especially also to the Modelica.Blocks.Logical library that is often used in a StateGraph.
Improvement suggestions and contributions are welcome.

The Modelica Association

References
[1] Årzen K.-E. (1996): Grafchart: A Graphical
Language for Sequential Supervisory Control
Applications. IFAC'96, Preprints 13th World
Congress of IFAC, San Francisco.
[2] Årzen K.-E., Olsson R., and Akesson J. (2002):
Grafchart for Procedural Operator Support
Tasks. Proceedings of the 15th IFAC World
Congress, Barcelona, Spain.
[3] David R., and Alla H. (1992): Petri Nets and
Grafcet: Tools for modeling discrete event systems.
Prentice Hall.
[4] Dressler I. (2004): Code Generation from
JGrafchart to Modelica. Master Thesis, ISRN
LUTFD2/TFRT-5726-SE, Department of Automatic
Control, Lund Institute of Technology, Sweden.
[5] Elmqvist H., Mattsson S.E., and Otter M. (2001):
Object-Oriented and Hybrid Modeling in
Modelica. Journal Européen des systèmes
automatisés, vol. 35, no. 1, pp. 1-22.
[6] Harel D. (1987): Statecharts: A Visual Formalism
for Complex Systems. Science of Computer
Programming, Vol. 8.
[7] Mosterman P.J., Otter M., and Elmqvist H. (1998):
Modeling Petri Nets as Local Constraint Equations
for Hybrid Systems Using Modelica. In Proceedings
of SCS Summer Simulation Conference, pp. 314-319,
Reno, Nevada, July 1998.

578

Modelica 2005, March 7-8, 2005

Using Modelica and Control Systems for Real-time Simulations in the Pulp & Paper industry

Using Modelica and Control Systems for Real-time Simulations
in the Pulp & Paper industry
Johan Bäckman
Mattias Edvall
Metso Paper Sundsvall AB
851 94 Sundsvall, SWEDEN
johan.backman@metso.com
mattias.edvall@metso.com

Abstract
Metso Paper regularly uses process simulations when
designing and delivering a new pulp mill. The
simulations have two main purposes. Operators are
trained in running the new process before it exists
and complex control logic can be validated efficiently before start-up. The simulations are built using Dymola/Modelica, executed in real-time and
connected to the plant's control system.
This paper will discuss the general technical solution
for using Dymola/Modelica in combination with a
control system for real-time simulations. The paper
will also provide an overview of the different applications that Metso Paper has implemented. Expectations of future development of Modelica and connected software will be discussed from an industry
perspective.
Keywords: dynamic simulation; control system; pulp
and paper; operator training; logic verification

1

Introduction

Different kinds of simulations are used within Metso
Paper for designing and developing the pulp and paper processes. Static simulations for balancing and
dimensioning the process with respect to flows,
steam, chemicals etc. The second type is advanced
and computational demanding FEM-type of simulations for more detailed simulations and analyses of
different optional machine designs. The third type of
simulations is the real-time dynamic process simulator for operator training and control system verification. This paper will focus on the real-time dynamic process simulations. A training session using
simulators is shown in Figure 1.

The Modelica Association

Figure 1. Simulator training in progress
When delivering a new machine, process area or a
complete mill Metso Paper has offered dynamic process simulations since beginning of the 1990's. The
main purpose of these simulations is to train operators and other mill personnel in running the new
equipment in an efficient and optimal way. The operators get used to the new operator displays, interlocking logic and most importantly new process dynamics. Difficult and rare process conditions can be
introduced in the simulations. By regularly exposing
the mill personnel to these difficult situations in the
simulator environment, expensive and unwanted
stops in the real production can be avoided.
Earlier these types of simulations were made in a
single PC where the process simulations as well as a
mimic of the real operator displays and the plant's
control system was configured. Even if this system
worked fine technically speaking and served its purpose as an educational tool, it had some drawbacks.
The two major problems with this solution were:
• It was a very expensive solution due to the many
engineering hours needed in order to convert the
real operator displays and control logic into the
simulator world. When new revisions of displays
and control logic were made, new revisions must

579

Modelica 2005, March 7-8, 2005

J. Bäckman, M. Edvall

•

be made in the simulator as well. On top of this,
it was very difficult to reuse models and configurations between projects.
It was difficult to keep the simulator up to date
once delivered to a customer since every change
in the real control system and operator displays
must be followed by a corresponding change in
the simulator system. Typically, the changes in
the real process were done by the mill personnel
while changes in the simulator demanded involvement from other competencies. In practice
the simulator and real world configurations
slowly drifted apart.

Starting in beginning of year 2001 a new architecture
for dynamic process simulations within Metso Paper
were developed using Modelica and Dymola. The
main difference between the old and new architecture is that in the new architecture the real control
system and real operator displays are used instead of
including a mimic version of the two into the simulator. The simulation models are also designed in a
way that modular building blocks of typical process
equipment and areas easily can be reused from project to project. The advantages of the new architecture are substantial
• Since no mimic is done of the operator displays
and control logic the engineering hours has reduced dramatically. The modular design of the
new simulation models has also contributed to
lower the engineering hours since much can be
reused from project to project. The operators get
to use the real displays and real control system
when doing simulator training, and no changes
needs to be made in the simulator when changes
are made to the displays and control logic.
• It is much easier to keep the simulator system up
to date since the real control system is used.
Changes made to the displays and control logic
can be transferred into the simulator system directly by the mill personnel.
Another big advantage with the new architecture is
that the simulator system can be used to validate the
upper level control system and mill control system
before start-up. This has traditionally been a very
time and resource-consuming task and even then, the
quality of the validation has been difficult to verify
due to the complexity of the control logic. Errors in
the control system, as well as in the dimensioning of
process equipment, are corrected easily and effectively early in the projects. Considerably reductions
in test time have been noticed since starting using
simulators for test purposes. As the simulations get

The Modelica Association

more accurate it is also possible in some areas to pretune PID controllers using the simulator. Starting the
real mill with verified control logic, trained operators
and pre-tuned PID controllers are a great benefit for
Metso Paper customers.

2
2.1

The Simulator system
Architecture

The new simulator architecture is shown in Figure 2.

Simulator Control Room

Control System

Process Simulator

Figure 2. The new simulator architecture
A Metso Paper simulator system typically consists of
a control system that is the same control system used
to control the real process (example: metsoDNA,
ABB Industrial IT, Siemens PCS7, Emerson DeltaV,

580

Modelica 2005, March 7-8, 2005

Using Modelica and Control Systems for Real-time Simulations in the Pulp & Paper industry

etc). Another computer executes specific process
simulation models in real-time. The operators are
using the same operator displays as they would in the
real control room. The system can be extended to
include several computers that simultaneously are
running different simulations towards the same control system. Real control system hardware can be
used to execute the control logic and operator displays. However, a modern control system usually
offers a software version (example Metso's VirtualDNA) of the control system, which can be more
convenient to use. Included in the control system are
all control logic, graphical displays, PID controllers,
alarm limits, interlocking diagrams, trend displays
etc. Everything that an operator will have once running the real process is already there since it is the
same system being used.
2.2

Models

Using Modelica and Dymola a specific model library
has been developed including models that make it
possible to build complete simulations of Metso Paper machines and processes. Examples are SuperBatchTM cooking, Washing and Screening, Refining,
Pulp Bleaching and Pulp Drying area. In Figure 3 a
small part of the washing and delignification process
can be seen.

Together the models are used to build up simulations
of complete pulp mills. Creating a large net of equations defining the flows, pressures, temperatures,
chemical consumption, pulp consistency and other
process values, all values will react depending upon
the actions taken by the operator using the control
system. A complete simulation includes all process
machinery and instrumentation, starts with chips enter the digester area, and finish when dried and
bleached pulp exits the drying machine.
2.3

The simulation models are compiled with Dymola
forming a Windows application that is used as a realtime DDE Server. Modern control systems offer an
OPC Server in order to open communication with
any OPC Client. The Metso Paper simulator system
includes special software to transfer the signals from
the DDE Server in the run-time simulation to the
OPC Server in the control system. Since practically
all modern control systems have opened up to OPC
technology the communication link can be used
without changes no matter what control system the
customer selects. The only configuration that needs
to be done is a cross-reference list between the signal
names in the simulator and the corresponding signal
names in the control system. Typically are process
values like flows, pressures, temperatures, pH, consistencies etc, sent from the simulations to the control system. The control system writes values like
valve openings, starting orders for pumps and motors
etc, back to the simulation.
Modelica models for I/O communication have been
developed. They are using the input/output qualifiers
to accept values from, and to give values to, the control system via the communication link.
2.4

Figure 3. A part of pulp making process
The library includes models of Metso Paper specific
machinery such as SuperBatchTM digesters, DeltaCombiTM screens, Refiners, TwinRollTM presses,
OxyTracTM delignification towers and Pulp Drying
machines, but also more general equipment such as
valves, pumps, pipes, heat exchangers, tanks, etc.

The Modelica Association

Communication

Teacher interface

The extended functionality of the communication
link includes an interface for a teacher. From this
software a teacher can operate the dymosim application, start, pause and stop the simulation. It is also
possible to start the simulations with different initial
positions, empty tanks, almost full tanks etc. making
it possible to train how to get out of difficult process
situations without losing production.
Different kind of scenarios and disturbances can be
applied to the simulations to investigate how operators solve and detect common process problems.
Problems like drifting process values, malfunction in
valves, blinding of screens, channeling in reactors,
web break in the dryer section as well as other criti

581

Modelica 2005, March 7-8, 2005

J. Bäckman, M. Edvall

cal situations can be trained. Figure 4 shows screen
displays from the teacher interface.

Figure 4. Teacher interface
A large database is used to collect data from the
training sessions and each operator can evaluate their
actions and compare the results with earlier sessions.
2.5

3

Performance

Due to the complexity and scope of the process to be
simulated the simulation model files and I/O communication lists becomes large. For example when
simulating a SuperBatchTM digester area the I/O list
consists of about 1800 signals, the executable simulation file is close to 40 Mb. Figure 5 shows messages from a translation of a digester area model.
STATISTICS
Original Model
Number of components: 20084
Variables: 137615
Constants: 1574 (0 scalars)
Parameters: 35394 (69071 scalars)
Unknowns: 100647 (100658 scalars)
Differentiated variables: 9146 scalars
Equations: 52124
Nontrivial : 39885
Translated Model
C onstants: 53502 scalars
Free parameters: 17018 scalars
Parameter depending: 19966 scalars
Inputs: 0
Outputs: 0
C ontinuous time states: 9146 scalars
Time-varying variables: 42482 scalars
Alias variables: 24590 scalars
Number of mixed real/discrete systems of equations: 18
Sizes of linear systems of equations: {2, 2, 2}
Sizes after manipulation of the linear systems: {0, 0, 0}
Sizes of nonlinear systems of equations: {5, 732, 35, 35, 66, 38,
7, 14, 35, 7, 35, 18, 66, 18, 35, 7, 14, 35, 7, 14, 7, 7, 14, 35, 7, 35,
7, 7, 5, 1, 7, 23, 6}
Sizes after manipulation of the nonlinear systems: {1, 89, 4, 4,
9, 2, 1, 3, 4, 1, 4, 2, 9, 2, 4, 1, 3, 4, 1, 4, 1, 1, 3, 4, 1, 4, 1, 1, 1, 1,
1, 3, 1}
Number of numerical Jacobians: 0
Finished

Figure 5. Translation of a digester area model

The Modelica Association

The digester area is about 25% of the total pulping
process. It is possible to run these kinds of simulations on a PC. However, the speed of the internal
memory bus is vital to simulation performance. Due
to the slow nature of pulping processes, it is common
that the simulations are run for several days without
interruptions.
For training purposes it is very important that the
system is robust and that the accuracy is high enough
for the operators to trust the simulations. However, it
is important to keep in mind that the purpose is not
to simulate each process component as accurately as
possible. The purpose is to produce a simulation of a
large area including a large amount of equipment
that will give an operator the right look and feel for
the dynamics in the mill.

Practical experiences and future
development

Today the simulator system has been connected to
the following control systems: metsoDNA, ABB Industrial IT, Emerson DeltaV and Siemens PCS7.
There are of course advantages and disadvantages
with all of these systems when it comes to engineering efficiency and costs, but from our point of view;
there are no technical differences. The same communication link has been used without modification,
and the signal transferring between an OPC Server
included in the control system and the real-time
simulations has shown a similar performance with all
mentioned control systems. Two complete simulator
systems have been delivered so far. Figure 6 shows
operator training in Chile. During 2005, three more
deliveries are expected.

Figure 6. Simulator training in Chile
During the internal development work and practical
training sessions with Metso Paper customers around

582

Modelica 2005, March 7-8, 2005

Using Modelica and Control Systems for Real-time Simulations in the Pulp & Paper industry

the world some development ideas have emerged.
The ideas, if emasculated, would heavily increase the
value and competitiveness of using Modelica and
Dymola in combination with control systems for
real-time simulations. Some of the most important
areas to strengthen in order to meet industry demands in the future are as we see it:
• Replacing the Dymosim DDE Server with a
modern OPC Server will open the simulation environment to all modern control systems and increase the communication performance significantly. Many OPC Clients are available on the
market, some even free of charge. Viewing and
changing simulator values during run-time
simulation would be facilitated.
• A possibility to see and change simulation values
from the modeling user interface during run-time
simulation would be very time saving and valuable during development of large simulation
models.
• Increased debugging functionality. When a
model for some reason crashes after several days
of simulation, it is very hard to find the reason
quickly. The large simulation models and long
simulation time makes it difficult to store values
for debugging due to the huge amount of data
collected.

4

Conclusions

Dynamic process simulation is a powerful tool when
educating new operators in running a pulp mill. Successful real-time simulators using Dymola/Modelica
with control system in the loop have been used for
control system validation and for operator training in
Metso Paper processes. The strong modular focus in
Dymola/Modelica have been helpful in reusing
simulation models and thereby shortened the engineering hours in new projects.
Some proposals of improvements to Dymola/Modelica has been made in order to strengthen
the focus, increase competitiveness and general
awareness of using Dymola/Modelica in industry
applications.

The Modelica Association

583

Modelica 2005, March 7-8, 2005

The Modelica Association

584

Modelica 2005, March 7-8, 2005

Session 7c
Modelica Interfaces

The Modelica Association

585

Modelica 2005, March 7-8, 2005

The Modelica Association

586

Modelica 2005, March 7-8, 2005

Usage of Modelica for transmission simulation in ZF

Usage of Modelica for transmission simulation in ZF
Jochen Köhler
Alexander Banerjee
ZF Friedrichshafen AG
Graf-von-Soden-Platz 1, D-88046 Friedrichshafen, Germany

Abstract

1

At ZF transmission models are an essential component within the development process. To guarantee
an efficient use of modeling know how as well as a
persistent use of models in different simulation environments, Dymola has been declared as a standard at
ZF and a central model component library ZFlib has
been developed accessible to all business units. This
paper gives an overview of some features of the library, such as easy parameterization of models independent of the environment in use and the export of
complex models into environments with simple integration algorithms. Furthermore a short description
of the automatic testing of the library which guarantees a software development process at a high level
of quality will be given.

For ZF as an automotive vendor for transmission
components and systems, modeling and simulation
has a long tradition. A long time ago the modeling of
transmission systems was mainly done by experts of
the business units which often used different tools
and different approaches. In the meanwhile there has
been an exponentially increasing demand for models
and model components which should be accessible
to and usable even by non-experts. Due to this fact
ZF started a centralization process with the intention
to standardize the modeling approach of transmission
systems and merge the modeling know-how of components and systems in one library accessible to all
business units. A further requirement has been to
guarantee a persistent use of models in different
simulation environment (e.g. SIMULINK or dSpace),
which actually demands for models given as C-Code
(Figure 1). Beside this, the tool under consideration

Keywords: Model Export, Parameterization, Automatic Testing

Introduction

Figure 1: Exporting models to various environments

The Modelica Association

587

Modelica 2005, March 7-8, 2005

J. Köhler, A. Banerjee

should offer the user an interactive graphic interface
for modeling. Since Dymola offers such an interface,
allows the continuous extension of libraries by using
the Modelica language and enables the user to export
models as C-Code, ZF came to the decision to define
Dymola as a standard for transmission system modeling.
This was the starting point for the development of a
Modelica library called ZFlib which is an extension of the commercial library Powertrain. This
library has a lot of models of ZF specific components as well as some add-ons for the export to other
simulation tools.
The focus of this article is a short explanation of the
ZFlib and how models can be parameterized independently from the environment in use (chapter 2),
how the export of complex models into environments which only allow the use of discrete integration algorithms (chapter 3) has been realized and
how an automatic testing of modules can be performed whenever a modification within the library
has occurred (chapter 4).

2
2.1

dardized format. At initialization the files are read by
the model for parameterization. Therefore some extensions had to be done to read the files and parameterize the modules in an easy way.
2.2

The format of these ASCII-files has a very primitive
syntax to define scalar or vectors as well as characteristics with variable dimensionality. One parameter
is defined simply by a triple: Identifier, Unit and
Value (see Figure 2).
J1
[kgm^2] 0.1
; scalar parameter
InU [-]
0
1
2
OutY [-]
0
1
2
; two vectorial parameters
Test_Table2D[
[-] U1 [-] 0
1
2
2
Y [-] -2 -1
0
1
Y [-] -1
0
1
0
Y [-] 0
1
2
Test_Table2D]
; Two-Dimensional-Table

Usage of ZFlib
ZFlib as code generator

The main issue in using the ZFlib is to set up models that can be used within different environments –
not only with Modelica Tools like Dymola or MathModelica. Dymola is used to translate the models
developed with Modelica to C code.
The generated C code in form of the dsblock function can be integrated into the demanded environment. This is done already by Dynasim for Simulink
with a special interface-module called DymolaBlock.
Nevertheless we did some modifications of this
module to meet our special demands. Other interfaces for further environments (e.g. ASCET and
some ZF programs) were developed to wrap the different calls (e.g. initialization, update …) from these
environments to the appropriate functionality of the
dsblock function.
One big drawback with the generated code of a standard Modelica model is that we can’t parameterize
the model in one, easy way in different environments. Another aspect is, that we want to use a standardized way of parameterization in ZF for these
models. The basic idea was to separate models and
parameters from each other. The parameter values
should be stored in ASCII-files according to a stanThe Modelica Association

Performing parameterization in different
environments

Figure 2 Example of an ASCII-file

A large database of parameter data exists already in
ZF that shall be used also for the Modelica models.
We implemented a Modelica package to read these
files and made the data available to other modules.
The functionality consists of two parts:
First, we implemented some basic Modelica functions that serve as an interface to a set of Cfunctions, which do the data-management.
Second, the C-functions handle the reading of the
needed files, collect all parameter data specified
there and make them available within Modelica. For
tables, also the interpolation is done in C-Code.
To use this functionality, users have to do the following things:
1. Specify the files to be read:
By including the Load block, the user specifies all
the files to be read in a list. At initialization all parameters are scanned and stored in database.
2. Use scalar or vectorial parameters

588

Modelica 2005, March 7-8, 2005

TorqueTable

ZBF
Table 2D
ZBF
Y
dY/dU

I_Engine

w

With the ZFlib-functions GP(String identifier) and GV(String Identifier), the
model finds the data of interest through the defined
data identifier within the database. If the asked identifier is not found in the database, the simulation
aborts.

SpeedSensor1

Usage of Modelica for transmission simulation in ZF

Torque1
tau

J=ZBF.Functions.GP("J1")

Load Block

ZBF

Figure 4 Example of a model using ASCII file package

2.3

Figure 3 ASCII file package in the ZFlib

3. Use tables
For using tables we have implemented three different
Table blocks for one-, two and N-dimensional Tables. They also get access to the tables within the
database through some interface functions. With the
function (BoundsTableND(String Id)) the
boundaries of the table input vectors can be queried.
In addition to the interpolation, the gradient (one dimensional) or normal vector (n-dimensional) can be
calculated on demand. This is very useful for some
forward control algorithms.
Another useful feature is the possibility to convert
the ASCII data to SI units. This is needed because
very often data are saved in units like [rpm] or [mm]
and Modelica handles only SI units.
The implementation of these features was done in
C++. The sources or binaries can be included in
various environments and therefore, this kind of parameterization can be used everywhere, where code
can be included.
Using this functionality allows the user of the model
to change the parameters easily by editing the used
ASCII files. The changed parameters will be used at
the next simulation run without a new translation of
the model.

The Modelica Association

Extending from the Powertrain library

The ZFlib was extended from the commercial library Powertrain. The maximum benefit can be
achieved by reusing the included elements as often
as possibly. Nevertheless, we want to use our own
tables within the models in the Powertrain library. Due to this, modifications have to be done for
a few models within the Powertrain: The Modelica keyword replaceable in front of all declarations of tables had to insert.
Another modification concerns the usage of the bus.
The concept of the Powertrain bus has a lot of
advantages: The implementation of complex models
is easily done and quite transparent. It’s very easy to
change big parts of a complex model without intensive modifications. We decided to extend our own
bus called ZFBus from the Bus in the Powertrain. To be able to use the control units in the
Powertrain together with this extended bus it was
also necessary to add the replaceable keyword
to all bus declarations with control unit implementations. It would be more convenient, if it would be
possible in Modelica to link connectors that extend
from one root. Another approach to make combinational usage of different libraries easier could be a
hierarchical structure of one global bus.
With this second modification we can use all models
in the Powertrain and our library seamlessly.
Certainly it would be a great help to add these modifications to the original Powertrain without any
disadvantage for other users.

589

Modelica 2005, March 7-8, 2005

J. Köhler, A. Banerjee

3

Using Modelica models with discrete algorithms in Simulink

Simulink is used more and more to develop control
algorithms for transmissions in ZF. The simulation
of systems with a digital controller requires the use
of a discrete, fixed step integrator. On the other hand,
there is a very strong demand to use complex and
often numerically stiff models of transmissions to
test these controls in simulation. Hence the use of
numerical integrators with varying step size is necessary.
These transmission models are modeled in Dymola
using the ZFlib. Because of the arguments mentioned above, the original DymolaBlock for Simulink
can’t be used unmodified in conjunction with the
fixed step integrator from Simulink.
3.1

Making the Dymolablock “discrete”

Figure 5 The user can change the DymolaBlock behaviour easily by changing the mentioned parameters

So, we decided to embed a continuous variable step
integrator within the S-function of the DymolaBlock.
We used the same DASKRT integrator as in Dymola
[1]. To make the modified DymolaBlock look like a
discrete Block, the S-function just returns that no
continuous states are needed. Then it’s easily possible to combine this model with discrete controllers in
Simulink.
The DASKRT is used exclusively for the exported
Modelica model inside the S-function. Every time
the outputs are demanded from Simulink, the Sfunction calls the internal integrator to integrate up to
the new time. During this interval several events may
happen, that have to be handled. Additionally we
have to make sure, that the DASKRT stops correctly
at the given time point. Otherwise it may happens,
that the integrator takes a step size larger than the
sample interval of the Simulink model. This would
lead to outputs which refer to a later point in time
with respect to the actual integration time.
3.2

block. Furthermore you can specify the tolerances of
the integration algorithm. MinProgress is an abstract
criterion to abort the simulation if the simulation
progress is too low.

With GenerateResult the user can enable the logging
to the dsres.mat file if needed. This is more convenient than the check box in the original DymolaBlock
because you can change it without compiling.
The interface between Simulink and the Modelica
model consists of two connectors that contain all
input or output signals. It’s possible to use the same
or similar connectors for different models because
they contain the same signals as the “real software
connectors” in a vehicle. Another advantage is that
existing algorithms can be connected easily to these
models.

Controlling the behavior of the DymolaBlock

A simple model was implemented in Modelica as a
parent to be able to control the behavior of the modified DymolaBlock. The declared parameters can be
read by the DymolaBlock. The user can enable or
disable the internal integration by setting the parameter InternalIntegration to 1 or 0. So it’s possible to
use the model also in continuous environments or
with the simple fixed step integrators of Simulink.
The FixedStepSize specifies the sample time of the
The Modelica Association

Figure 6 Example for a model that can be exported to
Simulink with one input connector (top) and one output connector (bottom).

590

Modelica 2005, March 7-8, 2005

Usage of Modelica for transmission simulation in ZF

As one can see in Figure 6, the interface between
Simulink and Modelica consists exclusively of directed input or output signals. This is caused by the
analogy to a connector for a control unit but it’s also
a design decision to have no coupling on a “physical
layer”. Due to this fact, there is no problematic coupling of two integrators as it can be with “normal cosimulation”.

4

Automated Testing of ZFlib components

One important aspect in implementing basic elements for a library which will be used heavily in
simulation, is to be sure, that everything works correctly. Based on experience, modifications on library
elements that worked well before can cause strange
errors in a complex model. To avoid this, we introduced basic “single element tests”. For (almost)
every ZFlib element at least one test exists. Such a
test shall stimulate an element in a way that a specific behavior can be checked.
For more complex elements, it is necessary to set up
several tests with different parameters or with different structures to cover all possible “areas”. After the
tests have been set up, the developer has to judge, if
the simulation result is correct. This result and the
corresponding parameters are saved as a reference
for later comparison. Of course, this work has to be
done very careful!
This approach leads to several benefits. The original
developer had to make sure that the new module
works as required. The second benefit is the possible
use of the tests as an example on how to use the
tested element. As mentioned, the third benefit is the
possibility to test this element after modifications
against the old references.
Also, if a developer finds a bug in an element later
on, he can set up new tests that check, if the bug still
exists. Testing with these new tests, the developer
can be sure, that the same error can’t pop up again
after another modification.
These tests are useful only, if they are run on regular
basis. They should be performed and automatically
compared with the reference results of all elements.
Therefore we implemented some Matlab scripts,
which scan the Modelica code for existing tests, run
them automatically and compare the results with the
reference files.

The Modelica Association

Figure 7 Test for a clutch with an opening/closing
spring.

4.1

Collecting tests

To add a test to the automatic procedure it must fulfill two conditions: It has to be inside a package
called Tests and it has to be extended from the basic
model ZFlib.Tools.TestModel. This model
defines some tolerance parameters and an OutPort
reference to the signals which are used for comparison.
// preparation
clear
openModel("../dymola/zflib/package.mo")
checkModel("ZFlib")
cd ../dymola
// newModel M_Limiter
translateModel(
"ZFlib.Blocks.NonLinear.Tests.M_Limiter")
// newResultTest
RunScript(
"../TestReferences/M_Limiter_Ref.mos")
simulate
$copy

dsres.mat ..\temp\M_Limiter.mat

// endTest
// newModel M_RateLimiter
translateModel(
"ZFlib.Blocks.NonLinear.Tests.M_RateLimiter")
// newResultTest
RunScript(
"../TestReferences/M_RateLimiter_Ref.mos")
simulate
$copy dsres.mat ..\temp\M_RateLimiter.mat
// endTest

Figure 8 Modelica Script built by the test collector

591

Modelica 2005, March 7-8, 2005

J. Köhler, A. Banerjee

For each of these models, the collecting function
searches for reference parameter files (exported from
dsin.txt). These were saved earlier with the result
reference files. For every parameter file that can be
found, the model is simulated and tested against the
corresponding reference result. The collecting of the
tests leads to a Modelica script file that can be run by
Dymola.
4.2

completed, the user can take a look at the test result
log files and decide on further actions.
The result log files can be run in the same way as the
first test script. The log file provides some explanations of the errors, which supports the user in doing
the corrections.

5

Performing tests

The test script is parsed by another Matlab script that
calls the Modelica instructions sequentially and tests
the results. Every line in this script is a test! First of
all the whole package is syntactically checked. After
this, each test model is translated. If this was successful, the simulation runs can be performed.
// preparation
// newModel M_StarterPrimitive
translateModel(
"ZFlib.Engines.Tests.M_StarterPrimitive")
// .. Caused an Error
// endTest

Conclusions

The ZFlib library has been used successfully in
several projects working with various simulation
environments. The ASCII file parameterization is
well accepted. With the modified PowerTrain
library we can use a lot of components and save time
for implementing ZF-own models.
The enhanced “discrete” Dymola-Block works fine
and quite fast (also in combination with ZBF parameterization).
The automated testing needs some extra effort. But
on the other side, errors can be found quicker and
other users get a better understanding of the tested
element.

// newModel M_EngineTableWithBrake
translateModel(

6

"ZFlib.Engines.Tests.M_EngineTableWithBrake")

References

// newResultTest
RunScript(

[1]

"../TestReferences/M_EngineTableWithBrake_Ref
.mos")
// .. Caused an Error
// endTest
// newModel M_Clutch

L. R. Petzold. A description of DASSL: A
differential-algebraic system solver. In R. S.
Stepleman, editor, Scientific Computing,
pages 65–68, Amsterdam, 1983, NorthHolland.

translateModel(
"ZFlib.Mechanics.Rotational.Tests.M_Clutch")
// newResultTest
RunScript(
"..\TestReferences/M_Clutch_Ref.mos")
simulate
$copy

dsres.mat ..\temp\M_Clutch.mat

// endTest
// COMPARE DIFF M_Clutch
Correlation Coefficient <0.99s.mat ..\temp\M_KK_3.mat
// endTest

Figure 9 Result script with failed commands and error
description

The testing environment can test against the result
file and against the log file (dslog.txt). In the result
file, only signals that end in the Outport called
Reference are tested (see Figure 7). Every command
that was performed successful is appended to a text
file. In the same way every command that causes any
error is stored in another file. Nevertheless, the
whole test script is executed. After the run has been

The Modelica Association

592

Modelica 2005, March 7-8, 2005

Implementation of a Generic Data Retrieval API for Modelica

Implementation of a Generic Data Retrieval API for Modelica
Dr. Michael M. Tiller
Ford Motor Company, Research and Advanced Engineering
Dearborn, MI USA

Abstract
For model developers, the Modelica modeling
language is a valuable tool for describing the behavior of dynamic systems. However, developing models and performing analyses as part of a large scale
engineering operation involves much more than creating behavioral descriptions [1],[2]. In order to integrate modeling and simulation into a typical product development process it is necessary to extract
data (e.g. product information, part geometry, controller calibrations) from external sources.
This paper will describe an application programmer interface (API) for data retrieval that has
been developed using the standard external function
interface in Modelica. The API is composed of generic functions that can be implemented to extract
data from a variety of external data sources. Such an
API can be used to access data for material properties, part geometries, data tables, etc.
While the interface definitions are generic, our
implementation of the generic API was specifically
developed to retrieve data stored in XML [3] and
utilizes the libxml2 library [4] to retrieve and
parse XML files containing product information.
Furthermore, the API queries are performed using
XPath expressions [5].
Currently, there is no standard API to allow
Modelica models to retrieve information from external data sources. Hopefully this paper can demonstrate the power of such capabilities and prompt further discussion on formalizing a standard API with
similar functionality.
Keywords: XML, XPath, HDF, MATLAB, Java

1

Introduction

Data is an integral part of modeling. Because
Modelica is so often used for physical, firstprinciples modeling, there is typically a need to provide design data for numerous individual compo-

The Modelica Association

nents. Such data is often available “somewhere” (we
will use the term external data source as a generic
term for sources of such data) but it must be collected to populate the Modelica model.
Because there is no standard way in Modelica to
access such external data sources, this data is typically either entered by hand for each component or
aggregated and organized into Modelica record definitions. We will refer to data managed in this way as
a Modelica representation of the data.
While Modelica representations can be used,
there are numerous drawbacks when trying to integrate the resulting models into large scale engineering and analysis processes. For example, such data
often already exists in an external data source and
copying it into a Modelica representation is both tedious, redundant and error prone. It also makes
models that depend on the Modelica representation
of the data difficult to update as new data becomes
available. The best approach is one that retrieves the
data as needed from the centralized external data
sources. For example, if product information is
stored in a relational database somewhere within a
company, the ideal situation would be that the information could be automatically extracted directly
from that database.
Another problem with Modelica representations
of the data is cataloging large collections of component data. Representing such data in Modelica
means, in practice, that large datasets are loaded into
the modeling environment when only a very small
percentage of that data is used. For example, we
have data for a large number of production engines.
The space required to store the data for each engine
is considerable. We currently store all this information in a hierarchy of Modelica records. Storing the
data in this way means slower loading times and
higher memory consumption even though any given
analysis only requires the data for one particular engine. Another issue with cataloging the data is querying the data set to see what information is available. While most data management systems include
formalized query systems, there is no functional

593

Modelica 2005, March 7-8, 2005

M. Tiller

equivalent in Modelica to query languages such as
SQL, XPath or XQuery [6].
Often times, different characterization data is
needed for the same component depending on the
desired level of fidelity. Representation in Modelica
often results in a variety of record definitions associated with a given physical component (i.e. one for
each level of fidelity). Typically these record definitions include large amounts of redundant data between them. However, because of the semantics associated with records1 in Modelica, it is difficult to
eliminate such redundancy.
Use of data expressed directly in Modelica typically results in that data being “hard-wired” into the
resulting simulation. Although the data can be
changed it is typically a manual process and impractical for large data sets. Ideally it should be possible
to load the data on demand from a data source in the
event that such a data source has been changed or
updated.
Another concern is storage of the data. A centralized data source is often accessed over the network. As such, the data is only stored in one place.
This not only conserves space but also provides a
definitive source for the data. If data is represented
in Modelica there is the risk that variations will develop across multiple copies of the data. Loading
data on demand over a network provides a more dynamic system for data management.
Some applications require very large data sets to
be available but only use relatively small chunks at
any given time [7]. In such a case, a system that is
able to load data into memory for use by a model on
an “as needed basis” can save a considerable amount
of space (e.g. in results files). By avoiding the need
to represent the entire dataset in Modelica and the
compilation process (e.g. symbolic analysis) avoids
the need to read in and analyze such data.

2

Interface

For these reasons, we have developed an API
that allows us to retrieve data from external sources.
This is not a “database API” because it does not include the complete set of operations typically associated with database interactions (e.g. changing data,
committing transactions, etc). Instead, the focus for
this package is on retrieval only. The interface is
generic so it could be mapped to a wide variety of

1

Specifically, the strict requirement that assignment is
only possible between identical record types.

The Modelica Association

external data sources (including, but not limited to,
databases).
In this section we will go through the API in detail to explain the basic functionality before moving
on to a discussion of our implementation of the interface and some examples of its use.
The data retrieval API is implemented within a
package called DataRetrieval. The package
contains several class definitions that extend from
the ExternalObject class used for handling opaque
references to external (e.g. C language) data. In addition, it contains several functions that operate on
these locally defined data types.
2.1

Opening and Closing a Data Source

In order to access a data source it is first necessary to open it for queries by instantiating an object to represent the data source. This object can
then be used in subsequent query operations. To
open a database, a Source object must be created,
e.g.
import DataRetrieval.*;
parameter Source s=Source(
format=”…”,
url=”…”,
context=”…”);

where format identifies the format of the data
source (e.g. “XML”), url is a string encoded using
the uniform resource locator (URL) syntax [8] and
context is used, in a data source specific way, to
limit the scope of subsequent queries.
The ExternalObject interface also provides for
a destructor although that is not called directly so the
details are not included.
2.2

Query Expressions

Once a data source is available (in the form of
a Source object), queries can be made against it.
Because Modelica is a strongly typed language and it
is currently not allowed to overload functions, query
functions are defined for specific data types (i.e.
String, Real, Integer and Boolean) and for specific
dimensionalities (e.g. scalars, vectors, matrices, etc).
But, each query function relies on a common query
expression syntax.
The precise semantics of the query expressions do not necessarily have to be defined for each
data source. The generic aspect of the API does not
interact in anyway with the semantics of these expressions. As we will discuss shortly, our implementation uses XPath expressions for such queries.

594

Modelica 2005, March 7-8, 2005

Implementation of a Generic Data Retrieval API for Modelica

2.3

Retrieving Scalars

For each built-in type, there is a function to
extract scalars of that type from the data source. For
example, the function getReal is invoked as follows:
import DataRetrieval.*;
parameter Real x = getReal(
source=SourceObj,
name=”…”);

where source is a Source object, name is a
query expression to identify the scalar. The function
returns a scalar of the type indicated by the name of
the function. In a completely analogous fashion,
similar “get” functions are defined for each other
built-in type.
The assumption is that the underlying, data
source specific layer will interpret the query expression according to the semantics for that source and
will perform the necessary casting of the data into
the appropriate built-in type.
2.4

Retrieving Arrays

Unlike scalars, extracting data from arrays
cannot be done in a single step for several reasons.
First, we do not know, a priori, the size of an array
to be extracted from an external source. So if the
entire array is to be loaded, we must first establish
the size of the data and then use that information to
declare the Modelica variable to hold the data. Furthermore, it is often the case that we may only wish
to extract a portion of an array and in some cases
which particular portion may change during the
simulation (e.g. table lookup).
For these reasons, a special type of ExternalObject must be created to represent arrays.
Creating an instance of such a type loads the entire
array into memory along with information on the size
of each array dimension. For each built-in type there
is a type definition in the DataRetrieval package formed by concatenating the built-in type name
with either Vector or Matrix. For example, a
matrix of Reals would be defined by RealMatrix. Creating instances of these special objects is
accomplished by calling the constructor, e.g.
import DataRetrieval.*;
parameter RealMatrix props =
RealMatrix(source=engine,
rows="…", cols="…");

where source specifies the data source, rows is an
expression to identify all rows to be loaded and

The Modelica Association

cols is an expression (typically evaluated within
the context of each row) to identify individual columns.
Once these special objects have been created,
data can be extracted from them by using the ‘extract’ function. Because it is not possible in Modelica to define methods associated with these objects,
functions have been defined to perform such extractions. The name of the function is constructed by
prepending extract to the name of the special
type from which the data will be extracted. For example,
import DataRetrieval.*;
parameter Real y[…,…] =
extractRealMatrix(mat=MatrixObj,
i=5:17, j=1:3);

where mat is a special array object (whose type is
consistent with the name of the extraction function,
e.g. RealMatrix in this case), i represents the
row indices of the elements to be extracted and j
represents the column indices of the elements to be
extracted.
While it is quite simple to write special functions to provide the size of the data associated with
these array objects, it is not particularly useful for
reasons that will be discussed later in Section 6.
2.5

Retrieving Records

Given the ability to extract scalars and arrays
from data sources, we can do more sophisticated
things like populating records with information from
data sources. Ideally, it would be possible to automate the process of loading records with information
from external data sources. However, such functionality would require some degree of integration with
the underlying tool or some kind of reflective capabilities in the Modelica language itself. Nevertheless, it is certainly possible (using the functionality
already described) to load records from data sources
using specially written functions (see Section 4 for
an example).
As previously eluded to, data sources are not
likely to match Modelica records definitions exactly.
Typically such external sources will include information that is not modeling related. Of the information
that is modeling related, only subsets may be useful
depending of the model’s particular level of fidelity.
For this reason, the fact that information in a data
source does not have to match the Modelica record
definition exactly (either in naming or in structure) is
a useful advantage. It means that a single data
source can be used for modeling and non-modeling

595

Modelica 2005, March 7-8, 2005

M. Tiller

related information and that information for different
levels of model fidelity can be grouped together in
the same data source.
2.6

Querying Available Choices

Our data retrieval API is built around the idea of
query expressions. In most of the previous sections
it is assumed that the query expression is written to
match exactly one piece of data. However, allowing
query expressions to match multiple pieces of data
can be quite useful because it would provide tools
with the ability to identify all data that is potentially
compatible for a specific data type. For example,
when loading records that characterize electric motors it is useful to query a data source for compatible
data and use it in the same way that the choices
family of annotations are used.
The current version of our API does not provide
such functionality for two reasons. First, such functionality would require tool support. The other reason is that such functionality would require certain
concepts (e.g. ordering, filtering, etc) not current expressed in the data retrieval API. In Section 6 we
will discuss how such capabilities could be implemented with some degree of tool support and a
slightly more sophisticated querying scheme.

3

But storing the data is only one aspect that we
need to worry about. The other aspect is querying
our data source to extract data. For this, our implementation uses XPath, a standard for “addressing
parts of an XML document”. XPath provides a standardized way of identifying what data in an XML
document we wish to extract. A similar emerging
standard is XQuery [6] which may prove to be a superior (and mostly backwardly compatible) technology once it is formally standardized.
Consider the sample engineering database
shown in Figure 1. We will use this trivial database
to demonstrate the capabilities of the XPath standard.
Although the data and structure of the database are
quite simple, all these examples could be applied to
much larger databases without alteration.
<?xml version="1.0"?>
<engineering_data>
<product name="ZY300">
<base_motor type="C12"/>
</product>
<part>
<motor name="C12">
<rotorJ>0.011</rotorJ>
</motor>
</part>
</engineering_data>

Implementation

Up to this point, the discussion has been completely generic with only a few fragments of actual
code and only vague discussions on query expressions. In the next two sections we will describe an
implementation of the API and get into specific detail about how it can be used.
Our implementation was developed specifically to extract data from XML documents. Such
documents may exist on web servers or they may be
stored in local files. XML is fast becoming an important technology in all aspects of computing because of its ability to structure information in an operating system, programming language and application neutral way. In addition to existing high quality
implementations [9], there are several advances on
the horizon that will support handling of large collections of binary data [10], [11] (e.g. simulation results).
We treat each XML document as an objectoriented database (OODB). An OODB is useful for
storing heterogeneous collections of objects. In our
experience, engineering data (part dimensions, test
data, etc) fits quite well into OODBs.

The Modelica Association

Figure 1: Sample Engineering Database

Let’s begin with a simple example. Imagine
we wanted to extract the name of the base motor
used in the ZY300 product. Using the query expression:
//product[@name=’ZY300’]
/base_motor
/attribute::type
to query the database shown in Figure 1 would return
‘C12’. The ‘//’ at the start of the request means “at
any level in the document hierarchy”. The ‘product’ string following this is interpreted as the name
of the element type that is being requested. Anything contained in ‘[]’s represents a predicate.
Elements for which the predicate is false will be filtered. In this predicate ‘@name’ represents the attribute ‘name’. So the first line locates the ZY300
product in the database. Each subsequent ‘/’ in the

596

Modelica 2005, March 7-8, 2005

Implementation of a Generic Data Retrieval API for Modelica

expression is used to indicate traversal one level
deeper into the hierarchy. If a name is prefixed by
‘attribute::’ that indicates that the query is for
an attribute rather than an element. So the complete
expression can be interpreted as “Search the hierarchy for product elements whose name attribute is
ZY300 and for each of these find the base_motor
element immediate below it and return the value of
the type attribute for that element”.
Imagine we wish to extract the value contained between the rotorJ tags in Figure 1. We
can extract that data with the following XPath expression:
//motor[@name=’C12’]
/rotorJ/text()
This query is quite similar to the previous query except it uses the ‘text()’ function to return the textual content within the rotorJ element.
But now let’s look at a more challenging
example. In the second example, we assumed that
we knew the model name for our motor, C12, a priori. Imagine we want to extract the rotational inertia
of the rotor but we don’t know the motor name. Instead, what we know is that it is the base motor used
in the ZY300 product? In this case, we can combine
the two queries we made previously into:

to use the libxml2 [4] library that was developed
for use with the Gnome desktop environment. The
libxml2 library includes complete, robust implementations of many XML related standards including DOM [12], SAX, XPointer [13] and XPath [5].

4
4.1

The Modelica Association

Retrieving Parameter Values

One of the most common uses of the data retrieval API is to supply parameter values in a model.
In this section we will show how the data retrieval
API can be combined with a sample data set (shown
in Figure 2) and specific query expressions (using
the XPath notation described in Section 3) to accomplish this task.
<?xml version="1.0"?>
<engine_data>
<engine name="Beta">
<real name="bore">88.2</real>
<stroke>84.0</stroke>
<val name="conrod" units="mm"
value="125.0"/>
</engine>
<engine name="Gamma">
<real name="bore">87.2</real>
<stroke>85.0</stroke>
<val name="conrod" units="mm"
value="123.7"/>
</engine>
</engine_data>

//motor[@name=
//product[@name=’ZY300’]
/base_motor
/attribute::type]
/rotorJ/text()
With this example we have nested our requests for
the type of base motor used inside a predicate used to
search for the motor. By using the query for the
ZY300 base motor type in the predicate involving
the motor name, we were able to identify rotor inertia based on its relationship to the ZY300 product
rather than by name.
These are a few examples of the kinds of
queries that are possible with XPath expressions.
This is by no means a complete introduction to
XPath. Instead the goal of these examples was to
provide sample expressions so that expressions in
subsequent examples can be interpreted.
It is important to note that parsing XML, converting it into a traversable data structure and implementing an XPath query engine are not trivial
tasks. Fortunately, there are multiple implementations of these standards that can be used as off-theshelf software components. For our work, we chose

Examples

Figure 2: Sample Engine Data

An important thing to note about the engine
data shown in Figure 2 is that each parameter
(bore, stroke and conrod) are represented using different XML constructs. The engine bore is
represented as the text inside a generic real element, the stroke appears as the text inside a special
element type of its own and the connecting rod
length is given by an attribute associated with another generic element type, val, but with a specific
string, conrod, given for its name attribute.
So the challenge in this example is to show
how XPath syntax is expressive enough to allow us
to address each piece of data even though the contexts are quite different. Figure 3 shows the various
XPath expressions that can be used to extract the
necessary data from the XML file.

597

Modelica 2005, March 7-8, 2005

M. Tiller

function Load
import DataRetrieval.*;
input String engine;
input String url;
output EngineData data;
protected
String context=
"//engine[@name='"+engine+"']";
Source source=
Source(format="XML", url=url,
context=context);
algorithm
data.bore :=
getReal(source=source,
name="real[@name='bore']
/text()");
data.stroke :=
getReal(source=source,
name="stroke/text()");
data.conrod :=
getReal(source=source,
name="val[@name='conrod']
/attribute::value");
end Load;

model TestReals
import DataRetrieval.*;
parameter Source engine =
Source(format="XML",
url="engines.xml");
parameter Real bore =
getReal(source=engine,
name="//engine[@name='Beta']
/real[@name='bore']
/text()");
parameter Real stroke =
getReal(source=engine,
name="//engine[@name='Beta']
/stroke/text()");
parameter Real conrod =
getReal(source=engine,
name="//engine[@name='Beta']
/val[@name='conrod']
/attribute::value");
end TestReals;
Figure 3: Parameter Extraction

4.2

Populating Records

The example shown in Figure 3 includes several complex XPath expressions. Because it can be
difficult to formulate such expressions and because
entering them manually or copying and pasting them
several times can be error prone and/or difficult to
maintain, it is desirable to try and encapsulate these
expressions somehow. One way to accomplish this
in Modelica is to create a special record type for the
data and then create a function that can populate
such a record automatically. For example, consider
the following Modelica record definition:
record EngineData
import Modelica.SIunits.*;
parameter Diameter bore;
parameter Length stroke;
parameter Length conrod;
end EngineData;

Figure 4: Populating a record

The function shown in Figure 4 also highlights another feature of the data retrieval API.
When the source object is created, the optional
context argument is used to define the context in
which all subsequent XPath expressions should be
evaluated. What this means in practice is that it is
assumed that any queries associated with the
source object apply only to the specific engine for
which data is being retrieved. In this way, the query
expressions for each invocation of getReal can
leave off the engine selection prefix expressions resulting in shorter path expressions.
Once defined, the Load function shown in
Figure 4 can then be used to provide values for a record without any need to include calls to the data
retrieval API or any XPath expressions,
e.g.

To populate such a record with data from the
file shown in Figure 2, we could write a function that
constructed such a record from the name of the engine and the location of the data. Figure 4 shows
what such a function might look like.

The Modelica Association

598

parameter EngineData engine =
Load(engine="Gamma",
url="engines.xml");

Modelica 2005, March 7-8, 2005

Implementation of a Generic Data Retrieval API for Modelica

4.3

Loading Arrays

While loading a complete array into Modelica
for use in a model is an obvious example of how the
data retrieval API might be used, there are also other
reasons why you might want to load only a partial
array. Consider the case of cubic interpolation.
Imagine we have interpolation data that is stored in
an array as follows:

x1

f ( x1 )

f '( x1 )

xn

f ( xn )

f '( x n )

Generating “choices”

//engine/attribute::name

The results of such a query could then be used in
subsequent queries to select from elements in an
XML document. As mentioned previously, this capability would require some degree of tool support.

5
5.1

df="0"/>
df="1"/>
df="0"/>
df="-1"/>
df="0"/>

We can use the following Modelica code to evaluate
the function “z” described in the data file:
parameter RealMatrix data =
RealMatrix(source=f,
rows="//function[@name='z']
/point",
cols="attribute::x
|attribute::f
|attribute::df");
Interpolate2 y(x=time,
data=data);

This code defines the contents of the matrix using
the XPath expressions and then passes it to a model
which only extracts the function and derivative values for the two closest points at any given time.
Now, formulating a cubic polynomial approximation
for a simple 1D function does not necessarily require

The Modelica Association

4.4

As mentioned previously, an XPath expression
might match several different entities in an XML
document. For example, if we wanted to extract the
names of all engines present in Figure 2, we could
express this with the XPath expression:

Now, if we need to construct the cubic polynomial
approximation for any value x, we only need to
know the values for the function and its derivative
associated with xi and xi+1 (where xi<=x<=xi+1). The
important point is that we do not need to load the
entire matrix into a Modelica variable. Instead, we
could simply extract the values that we need at any
given time and construct the approximations in a
piecewise form. So given the following data file:
<?xml version="1.0"?>
<data>
<function name="z">
<point x="0" f="0"
<point x="1" f="0"
<point x="2" f="1"
<point x="3" f="0"
<point x="4" f="0"
</function>
</data>

such powerful functionality. However, if we wanted
to construct a 3D approximation for a relatively large
data set [7] using a complex cubic interpolation
scheme this API could help us minimize memory
consumption while still exposing the underlying
mathematical structure.

Discussion
Alternative Source

While the data retrieval API is generic, the
implementation discussed in this paper assumes that
the data will be represented natively in XML and the
query expressions will follow the XPath specification. But there are several other formats that are frequently used to store data and for which a retrieval
API might be useful. Examples of these would include HDF [14] and the MATLAB “.mat” file formats [15].
The only significant impact of changing the
format of the underlying data source is on the query
expressions. There are two ways to approach query
expressions in such cases. First, for each format a
(potentially) unique query expression syntax could
be used. This would allow, for example, SQL to be
used if the underlying data source was a relational
database. The drawback of this approach is that it
would be impossible to write general functions (e.g.
the Load function for loading engine data shown in
Figure 4) for an arbitrary data source. Instead, a
function would have to be defined for each potential
data source format.
On the other hand, if each data source used the
XPath approach for querying, then a consistent syntax would be available across the various platforms.
The advantage of this is that users would only need
to be familiar with XPath and no other query expression format. The difficulty is that XPath applies to

599

Modelica 2005, March 7-8, 2005

M. Tiller

XML, not to other formats. One way to bridge the
gap would be to define a mapping from each format
to XML. For example, consider the following MATLAB code which writes several matrices to a file:
>> A = [1, 2, 3; 4, 5, 6];
>> B = [6,7; 8,9; 10,11];
>> save 'AB.mat' -V4 A B

The contents of the file ‘AB.mat’ are stored in the
MATLAB specific format. But for the purposes of
formulating queries we could create a mapping that
defines a translation to XML that would result in an
XML document that looks like this:
<?xml version=”1.0”>
<MATLAB>
<matrix name=”A”>
<row><col>1.0</col>…</row>
<row><col>4.0</col>…</row>
</matrix>
<matrix name=”B”>…</matrix>
</MATLAB>
In this way, it would then be possible to load data
from MATLAB using the data retrieval API with
code like
parameter Source f =
Source(format="MAT4",
url="AB.mat");
parameter RealMatrix data =
RealMatrix(source=f,
rows="//matrix [@name='A']
/row ", cols="col");

Note that the data itself would not necessarily
have to be translated into XML. Instead, a special
XPath interpreter could be developed for each format
that understood the “mapping” involved.
5.2

Data Management

The goal of this API is not just to provide a
package for opening and querying data sources. In
addition, the design goals are also meant to address
nagging problems with handling data in Modelica.
With this new API we can avoid loading large
amounts of data either as constants or definitions in
packages (e.g. Modelica.Media idea gas data) and we
can avoid (through the selective extraction functions)
loading entire data sets into Modelica variables when
The Modelica Association

only a subset are needed at any given time during a
simulation.
In addition, data stored in Modelica typically
ends up being compiled into simulations. In a sense,
the data is then frozen inside the analysis. Any
change in the data requires the model to be recompiled or have its input files modified in some way.
By relying on external data sources, the “fresh” data
can be loaded on demand.
5.3

Modelica Deficiencies

While the external function interface in Modelica provided enough functionality to implement the
API and create functioning examples, there are still a
few areas where Modelica could be improved.
First, the API structure would benefit greatly
from support for methods that can be invoked on
user defined classes. Without methods, special functions much be written and type information about
arguments and return types must somehow be aggregated to form unique function names. In addition,
features to support better abstraction and polymorphism support would allow specialized Source objects to be developed (e.g. XMLSource,
HDFSource) but remain compatible with all existing functions that required Source objects as arguments. As things stand currently, the definition
for the Source class must be familiar with all potential formats (hence the format argument) but
with the ability to subclass, new formats could be
supported without the need to change or update the
existing Source definitions.
Another issue with Modelica is units. While
the language allows unit information to be associated
with variables and data sources may include unit information, the current API specification does not
exploit any of this information. Built-in unit conversion capabilities in Modelica might make it possible
to handle units without having to implement any
manual unit conversions.
Finally, the XML related tools used in this
implementation were available in C and could be
integrated nicely through the Modelica external function interface. However, more and more of these
capabilities are appearing in Java. As things currently stand, it is not possible to leverage Java code
through the external function interface although it
would be nearly trivial to do so. By including an
instance of a Java Virtual Machine in Modelica tools
and/or generated code, it would be possible to easily
load Java classes into memory and invoke functions
(and perhaps methods) defined in Java. Simply de-

600

Modelica 2005, March 7-8, 2005

Implementation of a Generic Data Retrieval API for Modelica

fining how arguments are passed to and from Java
code would enable leveraging tremendous amounts
of existing Java code.
5.4

DTDs and Namespaces

Two features of XML not discussed in this
paper are Document Type Definitions (DTDs) and
namespaces. This section includes some discussion
about these topics and how they relate to our data
retrieval API.
DTDs define a specific schema associated
with an XML document. We could have forced all
XML data to be used with the data retrieval API to
follow a specified DTD. This would have made retrieval considerably simpler because we could have
anticipated, to a greater degree, the structure of the
data we were trying to retrieve. However, it is quite
impractical to expect that external sources of data
will always conform to a specified DTD. It is possible to translate such data from its native format into a
form that conforms to a specific DTD but this would
likely involve more work than our approach and
would still involve XPath or something similar. The
strength of our approach is the ability to use it in
conjunction with arbitrarily structured data.
Namespaces could also be useful in annotating
existing datasets with new element types that are
explicitly tagged to be specially included for our
purposes. In such a scenario, special tags could be
defined within a namespace and then added to existing XML documents. These specialized elements
should, in theory, be ignored by other applications
since they belong to a namespace that the application
is unfamiliar with. This would add a level of complexity to the implementation and the need to specially annotate external data sources but without any
real benefit. For this reason, we did not utilize
namespaces.

6

Benefits of Standardization

While we have created this implementation for
our own purposes based on identified needs in our
organization, it is quite likely that many Modelica
users would benefit from a standard data retrieval
API like the one described in this paper. In this section, we highlight some of the benefits a standard
API would have over the “user space” implementation we have created.
First, query expressions could be used to generate lists of “choices” much like the existing
choices annotation. Such functionality would

The Modelica Association

have to be available (i.e. compiled into) Modelica
tools in order to link such information to the graphical user interface. The current external function interface is, at least in the case of Dymola, limited to
user simulations and such external functions are not
available to the Dymola process itself.
Another advantage of a standard data retrieval
API is that it could be used within the standard Modelica libraries to manage data. For example, the
Modelica.Media library contains a tremendous
amount of data associated with ideal gases. This
data could be stored outside the Modelica environment and loaded selectively on an as-needed basis.
As mentioned previously, our API is implemented through the Modelica external function interface and, as such, is not available to the Dymola
GUI. This makes model checking and model compilation impossible for cases where variables in Modelica are dimensioned based on calls to the API (i.e. to
determine the full size of an external matrix). By
standardizing the API, it would be possible to use
external data to dimension variables used in Modelica.

7

Conclusions

In order to integrate Modelica models with existing engineering and analysis processes, retrieval of
data from external data sources for use in models is
essential. This paper outlines one way such integration can be accomplished. Use of XPath expressions
is a powerful component of our implementation and,
through formalized mappings as described in Section
5.1, this approach to querying can be extended to
other non-XML based data sources as well. Our implementation focuses only on XML documents as
data sources and represents only a proof-of-concept
implementation (e.g. no caching is performed in our
implementation).
Standardization of this API opens up many possibilities for integration of database information into
graphical model development environments. It
could also automate the tedious and error prone
process of writing special functions (like the one
shown in Figure 4) to populate records used to characterize models.
The topic of a formalized API for retrieving external data sources has come up occasionally in
Modelica design meetings. Hopefully this implementation can serve as a starting point for further
discussions, proposals and eventually standard functionality available to all Modelica users.

601

Modelica 2005, March 7-8, 2005

M. Tiller

References
[1]

[2]

[3]
[4]
[5]
[6]
[7]

[8]

[9]
[10]
[11]
[12]
[13]
[14]
[15]

Tiller M., Bowles P., and Dempsey M., “Development of a Vehicle Model Architecture in
Modelica”. Proceedings of the 3rd International Modelica Conference, Nov. 3-4, 2003.
Linköping, Sweden.
Tiller M, “Parsing and Semantic Analysis of
Modelica Code for Non-Simulation Applications”. Proceedings of the 3rd International
Modelica Conference, Nov. 3-4, 2003.
Linköping, Sweden.
“Extensible Markup Language (XML)”,
http://www.w3.org/XML/
“The XML C parser and toolkit of Gnome”,
http://www.xmlsoft.org/
“XML Path Language (XPath) Version 1.0”,
http://www.w3.org/TR/xpath
“XQuery 1.0, An XML Query Language”,
http://www.w3.org/TR/xquery/ (working draft)
Newman C. E., Batteh J. J., and Tiller M.,
“Spark-Ignited-Engine Cycle Simulation in
Modelica”, Proceedings of the 2nd International Modelica Conference, March 18th-19th,
2002. Oberpfaffenhofen, Germany.
Berners-Lee T., Fielding R., and Masinter L.,
“Uniform Resource Identifiers (URI): Generic
Syntax”,
RFC
2396.
http://www.ietf.org/rfc/rfc2396.txt
“Berkeley DB XML 2.0”, Sleepycat Software,
http://www.sleepycat.com/products/xml.shtml
“XBIS XML Information Set Encoding”,
http://xbis.sourceforge.net/
“XML-binary
Optimized
Packaging”,
http://www.w3.org/TR/xop10/
“Document
Object
Model
(DOM)”,
http://www.w3.org/DOM/
“XML Pointer Language (XPointer)”,
http://www.w3.org/TR/xptr/
“HDF
4.1r3
User’s
Guide”,
http://hdf.ncsa.uiuc.edu/UG41r3_html/
“MAT-File
Format,
Version
7”,
http://www.mathworks.com/access/helpdesk/h
elp/pdf_doc/matlab/matfile_format.pdf

The Modelica Association

602

Modelica 2005, March 7-8, 2005

External Interface to Modelica in Dymola

External Interface to Modelica in Dymola
Hans Olsson
Dynasim AB
Research Park Ideon
S-223 70 Lund, Sweden

Introduction
Dymola [1] provides an integrated environment for
modeling, simulation and scripting based on the
Modelica language. However, Modelica is not always the best choice for GUI-design, database access, or canned presentations of libraries (in the last
case the usual choices are PowerPoint® presentations, pdf-documents, or animation files).
The solution in these cases is to leverage other tools,
such that they can interface to Dymola’s Modelica
functionality and vice-versa for call-backs/links from
Dymola to external tools. These solutions are already
implemented for the forthcoming version Dymola 6,
except for a few specific items described as future
plans (these might be implemented in time for the
release of Dymola 6). Some solutions are also available in previous versions of Dymola as described in
the manual [1].

1

1.2

Model callbacks in Dymola

One goal of the external interface is to allow a model
developer to customize commands for the model by
calling external tools. This functionality is provided
in two separate parts:
• External tools can be interfaced to any Modelica
function.
• Models can be customized to have commands
calling Modelica scripts or functions in Dymola.
As a concrete example a model developer can add
model-specific commands to Dymola’s Commandsmenu. Users of the model can then call a command
from the Commands-menu, which for example
executes a Modelica script calling external Modelica
functions implemented in C.
1.1

The commands can be generic (independent of the
selected model, e.g. to select a specific demo model

Calling functions directly

A specific case of running a command is to call a
function related to the model e.g. to run an optimization of the model.
The advantage with directly using function calls is
that there is no need for any model-specific script
files (making it easier to e.g. copy the Modelica
model) and that a function call is part of the Modelica language and thus syntactically correct.
Furthermore it is possible to optionally prompt the
user to modify the arguments of the function call
before the function is called, e.g. to specify the operating point to optimize for. This uses the normal (and
extensible) function call dialog.

2

Variants of commands

The Modelica Association

or check that the model fulfils some guidelines), or
specific to the currently selected class (e.g. postprocess the simulation result).
The command can be called explicitly by the user
(from the Commands-menu in Dymola), or implicitly to extend existing functionality (the enable-field
in parameter-dialogs is one example where a user
can enable the input field based on a predicate callback). In the future, callbacks will be generated at
specific stages of translation, e.g. for users to gather
additional statistics of the use of specific models.
Obviously we could for a specific example provide
the functionality inside Dymola, but by providing an
API and callbacks we allow the customer to extend
Dymola. Thus the API to Modelica structure which
is presented later in the paper is intended to also be
useful for e.g. gathering statistics about the components used in the translated model. Some of these
functions need access to browser information (such
as the current class) as will be discussed below.

Communication protocols

The interprocess communication is between two
running programs one of which is Dymola. The

603

Modelica 2005, March 7-8, 2005

H. Olsson

transport mechanism can be seen as separate from
the structure of the messages. Currently Dymola can
send and receive DDE-messages. For the future extension of exchanging XML-data in SOAP-encoding
SOAP-HTTP is a suitable alternative [2], and is
portable to non-Windows platforms (for which the
demand is increasing).
2.1

DDE-interface

For DDE-execute, the return value does not allow
meaningful result values and thus specially formatted
DDE-Request(s) is used for returning data to other
programs with a special case for Matlab (below).
Thus Windows programs can call DDE-routines to
e.g. perform a parameter sweep from Excel (by programming in Visual Basic for Application). In this
case the update of the excel spread-sheet is done by
running a macro and there are no links in the Exceldocument, which only contains the start-values
(J1.w), parameter-values (J2.J), and final values for
two variables (J1.w and J2.w):

For communication with a running simulation (DDEcommunication between Dymola and Dymosim) we
have found it necessary to use special formats to
achieve the high bandwidth needed for e.g. online
animation of Modelica models, while respecting the
limitations of the protocol.
We do not anticipate similar bandwidth needs for the
communication with Dymola, since the natural way
of communicating a vector of values is to send it as
one DDE-message (which automatically solves most
of the performance problems).
The DDE-interface in the caller is preferably written
as one generic routine (as we have done in Matlab)
to make it easy to later extend it e.g. with handling of
messages exceeding the maximum length, and
optimized alternatives to the CF_TEXT-format.
2.2

The above handles the complex case of interprocess
communication between two running programs, but
sometimes a simpler mechanism suffices.
2.2.1

Figure 1 Parameter-sweep from Excel
The macro opens a DDE-channel to Dymola, sends
the command simulateExtendedModel as a DDErequest to simulate and get the final values of variables. To access the spread-sheet the Excel-routine
Sheets( "Sheet1").Cells(r, c).Value
is used to get and set the values.
It is also possible to use DDE to communicate directly with a running simulation, Dymosim, (provided the compiler option ‘Visual C++ with DDE’ is
selected). This is described in [1] and also allows
automatic update of variables after changes.
These protocols are extensible which allows calls
between two programs running on different computers, i.e. remote procedure calls. Although remote
procedure calls are beneficial, for security reasons
remote procedure calls must be explicitly enabled (as
is necessary for remote DDE).
Limitations of DDE
Unfortunately DDE has some restrictions (in addition to being platform-specific), in particular on the
maximum length of the messages, and no general
high-level API for communicating structured data.
The Modelica Association

Direct interfacing

Call of external functions

The Modelica language offers the possibility to directly interface to C and FORTRAN-functions such
that calls of Modelica functions declared as external
C/Fortran are mapped into calls of the corresponding
C or Fortran functions.
There is no restriction on the use of external functions in Modelica and to allow easy use of them in
the interactive environment Dymola performs demand-compilation of external functions. Thus a user
can call external functions in the same way as nonexternal functions.
This C interface provides an extensible mechanism
that also handles other languages that can give routines C linkage, such as C++ and languages that provide an interface for calls from C, such as Java.
Since the JNI interface to Java allows dynamic
loading of Java-libraries this could be done internally
in Dymola making it possible to directly call a Java
function from Dymola to e.g. show a modal dialog
and get the user response back without using any
external programs.
Below we demonstrate running a Java function
showing a modal dialog box, where the call of the
Java-functions has been included as an external
function call in Modelica (with suitable arguments),
and then compiled by Dymola (the JNIimplementation require that calls in translated Ccode use the Visual C++ compiler).

604

Modelica 2005, March 7-8, 2005

External Interface to Modelica in Dymola

Command line arguments to Dymola enable external
tools to for instance run simulations in Dymola.
The Commands-menu, Dymola’s Execute-function,
and links in the documentation layer also allows
opening other files than Modelica scripts using the
file associations in Microsoft Windows. This is useful for canned presentations, and selecting a menu
entry will automatically open the file in the corresponding tool (e.g. pdf-documents in Acrobat
Reader®, animation files in the media player, htmlfiles in the browser).

Figure 2 Calling a modal dialog in Java from a
Modelica function
Extending Modelica’s external interface to directly
include Java in addition to C and Fortran 77 is
straightforward and the specification was deliberately written to allow such extensions. By using single-quoted names it is possible to directly support
hierarchical external function name (i.e. containing a
dot) as in Java.
2.2.2

Linking to libraries

It is also possible to link with specific C-libraries
(including Dynamic Link Libraries, DLLs). Due to
the limitations of the C-compilers used, any libraries
must be provided in a binary format compatible with
the C-compiler used to compile the Modelica code in
Dymola (Visual C++ 6/7, egcs, or Watcom). Provided the external code is portable and available in
source-form that is in general possible. Additionally
Modelica models are often downloaded and run on
realtime platforms, which require different libraries
(or that the C-code is provided in source-form and
linked together with the model).
Another potential problem on Windows is that some
API calls require that the caller is a Windowsprogram.
This is e.g. necessary to use the DirectX interface
from Microsoft. An application of DirectX is to allow users to control a car-model from VehicleDynamics [6] by a steering wheel. In those cases a
Windows program must be generated (in Dymola
this currently requires that you select the compiler
Visual C++ with DDE) and special routines obtain
the window handles.
2.2.3

Calling programs

Modelica.Utilities.System [3] enables functions
written in Modelica to call external programs.

The Modelica Association

3

Data-structure encoding

To communicate Modelica data-structures in Dymola to other tools the data-structures must be
mapped into other data-structures. Following the C
and FORTRAN-interface this is defined in a generic
encoding for each interface, i.e. there is no need to
specify a mapping for each data-structure. If a special mapping is desired for a specific case that can
then be done either in a Modelica function or in the
other tool.
The basic idea of the interface is to return a string
that when evaluated returns the value, e.g. a numeric
value is returned as itself, i.e. 3/2 is returned as the
string ‘1.5’ (without the quotes).
For more advanced data-structures, arrays and records, it is necessary to define how the resulting string
is evaluated. The two variants that are implemented
are Modelica data-types constructors and Matlab.
3.1

Mapping to Modelica

The Modelica-mapping is identical to the output
format used in Dymola’s command-window and
makes use of record and array constructors for complex data-structures. Consider the examples (input in
bold and the response-string is given after the ‘=’):
Matrices.inv([1,2;3,4])
=
[(-2.0), 1.0;
1.5, (-0.5)]
GetClassAttributes("Modelica")
= Dymola.AST.ClassAttributes(
fullName = "Modelica",
isPartial = false,
isProtected = false,
restricted = "package",

605

Modelica 2005, March 7-8, 2005

H. Olsson

isInner
isOuter
isEncapsulated
isShortClass
isReplaceable
isRedeclared

=
=
=
=
=
=

false,
false,
false,
false,
false,
false

3.1.1

)

The mapping is sufficiently straightforward that we
will not go into details of it, and if the result is pasted
into Dymola’s command input and evaluated it returns the same result once more.
To use this functionality the application programmer
has to set up a DDE-channel to Dymola, and send a
Modelica-function call as string in a DDE-request.
Dymola’s DDE-server will respond with a string
containing the result as a Modelica data-structure.

Userprogrammed

Dymola
DDE

String(Modelica)

DDE-client

DDE-server

String(Modelica)

We have defined a subset of Modelica for representing any structured data values, that is primitive
types, arrays, and records.
The advantage of this format is that the mapping is
self-explanatory, complete for Modelica data-types,
and to be able to parse the Modelica-format it is only
necessary to implement a parser for a subset of expressions from the Modelica grammar:
expression:
primary
| "-" primary
primary :
UNSIGNED_NUMBER
| STRING
| false
| true
| component_reference function_call
| "[" expr_list { ";" expr_list } "]"
| "{" expr_list "}"
component_reference :
IDENT [ "." component_reference ]

Modelica

Dymola

Grammar for Modelica subset

expr_list :
expression { "," expression }

Modelica
function

function_call :
"(" [ function_args ] ")"

Modelica

function_args :
expression [ "," function_args
| named_args

Figure 3 Using Dymola’s interface to Modelica
functions from other programs.
For this to be possible, all data-structures in Modelica must have an output format that when evaluated
gives the data-structure back. This seems straightforward, but the problem is empty arrays, since
Modelica as a strongly typed language does not allow {} for empty arrays.
For primitive types a work-around is to use the filloperator. For an empty array of records this requires
using the record-constructor, but in many cases the
record constructor does not have defaults for all elements and thus cannot be called without specifying
arguments. A future extension of Modelica would be
to allow calls of the record constructor with no arguments in this specific case.

The Modelica Association

]

named_args:
named_argument [ "," named_args ]
named_argument: IDENT "=" expression

Some of the names in the grammar have been shortened to keep the grammar elements on one line.
The reason to keep component_reference and function_call is to use record constructors to build record
data-structures (using named arguments). Function
call without named arguments (the line in italics) is
only needed for the above-mentioned use of fill to
construct empty arrays.
3.2

Mapping for Matlab

Dymola can automatically map data-structures to
Matlab data-structures. They are first encoded in a
string, that is then automatically evaluated by the
Matlab-interface to the corresponding data-structure.

606

Modelica 2005, March 7-8, 2005

External Interface to Modelica in Dymola

Dymola/Modelica
Real
Integer
String
Enumeration(planned)
Boolean
Array
Record member

This does not include some of the advanced features
of Modelica, e.g. the mapping does not automatically
handle vectorized arguments to functions or allow
you to use named arguments from Matlab.
We have not yet found any performance issues with
this interface, but the m-file could be improved to
locally cache the Modelica class structure in order to
avoid sending the same query several times to Dymola (as will happen with e.g. arrays).

Matlab
double
double
string
string
double
matrix or cell array
struct member

3.2.1
Figure 4 Mapping to Matlab
Array results are returned as matrices, except array
of records and array of strings that are returned as
cell arrays.
This provides a complete interface from any datastructure (i.e. return-value) defined in Modelica to a
corresponding data-structure in Matlab. This includes the Modelica class and component structure
as will be defined later.
The interface for sending requests from Matlab to
Dymola cannot provide a similar feature based on
the data structures in Matlab. The reasons are that
Matlab does not distinguish between scalars, vectors
and matrices (i.e. ndims in Matlab is always >=2),
and that Modelica lacks a counterpart to Matlab’s
struct, i.e. an untyped record constructor.
However, as will be discussed in a following section
an API to the class structure is available and the
caller routine in Matlab (dymolaCall) has been extended with code to perform this mapping based on
the declaration of the called Modelica function. Thus
the Matlab-programmer only has to call dymolaCall
with the name of the Modelica function and arguments as Matlab data-structures (arrays and structs).
Dymola and dymolaCall and internally handle this
and the result is a Matlab data-structure.

Matlab

Dymola
DDE

Matlab
Matlab
m-file

String(Modelica)
dymolaCall
DDE-client

Matlab

Modelica

Dymola

DDE-server

String(Matlab)

Modelica
function

Examples

The following examples are only intended to demonstrate the possibilities and that strings, arrays of doubles, and records (containing strings and booleans)
are returned (running from Matlab). The first examples demonstrate sending the entire command as one
string:
>> dymolaCall('"Hello"+" world"')
ans =
Hello world
>> dymolaCall(…
'Modelica.Math.Matrices.inv([1,2;3,4])')
ans =
-2.0000 1.0000
1.5000 -0.5000
As indicated above the interface also allows call with
function arguments as Matlab data-types (the second
argument can optionally be used to specify an existing DDE-channel):
>> dymolaCall('Modelica.Math.Matrices.inv',[],..
[1,2;3,4])
ans =
-2.0000 1.0000
1.5000 -0.5000
dymolacall('GetClassAttributes',[], 'Modelica')
ans =
fullName:
isPartial:
isProtected:
restricted:

Modelica

'Modelica'
0
0
'package'

…
Figure 5 Interface between Matlab and Dymola

The Modelica Association

607

Modelica 2005, March 7-8, 2005

H. Olsson

>>dymolaCall(…
'Modelica.Math.Matrices.leastSquares',[],…
[1;0;1],[1;2;3])
ans =
2
We will later return to how this uses the API to the
Modelica class structure to construct the call.
3.3

Mapping for XML

For the abstract syntax tree one mapping to XML [4]
is defined in [5]. A future mapping of data-structures
to XML could use a subset of this by viewing them
as a function call/expression in this structure (i.e.
similar to the subset for the mapping to Modelica).
This can be viewed as too generic and another possibility is to automatically construct a specific document type declaration defining the grammar for the
specific Modelica data-structure(s), i.e. one for each
record class used, and placing this first in the XMLfile [4]. This might still be combined with an external pre-defined data-type declaration for the built-in
Modelica types, i.e. Boolean, Integer, Real, and
String.

4

API to Modelica class structure

The first problem with defining an API to the Modelica class and component structure is that it is not
possible to define a data-structure for the entire class
structure in Modelica (at least not as implemented in
Dymola), because the class structure is inherently
recursive. However, even if it were possible to replicate the entire class structure as a set of nested records it would not provide an efficient interface to the
class structure for simple queries or modifications.
Therefore we have instead defined access routines
that allow tree walking to be built in Modelica (in the
future there will also be corresponding routines for
modifying and adding classes and components).
4.1

Basic design of API

The three sets of routines are for classes, extendsclauses and components. In each set there is a routine
for obtaining the elements (as an array), a record defining the “attributes” (protected, inner, full class
name, …) and a routine for getting the attributes for
a specific element.
These interfaces assume that one can use the name of
elements in the queries, which is possible in the
cases above (technically excluding the obscure case
of repeated identical extends-statements which is
legal Modelica, but without any reasonable use).
Note that Dymola enforces this semantic restriction
in Modelica already during parsing of classes, and
thus it is safe to base the API-routines on this assumption.
The requirements also include access to the importstatements in the class. For import-clauses it is hard
to define which name to use as a key (when considering both the qualified and the unqualified importstatements, thus a combined routine has been added
that returns an array of records defining the importstatements.
This was found to provide such an increase in ease of
use that similar routines were added for the other
cases. These were trivial to implement based on the
existing routines, and we give a full example below
(excluding its documentation):
function ComponentsInClassAttributes
"Get components of a class"
input String className;
output ComponentAttributes res[:]=
GetComponentAttributes(className,
ComponentsInClass(className));
algorithm
end ComponentsInClassAttributes;

Here the names of the components is constructed by
ComponentsInClass and this is then used in a vectorized call (as defined in Modelica [3]) of GetComponentAttributes to get the attributes of all components.
Thus functions exists for all elements of table given
on the next page (where “elements in class” has a
class/ package as input and get attributes also exist in
a form that returns an array containing the attributes
of all elements).

In order to provide a useful interface to the classes
and components three sets of routines were provided
as follows in package Dymola.AST. Originally each
set was only comprised of two functions and one
record, and the intention is to further extend this (e.g.
with routines for modifying the elements).

The Modelica Association

608

Modelica 2005, March 7-8, 2005

External Interface to Modelica in Dymola

Classes
Extends
Components
Import

Record of attributes
ClassAttributes
ExtendsAttributes
ComponentAttributes
ImportAttributes

Elements in class
Get attributes
ClassesInPackage
GetClassAttributes
ExtendsInClass
GetExtendsAttributes
ComponentsInClass
GetComponentAttributes
ImportsInClassAttributes

Figure 6 Overview of API to class structure. The row headings are the element types and the column
headings the different functions (and records).
To make it possible to traverse all classes it is also
possible to list all top-level classes (optionally limited to the ones defined in a specific Modelica file).
4.1.1

Example

These functions can be used in Modelica to find all
restricted classes and provide e.g. the following list
of accessible classes (excluding protected and partial
ones):
Modelica 1.6
Modelica 2.1
Model
222
429
Block
71
147
Function
41
199
Type
485
513
Package
50
130
Figure 7 Statistics for Modelica Standard Library
The growth of the standard library is in part due to
the fact that ModelicaAdditions libraries were completed and after (in some cases major) revisions included in the Modelica Standard Library.
An alternative to returning all elements as one array
of records would be to provide an iterator, or a callback-routine for enumerating the elements (and access routines instead of record elements). This is a
traditional style in several environments (iterators in
C++, enumeration callbacks in Windows API) since
it avoids allocating large arrays. However, it requires
additional state (in the iterator or enumerator call),
which is contrary to the limitations on functions in
Modelica, and therefore also increases the risk of
errors in application code.
4.2

API to semantics not only to syntax

The API above defines basic routines that can be
used directly. They also provide the basis for writing
functions intended to answer higher-level questions,
e.g. to search in a hiearchy for all components declared of a certain class.
Programming such queries require that the API answers questions related to the semantics of the declarations instead of questions based on their syntax
The Modelica Association

(i.e. Dymola must not only parse the Modelica
classes to answer the question, but also implement
e.g. the semantics of look-up in Modelica).
To clarify this consider the declaration of T2 in the
coupled clutches demo:
parameter SI.Time T2;

To obtain information about this declaration we can
use the following:
Dymola.AST.GetComponentAttributes(
"Modelica.Mechanics.Rotational"+
".Examples.CoupledClutches","T2")

which gives the result:
Dymola.AST.ComponentAttributes(
name = "T2",
fullTypeName="Modelica.SIunits.Time",
isProtected = false,
sizes = {},
variability = "parameter",
isInput = false,
isOutput = false,
isInner = false,
isOuter = false,
isReplaceable = false,
isRedeclared = false,
isGraphical = false
)

By returning the full name of the type ("Modelica.SIunits.Time") and not the type-name part of the
declaration ("SI.Time") it is straightforward to program this kind of queries and this also made it easier
to program the calling interface from Matlab.
Obviously advanced users would like to also have
access to the exact declaration (including modifiers
and annotations) and that is planned for the future.
Basing the API on the semantics is also important for
future improvement of providing routines to modify
the classes through the API, where declaring a new

609

Modelica 2005, March 7-8, 2005

H. Olsson

component might require the addition of importstatements. When a user drags and drops a class to
the diagram layer to declare a new component Dymola automatically adds import-statements if necessary. The API can internally re-use this functionality.
Similarly copying (or moving) a class from one
Modelica package to another might require changes
to its declarations which is done automatically by
Dymola’s GUI and hidden from the user.

attr:=cat(1,attr,{attributes});
if attributes.restricted
== "package" then
attr := cat(1, attr,
attributeModelsInPackage(
attributes.fullName));
end if;
end for;
end attributeModelsInPackage;

4.3.2
4.3

Simplification in Modelica 2.2

One previous problem with using these functions
was that the sizes of non-inputs to functions had to
be known from the call according to the Modelica
2.1 standard [3]. That requires complex workarounds and/or additional functions.
The restriction has now been lifted in Dymola (and
accepted for Modelica 2.2) allowing a variable declared with size : (and without any binding assignment) to be re-sized (if necessary) when assigned in
the function (note that this includes not only variables declared directly in the function but also their
record elements). The change is backward compatible since such variables previously were semantically incorrect.
The change is not limited to working with the
Modelica-structure, but is also useful in Modelica for
unrelated uses, e.g. a routine that returns the positive
eigenvalues. It was also needed to implement the
API functions themselves, in particular the size-field
for array of a component.
Those wanting an additional rationale can examine
the case below where the same function as given in
two versions, one written before the feature was implemented and another version rewritten to use it:
4.3.1

Example after simplification

As an example consider a function for finding the
attribute of all classes defined in package (including
the contents of packages – after the package):
function attributeModelsInPackage
import Dymola.AST.*;
input String s;
output ClassAttributes attr[:];
protected
String localClasses[:]=
ClassesInPackage(s);
ClassAttributes attributes;
algorithm
for i in 1:size(localClasses,1) loop
attributes:= GetClassAttributes(
s + "." + localClasses[i]);

The Modelica Association

Example before simplification

Before this feature of automatic resizing of arrays
was available it was necessary to write two routines,
one to determine the length of the array and one to
actually return the array.
We consider this for the simpler case of only returning the full names of the classes, first we have to
count the size of the output:
function countModelsInPackage
import Dymola.AST.*;
input String s;
output Integer count= 0;
protected
ClassAttributes attributes;
algorithm
for i in ClassesInPackage(s) loop
attributes:=GetClassAttributes(
s + "." + i);
count:=count+1;
if attributes.restricted
=="package" then
count := count +
countModelsInPackage(
attributes.fullName);
end if;
end for;
end countModelsInPackage;

Note that there is no declared array for the result of
ClassesInPackage – instead it is directly iterated over
removing the need for any local variable (and the
problem of its size).
function attributesModelsInPackage
import Dymola.AST.*;
input String s;
output String
attr[countModelsInPackage(s)];
protected
ClassAttributes attributes;
Integer index=0;
Integer len;
algorithm
for i in ClassesInPackage(s) loop
attributes:=
GetClassAttributes(s + "." + i);

610

Modelica 2005, March 7-8, 2005

External Interface to Modelica in Dymola

index:=index+1;
attr[index]:=attributes.fullName;
if attributes.restricted
=="package" then
len :=countModelsInPackage(
attributes.fullName);
attr[index+1:index+len] :=
attributesModelsInPackage(
attributes.fullName);
index:=index+len;
end if;
end for;
end attributesModelsInPackage;

Apart from practical problem of writing such complex functions an additional problem is that there is a
need to maintain multiple functions. If requirements
change (e.g. only return public classes) it is necessary to update two functions.
4.4

Revisited example from Matlab

5

When we previously considered the following call
from Matlab
>>dymolaCall(…
'Modelica.Math.Matrices.leastSquares',[],…
[1;0;1],[1;2;3])
we indicated that Dymola’s API was used to construct this argument. The calls of Dymola API functions are:
Dymola.AST.GetComponentAttributes(
"Modelica.Math.Matrices.leastSquares",
"A")
Dymola.AST.GetClassAttributes("Real")
Dymola.AST.GetClassAttributes("Real")
Dymola.AST.GetClassAttributes("Real")
Dymola.AST.GetComponentAttributes(
"Modelica.Math.Matrices.leastSquares",
"b")
Dymola.AST.GetClassAttributes("Real")
Dymola.AST.GetClassAttributes("Real")
Dymola.AST.GetClassAttributes("Real")

Finally the result is the following function call:

The first call, GetClassAttributes, determines that
this is a function call and not the call of a record constructor. The next call, ComponentsInClass, is used
to determine the components of the function. For
each argument the next input component is found by
looking at the component attributes (this check is not
performed for record constructors). The type of input
component is then accessed, GetClassAttributes(
"Real"), to find that it is a primitive numeric type
(since booleans must be treated specially).
The significant part is that in Matlab there are two
matrices/columns vectors and based on the Modelica
function the first one is sent as matrix to Dymola
([1;0;1]) and the second one as a vector ({1,2,3}).
Without the API-calls it would not have been possible to determine that these should be treated differently.

This paper shows that Dymola 6’s Modelica implementation provides an extendable external interface
to use other tools and also be useful from other tools.
In addition it shows that an interface to the Modelica
class structure is useful in itself and also can be used
when implementing the external interface.

References
[1]
[2]
[3]

[4]

[5]

[6]

Modelica.Math.Matrices.leastSquares(
[1;0;1],{1,2,3})

The Modelica Association

Conclusions

611

Dynasim (2005): Dymola User’s Manual,
Dynasim, www.dynasim.com,
XML Protocol Working Group (2000-):
SOAP http://www.w3.org/2000/xp/Group
Modelica Association (2004): Modelica
Language Specification Version 2.1,
www.modelica.org
World Wide Web Consortium (1996-): Extensible Markup Language (XML),
http://www.w3.org/XML/
Pop A., P. Fritzson P. (2003): ModelicaXML: A Modelica XML Representation
with Applications, Proceedings of the 3rd
International
Modelica
Conference,
Linköping Sweden.
Andreasson J. (2003): VehicleDynamics
library, Proceedings of the 3rd International
Modelica Conference, Linköping Sweden.

Modelica 2005, March 7-8, 2005

