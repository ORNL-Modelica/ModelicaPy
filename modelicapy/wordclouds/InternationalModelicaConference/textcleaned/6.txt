2008
6

th

Proceedings of the
International Modelica Conference
March 3rd  4th , 2008
University of Applied Sciences Bielefeld,
Bielefeld, Germany

Bernhard Bachmann (editor)

Volume 1

organized by
The Modelica Association and
University of Applied Sciences Bielefeld
All papers of this conference can be downloaded from
http://www.Modelica.org/events/modelica2008/

Proceedings of Modelica 2008
University of Applied Sciences Bielefeld,
Bielefeld, Germany, March 2008
Editor:
Prof. Dr. B. Bachmann
Published by:
The Modelica Association (http://www.Modelica.org) and
University of Applied Sciences Bielefeld (http://www.fh-bielefeld.de)
Printed by:
Printmedien Elbracht

The Modelica Association

Modelica 2008, March 3rd  4th , 2008

Preface
The first International Modelica Conference took place in October 2000 in Lund, Sweden. Since
then, Modelica has increasingly become the preferred language tool for physical modelling of complex
systems. This is indicated by the high number of registrations from industry and science at the 6th
International Modelica Conference held between 3rd and 4th March 2008 at the University of Applied
Sciences, Bielefeld, Germany. It is also indicated by the number of excellent papers submitted to the
program committee which made the task of selecting papers for oral and poster presentation very
difficult and, last but not least, by the exhibition during the conference at which several companies
will be represented. This volume contains the papers of the 68 oral presentations and 14 poster
presentations at the conference. The ability of Modelica as a multi domain simulation language is
demonstrated impressively by the various fields the papers are covering.
Due to the special features of the Modelica language, such as object-oriented modelling and the
ability to reuse and exchange models, Modelica strongly supports an integrated engineering design
process. Thus in various fields Modelica has become the standard tool for model exchange between
suppliers and OEMs. A key issue for the success of Modelica is the continuous development of the
Modelica language as well as the Modelica Standard Library under strict observance of compatibility
to previous versions by the Modelica Association. The broad base of private and institutional members of the Modelica Association as a non-profit organization ensures language stability and security
in software investments.
The 6th International Modelica conference was organized by the Modelica Association and by the
University of Applied Sciences, Bielefeld, Germany. I would like to thank the local organizing committee, the technical program committee and the reviewers for offering their time and expertise throughout
the organization of the conference. Together with the entire team of the local organizing committee I
would like to wish all participants an excellent and fruitful conference.

Bielefeld, March 1st , 2008

Bernhard Bachmann

The Modelica Association

I

Modelica 2008, March 3rd  4th , 2008

Program Chair
 Prof. Bernhard Bachmann, University of Applied Sciences Bielefeld, Bielefeld, Germany

Program Board
 Prof. Martin Otter, DLR, Oberpfaffenhofen, Germany
 Prof. Peter Fritzson, Linkoping University, Sweden
 Dr. Hilding Elmqvist, Dynasim AB, Lund, Sweden
 Dr. Michael Tiller, Emmeskay Inc., Michigan, USA

Program Committee
 Prof. Karl-Erik Arzen, Lund University, Lund, Sweden
 Dr. John Batteh, Emmeskay Inc., Michigan, USA
 Dr. Ingrid Bausch-Gall, Bausch-Gall GmbH, Munich, Germany
 Daniel Bouskela, EDF, Paris, France
 Prof. Felix Breitenecker, University of Technology, Vienna, Austria
 Dr. Thomas Christ, BMW, Michigan, USA
 Prof. Francesco Casella, Politecnico di Milano, Milano, Italy
 Prof. Francois E. Cellier, ETH Zurich, Zurich, Switzerland
 Mike Dempsey, Claytex Services Limited, Leamington, U.K.
 Denis Fargeton, LMS Imagine, Roanne, France
 Dr. Rudiger Franke, ABB, Heidelberg, Germany
 Rui Gao, Dassault Systemes K.K., Nagoya, Japan
 Anton Haumer, Technical Consulting, Vienna, Austria
 Dr. Christian Kral, arsenal research, Vienna, Austria
 Gerard Lecina, Dassault Systemes, Paris, France
 Dirk Limperich, Daimler AG, Sindelfingen, Germany
 Kilian Link, Siemens AG, Erlangen, Germany
 Dr. Jakob Mauss, QTronic GmbH, Berlin, Germany
 Dr. Ramine Nikoukhah, INRIA, Rocquencourt, France
The Modelica Association

II

Modelica 2008, March 3rd  4th , 2008

 Franz Pirker, arsenal research, Vienna, Austria
 Prof. Gerhard Schmitz, Technical University Hamburg-Harburg, Germany
 Peter Schneider, Fraunhofer IIS/EAS, Dresden, Germany
 Dr. Edward D. Tate, General Motors, Michigan, USA
 Dr. Wilhelm Tegethoff, TLK-Thermo GmbH, Braunschweig, Germany
 Dr. Hubertus Tummescheit, Modelon AB, Lund, Sweden
 Dr. Andreas Uhlig, ITI GmbH, Dresden, Germany

Local Organizing Committee
 Prof. Bernhard Bachmann
 Dr. Elke Koppenrade
 Jens Schonbohm
 Ralf Derdau
 Eveni, Konferenz-Management-Software, www.eveni.com
 Bielefeld Marketing GmbH, www.bielefeld-marketing.de

The Modelica Association

III

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

IV

Modelica 2008, March 3rd  4th , 2008

Contents
Volume 1

1

Session 1a
Language, Tools and Algorithms

1

D. Broman, P. Aronsson, P. Fritzson: Design Considerations for Dimensional Inference
and Unit Consistency Checking in Modelica . . . . . . . . . . . . . . . . . . . . . . . .
S. E. Mattsson, H. Elmqvist: Unit Checking and Quantity Conservation . . . . . . . . .
H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist: Balanced Models in Modelica 3.0
for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 1b
Language, Tools and Algorithms
M. Najafi, R. Nikoukhah: Initialization of Modelica Models in Scicos . . . . . . . . .
D. Zimmer: Introducing Sol: A General Methodology for Equation-Based Modeling
Variable-Structure Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
J. Akesson : OptimicaAn Extension of Modelica Supporting Dynamic Optimization

. .
of
. .
. .

Session 1c
Automotive Applications
J. Batteh, C. Newman: Detailed Simulation of Turbocharged Engines with Modelica . .
H. Oberguggenberger, D. Simic: Thermal Modelling of an Automotive Nickel Metall
Hydrid Battery in Modelica using Dymola . . . . . . . . . . . . . . . . . . . . . . . . .
M. Corno, F. Casella, S. M. Savaresi, R. Scattolini: Object Oriented Modeling of a
Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 1d
Electric Systems & Applications

3
13
21

35
37
47
57

67
69
77
83

93

M. Kuhn, M. Otter, L. Raulin: A Multi Level Approach for Aircraft Electrical Systems
Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
C. Schallert : Incorporation of Reliability Analysis Methods with Modelica . . . . . . . . 103
F. Wagner, L. Liu, G. Frey: Simulation of Distributed Automation Systems in Modelica 113

Session 2a
Language, Tools and Algorithms

123

A. Jardin, W. Marquis-Favre, D. Thomasset, F. Guillemard, F. Lorenz: Study of
a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1 125
T. Johnson, C. Paredis, R. Burkhart: Integrating Models and Simualtions of Continuous
Dynamics into SysML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
The Modelica Association

V

Modelica 2008, March 3rd  4th , 2008

Contents
A. Leva, F. Donida, M. Bonvini, L. Ravelli: Modelica Library for Logic Control
Systems written in the FBD Language . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

Session 2b
Thermodynamic Systems & Applications

155

F. Casella, C. Richter : ExternalMedia: A Library for Easy Re-Use of External Fluid
Property Code in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
F. Cellier, J. Greifeneder: ThermoBondLib - A New Modelica Library for Modeling
Convective Flows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
T. Vahlenkamp, S. Wischhusen: FluidDissipation - A Centralised Library for Modelling
of Heat Transfer and Pressure Loss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173

Session 2c
Mechanical Systems & Applications

179

G. Verzichelli : Development of an Aircraft and Landing Gears Model with Steering System
in Modelica-Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
G. Looye : The New DLR Flight Dynamics Library . . . . . . . . . . . . . . . . . . . . . . 193
I. Kosenko, E. Alexandrov: Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203

Session 2d
Electric Systems & Applications

213
D. Winkler, C. Guhmann: Modelling of Electric Drives using freeFOClib . . . . . . . . 215
T. Bodrich : Electromagnetic Actuator Modelling with the Extended Modelica Magnetic
Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
A. Haumer, C. Kral, J. V. Gragger, H. Kapeller: Quasi-Stationary Modeling and
Simulation of Electrical Circuits using Complex Phasors . . . . . . . . . . . . . . . . . 229

Session 3a
Language, Tools and Algorithms

237
T. Pulecchi, F. Casella: HyAuLib: Modelling Hybrid Automata in Modelica . . . . . . . 239
G. Fish, M. Dempsey : Application of Neural Networks to model Catamaran Type
Powerboats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter: ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . 255
U. Donath, J. Haufe, T. Blochwitz, T. Neidhold: A new Approach for Modeling and
Verification of Discrete Control Components within a Modelica Environment . . . . . 269

Session 3b
Thermodynamic Systems & Applications

277

R. Franke, B.S. Babij, M. Antoine, A. Isaksson: Model-Based Online Applications in
the ABB Dynamic Optimization Framework . . . . . . . . . . . . . . . . . . . . . . . .
J. I. Videla, B. Lie: Using Modelica/Matlab for Parameter Estimation in a Bioethanol
Fermentation Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
L. Imsland, P. Kittilsen, T. Steinar Schei: Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F. Casella, F. Donida, B. Bachmann, P. Aronsson: Overdetermined Steady-State
Initialization Problems in Object-Oriented Fluid System Models . . . . . . . . . . . .
The Modelica Association

VI

279
287
301
311

Modelica 2008, March 3rd  4th , 2008

Contents

Session 3c
Automotive Applications

319

W. Chen, G. Qin, L. Li, Y. Zhang, L. Chen: Modelling of Conventional Vehicle in
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
J. Andreasson, M. Jonasson: Vehicle Model for Limit Handling: Implementation and
Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H. Isernhagen, C. Guhmann: Modelling of a Double Clutch Transmission with an Appropriate Controller for the Simulation of Shifting Processes . . . . . . . . . . . . . . .
A. Junghanns, J. Mauss, M. Tatar: TestWeaver - A Tool for Simulation-Based Test of
Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 3d
Electric Systems & Applications

321
327
333
341

349

C. Kral, A. Haumer: Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the ExtendedMachines Library . . . . . . . . . . . . . . . . . . . .
H. Kapeller, A. Haumer, C. Kral, G. Pascoli, F. Pirker: Modeling and Simulation
of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H. Giuliani, C. J. Fenz, A. Haumer, H. Kapeller: Simulation and Validation of Power
Losses in the Buck-Converter Model included in the SmartElectricDrives Library . . .
A. Ebner, M. Ganchev, H. Oberguggenberger, F. Pirker: Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . . .

Volume 2

351
361
369
375

381

Session 4a
Language, Tools and Algorithms

381
A. Abel, T. Nahring: Frequency-Domain Analysis Methods for Modelica Models . . . . . 383
F. Cellier : World3 in Modelica: Creating System Dynamics Models in the Modelica Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
F. Donida, A. Leva: Modelica as a Host Language for Process/Control Co-Simulation and
Co-Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
A. Pop, K. Stavaker, P. Fritzson: Exception Handling for Modelica . . . . . . . . . . . 409

Session 4b
Thermodynamic Systems & Applications

419

J. Fahlke, S. Puschel, F. Hannemann, B. Meyer: Modelling of the Gasification Island
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
M. Bockholt, W. Tegethoff, N. Lemke, N.-C. Strupp, C. Richter: Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration Cycles . . . .
C. Junior, C. Richter, W. Tegethoff, N. Lemke, J. Kohler: Modeling and Simulation
of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P. Li, Y. Li, J. Seem: Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 4c
Automotive Applications
The Modelica Association

421
429

437
447

465
VII

Modelica 2008, March 3rd  4th , 2008

Contents
M. Najafi, Z. Benjelloun-Dabaghi: Using Modelica for Modeling and Simulation of
Spark Ignited Engine and Drilling Station in IFP . . . . . . . . . . . . . . . . . . . . . 467
S. Karim, H. Tummescheit: Controller Development for an Automotive Ac-system using
R744 as Refrigerant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
H. Wigermo, J. von Grundherr, T. Christ: Implementation of a Modelica Online
Optimization for an Operating Strategy of a Hybrid Powertrain . . . . . . . . . . . . . 487
E. Tate, M. Sasena, J. Gohl, M. Tiller: Model Embedded Control: A Method to
Rapidly Synthesize Controllers in a Modeling Environment . . . . . . . . . . . . . . . 493

Session 4d
Mechanical Systems & Applications

503

F. Casella, M. Lovera: High-Accuracy Orbital Dynamics Simulation through Keplerian
and Equinoctial Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
J. Andreasson, M. Gafvert: Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
S. Wolf, J. Haase, C. Clau, M. Jockel, J. Losch: Methods of Sensitivity Calculation
Applied to a Multi-Axial Test Rig for Elastomer Bushings . . . . . . . . . . . . . . . . 521
M. Pfennig, F. Thielecke: Implementation of a Modelica Library for Simulation of HighLift Drive Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531

Session 5
Poster Session

541

T. Hirsch, M. Eck: 4-Dimensional Table Interpolation with Modelica . . . . . . . . . . . 543
M. Hobinger, M. Otter : PlanarMultiBody - A Modelica Library for Planar Multi-Body
Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
D. Simic, T. Bauml: Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the SmartElectricDrives Libraries . . . . . . . . . . . . . . . . . . . . . . . . 557
P. Machanick, A. Liebman, P. Fritzson: Modeling of CO2 Reduction Impacts on Energy
Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565
M. Schicktanz : Modelling of an Adsorption Chiller with Modelica . . . . . . . . . . . . . 573
T. Blochwitz, G. Kurzbach, T. Neidhold : An External Model Interface for Modelica

579

B. El Hefni, B. Bride, B. Pechine: Two Steady State CHP Models with Modelica :
Mirafiori overall Model and Multi-configuration Biomass Model . . . . . . . . . . . . . 585
J. V. Gragger, A. Haumer, C. Kral, F. Pirker: Efficient Analysis of Harmonic Losses
in PWM Voltage Source Induction Machine Drives with Modelica . . . . . . . . . . . . 593
J. Haase, S. Wolf, C. Clau: Monte Carlo Simulation with Modelica . . . . . . . . . . . 601
O. Enge-Rosenblatt, C. Clau, P. Schwarz, F. Breitenecker, C. Nytsch-Geusen:
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . 605
O. Enge-Rosenblatt, P. Schneider: Modelica Wind Turbine Models with Structural
Changes Related to Different Operating Modes . . . . . . . . . . . . . . . . . . . . . . 611
K. Tuszynski : ExcelInterface - A Tool for Interfacing Dymola through Excel . . . . . . . 621
K. Dietl, J. Vasel, G. Schmitz, W. Casas, C. Mehrkens: Modeling of Cold Plates for
Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
N. Philipson, J. Andreasson, M. Gafvert, A. Woodruff: Heavy Vehicle Modeling
with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
The Modelica Association

VIII

Modelica 2008, March 3rd  4th , 2008

Contents

Session 6a
Language, Tools and Algorithms

635
K. Stavaker, A. Pop, P. Fritzson: Compiling and Using Pattern Matching in Modelica 637
M. Tiller : Patterns and Anti-Patterns in Modelica . . . . . . . . . . . . . . . . . . . . . . 647
P. Fritzson, A. Pop, K. Norling, M. Blom: Comment- and Indentation Preserving
Refactoring and Unparsing for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . 657

Session 6b
Language, Tools and Algorithms

667
A. Elsheikh, S. Noack, W. Wiechert: Sensitivity Analysis of Modelica Applications via
Automatic Differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 669
R. Nikoukhah, S. Furic : Synchronous and Asynchronous Events in Modelica: Proposal
for an Improved Hybrid Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
F. Dshabarow, F. Cellier, D. Zimmer: Support for Dymola in the Modeling and Simulation of Physical Systems with Distributed Parameters . . . . . . . . . . . . . . . . . 683

Session 6c
Thermodynamic Systems & Applications

691

H. Tummescheit, K. Tuszynski, P. Arnold: Simulation of Peak Stresses and Bowing
Phenomena during the Cool Down of a Cryogenic Transfer System . . . . . . . . . . . 693
A. Joos, G. Schmitz, W. Casas: Enhancement of a Modelica Model of a Desiccant Wheel701
M. Gafvert, T. Skoglund, H. Tummescheit, J. Windahl, H. Wikander, P. Reutersward:
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . 709

Session 6d
Mechanical Systems & Applications

717

T. Juhasz, U. Schmucker: Automatic Model Conversion to Modelica for Dymola-based
Mechatronic Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 719
I. I. Kosenko, A. S. Kuleshov : Modelica Implementation of the Skateboard Dynamics 727
T. Hoeft, C. Nytsch-Geusen: Design and Validation of an Annotation-Concept for the
Representation of 3D-Geometries in Modelica . . . . . . . . . . . . . . . . . . . . . . . 735

The Modelica Association

IX

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

X

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Akesson, Johan: Lund University, Lund, Sweden
OptimicaAn Extension of Modelica Supporting Dynamic Optimization . . . . . . . . . . . . . . . . . . . . . 57
Abel, Andreas: ITI GmbH, Dresden, Germany
Frequency-Domain Analysis Methods for Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
Alexandrov, Evgeniy: Moscow State University of Tourism and Service, Moscow, Russian Federation
Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica . . . 203
Andreasson, Johan: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics . . . . . . . . . . . . . . . . . . . 515
Vehicle Model for Limit Handling: Implementation and Validation . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Antoine, Marc: ABB Power Technology Systems, Mannheim, Germany
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Arnold, Philip: Linde Kryotechik AG, Pfungen, Switzerland
Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic
Transfer System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
Aronsson, Peter: Mathcore Engeneering, Linkoping, Sweden
Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica . . 3
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Bauml, Thomas: Arsenal Research, Vienna, Austria
Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the
SmartElectricDrives Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
Bodrich, Thomas: Dresden University of Technology, Dresden, Germany
Electromagnetic Actuator Modelling with the Extended Modelica Magnetic Library . . . . . . . . . 221
Babji B.S.: ABB Corporate Research, Bangalore, India
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Bachmann, Bernhard: Bielefeld University of Applied Sciences, Bielefeld, Germany
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Batteh, John: Ford Motor Company, Dearborn, U.S.A.
Detailed Simulation of Turbocharged Engines with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Benjelloun-Dabaghi, Zakia: INRIA, Rocquencourt, France
Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station
in IFP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Blochwitz, Torsten: ITI GmbH, Dresden, Germany
The Modelica Association

XI

Modelica 2008, March 3rd  4th , 2008

Index of Authors
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
An External Model Interface for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Blom, Mikael: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Bockholt, Marcos: Braunschweig University of Technology, Braunschweig, Germany
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Bonvini, Marco: Politecnico di Milano, Milano, Italy
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Breitenecker, Felix: Vienna University of Technology, Vienna, Austria
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Bride, Benot: EDF R&D, Chatou, France
Two Steady State CHP Models with Modelica: Mirafiori overall Model and
Multi-configuration Biomass Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
Broman, David: Linkoping University, Linkoping, Sweden
Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica . . 3
Burghart, Roger: Hamburg University of Technology, Hamburg, Germany
Integrating Models and Simualtions of Continuous Dynamics into SysML . . . . . . . . . . . . . . . . . . . 135
Casas, Wilson: Hamburg University of Technology, Hamburg, Germany
Enhancement of a Modelica Model of a Desiccant Wheel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
Casas, Wilson: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Casella, Francesco: Politecnico di Milano, Milano, Italy
ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica. . . .157
High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters 505
HyAuLib: Modelling Hybrid Automata in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Cellier, Francois: ETH Zurich, Zurich, Switzerland
Support for Dymola in the Modeling and Simulation of Physical Systems with
Distributed Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 683
ThermoBondLib - A New Modelica Library for Modeling Convective Flows . . . . . . . . . . . . . . . . . 163
World3 in Modelica: Creating System Dynamics Models in the Modelica Framework . . . . . . . . 393
Chen, Liping: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Chen, Wei: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Christ, Thomas: BMW Hybrid Cooperation, Troy, U.S.A.
Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid
Powertrain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
Clau, Christoph: Fraunhofer Institut, Dresden, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
The Modelica Association

XII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Monte Carlo Simulation with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601
Corno, Matteo: Politecnico di Milano, Milano, Italy
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Dempsey, Mike: Claytex Services Ltd, Leamington Spa, United Kingdom
Application of Neural Networks to model Catamaran Type Powerboats . . . . . . . . . . . . . . . . . . . . . 247
Dietl, Karin: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Donath, Ulrich: Fraunhofer Institut, Dresden, Germany
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
Donida, Filippo: Politecnico di Milano, Milano, Italy
Modelica as a Host Language for Process/Control Co-Simulation and Co-Design . . . . . . . . . . . . 401
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Dshabarow, Farid: ABB Turbo Systems AG, Baden, Switzerland
Support for Dymola in the Modeling and Simulation of Physical Systems with
Distributed Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 683
Ebner, Arno: Arsenal Research, Vienna, Austria
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Eck, Markus: German Aerospace Center, Oberpfaffenhofen, Germany
4-Dimensional Table Interpolation with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
El Hefni, Baligh: EDF R&D, Chatou, France
Two Steady State CHP Models with Modelica: Mirafiori overall Model and
Multi-configuration Biomass Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
Elmqvist, Hilding: Dynasim AB, Lund, Sweden
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Unit Checking and Quantity Conservation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Elsheikh, Atya: Siegen University, Siegen, Germany
Sensitivity Analysis of Modelica Applications via Automatic Differentiation . . . . . . . . . . . . . . . . . 669
Enge-Rosenblatt, Olaf: Fraunhofer Institut, Dresden, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Modelica Wind Turbine Models with Structural Changes Related to Different Operating
Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611
Fahlke, Julia: Freiberg University of Technology, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Fenz, Claus J. : Arsenal Research, Vienna, Austria
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Fish, Garron: Claytex Services Ltd, Leamington Spa, United Kingdom
Application of Neural Networks to model Catamaran Type Powerboats . . . . . . . . . . . . . . . . . . . . . 247
Franke, Ruediger: ABB Power Technology Systems, Mannheim, Germany
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Frey, Georg: Kaiserslautern University of Technology, Kaiserslautern, Germany
The Modelica Association

XIII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Simulation of Distributed Automation Systems in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Fritzson, Peter: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Compiling and Using Pattern Matching in Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .637
Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica . . 3
Exception Handling for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Modeling of CO2 Reduction Impacts on Energy Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . 565
Furic, Sebastien: LMS-Imagine, Roanne, France
Synchronous and Asynchronous Events in Modelica: Proposal for an Improved Hybrid
Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
Gafvert, Magnus: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics . . . . . . . . . . . . . . . . . . . 515
Guhmann, Clemens: Technische Universitat Berlin, Berlin, Germany
Modelling of a Double Clutch Transmission with an Appropriate Controller for the
Simulation of Shifting Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
Modelling of Electric Drives using freeFOClib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Ganchev, Martin: Arsenal Research, Vienna, Austria
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Giuliani, Harald: Arsenal Research, Vienna, Austria
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Gohl, Jesse: Emmeskay, Inc., Plymouth, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Gragger, Johannes V.: Arsenal Research, Vienna, Austria
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Greifeneder, Jurgen: Kaiserslautern University of Technology, Kaiserslautern, Germany
ThermoBondLib - A New Modelica Library for Modeling Convective Flows . . . . . . . . . . . . . . . . . 163
Guillemard, Franck: PSA Peugeot Citroen, Velizy-Villacoublay Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Hobinger, Mathias: Vienna University of Technology, Vienna, Austria
PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems . . . . . . . . . . . . . . . . . . . . . 549
Haase, Joachim: Fraunhofer Institut, Dresden, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Monte Carlo Simulation with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601
Hannemann, Frank: Siemens Fuel Gasification Technologie, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Haufe, Jurgen: Fraunhofer Institut, Dresden, Germany
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
Haumer, Anton: Arsenal Research, Vienna, Austria
The Modelica Association

XIV

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the
ExtendedMachines Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Henriksson, Dan: Dynasim AB, Lund, Sweden
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Hirsch, Tobias: German Aerospace Center, Oberpfaffenhofen, Germany
4-Dimensional Table Interpolation with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
Hoeft, Thomas: Fraunhofer Institut, Berlin, Germany
Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 735
Imsland, Lars: Cybernetica AS, Trondheim, Norway
Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . 301
Isaksson, Alf: ABB Corporate Research, Bangalore, India
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Isernhagen, Henrik: Technische Universitat Berlin, Berlin, Germany
Modelling of a Double Clutch Transmission with an Appropriate Controller for the
Simulation of Shifting Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
Jockel, Michael: Fraunhofer Institut, Darmstadt, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Jardin, Audrey: INSA-Lyon AMPERE, Villeurbanne Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Johnson, Thomas: Georgia Institute of Technology, Atlanta, U.S.A.
Integrating Models and Simualtions of Continuous Dynamics into SysML . . . . . . . . . . . . . . . . . . . 135
Jonasson, Mats: Volvo Car Corporation, Goteborg, Sweden
Vehicle Model for Limit Handling: Implementation and Validation . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Joos, Andreas: Hamburg University of Technology, Hamburg, Germany
Enhancement of a Modelica Model of a Desiccant Wheel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
Juhasz, Tamas: Fraunhofer Institut, Magdeburg, Germany
Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation . . . . . . . . 719
Junghanns, Andreas: QTronic GmbH, Berlin, Germany
TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . 341
Junior, Christine: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Kohler, Jurgen: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Kapeller, Hansjorg: Arsenal Research, Vienna, Austria
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
The Modelica Association

XV

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Karim, Sanaz: Modelon AB, Lund, Sweden
Controller Development for an Automotive Ac-system using R744 as Refrigerant . . . . . . . . . . . . 477
Kittilsen, Pal: Cybernetica AS, Trondheim, Norway
Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . 301
Kosenko, Ivan I.: Moscow State University of Tourism and Service, Moscow, Russian Federation
Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica . . . 203
Modelica Implementation of the Skateboard Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727
Kral, Christian: Arsenal Research, Vienna, Austria
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the
ExtendedMachines Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Kuhn, Martin: German Aerospace Center, Oberpfaffenhofen, Germany
A Multi Level Approach for Aircraft Electrical Systems Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Kuleshov, Alexander S.: Lomonosov Moscow State University, Moscow, Russian Federation
Modelica Implementation of the Skateboard Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727
Kurzbach, Gerd: ITI GmbH, Dresden, Germany
An External Model Interface for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Losch, Jurgen: Fraunhofer Institut, Darmstadt, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Lemke, Nicholas: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Lemke, Nicholas: TLK-Thermo GmbH, Braunschweig, Germany
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Leva, Alberto: Politecnico di Milano, Milano, Italy
Modelica as a Host Language for Process/Control Co-Simulation and Co-Design . . . . . . . . . . . . 401
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Li, Lingyang: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Li, Pengfei: University of Wisconsin, Milwaukee, U.S.A.
Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . 447
Li, Yaoyu: University of Wisconsin, Milwaukee, U.S.A.
Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . 447
Lie, Bernt: Telemark University College, Porsgrunn, Norway
Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model . . . . . 287
Liebman, Ariel: University of Queensland, Brisbane, Australia
Modeling of CO2 Reduction Impacts on Energy Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . 565
Liu, Liu: Kaiserslautern University of Technology, Kaiserslautern, Germany
The Modelica Association

XVI

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Simulation of Distributed Automation Systems in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Looye, Gertjan: German Aerospace Center, Oberpfaffenhofen, Germany
The New DLR Flight Dynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Lorenz, Francis: LorSim, Liege, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Lovera, Marco: Politecnico di Milano, Milano, Italy
High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters 505
Machanick, Philip: University of Queensland, Brisbane, Australia
Modeling of CO2 Reduction Impacts on Energy Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . 565
Malmheden, Martin: Dynasim AB, Lund, Sweden
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Marquis-Favre, Wilfrid: INSA-Lyon AMPERE, Villeurbanne Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Mattsson, Sven Erik: Dynasim AB, Lund, Sweden
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Unit Checking and Quantity Conservation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Mauss, Jakob: QTronic GmbH, Berlin, Germany
TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . 341
Mehrkens, Christian: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Meyer, Bernd: Freiberg University of Technology, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Nahring, Tobias: ITI GmbH, Dresden, Germany
Frequency-Domain Analysis Methods for Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
Najafi, Masoud: INRIA, Rocquencourt, France
Initialization of Modelica Models in Scicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station
in IFP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Neidhold, Thomas: ITI GmbH, Dresden, Germany
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
An External Model Interface for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Newman, Charles: Ford Motor Company, Dearborn, U.S.A.
Detailed Simulation of Turbocharged Engines with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Nikoukhah, Ramine: INRIA, Rocquencourt, France
Initialization of Modelica Models in Scicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Synchronous and Asynchronous Events in Modelica: Proposal for an Improved Hybrid
Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
Noack, Stephan: Research Center Julich GmbH, Julich, Germany
Sensitivity Analysis of Modelica Applications via Automatic Differentiation . . . . . . . . . . . . . . . . . 669
Norling, Kristoffer: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Nytsch-Geusen, Christoph: Fraunhofer Institut, Berlin, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
The Modelica Association

XVII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 735
Oberguggenberger, Helmut: Arsenal Research, Vienna, Austria
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Thermal Modelling of an Automotive Nickel Metall Hydrid Battery in Modelica using
Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Olsson, Hans: Dynasim AB, Lund, Sweden
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Otter, Martin: German Aerospace Center, Oberpfaffenhofen, Germany
A Multi Level Approach for Aircraft Electrical Systems Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems . . . . . . . . . . . . . . . . . . . . . 549
Puschel, Stephan: Freiberg University of Technology, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Paredis, Chris: Georgia Institute of Technology, Atlanta, U.S.A.
Integrating Models and Simualtions of Continuous Dynamics into SysML . . . . . . . . . . . . . . . . . . . 135
Pascoli, Gert: Arsenal Research, Vienna, Austria
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Pechine, Bruno: EDF R&D, Chatou, France
Two Steady State CHP Models with Modelica: Mirafiori overall Model and
Multi-configuration Biomass Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
Pfennig, Malte: Hamburg University of Technology, Hamburg, Germany
Implementation of a Modelica Library for Simulation of High-Lift Drive Systems . . . . . . . . . . . . 531
Philipson, Niklas: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Pirker, Franz: Arsenal Research, Vienna, Austria
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Pop, Adrian: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Compiling and Using Pattern Matching in Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .637
Exception Handling for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Pulecchi, Tiziano: Politecnico di Milano, Milano, Italy
HyAuLib: Modelling Hybrid Automata in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Qin, Gang: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Raulin, Loic: Airbus, Toulouse, France
A Multi Level Approach for Aircraft Electrical Systems Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Ravelli, Lorenzo: Politecnico di Milano, Milano, Italy
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Reutersward, Philip: Modelon AB, Lund, Sweden
The Modelica Association

XVIII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Richter, Christoph: Braunschweig University of Technology, Braunschweig, Germany
ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica. . . .157
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Sasena, Michael: Emmeskay, Inc., Plymouth, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Savaresi, Sergio M.: Politecnico di Milano, Milano, Italy
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Scattolini, Riccardo: Politecnico di Milano, Milano, Italy
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Schallert, Christian: German Aerospace Center, Oberpfaffenhofen, Germany
Incorporation of Reliability Analysis Methods with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
Schei, Tor Steinar: Cybernetica AS, Trondheim, Norway
Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . 301
Schicktanz, Matthias: Fraunhofer Institut, Freiburg, Germany
Modelling of an Adsorption Chiller with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .573
Schmitz, Gerhard: Hamburg University of Technology, Hamburg, Germany
Enhancement of a Modelica Model of a Desiccant Wheel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
Schmitz, Gerhard: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Schmucker, Ulrich: Fraunhofer Institut, Magdeburg, Germany
Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation . . . . . . . . 719
Schneider, Peter: Fraunhofer Institut, Dresden, Germany
Modelica Wind Turbine Models with Structural Changes Related to Different Operating
Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611
Schwarz, Peter: Fraunhofer Institut, Dresden, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Seem, John: Building Efficiency Research Group, Milwaukee, U.S.A.
Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . 447
Simic, Dragan: Arsenal Research, Vienna, Austria
Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the
SmartElectricDrives Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
Thermal Modelling of an Automotive Nickel Metall Hydrid Battery in Modelica using
Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Skoglund, Tomas: Tetra Pak Procesing Systems, Lund, Sweden
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Stavaker, Kristian: Linkoping University, Linkoping, Sweden
Compiling and Using Pattern Matching in Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .637
Exception Handling for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Strupp, Nils-Christian: Braunschweig University of Technology, Braunschweig, Germany
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
The Modelica Association

XIX

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Tatar, Mugur: QTronic GmbH, Berlin, Germany
TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . 341
Tate, Edward: General Motors, Michigan, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Tegethoff, Wilhelm: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Thielecke, Frank: Hamburg University of Technology, Hamburg, Germany
Implementation of a Modelica Library for Simulation of High-Lift Drive Systems . . . . . . . . . . . . 531
Thomasset, Daniel: INSA-Lyon AMPERE, Villeurbanne Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Tiller, Michael: Emmeskay, Inc., Plymouth, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Patterns and Anti-Patterns in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 647
Tummescheit, Hubertus: Modelon AB, Lund, Sweden
Controller Development for an Automotive Ac-system using R744 as Refrigerant . . . . . . . . . . . . 477
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic
Transfer System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
Tuszynski, Kristian: Modelon AB, Lund, Sweden
ExcelInterface - A Tool for Interfacing Dymola through Excel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621
Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic
Transfer System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
Vahlenkamp, Thorben: XRG Simulation GmbH, Hamburg, Germany
FluidDissipation - A Centralised Library for Modelling of Heat Transfer and Pressure Loss . . 173
Vasel, Jens: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Verzichelli, Gianluca: Airbus, Filton, United Kingdom
Development of an Aircraft and Landing Gears Model with Steering System in
Modelica-Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
Videla, Juan Ignacio: Telemark University College, Porsgrunn, Norway
Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model . . . . . 287
von Grundherr, Johannes: BMW Group, Munic, Germany
Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid
Powertrain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
Wagner, Florian: Kaiserslautern University of Technology, Kaiserslautern, Germany
Simulation of Distributed Automation Systems in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Wiechert, Wolfgang: Siegen University, Siegen, Germany
Sensitivity Analysis of Modelica Applications via Automatic Differentiation . . . . . . . . . . . . . . . . . 669
Wigermo, Henrik: BMW Group, Munic, Germany
Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid
Powertrain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
The Modelica Association

XX

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Wikander, Hans: Avensia Innovation AB, Lund, Sweden
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Windahl, Johan: Modelon AB, Lund, Sweden
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Winkler, Dietmar: Technische Universitat Berlin, Berlin, Germany
Modelling of Electric Drives using freeFOClib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Wischhusen, Stefan: XRG Simulation GmbH, Hamburg, Germany
FluidDissipation - A Centralised Library for Modelling of Heat Transfer and Pressure Loss . . 173
Wolf, Susann: Fraunhofer Institut, Dresden, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Monte Carlo Simulation with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601
Woodruff, Andrew: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Zhang, Yunqing: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Zimmer, Dirk: ETH Zurich, Zurich, Switzerland
Introducing Sol: A General Methodology for Equation-Based Modeling of
Variable-Structure Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
Support for Dymola in the Modeling and Simulation of Physical Systems with
Distributed Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 683

The Modelica Association

XXI

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

XXII

Modelica 2008, March 3rd  4th , 2008

Session 1a
Language, Tools and Algorithms

The Modelica Association

1

Modelica 2008, March 3-4, 2008

The Modelica Association

2

Modelica 2008, March 3rd  4th , 2008

Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica

Design Considerations for Dimensional Inference and Unit
Consistency Checking in Modelica
David Broman1

Peter Aronsson2

Peter Fritzson1

1 Department

of Computer and Information Science,
Linkping University, Sweden, {davbr,petfr}@ida.liu.se
2 MathCore Engineering, Sweden, peter.aronsson@mathcore.com

Abstract

better unit consistency checking. However, this may
lead to incompatibility, where some tools reject certain
model and others accept them. Unit related research
results within the field of programming language (e.g.,
[1, 5, 9, 13, 18]) have shown that there exist many concepts and constructs that affect the possibility and simplicity to perform correct dimensional and unit checking. Design considerations must be taken from both
the end user perspective and from the library and tool
implementor perspective.

The Modelica language supports syntax for declaring
physical units of variables, but it does not yet exist
any defined semantics for how dimensional and
unit consistency checking should be carried out. In
this paper we explore different approaches and new
constructs for improved dimensional inference and
unit consistency checking in Modelica; both from an
end-user, library, and tool perspective. A proposal for
how dimensional inference and unit checking can be
carried out is outlined and a prototype implementation
is developed and verified using several examples from
the Modelica standard library.

This paper introduces and discusses several different
concepts and constructs, which are important when designing a language with support for dimensional inference and unit consistency checking1 . Examples are
given using both existing Modelica syntax, and adKeywords: dimensional analysis, unit checking; ditional suggested constructs. The main contribution
dimensions; types; Modelica; language design
of the work is the suggested design for incorporating
the unit checking as part of the elaboration (instantiation) process, which supports both implicit inference
1 Introduction
of unspecified dimensions and rational numbers of dimension exponents. To verify the design, a prototype
The Modelica language enables expressive modeling implementation was constructed in the OpenModelica
by making use of object-oriented acausal constructs. [17] environment.
However, certain powerful language constructs eas- The paper is structured as follows: Section 2 introily lead to modeling errors, which are often hard to duces fundamental terminology and describes design
detect at simulation time. One class of modeling er- considerations affecting primarily the end user. Secrors that can be detected statically before simulation is tion 3 describes design issues from a library and tool
model and equation consistency with regards to phys- perspective. Both these sections explore the design
ical dimensions, quantities and units. The Modelica space in which a specific design can be created. Seclanguage specification [12] states how units and quan- tion 4 specifies a number of design choices made for a
tities can be declared. However, the semantics and prototype implementation created in the OpenModelstrategy for how physical units and dimension of quan- ica environment. Section 5 discusses related work and
tities can be checked for consistency, are not described section 6 concludes the paper.
in the specification.
Several of the available tools (e.g., Dymola[4] and
1 In the remainder of the paper, the term unit checking will be
Simulation X[8]) implement various algorithms for used for dimensional checking as well. However, note that even
handling units and dimensions. Furthermore, tool spe- if a system is dimensionally consistent, it might have conflicting
cific language constructs are being added to enable units of measure.
The Modelica Association

3

Modelica 2008, March 3rd  4th , 2008

D. Broman, P. Aronsson, P. Fritzson

2 End User Perspective

Hence, unit and dimensional checking can advantageously be performed statically at compile time. This
In this section, several aspects of unit checking will process is typically accomplished by using a static type
be discussed primary from an end user perspective. checker, which takes a Modelica model as input and
The section starts by refreshing fundamental terminol- returns one of three possible answers:
ogy; followed by description of concepts such as type
checking and polymorphism.
 Consistent and complete. The equations, connectors, hierarchy composed components, and the
declared derived physical units match without ex2.1 Units, Quantities, and Dimensions
ception. All variables have a specific unit asPhysical quantities are organized into different dimensigned to it.
sions, such as length, time, and mass. The SI Consistent and incomplete. The model is consissystem [7] defines seven base quantities, which can be
tent (no conflicting constraints), but some varicombined to form new derived quantities.
ables have no units assigned to them.
For a particular quantity, there exist several different
units, e.g., the quantity length can be used with
 Inconsistent. One or several relations mismatch.
both of the units meter and foot. To convert beFor example, an equation a = der(b)*33+c
tween different units within the same quantity dimenis inconsistent if a and c do not have the same
sion, conversion factors are defined. To convert from
units, or if the unit of b multiplied by "s" (time)
foot to meter a scale factor of 0.3048 is multiplied to
is not equal to the unit of c.
the measured value. However, some unit conversions
are more complex. For example, the formula TCelsius =
A language and type checker can be designed to infer
(5/9)  (TFahrenheit  32) for converting Fahrenheit
missing unit types, which can result in both a consisto Celsius involves both a scale factor of 5/9 and
tent and an inconsistent result.
an offset of value 32  (5/9).
Furthermore, from a users point of view, it is imporThe SI-system defines seven base units
tant to know that the model is consistent, e.g., that the
(m,kg,s,A,K,mol,cd) as well as derived
type checker can guarantee that unit errors do not exunits, which are accepted within the SI-system. These
ist. The property that a tool cannot find any inconsisderived units have specific names and symbols and
tencies in a model, does not imply that the model is
always have a corresponding normalized form exconsistent. In our proposal, this is a strong requirepressed in base units. For example newton meter has
ment for the design of the unit checker.
the symbol N m, which has the expression m2 kg s2 .
For some derived quantities, the dimensional exponents are zero. Such a quantity is referred to as di- 2.3 Detecting Errors, Isolating Faults
mensionless or having dimension one. For example The previous described approach for unit checking enthe derived quantity plane angle with derived unit ables detection of modeling errors, i.e., to give a sound
radian is such a dimensionless quantity.
judgement of the models correctness regarding physIn Modelica, there is a syntax to define derived ical units and quantities. However, even if a tool can
unit using base unit expressions. For example, the respond that a model is incorrect, it is very important
above expression of newton meter can be expressed for the user to know where in the model the fault is
as "m2.kg.s-2". From now on, this syntax will be located. Hence, the tools ability to isolate faults in a
used for describing unit expressions.
model is critical for making the unit checking process
useable.

2.2 Static Unit Type Checking
2.4 Polymorphism

When simulating Modelica models, the state of a dynamic model changes during the simulation, but the relation between the units of variables should not change
dynamically2 .

A language where an object only can be of one type
is said to have a monomorphic type system. This
leads to a very restrictive language, with limited ex2 Using algorithms and functions, it is possible to define ex- pressiveness. Modelica is a polymorphic language,
pressions that violates this principle. However, it would require where polymorphic behavior is primarily expressed
using subtyping polymorphism.
the theory of dependent types to manage this property statically.
The Modelica Association

4

Modelica 2008, March 3rd  4th , 2008

Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica

Consider the following example of the block Gain,
defined in the Modelica standard block library.

 Explicit type declaration means that the user
specifies units for variables, and thus removes the
need of deducing units.

block Gain
parameter Real k(unit="1") = 1;
public
Interfaces.RealInput u;
Interfaces.RealOutput y;
equation
y = k*u;
end Gain;

For instance, consider the following example:

model A
Real(unit="m") x1,y1,d1,d2;
Real x2,y2;
equation
d1 = sqrt(x1^2+y1^2);
d2 = sqrt(x2^2+y2^2);
Both input and output to and from the model are deend
A;
fined using Real types, i.e., no units are defined for

this block. If a unit checker should be able to check
instances of this block, unit types must be specified
for its formal parameters. For example, both input
and output can be defined to have unit type Voltage.
However, this would result in a new block definition
for every imaginable unit, which clearly is impractical.
A solution to this problem which is being implemented
in this proposal is the use of unit type variables, and
so called parametric polymorphism i.e., the block is
declared to take a unit type variable p as both input
and output. Hence, the unit information is propagated
from the input to the output3 . This approach is similar
to ordinary type variables used in for example Haskell
[16] or Standard ML [11].
For general information about types and polymorphism see [3]. An accessible description on how types
are related to Modelica can be found in [2].

The example calculates the distances of two points to
the origin (0,0). The first point (x1,y1) uses explicit unit type declaration, giving x1,y1 and d1 the
unit "m", and the second point (x2,y2) uses implicit type inference, where units are not specified. In
the second case the units can be deduced from the unit
of the distance variable d2, i.e., the unit type of x2
and y2 are inferred from the unit type of d2.
A problem is how to distinguish between dimensionless units and implicit type inference. Consider the
following declaration:
Real x;

Is x dimensionless or should the type be inferred (i.e.,
has any dimension)? The most probable interpretation
is that it should be inferred. There are several alternatives of how to declare a dimensionless unit. One
solution is to use
Real x(unit ="1");

3 Design from Library and Tool
Perspective

It is important to differentiate between any dimension
and dimensionless, because the distinction can give
better information for the unit checker to perform its
This section presents requirements and a proposed de- task.
sign for unit checking from the perspective of imple- To be able to handle parametric polymorphism it must
menters of libraries and tools.
be possible to declare unit type variables. A unit type
variable can hold any unit type and thus provides flexibility of e.g., writing functions. For instance, consider
3.1 Unit Type Declaration
the following example:
There are two approaches of handling declaration of
unit types, implicit unit type inference or explicit type function myDer
input Real x(unit="p");
declaration.
output Real y(unit="p.s-1");
algorithm
 Implicit type inference means that the user does
y:= der(x);
not specify units for all variables and that the tool end myDer;

uses type inference to deduce the units of those
The example is a wrapper around the der operator.
variables.
The unit of the input argument uses a unit type variable
3 Note that parameter k needs to be explicitly defined to be di"p" which is used to express the unit of the result
mensionless (unit="1") in order to make a unit type inference algorithm to work. If it was left as unspecified, the gain could generate from the function. Here the character  is part of the
any possible unit, regardless of its input.
type variable identifier and indicates that this is a type
The Modelica Association

5

Modelica 2008, March 3rd  4th , 2008

D. Broman, P. Aronsson, P. Fritzson

representation to a string must be considered. Often,
the choice of derived units to use is not obvious, and
heuristics must be used to achieve what a user might
expect as output. Such heuristic is not trivial to do
and it might even be different depending on the context
(application area) of the user model.

variable and not a normal variable. Using a type variable makes it possible to use the myDer() function
for any type of unit, and still being able to express the
relation between the unit types of the input and output
argument.

3.2 Unit Conversion
For many situations it is necessary to convert expres- 3.4 Defining Units in the Modelica Language
sions from one unit to another. A unit conversion does
To be able to handle other units than those described
not change the dimension of an expression, only its
by the SI standard, a more elaborate design than using
value. For instance:
seven base units must be introduced. For instance, a fiSI.Length d1 = 25.4;
nancial institute involved in modeling and simulating
Real d2 =
the stock market might be interested in using the quanunitConvert(d1,"mm");
tity "money". Also, they would like to be able to add
For this case 25.4 is interpreted as meter (defined scaling factors between different units of money ($,
in SI.Length). The proposed built in function C, SEK, etc.). Thus, an important design requirement
unitConvert(var,unit) converts the value to for the unit checking framework is that the number of
25400 and assigns it to d2. Moreover, d2 is now as- base units is not known a priori, i.e., end users must be
sumed to have unit "mm". Note that it is not possi- able to add whatever units they want. Also, the scale
ble to just scale this using an ordinary multiplication, and offset information must be available for the unit
since the user must tell the type checker that the unit checking module. Finally, it must also be possible to
has been changed.
describe the relation between base units and derived
In conclusion, unit conversion is a fundamental re- units.
quirement to be able to work conveniently with units. Currently, Modelica does not have support for adding
scaling (and offset) for units, neither can one add ones
own "base units". Today, Modelica has some knowl3.3 Representation of Units
edge about the SI units, e.g., a Modelica tool with unit
The unit checking mechanism requires the tool to be checking capabilities knows that unit="m" refers to
able to distinguish between different (base) units. This the base unit meter and unit ="F" refers to the nonis typically solved (e.g., in [14, 15]) by having a vec- base unit farad (expressed as "m-2.kg-1.s4.A2"
tor of seven base units, as described by the SI standard in base units) and not to Fahrenheit. But, if users
[7]. For instance, energy can in the SI units be de- should be able to add their own base units, the lanscribed using "J" (Joule) or "N.m" (Newton meter) guage should instead be extended so that base units
corresponding to the base unit "m2.kg.s-2". Cur- can be described in Modelica. The SI-units package
rently, a Modelica tool would need to know that "J" would then first declare the SI base units, and then deor "N.m" correspond to the base unit "m2.kg.s-2" rive units based on these base-units.
and how to construct the appropriate vector for such a Moreover, information for converting between units is
unit.
not covered by current Modelica. To be able to convert
To be able to handle functions like calculating the between different units, scaling and offset information
square root of a value (the sqrt function), the coeffi- must be introduced. For instance, consider converting
cients of the dimension vector must be able to handle between Fahrenheit and Kelvin. This can be achieved
more than integer numbers. By using rational num- using a scaling factor and an offset as illustrated by the
bers instead it is possible to express e.g., the square conversion function in the standard library:
root with exponent (1/2). Note that it is not possible to
use floating point precision as coefficients , since that function from_degF
input NonSIunits.Temperature_degF
would lead to roundoff errors.
fahrenheit;
A problem related to the representation of units is how
output Temperature kelvin;
to present a unit to the user. Often a user has no idea algorithm
what the unit "m2.kg.s-2" means. Instead, the user
kelvin := ((fahrenheit - 32)*5)/9 expects the derived unit to be output, i.e., "N.m". The
Modelica.Constants.T_zero;
problem of unparsing (pretty printing) the internal unit end from_degF;
The Modelica Association

6

Modelica 2008, March 3rd  4th , 2008

Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica

Figure 1: Possible unit checking-times (T1,T2,T3,T4) during the Modelica compilation and simulation process.

4 Prototype Implementation

If the scale and offset information instead is added to
the unit types (e.g., as attributes to the built-in Real
class), such conversion functions would not be required. Instead the tool could perform the conversion
using the built-in unitConvert() function, rendering convert functions in the standard library redundant.

A prototype implementation based on the design requirements presented above is under development in
the OpenModelica[17] and MathModelica[10] compilers. The compiler does a static (during compilation)
check of dimensions and units of measure.

3.5 Time of Checking

4.1 Design

There are several different points in time during the
The design includes the following aspects:
translation process where the unit checking mechanism could be introduced, see Figure 1.
 Rational numbers as exponents on dimensions.
 Unit type variables in declarations.

 T1 - At the model level.

 Literal constants are treated differently depending on context (dimensionless in multiplication/division and unknown in addition/subtraction).

 T2 - During elaboration.
 T3 - At the hybrid DAE (flat Modelica) level.

 Type inference of dimensions.
 T4 - During runtime/simulation.
 User defined base and derived units.
Some checks can be made at the model level (T1), performing checks for each individual sub-model. Local
equations in the model can be checked this way, but
not equations generated from connecting components
together, or components where types must be deduced
from the surrounding environment (e.g., connections
or modifiers). Another approach is to combine the
unit checking phase with the elaboration (flattening)
process (T2).
Checking on the flat model (T3) is of course feasible,
leading to a large check of the overall system. The advantage of this approach is its simplicity; a translation
of the model into equations for the unit checking module is performed only once. The disadvantage is that it
is much harder to isolate the fault, since only the flat
set of equations is available. Also, this approach will
not make use of already checked parts, e.g., checking
the model equations of an electrical resistor will be
done not only once but for as many times as the resistor model is used as a component. The gPROMS
unit checking tool [14, 15] uses this approach. Finally,
some analysis cannot be performed statically and must
then be performed during runtime, i.e., during the simulation (T4).
The Modelica Association

 Checking is performed during elaboration / flattening to enable better fault isolation.
The design is split into separate parts, see Figure 2.
One part is integrated with the elaboration (flattening)
process in the OpenModelica compiler. It will create
an equation systems to be solved by the Unit Checker
(the second part) for model components according to
the same principles as components are instantiated in
Modelica (i.e., a recursive process). This is done by
first adding units to a unit store by calling the addStore
function in the UnitASTBuilder module. Next, local equations are traversed to build unit terms, with
the buildTerms function. Both the unit store and unit
terms are defined in the UnitAbsyn module. Finally,
the check function in the UnitChecker module is called
to perform the dimension analysis. The result from
the checking of each component contains two pieces
of information. First, for each component it will receive an answer whether a component is Ok (consistent and complete), inconsistent (incompatible types)
or consistent and incomplete (not enough information
available). Secondly, it will calculate the resulting unit
type variables of a component which can then be used
7

Modelica 2008, March 3rd  4th , 2008

D. Broman, P. Aronsson, P. Fritzson

UnitASTBuilder
Elaboration (instantiation) module
addStore(name,unit,st) -> st
buildTerms (eqns,st)
-> (terms,st)

Recursion over all
sub components

Unit
Store

UnitAbsyn

UnitChecker
check(terms,st) ->
({ConsistentComplete,
ConsistentIncomplete,
InConsistent},st)

Figure 2: Outline of the main modules of the unit type checking engine of the prototype implementation.
Arrows describe dependencies between modules.
when checking the complete model. This will give the to its corresponding unit. During the instantiation and
following steps of the unit checking function.
unit checking process the unit store is updated with
new units. The following model shows how the unit
1. Check components in the class.
store is used:
2. Build a new equation system from the type vari- model SimpleOde
Real x;
ables from each component together with local
Velocity v;
equations and connections.
equation
der(x)=2*v + 1.0;
end SimpleOde;

3. Call the unit checker for the model itself.

First the unit store is built by adding the units of the
variables x and v. Since x is declared as a Real it
gets an unspecified unit, and v gets the unit "m/s".
After the unit checking module has been executed on
this class, it will update the unit store with the unit
for x with "m", because this was inferred by the
UnitCheck module. This information can then be used
higher up in the instance tree to check units of other
components.

Note that checking the components of a class means a
recursion over the three steps for the class of the component.
The equation systems for the unit checker are created
from two data structures, a unit store that holds units of
variables, and unit terms that describe constraints between different variables. The following sections show
how these are built.
4.1.1 Storing Units

4.1.2 Building Unit Terms
Each variable in a model has a corresponding unit. A
The second data structure required for building unit
unit can be
constraint equations is the Unit Term which describes
 A specified unit, e.g., "m/s".
relations between variables. This structure is similar
to the data structure for equations, containing nodes
 A unit type parameter e.g., "p", with an op- for e.g., addition, multiplication, etc. It is sufficient to
tional exponent, e.g., "p^2".
only have four types of relations between units: multi A combination of specified unit and type parame- plication of terms, division of terms, addition of terms,
and equality between terms. Since an addition of two
ter, e.g., "p/s".
variables and a subtraction of two variables both im unspecified unit e.g., the unit of a declaration ply the same rules for the units, both of these can be
expressed using the same unit term. The leaf nodes of
"Real x;".
terms are references to units in the unit store.
The unit store is a data structure that holds the units Let us again consider the example SimpleOde above.
of variables. It gives a mapping from a variable name We use ADD and MUL for addition and multiplicaThe Modelica Association

8

Modelica 2008, March 3rd  4th , 2008

Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica

Figure 3: An inconsistent circuit that should fail during dimensional checking.

Figure 4: A dimensionally correct circuit.

4.2 Example
tion in our data structure and EQN for equality between terms. For the leaf nodes, with references to
the unit store, are described with LOC. The example
above corresponds to the following terms (somewhat
simplified):

Let us consider an example using components from
the Modelica Standard Library to illustrate the different aspects of unit checking. Figure 3 shows an example where unit checking will return an error because of
inconsistent units4 . A VariableResistor and a VariableConductor is fed from the same signal source, taken
from the Blocks library. All sources in the Blocks
library have unspecified units, such that they can be
used in any context. The unit checker will find that the
unit of the output of the clock generator should be both
"Ohm" (Resistance) and "S" (Conductance), i.e., an inconsistency is reported. This inconsistency is detected
first when the local equations of the Circuit model is
unit type checked. The unit store then contains an unspecified unit for the clock generator (clock1.y) and
specified units for the inputs on the resistor R1 (R1.R)
and the conductor G1 (G1.G).
To resolve the inconsistency of the circuit the user has
to use two separate clock generators, see Figure 4. The
unit of clock1.y will become "Ohm" and clock2.y will
become "S", resulting in a consistent system.
When using math blocks (Gain, Add, TransferFunction, etc) in models it becomes evident that polymorphism is required. For instance, lets add a gain to

EQU(
LOC("der(x)"),
ADD(
MUL(LOC("V"),LOC("2")),
LOC("1.0")))

From the unit store and the unit terms, constraint equations are built. A multiplication of unit terms means
that the unit vector is added, and an addition of unit
terms means that the units must be equal.
4.1.3 Built-in Functions and Operators
The built-in functions and operators are extended with
units containing unit type parameters. That gives us
a uniform way of dealing with functions, regardless if
the function is a built-in function, a built-in operator,
or a user-defined function. For instance, the der operator is internally described as
function der
input Real x(unit = "p");
output Real y(unit = "p/s");
external "builtin";
end der;

4 The circuit is inconsistent since the VariableResistor and Vari-

ableConductor have declared their inputs to Resistance and Conductance respectively. If they were declared as dimensionless
the circuit would have been consistent, thus also making it a library design issue. Also, it could be possible to have different
unit checking semantics depending on the causality of equations,
which would allow this kind of connections.

That is, applying the derivative operator to an expression will change its unit by multiplication with "s-1".
The Modelica Association

9

Modelica 2008, March 3rd  4th , 2008

D. Broman, P. Aronsson, P. Fritzson

Figure 5: An inconsistent model with a polymorphic
block.
our inconsistent model, see Figure 5. The gain block
should be possible to use for any unit, i.e., it should
be a polymorphic block. If that would not be possible, the user would have to write a new block model
for each particular use, in this case for amplifying a
Conductance signal. In our implementation, the unit
checker will treat the Gain block as having a polymorphic unit and assign a unit type parameter to it.
The result of checking the gain block is a unit type
parameter that propagates the unit of the input to the
unit of the output. Hence, when the circuit model is
checked, the unit from the VariableConductor is propagated to the unit of clock1.y, leading to an inconsistent system of equations. Typically, for larger block
models, this propagation can be performed over many
subsystems of components. This implementation will
however lead to a detection of the inconsistency at the
lowest level possible, making it easier for the user to
correct the inconsistency.

5 Related Work
Unit checking has been introduced in several Modelica tools over the last couple of years, for instance,
Dymola[4] from Dynasim and Simulation X[8] from
ITI GmbH. Dymola version 6.1 has a unit checking
mechanism, as well as support for deduction of units.
However, unit parametric polymorphism is yet not
supported.
Simulation X has a conversion extension to Modelica
for giving units to literals. For instance, the expression
The Modelica Association

a + 2.5 mm will translate the literal 2.5 into SI
base unit meter by multiplying it with 10e-3.
Both of these tools will (or soon will) support entering other units than default units for e.g., parameter
values, i.e., making it possible to enter 2.5 mm as a
parameter value. The displayUnit attribute of Modelica standard is available for this purpose.
Unit checking and checking of dimensional inconsistency has been extensively explored in the programming language research community and is far from
a new research area. Many library-based approaches
exist for imperative programming languages, such as a
package approach for Ada [6] and a template approach
in C++ [18]. An approach for dimensional inference is
presented in [19], where gaussian elimination is used
for solving the resulting equation system. The work
shows how dimensions with rational exponents can be
added to the simply typed lambda calculus.
In Kennedys thesis [9], an extension of a core calculus
of ML with support for type inference over dimension
types is given. Lately, dimension and unit checking
have also been addressed in a nominally typed objectoriented language [1].
Besides the work on gPROMS [14, 15], few attempts
have been made to incorporate dimensional and / or
unit checking in equation-based object-oriented languages, such as Modelica. In addition, even though
Modelica today supports syntax for stating units of
variables, no sound solution exists that guarantees the
absence of unit errors.

6 Conclusions
This paper has presented a design for dimensional
analysis and unit checking of Modelica models. Requirements from an end user and tool perspective have
lead to a design which has been implemented as a prototype on top of the OpenModelica and MathModelica compilers. MathModelica has also been used for
building the models presented in this paper, and a future release of MathModelica will contain unit checking based on the design in this paper. The design introduces unit type variables enabling polymorphism
of unit types in Modelica, which increase the safety
and flexibility of the dimensional analysis. We have
also chosen to represent exponents as rational numbers which enables dimensional checking of e.g., the
sqrt function. The design of the dimensional analysis
also allows the possibility of adding additional base
units, on top of the seven base units of the SI system.
This enables modeling of e.g., financial systems using

10

Modelica 2008, March 3rd  4th , 2008

Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica

base unit money, and other application areas.
The prototype implementation has been described and
illustrated with several examples from the standard library. The analysis results in either a consistent and
complete system, a consistent but incomplete system
(which means that not sufficient unit information is
available to fully determine units) or an inconsistent
system (indicating where the inconsistency is located).
By using the prototype we have detected some minor
problems with the standard library. For instance, the
Gain component in the Blocks Math library currently
has unspecified units on its gain parameter. In order to
fully check the dimensions of models using this component, the gain parameter should be dimensionless.
This paper has also discussed unit conversion, even
though this has not yet been implemented. Nonetheless, some ideas presented here could be a useful starting point for the Modelica Design Groups activities
regarding this topic.

[4] Dynasim.
Dymola - Dynamic Modeling
Laboratory (Dynasim AB). http://www.
dynasim.se/ [Last accessed: Jan 22, 2008].

Acknowledgments

[9] Andrew Kennedy. Programming Languages and
Dimensions. PhD thesis, St. Catharines College,
University of Cambridge, UK, UK, 1996.

[5] Narain Gehani. Adas derived types and units
of measure. Software Practice and Experience,
15(6):555569, 1985.
[6] Paul N. Hilfinger. An ADA Package for Dimensional Analysis. ACM Transactions on Programming Languages and Systems, 10(2):189
203, 1988.
[7] Bureau international des poids et mesures
(BIPM). Le Systme international dunits, The
International System of Units. Organisation intergouvernementale de la Convention du Mtre,
8th edition.
[8] ITI. SimulationX. http://www.iti.de/
[Last accessed: November 8, 2007].

This research was funded by CUGS (National Graduate School in Computer Science), MathCore Engi- [10] MathCore. MathModelica System Designer:
neering, by Vinnova under the NETPROG Safe and
Model based design of multi-engineering
Secure Modeling and Simulation on the GRID project,
systems.
http://www.mathcore.com/
the Swedish Research Council (VR), and Forska&Vx
products/mathmodelica/ [Last accessed:
program under the project Lttanvnt Generellt SimuJan 23, 2008].
leringsverktyg fr Industriell Produktutveckling.
[11] Robin Milner, Mads Tofte, Robert Harper, and
David MacQuee. The Definition of Standard ML
- Revised. The MIT Press, 1997.
References
Modelica - A Uni[1] Eric Allen, David Chase, Victor Luchangco, Jan- [12] Modelica Association.
fied Object-Oriented Language for Physical SysWillem Maessen, and Jr. Guy L. Steele. Objecttems Modeling - Language Specification Version
Oriented Units of Measurement. In OOPSLA
3.0, 2007. Available from: http://www.
04: Proceedings of the 19th annual ACM SIGmodelica.org.
PLAN conference on Object-oriented programming, systems, languages, and applications,
[13] Gordon S. Novak. Conversion of Units of Meapages 384403, Vancouver, BC, Canada, 2004.
surement. IEEE Transactions on Software EngiACM Press.
neering, 21(8):651661, 1995.
[2] David Broman, Peter Fritzson, and Sbastien [14] Daniel Persson. Dimensional Analysis and InFuric. Types in the Modelica Language. In
ference for gPROMS. Masters thesis, DeProceedings of the Fifth International Modelpartment of Computer Science and Engineering,
ica Conference, pages 303315, Vienna, Austria,
Mlardalen University, Sweden, 2003.
2006.
[15] Mikael Sandberg, Daniel Persson, and Bjrn
[3] Luca Cardelli and Peter Wegner. On UnderstandLisper. Automatic Dimensional Consistency
ing Types, Data Abstraction, and Polymorphism.
Checking for Simulation Specifications. In SIMS
ACM Comput. Surv., 17(4):471523, 1985.
2003, September 2003.
The Modelica Association

11

Modelica 2008, March 3rd  4th , 2008

D. Broman, P. Aronsson, P. Fritzson

[16] Simon Peyton Jones. Haskell 98 Language and
Libraries  The Revised Report. Cambridge University Press, 2003.
[17] The OpenModelica Project. http://www.
ida.liu.se/~pelab/modelica/
OpenModelica.html
[Last
accessed:
January 22, 2008].
[18] Zerksis D. Umrigar. Fully static dimensional
analysis with C++. ACM SIGPLAN Notices,
29(9):135139, 1994.
[19] Mitchell Wand and Patrick OKeefe. Automatic
Dimensional Inference. In J.-L. Lassez and
G. Plotkin, editors, Computational Logic - Essays in Honor of Alan Robinson. The MIT Press,
1991.

The Modelica Association

12

Modelica 2008, March 3rd  4th , 2008

Unit Checking and Quantity Conservation

Unit Checking and Quantity Conservation
Sven Erik Mattsson
Hilding Elmqvist
Dynasim AB
Ideon Science Park, SE 223 70 Lund, Sweden
SvenErik.Mattsson@3ds.com Hilding.Elmqvist@3ds.com

Abstract
What can be done to guaranty correctness of a
model? The paper discusses two approaches to
automatic checking. First, Dymolas support of units,
unit checking and unit deduction is described. It has
already proven useful and has helped improving the
quality of the Modelica Standard Library. The display unit concept allows users to enter parameters
and plot variables in different units. The inputs, outputs and parameters of general blocks defining
sources and mathematical operations have of course
no units specified. Dymola infers their units in order
to improve the variable browsers for entering parameter values and plotting variables during simulation. Second, the possibilities of checking quantity
conservation automatically are discussed. It is in
open area with a large potential to check that models
fulfill the very basic laws of physics including energy conservation, Newtons third law action equals
reaction, etc. To really support automatic checking
of quantity conservation it is necessary to include
more information in the models. Fortunately, it
seems as if most of this can be done in the basic
components such as inertia, body, volume, capacitor
etc which actually store some quantities and in dissipative elements as for example resistors or friction
elements.

1

Introduction

Modelica (Modelica, 2007) is a powerful modeling
language. It allows you to quickly build complex
models by putting together model components from
free public and commercial libraries. The openness
of Modelica makes it easy to modify an existing
component. All this opens for errors. How can we
guide users and provide automatic checking? How
can we guarantee quality of provided library components?
Modelica is a strongly typed language implying that
classical computer scientific methods can be used.

The Modelica Association

The Modelica 3.0 definition has taken this further
and introduced the concepts of plug-in compatibility
and balanced models. This paper will discuss two
other orthogonal approaches:
1. unit checking of expressions and equations
2. checking of quantity conservation.
In Sections 2-4, Dymolas support of units, unit
checking and unit deduction is discussed. In Section
5 the possibilities of checking quantity conservation
automatically are discussed.

2

Support of Units in Dymola

Physical modeling deals with physical quantities
such as length, mass, force, current. The value of a
quantity is generally expressed as the product of a
number and a unit. Modelica (2007) supports this
approach. A real variable have a quantity attribute
and a unit attribute, for example
type Mass = Real(quantity="Mass",
final unit="kg");

The package Modelica.SIunits provides a large set of
predefined quantities and it is recommended to use
them whenever possible.
2.1

SI units

The Modelica specification states A basic support
of units in Modelica should know the basic and derived units of the SI system. Dymola fulfils this requirement.
A good reference on SI units is what commonly is
called the SI brochure published by Bureau International des Poids et Mesures [BIPM, 2006]. The NIST
Reference on Constants, Units, and Uncertainty
[NIST, 2000] gives a good overview; see also [Taylor, 1995]. ISO does not specify a formal syntax for
unit expressions but there are strict recommendations. The Modelica language specification includes
a formal specification based on these recommendations.

13

Modelica 2008, March 3rd  4th , 2008

S. E. Mattsson, H. Elmqvist

Dymola supports all the 20 SI prefixes to form decimal multiples and submultiples of SI units.
Factor

Name

Symbol

Factor

Name

Symbol

101
102
103
106
109
1012
1015
1018
1021
1024

deca
hecto
kilo
mega
giga
tera
peta
exa
zetta
yotta

da
h
k
M
G
T
P
E
Z
Y

10-1
10-2
10-3
10-6
10-9
10-12
10-15
10-18
10-21
10-24

deci
centi
milli
micro
nano
pico
femto
atto
zepto
yocto

d
c
m

n
p
f
a
z
y

henry
degree Celcius
lumen
lux
becquerel
gray
sievert
katal

Symbol

metre
kilogram
second
ampere
kelvin
mole
candela

m
kg
s
A
K
mol
cd

as well as the 22 SI derived units that have been
given special names and symbols
Name

Symbol
(in Modelica)

Definition

radian
steradian
hertz
newton
pascal
joule
watt
coloumb
volt
farad
ohm
siemens
weber
tesla

rad
sr
Hz
N
Pa
J
W
C
V
F
Ohm
S
Wb
T

1
1
1/s
kg.m/s2
N/m2
N.m
J/s
A.s
W/A
C/V
V/A
A/V
V.s
Wb/m2

The Modelica Association

Wb/A
K
cd.sr
lm/m2
1/s
J/kg
J/kg
mol/s

There are also units that are not part of the
International System of Units, that is, they are
outside the SI, but they are accepted for use with the
SI. Dymola knows the following of them:

Dymola knows all the seven SI base units
Name

H
degC
lm
lx
Bq
Gy
Sv
kat

Name

Symbol

Expressed in SI units

minute
hour
day
degree
litre
decibel
electronvolt
bar
phon
sone

min
h
d
deg
l
dB
eV
bar
phon
sone

60 s
60 min
24 h
(/180) rad
dm3
1
0.160218 aJ
0.1 MPa
1
1

In power systems the unit for apparent power is
V.A. Dymola knows var = V.A which has been
adopted by the International Electrotechnical Commission, IEC, as the coherent SI unit volt ampere for
reactive power, see IEC [2007].
The rotational frequency n of a rotating body is defined to be the number of revolutions it makes in a
time interval divided by that time interval. The SI
unit of this quantity is thus the reciprocal second, s-1.
However, the designations "revolutions per second" (r/s) and "revolutions per minute" (r/min) are
widely used as units for rotational frequency in
specifications on rotating machinery. Although use
of rpm as an abbreviation is common, its use as a
symbol is discouraged. Dymola knows r = 2 rad. It
can be used for example as r/s or r/min.
Dymola also knows the temperature units degF (degree Fahrenheit) and degRk (degree Rankin).
2.2

Other units

Dymola recognizes the users' needs to enter parameters and plot variables in different units. Modelica

14

Modelica 2008, March 3rd  4th , 2008

Unit Checking and Quantity Conservation

defines displayUnit for that purpose. Dymola supports displayUnit when plotting variables and when
entering values in parameter dialogs.

The start values for the angle, phi, and the angular
velocity, w, can be entered in SI units. The Modelica
code for J1 is

A user can define units for display and its meaning is
in terms of the SI unit. For example, the display unit
min is defined in the following way in terms of the
SI unit s as

Modelica.Mechanics.Rotational.Inertia
J1(J=1,
phi(fixed=true, start=0),
w(start=10, fixed=true))

defineUnitConversion("s", "min", 1/60);

We can enter the start velocity in deg/s. Click on
the unit to pop a menu and select unit

There is a fourth optional argument to specify offset.
For example, conversion from Kelvin to degrees
Fahrenheit can be specified as
defineUnitConversion("K", "degF",
9.0/5.0, 32-(9.0/5.0)*273.15);

However, if the quantity represents a temperature
difference the offset shall not be included. Dymola
supports an annotation __Dymola_absoluteValue
to control this. In Modelica.SIunits the quantity
temperature difference is specified as
type TemperatureDifference = Real (
final quantity=
"ThermodynamicTemperature",
final unit="K")
annotation
(__Dymola_absoluteValue=false);

These definitions are conveniently stored in script
(mos) file that is executed at the start of Dymola. By
default Dymola has a file displayUnit.mos including
display units of general interest.

Which alternatives that are available depends on
which defineUnitConversion calls that actually have
been invoked. It can be customized by any user by
editing the file displayUnit.mos. If a user wants to
see any length only in mm or inch, the user can restrict the display unit to that.

The value is now displayed as 572.96 deg/s. It is
easy to enter a new value, say 60 deg/s.

As an example, consider the model CoupledClutches
in Modelica Standard Library 3.0.

clutch1

J=1

step2

J=1

J2

startTime...

J1

step1

t...
freqHz=5

startTime...

torque

sin2

freqHz=f...

sin1

The Modelica code for J1 becomes

J3
clutch2

J=1

J4
clutch3

J=1

fixed

Pop the parameter dialog for the rotating body, J1.

Modelica.Mechanics.Rotational.Inertia
J1(J=1,
phi(fixed=true, start=0),
w(start=1.047197551196598,
fixed=true, displayUnit="deg/s"))

Note, that the attribute displayUnit is modified according to our choice. However, the parameter value
being 60 deg/s is stored in SI units, rad/s. Thus
portability is preserved and it is still a tool issue to
support the displayUnit in the dialogs.
Let us simulate the original example and plot J1.w.
Put the cursor on the curve and pop the context
menu.

The Modelica Association

15

Modelica 2008, March 3rd  4th , 2008

S. E. Mattsson, H. Elmqvist

unit strings and unit compatibility of equations. It
can be seen as a part of the type checking. It includes
the checking of actual function input arguments and
output arguments against their formal declarations.
Currently Dymola makes a relaxed checking. It
means that an empty unit string, "", is interpreted as
unknown unit. Also number literals are interpreted to
have unknown unit. The unknown unit is propagated
according to simple rules
unknown unit * "unit1" -> unknown unit
unknown unit + "unit1" -> "unit1"
There is one important exception. Let e be a scalar
real expression. Consider the inverse of e given as
1/e. The number 1 (one) in the numerator does not
relax the checking. If e has a well-defined unit then
also 1/e has a well-defined unit.

Selecting deg/s as unit for plotting gives the plot.
J1.w

600

[deg/s]

500

The unit checking is applied to the original equations. This has implications for vector, matrix and
array equations. For an array where all elements
have the same unit, the check works as if it was a
scalar. Arrays and array expressions where the elements have different units are allowed. However, the
check is then relaxed and the array is viewed to have
an unknown unit that is compatible with all units.
Checking the unit consistency between two records
is done recursively for each component.

400

300

200

100
0.0

3

0.4

0.8

1.2

1.6

Unit Checking

Equations add terms. Naturally these must be of the
same physical quantity. This is exploited in the classical physical dimension check of equations which
many of you have done by paper and pen in school.
Dymola (Dynasim, 2007) has automated this check.
The number of physical quantities we can think of is
large. Fortunately, they are related and all physical
quantities can be expressed as product of powers of a
small set of base quantities. The International System
of Units, the SI system, defines such a set including
seven physical quantities: length, mass, time, electric
current, thermodynamic temperature, amount of substance and luminous intensity, see BIPM (2006). The
SI base units define a unit for each of these seven
quantities. The units for other quantities are derived.
For example, the unit for area is m2 because the
physical quantity area = length*length and the unit
for length is m (meter). Thus there is a mapping from
quantity to unit in terms of the seven SI base units.
Dymola exploits this for unit checking.
Dymolas checking of units is active when checking
a package, function or model as well as when translating a model for simulation. It includes checking of

The Modelica Association

Currently, the unit checking does not issue error
messages but it generates only warnings. The unit
checking can be disabled.
As a simple example consider the modeling of motion where there is a mistake
parameter Modelica.SIunits.Mass m=1;
Modelica.SIunits.Velocity v;
Modelica.SIunits.Force
f;
equation

m*v = f; //Should read m*der(v) = f;
When checking or translating it, Dymola outputs
Warning: Incompatible units in
m*v = f;
The part
m*v
has unit N.s
The part
f
has unit N

Dymolas unit checking has already been proven
useful. Several errors in the Modelica Standard Library were found. A user reported that he several
years ago had rewritten a model in Modelica, but he
did not get the same simulation result. He had really

16

Modelica 2008, March 3rd  4th , 2008

Unit Checking and Quantity Conservation

tried to find the reason, without success. Dymolas
unit checking pointed out an inconsistency and he
had found the error.
The basic laws for conservation of mass, momentum,
electrical charge, energy are expressed as balance
equations between physical quantities. Also constitutive equations such as Ohms law are readily expressed as equations for physical quantities. It means
that the unit checking should not make the modeling
more complicated in most cases.
However, the parameterized curve descriptions used
to model idealized characteristics of for example diodes or Coulomb friction needs more attentions.
Consider the modeling of an ideal diode having the
characteristics shown in the figure.

In summary, dont just declare real variables, but
declare physical quantities. Use the predefined quantities available in Modelica.SIunits whenever possible. The SI units were invented to allow equations to
be written in a clean way without conversion factors.
This simplicity is a very good reason for using the SI
units in physical modeling. Thus, it is recommended
that unscaled SI units are used when specifying the
unit attribute of a real variable. To be clear, this also
means that prefixes shall not be used. For example
"m", "kg", "V", "N.m" and "W" are good, but not
"cm", "g", "kV", "MW" or "bar". The displayUnit
concept provides convenient entering of parameter
values and displaying and plotting of results in other
units.

4

The parameterized curve description is
off = s < 0;
v = if off then s else 0;
i = if off then 0 else s;

The curve parameter is just a real variable that is either representing a voltage or a current. To make the
equations unit consistent, the equations can for example be rewritten as
v = unitVoltage*(if off then s else 0);
i = unitCurrent*(if off then 0 else s);

The s parameter and the unit constants are declared
protected as
protected
Real s(final unit="1");
constant Modelica.SIunits.Voltage
unitVoltage= 1
annotation(HideResult=true);
constant Modelica.SIunits.Current
unitCurrent= 1
annotation(HideResult=true);

The Modelica.Blocks library includes general blocks
to define sources and mathematical operations. Their
inputs and output have of course no units specified.
For user convenience, Dymola has introduced automatic deduction of units. Here is a short description
Consider the expression, e1 + e2, where Dymola has
found that the expression e1 has a well-defined unit
u1, but the unit of the expression e2 is unknown. We
can then deduce as described in the introduction that
the unit of the sum e1 + e2 is u1. Moreover, for unit
consistency reasons the unit of e2 must also be u1. If
now e2 is a simple variable reference, v, we can deduce that v must have the unit u1. For more complex
expressions Dymola makes a downwards recursion
to see if it is possible to deduce units of variables
with unknown units.
The SignalType definition in the Modelica Standard
Library 2.0 allowed the user to specify the units
manually by declaring the type of the inputs, the outputs and the parameters of the block. The SignalType is removed in the Modelica Standard Library 3.0 and the units are deduced automatically.
The deduction of units may reveal unit inconsistencies. In such a case it may be useful to enable the
logging and inspect the log. It is also useful to check
the log when developing a model component, because if a real variable gets its unit deduced that may
indicate that the variables shall be declared using any
of the quantities defined by Modelica.SIunits.

The HideResult annotation has the effect that the unit
constants are not included in the simulation result.
Basically these constant are only active during unit
checking and then eliminated in the equations.

The Modelica Association

Unit Deduction

As an example consider the model ElasticBearing in
Modelica.Mechanics.Rotational.Examples.

17

Modelica 2008, March 3rd  4th , 2008

S. E. Mattsson, H. Elmqvist

torque

shaft

spring

tau

c=1e3

J=50

d=5

springDamper=1e5

load

J=5

J=1

housing

duration=5

5

idealGear=3

ramp

fixed=0

The component ramp is of the class Modelica.Blocks.Sources.Ramp. The parameters
parameter Real height=1
"Height of ramps";
parameter Real offset=0
"Offset of output signal";

have no units specified. Similarly the unit of the output y is not specified. At translation Dymola deduces
their units and displays them in the variable browser

Quantity conservation

The design of Modelica.Mechanics.Rotational and
the discussion on the modeling of mounting have
clearly indicated the need for more automatic testing
of models. The failure to model the mounting of a
drive-train element is an example where the user
fails to account for important interactions between
components or between a component and its environment. The failure to model the mounting of a
component gives a simulation result where momentum is not preserved. Such a model violates Newtons third law action equals reaction.
Balance equations and conservation of physical
quantities such as mass, momentum, energy and
electrical charge are basic in physical modeling.
A flow variable of a connector represents the flow of
a conserved quantity into a component. Thus it is
straightforward to calculate the net amount of a conserved quantity flowing into a component. A prototype implementation has been made in Dymola. As
an example consider the model

freqH...

The deduced SI unit radian is treated in a special way
by Dymola. Consider Eulers equation for a one dimensional rotating body
J*a = flange_a.tau + flange_b.tau;

where the inertia, J, has unit kg.m2, the rotational
acceleration, a, has unit rad/s2 and the torques
flange_a.tau and flange_b.tau have the unit N.m. It
means that the left hand side of the equation has the
unit, rad.kg.m2/s2 and the right hand side has the
unit, N.m = kg.m2/s2. It means that the units are
equal besides the left side has a factor rad. This is
fine from the formal point of view because the derived unit radian is formally expressed as m/m, see
Table 3 in [BIPM, 2006], which also states that the
radian is a special name for the number one that
may be used to convey information about the quantity concerned.
However, in order to support the use of radians when
deducing units, Dymola treats the radians as if it was
a SI base unit during the analysis. The consistency
checking is of course relaxed for radians. The resulting unit will include the minimum power of radians.

The Modelica Association

torque

sin2

freqH...

sin1

J1
J=1

J2
clutch1

J=1

The flow variables of the connectors have their attributes quantity="Torque". Dymola introduces for
each component a variable named sum_Torque and
an equation such as
J2.sum_Torque = J2.flange_a.tau+J2.flange_b.tau;
For the clutch that has no inertia, the sum_Torque
variables are zero as it should be. It is not zero for
inertia models J1 and J2 because they can store momentum. Their models include the equation
J*a = flange_a.tau + flange_b.tau;
Thus, for inertia we have
sum_Torque = J*a
The variable torque.sum_Torque is non zero. For the
system, above momentum is not preserved. In reality
the drive train is mounted in the car. The chassis
provides a corresponding reaction torque, which
propagates through the wheels and tires to the road.
Thus if we put the drive train above into a chassis
model without connecting the bearing connectors of
the drive train properly to model the real mounting,
we will get wrong simulation results. How can we
provide some automatic checks?

18

Modelica 2008, March 3rd  4th , 2008

Unit Checking and Quantity Conservation

a ground component to the bearing connector of the
component torque. This component can be viewed as
a rig where we put the drive train for testing. The rig
may be viewed as representing the infinite mass of
the earth.

For components not storing conserved quantities, we
can use sum_Torque and the other sum variables and
add an assertion that the sum should be zero. For the
example, the simulation stops issuing
Assertion failed: abs(torque.sum_Torque)< 1E-005
Torque not conserved in the component torque.
In the general case, a component needs to include
information on what are the storage terms. Tiller and
Kittirungsi (2006) propose annotation to be used. For
example to indicate that the term J*a above implies
storage:
Modelica.SIunits.Torque
torqueStorage = J*a
annotation(storageTerm));

In 3 D mechanics forces are vectors and the balances
of forces must be set up in the same frame. Moreover, the torque balances are even more complicated
since they also include terms referring to the forces
acting on the body.

pin.v*pin.i
=>
V*A=W
der(flange.s)*flange.f
=> m/s*N=W
der(flange.phi)*flange.tau => rad/s*Nm=W
It works for Electrical, Rotational and Translational.
For MultiBody there is the problem with different
coordinate systems.
Establishing energy conservation also includes identification of energy dissipation. For example a resistor dissipates energy, or more explicitly, it converts electrical energy into heat. The basic components in Electrical do not include such information.

One idea is to add an annotation to
Modelica.Mechanics.MultiBody.Interfaces.Frame:
connector Frame
"Frame of a mechanical system"
annotation(ConservedQuantity(
Force= Frames.resolve1(R.T, f),
Torque=Frames.resolve1(R.T,t)+
cross(r,Frames.resolve1(R.T,f))));
import SI = Modelica.SIunits;
SI.Position r_0[3];
Frames.Orientation R;
flow SI.Force f[3];
flow SI.Torque t[3];
end Frame;

The scope for the right-hand-sides is the local connect (exactly as for e.g. a binding equation in the
class) and this takes precedence over the defaultsumming of quantity-flows to 0. This annotation
should only be added once [i.e. for the base-class of
all flange-connector and not for each model], and we
could alternatively have this built-in in Dymola for
this class.
Please, note that if a model component fails to annotate or mark a term as contribution to storage then
the check will detect this, i.e., the component model
is not conserving properly.
In order not to be forced to model all universe, it is
necessary to support infinite sources or sinks for
conserved quantities. Again it is possible to use an
annotation to mark such components. However, there
is a potential risk with ground elements. Assume that
we fix the coupled clutch model above by connecting

The Modelica Association

Energy conservation is important to check. However,
it is more complex. For thermodynamics the heat
flows as well as the enthalpy flows are a power flow.
However, the energy flow does not always appear
explicitly as flow variables in the connectors. Some
energy flows can be computed by multiplying the
flow quantities by a proper derivative of the corresponding across variable. Examples:

The automatic checking of conservation may have
several objectives. A primary objective is to catch
model errors. However, a conservation condition
may be violated over time due to numerical drift of
the numerical solution for the conserved quantity.
This calls for a more sophisticated checking considering the numerical drift. On the other hand it may
also be used to improve the numerical solution. A
numerical solver may exploit these invariants for
automatic selection of tolerances, i.e. the user put
tolerances on invariants. Projection methods may be
used to numerically control the drift.
Evidently there is a need to include more information
in the models in order to be able to perform automatic checking of quantity conservation. Fortunately, quantity storing is done in the basic components such as inertia, body, volume. For energy balances we need also to consider dissipation in for example resistor, damper, pipe friction etc.

6

Conclusions

Dymolas support of units, unit checking and unit
deduction has been described. It has already proven
useful. Several errors in the Modelica Standard Library were found. It has encouraged the developers
of the Modelica Standard Library to declare vari-

19

Modelica 2008, March 3rd  4th , 2008

S. E. Mattsson, H. Elmqvist

ables representing quantities appropriately. The displayUnit concept allows users to enter parameters
and plot variables in different units while allowing
clean equations without complicating conversion
factors because the equations can refer to the quantities in SI units. The Modelica.Blocks library includes
general blocks to define sources and mathematical
operations. Their inputs and outputs have of course
no units specified. This may also be the case for
some parameters such as gain. At translation of a
model for simulation Dymola infers their units in
order to improve the variable browsers for entering
parameter values and plotting variables during simulation.
Second, the possibilities of checking quantity conservation automatically are discussed. It is in open
area where there is a large potential to check that
models fulfill the very basic laws of physics including energy conservation, Newtons third law action
equals reaction. Evidently there is a need to include
more information in the models to really support
automatic checking of quantity conservation and
there is a need for extensions of Modelica. Fortunately, it seems as if most of this can be done in the
basic components such as inertia, body, volume, capacitor etc which actually stores some quantity. For
energy balances it is also necessary to identify and
mark dissipation in resistors, friction elements etc.

References
BIPM 2006. The International System of Units (SI), Bureau International des Poids et Mesures, 8th edition,
2006. Available at www.bipm.org/en/si/si_brochure
Dynasim. 2007. Dymola Version 6.1. Dynasim AB,
Lund. Sweden. http://www.dynasim.se/.
Modelica 2007. Modelica - A Unified Object-Oriented
Language for Physical Systems Modeling  Language
Specification, Version 3.0, Available in electronic form
at www.modelica.org/documents/ModelicaSpec30.pdf
M.Tiller and B. Kittirungsi: UnitTesting. 2006. A library for Modelica unit testing. Proceedings of the 5th
Modelica Conference, Vienna, Austria, 2006, Vol. 2,
pp. 695-704.

The Modelica Association

20

Modelica 2008, March 3rd  4th , 2008

Balanced Models in Modelica 3.0 for Increased Model Quality

Balanced Models in Modelica 3.0 for Increased Model Quality
Hans Olsson1
Martin Otter2
Sven Erik Mattsson1
Hilding Elmqvist1
1
Dynasim AB, Ideon Science Park, SE-223 70 Lund, Sweden
2
German Aerospace Center (DLR), Institute of Robotics and Mechatronics, Oberpfaffenhofen,
82234 Weling, Germany
{Hans.Olsson, SvenErik.Mattsson, Hilding.Elmqvist}@3ds.com, Martin.Otter@dlr.de

Abstract
A Modelica model can only be simulated, if the
number of unknowns and the number of equations
are equal. In Modelica 3.0, restrictions have been
introduced into the language, in order that every
model must be locally balanced, which means that
the number of unknowns and equations must match
on every hierarchical level. It is then sufficient to
check every model locally only once, e.g., all models
in a library. Using these models (instantiating and
connecting them, redeclaring replaceable models
etc.) will then lead to a model where the total number of unknowns and equations are equal. Besides
this strong guarantee, it is possible to precisely pinpoint which submodels have too many equations or
lack equations in case of error. This paper gives the
rationale behind the Modelica 3.0 design choices
including proofs of the new guarantees, and discusses the limitations of this approach.

imply that we want to verify correctness early, in
particular already for incomplete models where implementation of the parts is left open. An example
below (sunken icons means partial replaceable components) shows a driveline where the input torque
and compliance between the inertias are unspecified.
torque

source
tau

J=1

torque

inertia1

tau
freqHz=2

The Modelica Association

21

J=2

The goal is that by separately verifying that the template model is correct, and imposing restrictions on
the models we plug in, we can be certain that the
complete model is correct.
Without the restrictions, the tool would need to perform a global analysis, and if the complete model is
not balanced we would not know whether the implementation of the part or the template model itself
was in error. Having to verify this for all combinations of sources and gears (one is shown below) is
not practical:

Background

In a causal modeling paradigm, where only input/output blocks are used, it is straightforward to
verify that all input connectors have been connected,
and thus causal modeling naturally lead to a simple
plug and play metaphor for end-users. The goal is to
ensure that acausal Modelica model components are
as convenient to use for end-users.
The need for this is growing in importance with larger and more complex model libraries and with
companies expanding Modelica usage from research
to development. Furthermore, libraries with template
models, i.e., incomplete models with replaceable
components, like VehicleInterfaces, PowerTrain,
VehicleDynamics library, can easily lead to wrong
models in Modelica 2 when using the templates,
without being able to give reasonable diagnostics for
the source of the error. Shortened production cycles

inertia2
compliant

source

1

inertia1

J=1

compliant
c=1000

inertia2

J=2

The first possibility would be to improve the analysis
of structural singularities for Modelica 2 to find the
errors without requiring balancing, but instead use
other information including annotations and confidence in different equations [2]. Similar techniques
are also useful at the lowest level to go from one
equation too many in the current model to pinpointing which equation is superfluous.
Previously there have been checks in Dymola [3]
(since Dymola 5.3 released in 2003) to determine in
case of an unbalanced simulation model which submodels are incorrect based on the actual use. That
was introduced to help users in finding errors, but it
did not always work satisfactorily since it was not
always possible to determine how many equations
should be present in each model (the best what could
be done in general was to determine a range for the
Modelica 2008, March 3rd  4th , 2008

H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist

number of equations); thus for the complete model it
was not possible to determine whether the error was
in the template or in one of the implementations 
and if so which one. Thus without stricter language
rules no reliable diagnostics could be given to users
to pin-point the errors.
A related work [4] allows unbalanced classes, maintains the (un)balancing of connectors and models
when modified. The difference is that in Modelica
3.0, it is enforced that models are balanced from the
start and on all levels.

This leads to the external equations
m1.c.f = 0; // nf equations

Since m1 requires ne external equations and instantiating the component gives nf equations, we have the
requirement: ne = nf.
The next case is to have two of such components not
being connected:
m2

m3

c

c

In this case we get the external equations

2

Number of equations in the model

m2.c.f = 0; // nf equations
m3.c.f = 0; // nf equations

Since m2 requires ne equations and m3 requires ne
equations, we have the requirement: 2ne = 2nf
The next case is to have two of such components, but
being connected:

In order to verify whether a component model is balanced we must have a clear definition of how many
equations the model contains  and how many equations it should contain (both based on its interface).
2.1

Restrictions on physical connectors

The goal is that combining models having (physical)
connectors and connecting them (in legal ways) we
should get new balanced models; without imposing
additional restrictions on the models or requiring
adding equations.
Consider the simplest case of a model where the only
public part is one connector, and it is physical, i.e.
containing nf flow variables Real f[nf] and np
non-causal, non-flow, potential variables Real
p[np] (i.e., no connector variable has the input or
output prefix); and the model is balanced, i.e., the
model requires that externally a specific number of
equations (ne) is provided, in order that all unknowns
of the model can be uniquely computed together with
the internal equations in the model. We will call
these required equations in the sequel external equations of a model component. The number of external
equations has to be uniquely defined by the interface
of the model. The balancing is that the number of
unknown variables equals the number of equations
defined inside the model plus the number of external
equations.
The simplest use of a model m1 with connector c is
that the connector is unconnected.
m1
c
The Modelica semantics does state that the flowvariables are summed to zero, whereas the potential variables should be equal [1].

The Modelica Association

m4

m5

c

c

Here we get connection equations:
m4.c.f + m5.c.f = 0; // nf equations
m4.c.p = m5.c.p;
// np equations

Since m4 requires ne equations and m5 requires ne
equations, we have the requirement: 2ne = nf + np
The final case is to have N components that are connected together:
M1

M2

c

c

...

MN
c

Here we get one time the zero-sum equations for the
flow variables and N-1 identity equations for the
potential variables. Since every model requires ne
equations, we have the requirement:
Nne = nf + (N-1)np
To summarize, we get the following relations that all
have to be fulfilled, in order that instantiating and
optionally connecting components does not require
to add any more equations (= necessary and sufficient conditions):
1st model (m1):
n e = nf
nd
2 model (m2,m3):
2ne = 2nf
rd
3 model (m4, m5)
2ne = nf + np
th
4 model (M1, ...Mn) Nne = nf + (N-1) np
or equivalently

22

Modelica 2008, March 3rd  4th , 2008

Balanced Models in Modelica 3.0 for Increased Model Quality

n f = ne
np = n f
This leads to the conclusion that the number of flow
and non-causal, non-flow variables must match
(counting arrays as the number of elements of simple
types), and this must correspond to the number of
external equations for this connector.
Models may also have variables that are declared
with the input prefix, both in a declaration of a
model and in a (top-level) connector. These variables
are treated as unknowns in a model. It is natural to
require that for all these input variables external
equations must be provided.
In order to force the user that all missing equations
for a model are provided when instantiating the
model, it is required that all input variables declared
in a model are provided as modifiers and that all inputs in a (top level) connector are provided by connecting the connector. Since a connector must have
the same number of flow and potential variables (see
derivation above), the means that a connector with
an input variable A must be connected to another
connector where variable A has the output prefix (an
exception of this last rule will be discussed in the
next section).
According to these rules, it is no longer allowed to
provide modifiers for other variables (with exception
of variables declared with the input, parameter or
constant prefix) or add other equations for the component externally, because all of these actions would
introduce superfluous equations.
To summarize, we have basically the following requirements (for simplicity, not yet considering special cases such as over-determined connectors, noncausal variables with a declaration equation, partial
models, or connectors with input variables that are
not connected):
1. The number of flow variables in a connector
must be identical to the number of non-causal,
non-flow variables (variables that do not have a
flow, input, output, parameter, constant prefix).

2. The number of equations in a model = number of
unknowns  number of inputs  number of flow
variables (of top-level public connector components). For the equation count, components are
not taken into account, because this is taken into
account by the next rule 3.
3. When using a model, i.e., making an instance, all
missing equations of this component must be
provided to make the component balanced by:

The Modelica Association

a) Connecting connectors or by leaving physical connectors unconnected (since the missing equations are then automatically introduced by setting all flow variables to zero).
b) Providing a modifier for every nonconnector component variable with an input prefix. Besides parameters and constants, modifiers on other variables are no
longer allowed.
The above rules shall be clarified with a few simple
examples (assuming a global definition
import SI=Modelica.SIunits;):
connector FluidPortA
SI.Pressure
flow
SI.MassFlowRate
input SI.SpecificEnthalpy
output SI.SpecificEnthalpy
end FluidPortA;
connector FluidPortB
SI.Pressure
flow
MassFlowRate
output SI.SpecificEnthalpy
input SI.SpecificEnthalpy
end FluidPortB;

p;
m_flow;
h_inflow;
h_outflow

p;
m_flow;
h_inflow;
h_outflow

The two connectors FluidPortA and FluidPortB are
valid, since they each have 1 flow and 1 non-causal,
non-flow variable and 2 causal variables. Note,
whenever input/output prefixes are present, there are
connection restrictions because the block diagram
semantics holds (e.g. an output cannot be connected
to an output). As a result FluidPortA can only be
connected to one FluidPortB, but not to another FluidPortA.
connector WrongFlange
SI.Angle
SI.AngularVelocity
flow SI.Torque
end WrongFlange;

// wrong connector
angle;
speed;
torque;

This connector is not valid, since the number of flow
and non-flow variables is not the same. This is a
typical situation of old connectors, such as the
connectors of the (obsolete) ModelicaAdditions.MultiBody library. Both these old connectors, as well as the WrongFlange connector above
can be made valid, by using the prefix input or output for one of the non-flow variables (similarly to
FluidPortA and FluidPortB above).
model Pin
SI.Voltage
v;
flow SI.Current i;
end Pin;
model Capacitor
parameter SI.Capacitance C;
SI.Voltage u;
Pin p, n;
equation
0 = p.i + n.i;
u = p.v  n.v;

23

Modelica 2008, March 3rd  4th , 2008

H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist

C*der(u) = p.i;
end Capacitor;

The Capacitor model has 5 unknowns 1 (u, p.v,
p.i, n.v, n.i) and 2 flow variables (p.i, n.i).
It is therefore required that this model has 5  2 = 3
equations, and the model fulfills this requirement.
model Test1
Capacitor C1(C=1e-6);
// o.k
Capacitor C2(u=sin(time)); // wrong
end Test1;

The declaration of C1 is correct, because a modifier
for a parameter is given. The declaration of C2 is
wrong, because it is no longer allowed in Modelica 3
to provide a modifier for a variable that does not
have a constant, parameter or input prefix.
model VoltageSource
input SI.Voltage u;
Pin p, n;
equation
u = p.v  n.v;
0 = p.i + n.i;
end VoltageSource;

The VoltageSource model has 5 unknowns (u,
p.v, p.i, n.v, n.i), 2 flow variables (p.i,
n.i) and 1 input variable (u). It is therefore required
that this model has 5  2  1 = 2 equations and the
model fulfills this requirement.
model Test2
...
VoltageSource V1(u=sin(time)); // o.k
VoltageSource V2;
// wrong
...
end Test2;

Component V1 is correct, because the missing external equation for the unknown input u is given as
modifier.
Component V2 is not correct, because no modifier or
equation is provided for the missing unknown input
u.
The counting for non-connector inputs (such as u) is
defined as if they always had a declaration equation.
Thus the result would be the same for this modified
model:
model VoltageSource
input SI.Voltage u=0; // Default
Pin p, n;
equation
u = p.v  n.v;
0 = p.i + n.i;
end VoltageSource;

2.2

Correlations and non-connector inputs

Causal variables are not limited to connectors, but
there are also non-connector inputs and outputs 
which can be viewed as time-dependent parameters. The non-connector outputs have no special
significance here (they are useful to indicate special
interesting variables). The non-connector inputs are
for the balancing always counted as having a binding
equation  and must have a binding equation in the
complete model. This simplifies the requirement for
counting equations such that modifiers are not
counted as providing external equations for the
model; since they are seen as replacing old declaration equations with new ones of similar size. The
important aspect is that other alternatives, such as
giving normal equations for them  or modifying
some non-input would not preserve the balancing of
equations.
One example demonstrating this issue is correlations;
i.e., relations constraining a set of variables to be on
a hyper-plane of a certain dimension. The simplest is
a correlation involving two variables; in this case the
variables will simple be on a curve. We can arbitrarily declare one as input, but the correlation normally
is written as just an equation relating the variables
(and the line could have straight segments in both x
and y direction). Note: This example is illegal in
Modelica 3.0.
partial model Correlation
input Real x;
Real y;
end Correlation;
model UseCorrelation
// Wrong in Modelica 3
replaceable Correlation corr;
equation
corr.y=2+time;
/* Same number of equations as
modifying x; could also be
written as modifier for y */
end UseCorrelation;
model LineCorrelation
extends Correlation(x=3);
equation
x+y=0;
end LineCorrelation;

1

model Complete=UseCorrelation
(redeclare LineCorrelation corr);
// model is not balanced since
// 2 unknowns (x,y), but 3 equations:
//
x + y = 0;
//
x = 3;
//
y = 2 + time;

Alternatively, one could define u as known (because it
is a potential state) and der(u) as unknown. However,
this does not hold in general, since der(..) might have an
expression as argument. For this reason, der(..) is used as
operator that does not have an influence on the equation
counting.

The Modelica Association

This implies that we can add default values without
modifying the use of the model.

24

Modelica 2008, March 3rd  4th , 2008

Balanced Models in Modelica 3.0 for Increased Model Quality

In practice we would have a set of correlations and a
set of uses of them, and what we want to verify is
that they are all correct without performing all the
tests (which would lead to a combinatorial explosion
in the number of tests). For Modelica 3.0 we wanted
to support the model Correlation and the use in
LineCorrelation and Complete  without the possibility of too many equations in the Complete
model. Since we would expect these models to be
developed by separate teams (and normally be part
of larger systems) it represents exactly the situation
to avoid  an unbalancing due to the interaction of
several correct models  and without a clear description of where the error is. The solution is in this case
to disallow the construct in UseCorrelation for
non-connector inputs, and find another way of providing the correlations: Component corr in UseCorrelation has one input variable and it is required to provide a modifier for this variable in order
to make model corr balanced. This is not the case
above and therefore the model is not correct.
This restriction on modifiers to parameters, and nonconnector inputs is part of Modelica 3.0.
The ideal solution for modeling the correlation
would be that UseCorrelation, LineCorrelation
(except for x=3), and Complete would all be legal,
and rewrite Correlation to allow this. The first
attempt was to have some way to disable the balancing test for Correlation and derived classes; that
implied that only the class Complete could be
checked; and in case it failed it would be impossible
to determine whether UseCorrelation or LineCorrelation should be modified. During the design
of Modelica 3.0 several attempts were made of introducing a special syntax for stating that Correlation is lacking a certain number of equations 
without defining x as an input (because either x or
y shall be defined when using the component). This
requires the introduction of additional non-intuitive
syntax and the final decision was to change instead
x to a connector input and modify the language
rules to allow unconnected connector inputs and
provide the binding equation for the input connector
as equation. The example then becomes (the differences in Correlation are highlighted):
partial model Correlation
InputReal x;
Real y;
connector InputReal=input Real;
end Correlation;
model UseCorrelation
replaceable Correlation corr;
equation
corr.y=2+time;
end UseCorrelation;

The Modelica Association

25

model LineCorrelation
extends Correlation;
equation
x+y=0;
end LineCorrelation;
model Complete=UseCorrelation
(redeclare LineCorrelation corr);

In this case LineCorrelation may not use modifiers for x, since x is a connector, and we are thus
once more certain that the number of equations will
automatically balance. This is used for Modelica.Media, and can be used in other cases for correlations as well.
Note that UseCorrelation is exactly identical to the
original version, but is now legal due to the change
in the Correlation model (i.e. corr.y = 2 + time,
is the missing equation for the input connector x).
This approach was decided upon even though it has
the disadvantage that we allow unconnected input
connectors, and to count equations we thus have to
combine the normal equations and the equations for
missing input connections in the count of equation.
In this case corr.x is not connected in the UseCorrelation model; and instead a non-connect
equation is giving.
This can be compared to a causal paradigm, where
we would just require that corr.x must be connected. However, even if the use above is legal a tool
could still inform the user that corr.x lacks a connection if UseCorrelation or LineCorrelation
are not balanced or if the simulation model is structurally singular, in order to help in pinpointing the
error.

3

Locally balanced models

In the previous chapter, the counting rules have been
sketched for the most important cases. We will now
formulate the exact rules and what guarantee can be
given:
A model or block is called locally balanced if the
local number of unknowns matches the local equation size (both terms are defined below). Note, that
all counts are performed after expanding all records
and arrays to a set of scalars of primitive types. We
will here ignore inner and outer components, as well
as over-determined connectors, to simplify the definitions and results  for complete definitions see the
Modelica 3.0 specification [1].
The local number of unknowns is the sum of:

Modelica 2008, March 3rd  4th , 2008

H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist

(1) the model or block is partial,
(2) the connection set includes variables from an
outside public expandable connector,
(3) the set contains protected outside connectors,
(4) it contains one inside output connector, or
(5) one public outside input connector, or
(6) the set is comprised solely of an inside input
connector that is not part of an expandable
connector.
i.e., a connection set must  unless the model or
block is partial  contain one source of a signal
(the last items covers the case where the input
connector of the block is unconnected and the
source is given as equation in the equation or algorithm section).
A protected outside connector must be part of a
connection set containing at least one inside
connector or one declared public outside connector (i.e., it may not be an implicitly defined part
of an expandable connector).



For each declared component of specialized
class type (Real, Integer, String, Boolean, enumeration and arrays of those, etc) or record it is
the number of unknown variables inside it
(i.e., excluding parameters and constants).
 For each declared connector component, it is the
number of unknown variables inside it (i.e.,
excluding parameters and constants).
 For each declared block or model component, it
is the sum of the number of inputs and flow
variables in the (top level) public connector
components of these components.
The local equation size is the sum of:
 The number of equations defined locally (i.e. not
in any model or block component), including
modifier equations, and equations generated
from connect-equations.
 The number of input and flow-variables present
in each (top-level) public connector component,
i.e. the externally needed equations.
 The number of (top level) public input variables
that neither are connectors nor have binding
equations, i.e., further externally needed equations.
The following restrictions are imposed in Modelica
3.0











All non-partial model and block classes must
be locally balanced.
In a non-partial model or block, all nonconnector inputs of model or block components
must have binding equations (i.e. they are defined in a modifier).
Modifiers for components shall only contain redeclarations of replaceable elements and binding
equations for parameters, constants (that do not
yet have binding equations), inputs and variables
having a default binding equation.
In a connect-equation the primitive components
of the two connectors must have the same primitive types, and flow-variables may only connect
to other flow-variables, causal variables (input/output) only to causal variables (input/output).
A connection set of causal variables (input/output) may at most contain one inside output connector or one public outside input connector. [i.e., a connection set may at most contain one source of a signal, which is the usual
semantics for block diagrams.]
At least one of the following must hold for a
connection set containing causal variables:

The Modelica Association

26



4

Plug and play

We will show that if a user uses locally balanced
classes and follow the language restrictions and
drags and drop components and connect them, they
will automatically build locally balanced classes as
shown below. We will go through this starting from
an even more restricted case; in the conclusion we
will explain why these rules are not present in the
language.
4.1

Only components and connections

Assume we build a non-partial model (or block)
composed solely of components of model and block
classes (with optional legal value modifiers applied)
and connections that satisfy all restrictions, as it is
the case in the following figure:
torque

source

inertia1

inertia2
compliant

tau
J=1

J=2
speedSensor

w

Furthermore for connection sets involving causal
variables the connection set should satisfy case 4 in
the itemized lists above (=contain an inside output
connector generating the signal)  i.e. explicitly excluding case 6 (since cases 1, 2, 3, and 5 cannot ap-

Modelica 2008, March 3rd  4th , 2008

Balanced Models in Modelica 3.0 for Increased Model Quality

ply here). The model or block is then automatically
locally balanced.
Note: The excluded case (6) would correspond to
removing the source-component above, and instead
write a textual equation for torque.tau. This also applies to case (3), which is less needed.
In this case the local number of unknowns corresponds to the number of inputs and flow variables in
the public connectors of the components; and the
equations to the equations generated by connection
equations.
We can split the connectors into causal and noncausal parts (due to the restriction that connection
sets may not mix the two; this restriction was added
in Modelica 3.0 to allow this analysis).
For the causal part we have the local number of unknowns corresponding to the number of inputs in the
public connectors of the components. Among these
variables we have ni inputs and no outputs, and the
number of equations is thus ni + no - 1; the case 4
above gives no = 1 yielding the local number of equations ni + no  1 = ni + 1  1 = ni exactly matching
the local number of unknowns.
For the non-causal part we have the local number of
unknowns corresponding to the number of flow variables in the public connectors. Assume there are n
connectors in this set, and each connector has nf
flow-variables and np = nf non-causal, non-flow variables (potential variables). We have nnf local
number of unknowns; one zero-sum equation for
flow variables and n  1 equality equations for the
potential variables; in total this gives the size

n f + (n  1)  n p = n f + (n  1)  n f = n  n f
which exactly matches the local number of unknowns.
This case is important for users combining models
from different libraries  and ensures that as long as
the user only combines correct models without introducing simple variables or equations, the model is
automatically balanced.
4.2

Connectors

Assume we extend the above list to include components of connectors classes (without any value modifiers), that cases 3 and 6 in the itemized list above
does not apply, and that each connector component
is connected (case 1 does still not apply since we
build a non-partial model or block). The cases are
indicated below.

The Modelica Association

27

2 controlBus
tau
torque

inertia1

inertia2

flange_b

tau
J=1

clutch

5

J=2
speedSensor

w

4

We will apply the split into causal and non-causal
part. For the non-causal part it seems that the previous proof goes through automatically  this is true
with one minor caveat: if a (public) outside connector had not been connected (the case we excluded) it
would not have been part of a connection set and
would have given 0 equations instead of the correct
number nf.
For the causal part it is more complex since we have
both protected and public causal variables. If we disregard case expandable connectors and use superscript i/o for inside/outside, and subscript n for nodes
(regardless of input/output).
The unknowns are given by the local connectors:
nio outside inputs, n oo outside outputs, n n nodes (protected connectors), and the subcomponents: nii inside
inputs. The number of equations (n-1) is extended
with nio outside inputs. Thus for balancing we get the
requirement:

nio + noo + n n + nii = ( n n + nio + noo + nii + noi  1) + nio
Simple cancellations gives: nio + noi = 1 , or stated
differently: either case (5) an outside input connector, or case (4) an inside output connector. The either
is due to the restriction about multiple sources in a
connection set. For expandable connectors (case 2)
the same rules apply after we have deduced the causality; this will also influence the number of unknowns.
4.3

Redeclare of components

When redeclaring a component, the missing equations for the component must be either provided via
modifier equations (parameters, inputs) or connectors must be connected. When these restrictions are
fulfilled, the redeclared component is automatically
locally balanced.
One situation has to be treated specially: If the redeclared component introduces additional connectors
that are not defined in the constraining clause.
Unless the connectors are part of a redeclared inherited top-level component, it is not possible that a user
Modelica 2008, March 3rd  4th , 2008

H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist

can connect to these newly introduced connectors.
This is uncritical, if the not connected connectors do
not have input variables, since the default connection
semantic will set the flow variables to zero. Consequently, the restriction is introduced in Modelica 3.0
that additional connectors that are not defined in the
constraining clause are default connectable, i.e. shall
not have input variables.
A record or connector component that is directly replaceable or more commonly declared using a connector from a replaceable package also has a parameter dependent size. In such a case a redeclaration
may add additional unknowns  which should also
be balanced with matching equations. This is a parameter-dependent size and can be handled using
the techniques in the next section  except that only
unknowns are added in this way  but no equations,
and at first it seems that this will inevitably lead to
unbalanced models. However, it is possible to handle
this correctly: by not using replaceable connectors
directly, but instead use a replaceable package containing connectors and corresponding models (or
functions)  similarly as in the Modelica.Media
package.
This is a special case and we will not discuss the details. However, it has a direct relevance to a more
fundamental change introduce in Modelica 3.0. Previously a connector component of a replaceable
model component was implicitly replaceable, i.e. the
problem that a redeclare could introduce missing
equations was present for any replaceable model
component having connectors  even if the connectors were not replaceable.

5

Parameter dependent sizes

An important aspect of the counting of equations is
that it holds not only for the current set of parameters, but for any legal set of parameters values. The
restriction in Modelica 3.0 is formulated such that
even though the model should be balanced in all
cases, the tool does not have to verify this. The reason was that at the time it was not possible to verify
that a given set of restrictions ensures that submodels will always be within the restrictions, and
that user libraries could be rewritten to conform to
this.
Dymola can perform this test in several cases as will
be outlined here; and in the remaining cases it is
verified for the actual parameter values and a warning given.

The Modelica Association

28

The number of scalar variables is obtained by recursively symbolically adding the number of components of each variable:
 A scalar variable has the size 1.
 An array v[n] has the size: n<the size of its
elements>. Modelica implicitly assumes that
n  0. A multidimensional array is in Modelica considered as a nested array. For example, a matrix M[m, n] has the size mn<the
size of its elements>. If the size is declared
using the colon operator, v[:] = , the size
is represented as size(v, 1)<the size of its
elements>. The idea is to represent the size
expressions of arrays symbolically as defined by the model developers.
 The size of a record is the sum of the size of
its components.
The current restrictions when counting variables are
evaluation of sizes of arrays of components and the
conditions of conditional components.
The number of components of an equation is counted
by traversing all its subexpressions and deducing the
dimensionality and the size of each dimension and
propagating this information upwards without any
evaluation. At the top level the number of components is formed in a way analogous to that of variables. Also size constraints are collected for immediate or deferred checking. An interesting fact is that
the size of a for-loop equation can be formed as the
sum of the elements of an array constructor. One
restriction is that the instantiation procedure may
have evaluated some conditions.
The comparison of the number of variables and
equations is done in 3 steps:
 First all variables which bindings cannot be
modified (protect, final, constant) are substituted symbolically. If Dymola can symbolically deduce that the problem is balanced the
check was successful in this respect. It
means that the model is balanced irrespective of how a user rebinds or sets parameters
that may be rebound or set.
 Otherwise, Dymola substitutes all non-literal
bindings. If Dymola now can show that the
problem is balanced, the comparison is finished. It means that the user can change parameter values that are literals, but not otherwise rebind parameter values without risking making the problem non-balanced. A
remedy is to define critical parameter bindings to be final.

Modelica 2008, March 3rd  4th , 2008

Balanced Models in Modelica 3.0 for Increased Model Quality



The third step is to force evaluation of all
size parameters and then compare. This is
what Dymola has done previously when
checking or translating a model.
As an example consider model Modelica.Blocks.Continuous.StateSpace. The essence is:
block StateSpace
parameter Real A[:, size(A,1)];
parameter Real B[size(A,1), :];
parameter Real C[:, size(A,1)];
parameter Real D[size(C,1), size(B,2)]
=zeros(size(C, 1), size(B, 2));
extends Interfaces.MIMO(
final nin= size(B, 2),
final nout=size(C, 1));
output Real x[size(A, 1)];
equation
der(x) = A*x + B*u;
y = C*x + D*u;
end StateSpace;

6

Limitations of the approach

The previous section shows that the rules in Modelica 3.0 make it possible to provide early checks of
models that will avoid several hard to find errors
when completing large models. The early checks are
possible, since we only need the interface of subcomponents. However, some errors are still possible
when assembling sub-models and the natural question is why these errors cannot be handled in a better
way.

Checking the model in Dymola 7.0 results in
Model having the same number of
unknowns and equations:
size(A, 1) + size(B, 2) + size(C, 1)

6.1

The counting of the unknown variables which are x,
u and y, gives
size(A, 1) + nin + nout

The bindings for the parameters nin and nout are
final and can be used for substitution, which gives
the logged result. The counting of equations gives
first nin for the inputs. The size check of
der(x) = A*x + B*u;

has to check possible size constraints for each
subexpression. First, the matrix-vector multiplication, A*x requires size(A,2)=size(x,1). Exploring the declarations of A and x shows that either side
is equal to size(A,1). The product A*x is a vector
with size(A*x,1)=size(A,1). The product B*u
requires size(B,2)=size(u,1). Exploring the
declaration of u gives size(u,1)=nin and the final
binding to nin gives nin=size(B,2). Thus the constraint is fulfilled. The product B*u is a vector with
size(B*u,1)=size(B,1). Next, the sizes of the
two terms A*x and B*u must be equal. They are both
vectors and the size constraint is size(A*x,1)=
size(B*u,1). Since size(A*x,1)=size(A,1) and
size(B*u,1)=size(B,1)and since the declaration
states size(B,1)=size(A,1), the constraint is fulfilled. The resulting sum is a vector of size(A,1).
Since the declaration of x specifies size(x,1)=
size(A,1) all the size constraints of the equation
are fulfilled symbolically for all allowed A and B matrices and it has size(A,1) components. Similarly
the equation y = C*x + D*u is type consistent and
has size(C,1) equations.

The Modelica Association

Dymolas facility for checking that two symbolic
expressions are equal is rather elaborate. However, it
cannot handle all cases such as complicated forloop equations where there are, for example, conditions on the loop iterator. Dymola then resorts to
numerical evaluation.

29

Why are not all restrictions in the
language?

As noted above we can prove that models are automatically balanced if built subject to certain restrictions, but not all of these restrictions are part of the
language. This might seem odd considering that we
want to ensure correctness early on, but it is necessary to allow textual (non-connect) equations to be
given for low-level models. However, the check can
still be performed at the same level  and uses the
same description of balanced models; the only difference is that if the guidelines are followed the
check becomes even simpler. When the guide-lines
are not followed, a user would have to provide nonconnector equations as a replacement for connections; thus for a model with only connector equations
the simpler restrictions hold. This makes it straightforward to provide good diagnostics, while preserving the low-level openness of Modelica. Furthermore, a general recommendation is to avoid mixing
connections and textual equations (see e.g. [5]);
which makes it easier to separate the two cases.
The examples where this is necessary include writing
basic models such as a resistor where equations are
given for the connectors - instead of adding additional connections, and correlations for mediamodels are built such that there are multiple potential
inputs (see section 2.2 Correlations and nonconnector inputs). Allowing equations for input connectors is also convenient in some other cases (e.g.
when using table-lookup blocks); and by having the
semantics above we avoid introducing a special se-

Modelica 2008, March 3rd  4th , 2008

H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist

mantic construct for defining the number of external
equations needed for the media-models.
6.2

6.3

Requirements beyond balanced?

Having a balanced model is only a necessary requirement to be able to simulate it, but it is not sufficient. Whether a non-linear system of differentialalgebraic equations has a solution is NP-hard in general; imposing restrictions to ensure a solution would
impose such strict rules on the modeling (such as
convex equations) that it would be not practical in
general.
For the complete model a strong requirement is that
the system of equations is structurally regular (i.e. no
singularity when looking at the structure and ignoring the actual values). Dymola can also perform this
check already for incomplete models and then use a
generic coupling for local (replaceable) components,
and for top-level connectors. This can provide useful
diagnostics for many cases.
However, structural regularity is not entire welldefined, e.g. Dymola actually uses +/-1 from connections as well as zeros (finding more errors), and in
contrast to balanced models structurally singular
does not provide strong guarantees. Even plugging in
parameters might turn a structurally regular system
into a structurally singular one, since structurally
singular only ensures that the equations are nonsingular for most values of the non-zero elements.
Obviously this also applies to redeclarations, especially since one often uses simplified models as testcases. A simple example would be an electrical circuit testing different components with an ideal
source:

+

source

Conclusions

The new restrictions in Modelica 3.0 make it possible to provide diagnostics earlier in the development
process, while still maintaining the low-level openness of Modelica. These early diagnostics both
shortens development time, and makes it possible to
provide an interface for end-users where certain errors cannot occur  thus reducing the deployment
and training cost for these users.
In Dymola 7.0, the restrictions introduced in Modelica 3.0 are supported, but are only imposed when
using the Modelica Standard Library 3 (or later).
This allows users to continue to run correct Modelica
2 models.

ground

This model (with an ideal voltage source) will become structurally singular if we plug in a shortcircuit component as a load.

The Modelica Association

Currently there are no balancing restrictions on partial models in Modelica, and the contents of baseclasses are expanded prior to verifying the balancing.
This is the formal semantics; a tool may internally
handle this in a better way, taking special care of the
non-trivial handling of connection sets, and of multiple inheritance of the same component.
The reason for the lack of restrictions is that the
number of equations needed in derived models depend on whether the partial model is just an interface
(e.g. TwoFlanges in the Rotational library  this just
has two flange connectors), or contains an incomplete set of equations (e.g. Rigid in the Rotational
library  which also specifies that the angles are
identical). If we compare with e.g. Java this implies
that a partial class may be either an interface or an
abstract class.
A possible extension would be to have separate keyword for pure interfaces, and restricted such that
only public connectors, parameters, and causal variables are present. The number of equations needed in
derived classes would be uniquely defined from the
interface. In that case it would not be necessary to
verify that the interface is balanced, since it would
follow automatically from the requirement on interfaces, and on connector classes.
A practical smaller extension would be to require
that partial models may only be locally underbalanced, i.e. lacking equations, but not have too many
equations.
These possible extensions have not yet been investigated in details.

7

load

Restrictions on partial models?

30

Modelica 2008, March 3rd  4th , 2008

Balanced Models in Modelica 3.0 for Increased Model Quality

A connector that contains instances of overdetermined type and/or record classes is called overdetermined connector.
Every instance Ri of an over-determined type or record in an over-determined connector is a node in a
virtual connection graph that is used to determine
when the standard equation "R1 = R2" or when the
equation "0 = equalityConstraint(R1,R2)" has to be
used for the generation of connect(...) equations. The
branches of the virtual connection graph are implicitly defined by "connect(..)" and explicitly by Connections.branch(...) statements. Additionally, corresponding nodes of the virtual connection graph have
to be defined as roots or as potential roots with builtin functions Connections.root(...) and Connections.potentialRoot(...), respectively. Connections are
treated as breakable branches. By removing appropriate breakable branches, the virtual connection
graph is transformed into a set of spanning trees,
each comprised of one root.
An example is given in the figure below, where all
dotted lines characterize connect(...) equations.
After building up the spanning trees, the connections
that have to be removed to arrive at a spanning tree,
are specially handled for the generation of the connection equations (see below):

References
[1]

[2]

[3]
[4]

[5]

Modelica 3.0 Language Specification, Modelica
Association, September 2007.
http://www.modelica.org/documents/ModelicaSp
ec30.pdf
P. Bonus, P. Fritzson. Automated Static Analysis of Equation-Based Components. SIMULATION: Transactions of the Society for Modeling
and Simulation Internal. Special issue on Component-based Modeling & Simulation. Vol 80:8,
2004.
Dymola, by Dynasim AB, Sweden. See
www.dynasim.se for more information.
D. Broman, K. Nystrm, P. Fritzson: Determining Over- and Under-Constrained Systems of
Equations using Structural Constraint Delta.
In Proceedings of the 5th international conference
on Generative programming and component engineering
M. Tiller: Parsing and Semantic Analysis of
Modelica Code for Non-Simulation Applications. In Proceedings of Modelica2003 conference.
http://www.modelica.org/events/Conference2003/
papers/h31_parser_Tiller.pdf

Appendix 
Over-determined connectors
Over-determined connectors have been introduced in
Modelica 2.1 to handle a certain class of consistently
over-determined set of differential-algebraic equations, for example 3-dim. mechanical systems: Since
a MultiBody connector contains the transformation
matrix between the world frame and the connector
frame, and there are constraints between the elements of a transformation matrix, connecting components with such a connector can lead to an overdetermined (but consistent) set of unbalanced equations that have a mathematically well-defined solution. The over-determined connectors are defined
and used in such a way, that a Modelica tool is able
to remove the superfluous (consistent) equations arriving at a balanced set of equations, based on a
graph analysis of the connection structure. For equation counting, it is of course important to take this
special treatment into account:
A type class with an equalityConstraint(..) function
declaration is called over-determined type. A record
class with an equalityConstraint(..) function definition is called over-determined record. The equalityConstraint(R1,R2) functions are used to define the
minimal number of equations stating that overdetermined types or records R1 and R2 are identical.
The Modelica Association

31

selected root
selected root
node

root

potential root

nonbreakable branch
(Connections.branch)
breakable branch (connect)
removed breakable branch to get tree
For potential roots the model tests if the root is selected, and then uses different equations. The flowvariables always give the same equations as normal
connections, but for potential (=non-flow) variables this is different: If a connect(..) equation is
Modelica 2008, March 3rd  4th , 2008

H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist

not broken, the standard equality equations hold. If
a connect(..) equation is marked as removed in
the virtual connection graph, less equations are provided by using the residual equations defined by the
type or record specific function equalityConstraint() (shorted to r() below  with number of
equations nr) taking the two potential variables of
the connected connectors as input arguments.
If we examine the same cases as in Figure 1 and consider m1.c, m2.c, m3.c as unconditional roots we get
the same result for the left and for the right-case (the
connection must be a removed branch since two unconditional roots are connected):
0 = m2.c.f + m3.c.f;
0 = r(m2.c.p, m3.c.p);

// nf equations
// nr equations

and thus we get:
left model (m1):

neroot = n f

right model (m2,m3):

2neroot = n f + nr

or

neroot = n f
nr = n f
If we instead have a potential root, we will in the left
(unconnected) case select a root. If connected to a
similar component one of them will get a root and
the other one not, and the connection will not be
broken (i.e. normal connection equations are introduced). We then get the size-constraint:
left model (m1):

neroot = n f

right model (m2,m3):

neroot + nenon  root = n f + n p

Combing the two cases results in:
neroot = n f
nr = n f
nenon  root = n p

If there are several potential roots they should all
give the same external equation count. The requirement on the residual size (nr = nf) is included in the
Modelica specification [1], but additionally only the
rooted external equation count is included
( neroot = n f ) and not the non-rooted equation count.
Thus the balancing rules in Modelica 3.0 for overdetermined connectors are incomplete and hold only
for a very special case (e.g. when a MultiBody component is directly connected to the world object,
which is a definite root of the virtual connection
graph). This should be corrected in a future revision
of the Modelica Specification. In the remaining part
The Modelica Association

32

of this section, the non-rooted equation count is also
taken into account.
In a similar way as in section 2.1 Restrictions on
physical connectors, the above derivation is also
formulated in form of requirements on connectors
and models (the derivation requires extending the
above test models with a mixture of normal potential
variables and potential variables of over-determined
records or types):
1. The number of flow variables in a connector
must be equal to the number of (normal) noncausal, non-flow variables + the number of residual equations of over-determined records and
types (in the set of non-flow variables, the overdetermined records and types are not included,
because they are included via the residual equations)
2. The number of equations in a model =
number of unknowns
 number of inputs
 number of flow variables
 ((for every Connections.Branch(R1,R2)) and
(for every Connections.potentialRoot(R1,..)
where Connections.isRoot(R1) = false):
number of R1 variables 
number of R1 residual equations,
i.e., the number of R1 constraint equations)
3. When using a model with over-determined connectors, i.e., making an instance, all missing
equations of this component must be provided
to make the component balanced. Besides the
standard rules, the only way to make overdetermined connectors balanced is to connect to
these connectors or by leaving them unconnected.
These rules shall be demonstrated at hand of the
Modelica.Mechanics.MultiBody library:
The over-determined connector Orientation describes the transformation matrix from one frame to
another frame:
record Orientation
Real T[3, 3] "Transformation matrix";
encapsulated function equalityConstraint
import M=Modelica.Mechanics.MultiBody;
input M.Frames.Orientation R1
input M.Frames.Orientation R2
output Real residue[3]
algorithm
residue := { ... }
end equalityConstraint ;
end Orientation;

The Orientation object has a residue function with
3 equations and is used in a MultiBody connector to

Modelica 2008, March 3rd  4th , 2008

Balanced Models in Modelica 3.0 for Increased Model Quality

describe the rotation from the world frame to the
connector frame:

each other, then the transformation matrix between
two LineForce elements is arbitrary. This can be
made mathematically well-defined, by setting one of
the LineForce transformation matrices (= the selected root) to an arbitrary value:

connector Frame
import SI = Modelica.SIunits;
import M=Modelica.Mechanics.MultiBody;
SI.Position
r_0[3] "Origin of frame"
flow SI.Force f [3] "Cut-forces"

model LineForce
import SI=Modelica.SIunits;
import M=Modelica.Mechanics.MultiBody;
M.Interfaces.Frame_a frame_a
M.Interfaces.Frame_b frame_b
...
equation
Connections.potentialRoot(frame_a.R,10);
Connections.potentialRoot(frame_b.R,10);

M.Frames.Orientation R "Orientation"
flow SI.Torque
t[3] "Cut-torque";
end Frame;

Connector frame has 3+3 = 6 flow variables (f,t), 3
normal, non-flow variables (r_0) and 3 residual
equations (from R). Therefore, the connector fulfills
rule 1 above.
FixedTranslational is a MultiBody model that translates one frame along a given position vector:

frame_b.f = ...; // force law
0 = frame_a.f + frame_b.f;
if isRoot(frame_a.R) then
frame_a.R = Frames.nullRotation();
else
frame_a.t = zeros(3);
end if;

model FixedTranslation
import SI=Modelica.SIunits;
import M=Modelica.Mechanics.MultiBody;
M.Interfaces.Frame_a frame_a
M.Interfaces.Frame_b frame_b
parameter SI.Position r[3]
"Vector from frame_a to frame_b";
equation
Connections.branch
(frame_a.R, frame_b.R);
frame_b.r_0 = frame_a.r_0 +
M.Frames.resolve1(frame_a.R, r);
frame_b.R = frame_a.R;
zeros(3) = frame_a.f + frame_b.f;
zeros(3) = frame_a.t + frame_b.t +
cross(r, frame_b.f);
end FixedTranslation;

if isRoot(frame_b.R) then
frame_b.R = Frames.nullRotation();
else
frame_b.t = zeros(3);
end if;
end LineForce;

The number of equations in LineForce depends on
the selected roots. If isRoot(..) is false for both
frames the number of equations are required to be:
= 2*(3+3+9+3) // 2*(r_0+f+R.T+t)
- 2*(3+3)
// 2*(f+t)
- 2*(9-3)
// 2*(R.T  R.residuals)
= 12 equations

The number of equations in FixedTranslation is
required to be:

and the model fulfils this requirement.
If isRoot(..) is false for one and true for the other
frame, the number of equations are required to be:

= 2*(3+3+9+3) // 2*(r_0+f+R.T+t)
- 2*(3+3)
// 2*(f+t)
- (9-3)
// (R.T  R.residuals)
= 18 equations

and the model fulfils this requirement.
World is the MultiBody model that defines the inertial frame as:

= 2*(3+3+9+3) // 2*(r_0+f+R.T+t)
- 2*(3+3)
// 2*(f+t)
- 1*(9-3)
// 1*(R.T  R.residuals)
= 18 equations

and the model fulfils this requirement.

model World
import M=Modelica.Mechanics.MultiBody;
M.Interfaces.Frame_b frame_b;
equation
Connections.root(frame_b.R);
frame_b.r_0 = zeros(3);
frame_b.R
= M.Frames.nullRotation();
end World

The number of equations in World is required to be:
= 3+3+9+3
// r_0+f+R.T+t
- (3+3)
// (f+t)
= 12 equations

and the model fulfils this requirement.
LineForce is a MultiBody model that defines a
force along a line between two frames. The difficulty
is that if LineForce elements are directly coupled to

The Modelica Association

33

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

34

Modelica 2008, March 3rd  4th , 2008

Session 1b
Language, Tools and Algorithms

The Modelica Association

35

Modelica 2008, March 3-4, 2008

The Modelica Association

36

Modelica 2008, March 3rd  4th , 2008

Initialization of Modelica Models in Scicos

The Modelica Association

37

Modelica 2008, March 3rd  4th , 2008

M. Najafi, R. Nikoukhah

The Modelica Association

38

Modelica 2008, March 3rd  4th , 2008

Initialization of Modelica Models in Scicos

The Modelica Association

39

Modelica 2008, March 3rd  4th , 2008

M. Najafi, R. Nikoukhah

The Modelica Association

40

Modelica 2008, March 3rd  4th , 2008

Initialization of Modelica Models in Scicos

The Modelica Association

41

Modelica 2008, March 3rd  4th , 2008

M. Najafi, R. Nikoukhah

The Modelica Association

42

Modelica 2008, March 3rd  4th , 2008

Initialization of Modelica Models in Scicos

The Modelica Association

43

Modelica 2008, March 3rd  4th , 2008

M. Najafi, R. Nikoukhah

The Modelica Association

44

Modelica 2008, March 3rd  4th , 2008

Initialization of Modelica Models in Scicos

The Modelica Association

45

Modelica 2008, March 3rd  4th , 2008

M. Najafi, R. Nikoukhah

The Modelica Association

46

Modelica 2008, March 3rd  4th , 2008

Introducing Sol: A General Methodology for Equation-Based Modeling of Variable-Structure Systems

Introducing Sol: A General Methodology for
Equation-Based Modeling of Variable-Structure Systems
Dirk Zimmer
Institute of Computational Science, ETH Zrich
CH-8092 Zrich, Switzerland
dzimmer@inf.ethz.ch

Abstract
This paper presents a derivative language of Modelica
that is called Sol. It has been especially designed for the
convenient expression and simulation of variable-structure
systems within an object-oriented, equation-based modeling framework. Starting from a formal definition of the
grammar and type-system, the paper advances to an explanation of Sols semantics. Finally the current state of
implementation and corresponding processing mechanisms are presented. Keywords: language design, variable-structure systems, causalization mechanisms.

1

Motivation

Many contemporary models contain structural
changes at simulation run-time. These systems are
typically denoted by the collective term: variablestructure systems. The motivations that lead to the
generation of such systems are manifold. Typical
cases are represented by ideal switching or breaking
processes, variability in the number of entities, dynamic multi-level models or user interaction [5].
Let us focus on the modeling-paradigm that is represented by Modelica: declarative models that are
based on differential algebraic equations (DAEs)
with hybrid extensions. Within this paradigm, a
structural change is reflected by a change in the set
of variables and by a change in the set of relations
(i.e., equations) between the time-dependent variables. Such replacements may lead to severe changes
in the model structure. This concerns the causalization of the equation system, as well as the perturbation index of the DAE system.
Current contributions of this research domain include
the development of the language MOSILAB [8] or
Hydra [7]. Also some specific techniques, like inline-integrators [4] that can be included in Modelica
prove to be helpful in certain situations. However,
most of these approaches leave the standard domain
of Modelica, since the modeling of variable-structure
systems within the current Modelica framework is

The Modelica Association

47

very limited [10]. This is partly due to a number of
technical restrictions that mostly originate from the
static treatment of the DAEs. But these technical restrictions are not the only limiting factor. Another
major problem is the lack of expressiveness in the
Modelica-language itself.
To express structural changes, a corresponding modeling language has to meet certain requirements. For
instance, it must be enabled to state relations between variables or sub-models in a conditional form,
so that the structure can change depending on time
and state. In addition, variables and sub-models
should be dynamically declarable, so that the corresponding instances can be created, handled, and deleted at run time. Such requirements partly contradict
with fundamental assumptions made in the designprocess of Modelica.
Therefore we decided to develop a new language
called Sol [11]. It is a language primarily conceived
for research purposes that attempts to be of minimal
complexity with a high degree of expressiveness. We
want to explore the full power of a declarative modeling approach and how it can handle potential, future problem fields. The implementation of Sol will
be a small and open project that should enable other
researchers to test and validate their ideas with a
moderate effort. The longer term goal of our research
is to significantly extend Modelicas expressiveness
and range of application. Furthermore, the Solproject gives us a development-platform for technical solutions that concerns the handling of structurally changing equation systems. This includes solutions for dynamic recausalization or the dynamic
handling of structural singularities.
Although Sol forms a language of its own, it is designed to be as close to Modelica as reasonably possible. This should drastically ease the understanding
for anyone in the Modelica community. It is not our
goal to immediately change the Modelica standard or
to establish an alternative modeling language. Our
scientific work is intended to merely offer suggestions and guidance for Modelicas future development.
Modelica 2008, March 3rd  4th , 2008

D. Zimmer

Example 1: Model of a simple machine driving a fly-wheel with a fluctuating torque.
Definition of the main model: SimpleMachine

model SimpleMachine

(1) Header:
 Definition of a constant

define inertia as 1.0;
interface:
parameter Real meanTorque;
static Real w;

(2) Interface Section:
 Declaration of parameters
 Declaration of a public member

implementation:
static Real torque;
static Real a;
torque = inertia*z;
w = int(x=z);
phi = int(x=w);
torque = (1+cos(p=phi))*meanTorque;

(3) Implementation part:
 Declaration of private members

end SimpleMachine

End of the model-definition

 Stating Newtons law of motion
 Equation for the fluctuating torque


 An example declaration of the machine model.
 Simple Output Generation.

static SimpleMachine M1{ meanT << 10};
cout << SimpleMachine.w;

2
2.1

The Language: Sol
Principle Components

Essentially, Sol redefines the fundamental concepts
of Modelica on a dynamic basis. Following the spirit
of Modelica, it forms a language of strong declarative character and therefore completely abandons any
imperative parts. Unlike many other declarative
modeling languages, Sol enables the creation, exchange and destruction of components at simulation
time. To this end, the modeler describes the system
in a constructive way, where the structural changes
are expressed by conditionalized declarations. These
conditional parts can than get activated and deactivated of during run-time. This constructive approach
avoids an explicit description of modes and transitions and yet proves to be fairly powerful and flexible.
In contrast to Modelica, the grammar of Sol (cf. appendix) is significantly stricter. In its aim for simplicity, it prohibits any ambiguous ordering of its
major sections. Also any grammar elements that one
would typically denote by the term syntactic sugar
are largely omitted. Whereas the strict section ordering definitely leads to a good modeling style, the
lack of syntactic shorthand notations may sometimes
result in clumsy formulations.

The Modelica Association

48

On the top-level, the Sol language features only a
single language component that represents the definition of a model in a very generic way. Such onecomponent approaches are frequent for experimental
languages (e.g. [1]), since they typically result in a
uniform structure that eases further processing. In
addition, they yield to a clear and simple grammar.
The example above gives a first glance at Sol and
enables us to take a closer look at the structure of a
model-definition. A model-definition consists of
three parts, where each of them is optional:
 The header section is essentially composed out
of further definitions. These may be constants or
further models. Definitions of the header-part can
be publicly accessed and belong the model definition itself and not to one of its instances. In addition, the header enables you to state an extension
of an existing definition.
 The interface section enables the modeler to declare the members of a model that can be publicly
accessed. The members can either be basic variables or sub-models. Any of these members can
be marked as a parameter that is passed at the
models instantiation and remains constant for the
objects lifetime. Hence extra means for classparameterization as in Modelica become obsolete.
 The implementation part contains then the actual
relations between the variables and describes the
dynamics of the system.

Modelica 2008, March 3rd  4th , 2008

Introducing Sol: A General Methodology for Equation-Based Modeling of Variable-Structure Systems

This general structure of a model-definition enables
it to be used also for degenerated tasks like the definition of packages or connectors. A model in Sol
represents a uniform approach that is similar to the
class concept of Modelica. On the other hand side,
the term model is almost overstressed and became
so general that it lost some of its actual meaning. To
regain expressiveness, Sol offers you different
model-specifiers that enable the explicit denotation
of certain sub-kinds. The usage of these specifiers
involves consequently a number of restrictions.
However, the syntax and semantics still remain uniform.
2.2

Object-Oriented Organization

The object-oriented and hierarchic organization of
modeling code is substantially supported by two
model-specifiers:
 package: Packages are used to collect models in
a meaningful entity. A package-definition is reduced to the header part. It features neither an interface nor an implementation.
 connector: A connector typically collects members that are intended to be related by a connection-statement. A connector consists essentially
of an interface. Theres no implementation part.
The creation of an object-oriented hierarchy is illustrated in example 2 where the machine-model is split
up into its principle components: An engine, a flywheel and additionally a simple gear model. These
models use a uniform connector model and are based
upon partial models that have been collected in an
extra template package. Example 2 makes frequent
use of the keyword extends that demonstrates the
appliance of type-generation.
Example 2: Package structure in Sol
package MechTemplate
package Interfaces

end Interfaces;
end MechTemplate;
package Mechanics extends MechTemplate;
model Engine1
extends Interfaces.OneFlange;
interface:
parameter Real meanT;
implementation:
f.t = meanT;
end Engine1;
model Engine2
extends Interfaces.OneFlange;
interface:
parameter Real meanT;
implementation:
static Real transm;
transm = 1+cos(x = f.phi);
f.t = meanT*transm;
end Engine2;
model FlyWheel
extends Interfaces.OneFlange;
interface:
parameter Real inertia;
static Real w;
implementation:
static Real z;
f.phi = int(x=w);
w = int(x=z);
-f.t = z*inertia;
end FlyWheel;
model Gear
extends Interfaces.TwoFlanges;
interface:
parameter Real ratio;
implementation:
ratio*f1.phi=f2.phi;
-f1.t=ratio*f2.t;
end Gear;

connector Flange
interface:
static potential Real phi;
static flow Real t;
end Flange;
partial model OneFlange
interface:
static Flange f;
end OneFlange;

The Modelica Association

partial model TwoFlanges
interface:
static Flange f1;
static Flange f2;
end TwoFlanges;

end Mechanics;

49

Modelica 2008, March 3rd  4th , 2008

D. Zimmer

Sol offers three simple but
effective mechanisms for
type-generation. The most
important of them is the
type-extension better known
as inheritance. Any model
can extend any other model
as long as there are no circular or recursive dependencies. Since packages repFigure 2: Exemplary type-hierarchy in Sol
resent models as well, inheritance can be applied to complete packages as 2.3
Type-System
well. The remaining two mechanisms consist in the
redeclaration of members and the redefinition of Like Modelica, Sol features a structural type-system
models. Also these mechanisms can be applied to all [2]. It is solely based on the models interfaces. The
feasible elements. In contrast to Modelica the rede- development of implementations and interfaces can
claration is used for type-generation only and not for therefore be separated and disjoined lines of impleclass-parameterization.
mentation may yield into compatible types. The proFigure 1 depicts the resulting package structure of vided mechanisms of inheritance and redeclaration
our example. The solid lines denote the memberships enable a satisfactory degree of polymorphism.
whereas the dotted arrows represent inheritance.
The type of a model is composed out of its members
in the interface section. Any type-extension will
yield to the creation of a sub-type of the inherited
model. Also redeclarations and redefinition are limited to be only possible by sub-types of their original
representation. Figure 2 illustrates the resulting typestructure of Example 2.
A proper and user-evident type-system becomes increasingly important in a dynamic framework like
Sol. In situation where assignments are applied on
complete sub-models to perform a model-exchange
the corresponding assignments should be guarded by
the type-rules.
2.4

The implementation part represents a block. A block
may contain declarations of private members, relations (e.g. equations) or further nested conditional
blocks in any arbitrary order. Let us analyze each
component in more detail.
Private Declarations:
Declarations of private members do hardly differ
from their counterparts in the header sections. Only
the parameter attribute and the access-specifiers are
now meaningless and therefore disabled.
The declaration of a member links a model instance
to a given identifier. This linking is either static or
dynamic. This selection has to be stated before the
actual declaration. In contrast to a static linking, a
dynamic linking enables to modeler to (re-)assign a
new instance to the corresponding identifier.

Figure 1: Exemplary package-hierarchy in Sol

Whereas the example has been over-elaborated for
the purpose of demonstration, the combined usage of
type-generation mechanisms forms a powerful tool
for certain application domains like fluid-dynamics
[3]. There, a package for a certain material may
serve as a potential template. A modeler can then
quickly adapt to other materials by a packageextension and a redefinition of the basic material
model.

The Modelica Association

Implementation part

50

Modelica 2008, March 3rd  4th , 2008

Introducing Sol: A General Methodology for Equation-Based Modeling of Variable-Structure Systems

Conditional Blocks:
Sol features if-else-branches and when-elsebranches. The condition of an if-branch is immediately applied. It forms a safe condition that can be
assumed to hold for its content. Hence the condition
must be independent on any of its branches content.
When-statements are used to catch an event. The
events are triggered during the update-procedure and
are scheduled for the next one. Thus, whenconditions are not safe. Unlike Modelica, there are
no syntactical restrictions on the content of the
branches, but all branches shall finally lead to correct
system of equations.
Statements:
Three fundamental operators are provided for setting
up relations between members:

The operator = states an equation between two
expressions of type real.

The causal copy-transmission << is setting up
causal relationships between real variables and
can be used to link a copy of a model-instance to
an identifier.

The causal move-transmission <- is used to link
a model-instance to a new identifier and to remove the former linking.
Member-access in statements:
To access the public members of your sub-models,
three options are provided:

As in Modelica the . operator is the most
straightforward way of access, but not always
convenient.

The connection() statement exist also in Sol
and has practically the same meaning as its
counterpart in Modelica.

The ( ) operator enables a function-like notation. It is especially suited for anonymously declared members.
Whereas the . operator represents a universal form of
member access, the other two forms serve convenience and their proper appliance is determined by
specifiers at the corresponding member-declarations.
The connection statement only refers to variables
that have been marked by the specifiers flow or
potential. The specifiers in and out determine
the applicability of the access by round-brackets.

3

Example 3: Machine with a structural change
model Machine
implementation:
static Mechanics.FlyWheel F{inertia<<1};
static Mechanics.Gear G{ratio << 1.8};
connection(G.f2,F.f);
static Boolean fast;
if fast then
static Mechanics.Engine1 E{meanT<<10};
connection(E.f,G.f1);
else then
static Mechanics.Engine2 E{meanT<<10};
connection(E.f,G.f1);
end;
if initial then fast << false; end;
when F.w > 40 then fast << true; end;
end Machine;

The resulting model is presented above. It includes
two conditional branches, one for each mode. The
current mode is stored in the Boolean variable fast.
The corresponding transition is modeled by the
when-statement.
3.1

Simulation Result

Using an interpreter program, the system was simulated for 10 seconds by the excessive number of
10000 integration steps with the forward Euler
method. The computational effort sums up to a total
of 0.2 seconds on a standard CPU, where the effort
for parsing and preprocessing is almost completely

Example Model

The presented language elements are sufficient for
the formulation of highly variable systems. However,

The Modelica Association

given the brief introduction above, it may not be evident how objects can be dynamically created, exchanged and deleted as there appears to be no explicit tool for these purposes. Let us therefore look at
an example.
We reassemble the machine-model from example 1
that consists of an engine that drives a fly-wheel.
This time we use the components of the Mechanics
package in example 2. Furthermore we add a simple
gear to our model. We recognize that the package
provides two models for an engine: The first model
Engine1 applies a constant torque on the flange. In
the second model Engine2, the torque is dependent
on the positional state, roughly emulating a pistonengine. Both models share the same type (see figure
2). Our intention is to use the latter, more detailed
model at the machines start and to switch to the
simpler, former model as soon as the wheels inertia
starts to flatten out the fluctuation of the torque. This
exchange of the engine-model represents a simple
structural change on run-time.

51

Modelica 2008, March 3rd  4th , 2008

D. Zimmer

negligible. Figure 3 displays a plot of the angular
velocity. The structural change reveals more clearly
in the magnification. The actual change in the structure of equations is presented by the two causalitygraphs of figure 5 and 6. Their closer examination is
part of section 4.

The deletion of a model-instance is mostly done implicit by replacing the linking to an instance (as
above) or by the removal of the corresponding identifier. However, example 5 presents the predefined
trash object that is of type void and can be used for
the explicit deletion of any object.
Example 5: Explicit deletion of a model-instance
trash <- E;

This mechanism for the dynamic linking of a modelinstance represents a pointer-free modeling approach. The linking obeys clear ownership principles
and therefore the simulation system can assure a
memory-safe execution. Furthermore, the modeler is
freed from the tedious and error-prone task of memory-management.

4

Figure 3: Angular velocity of the flywheel.

3.2

Alternative modeling approach

In the prior example, model-instances have been implicitly created and removed by the if-statement. Using local engine-models in the two branches is a very
natural modeling approach, but often leads to redundant formulations (e.g. the connection statement) and
therefore not all structural changes can be formulated
in such a way. Thus, Sol enables the dynamic linking
of an identifier to its instance. This offers a more
convenient and general approach.
Let us model the machine for a second time, this
time using a dynamic engine-model E that is initially
linked to an Engine2 model. At the transition-event,
the Engine1 model is dynamically created by an
anonymous declaration. Since it is linked to the
member E by a move-transmission, its lifetime exceeds the event and the newly created model replaces
the former one. The replacement is valid because the
types of the two engine models are equivalent.
Example 4: Alternative version of the machine-model
model Machine
implementation:
static FlyWheel F{inertia<<1};
static Mechanics.Gear G{ratio << 1.8};
dynamic Engine2 E{meanT << 10};
connection(E.f,G.f1);
connection(G.f2,F.f);
when F.w > 40 then
E <- Engine1{meanT << 10};
end;
end Machine;

The Modelica Association

Processing Schemes

Sol is currently processed by an interpreter. The interpreter was named Solsim and represents a command-line program running under Linux or Windows. The input-file can be written in a standard
text-editor. The simulation is performed and its output can be written into a file readable by the programs Matlab or Gnuplot. In addition to its main
task, the interpreter provides also tools for the analysis of the model-hierarchy, type-structure and causalization mechanisms
Whereas the pair of a compiler and a simulator is the
preferred choice for high-end simulation tasks, an
interpreter is an appropriate tool (cf. [6]) for research
work on language design. The development process
becomes easier, faster and more flexible. Hence the
development of the interpreter can proceed in parallel with a further refinement of the language. Furthermore, new debugging techniques become crucial
in a more dynamic framework. This can be easier
provided by an interpreter, since all necessary metainformation is available. Figure 4 displays a simplified overview of the main processing scheme that is
composed out of six blocks. The following sections
discuss these parts in more detail.
4.1

Parsing and Lexing

The Lexer processes the elementary elements of the
language and discards all comments and formatting.
Since the remaining part of the language forms an
L1-Grammar, the actual parsing forms a rather trivial
task. The parser is handwritten and features an automatic error-generation.

52

Modelica 2008, March 3rd  4th , 2008

Introducing Sol: A General Methodology for Equation-Based Modeling of Variable-Structure Systems

nary just to the instantiation of its corresponding
condition. The actual content is instanced at a latter
evaluation cycle.
In the dynamic framework of Sol the instantiation of
models isnt restricted to the initial build up phase.
Later instantiations will most likely occur. Consequently also their removal has to be managed. This is
done in the exact reverse way.
4.4

Dynamic Causalization

In the next stage, the mechanisms for typegeneration are applied. This concerns primarily the
resolving of type-identifiers and the appliance of the
type-extensions. However these two processes cannot be implemented in a linear fashion. They usually
have to be processed in several, interleaved steps.
Since a type-extension can be applied even on a
complete package, the extension itself may generate
new type-identifiers that may have to be resolved
elsewhere. Thus, the algorithm has to crawl
through the dependencies. Circular or recursive extensions lead to an inevitable downfall of this process and are therefore detected.
Furthermore the mechanisms for model-redefinition
and member-redeclaration are processed. All methods for type-generation undergo a validation process,
where consistency of the type-structure is checked.
The resulting tree-structure of the package-hierarchy
and of the type-system can be displayed by the interpreter. Please note that figure 1 and 2 represent
graphs that have been automatically generated.

The result of the previous stage is a flattened model
represented by a global set of equations and transmissions. The dynamic causalization analyzes this
set of equations generates a data-structure that is
suited for later evaluation cycles. The final target of
this processing stage is depicted by the causalitygraph in figure 5 and 6. There, the actual change in
structure is revealed.
The resulting graph sketches the dependencies between the equations and transmissions. It includes
also logical dependencies (dotted-lines) that result
out of the conditional branches. This graph can then
be further simplified by removing alias-variables or
constant parts.
Any change in the set of equations will yield to an
update of the causality-graph. The new equations
need to be causalized and integrated into the graph.
Furthermore the causality of previously causalized
equations may now change. To handle all these cases
in an efficient manner, the algorithm for the dynamic
causalization is strongly optimistic. This means that
it preserves existing structures, as long as possible,
even if they temporarily loose their causal roots.
Hence we can ensure that a small local change will
not cause a global change unless the structure of the
equation system makes this inevitable. For instance,
the exchange of the engine model will not affect the
causality of the fly-wheel or the gear model. Therefore the update considers only a sub-graph and can
be treated locally. The details of this algorithm remain to be published.

4.3

4.5

Figure 4: Processing scheme of Sol

4.2

Preprocessing

Instantiation and flattening

At the beginning, the top model is instantiated. The
instantiation of a model evokes the following steps:
First, all members (i.e. variables or sub-models) are
instantiated recursively. Second all the statements in
the implementation are processed.
The process of instantiation is aligned with the flattening of the system. Hence common statements like
transmissions or equations are collected in a global
set. The processing of an if-statements leads prelimi-

The Modelica Association

53

Update and Evaluation

Based on the causality-graph, the system can be
evaluated. This may consider the whole system or
only a small subpart. Arbitrary updates can be triggered. If several updates are triggered at once, they
are evaluated synchronously. The update procedure
evaluates all dependent relations and successfully
avoids any multiple evaluations of relations where
separate update-paths meet.

Modelica 2008, March 3rd  4th , 2008

D. Zimmer

Figure 5 (left): Causality-graph of the machine at time 1
having Engine2 as submodel.
Figure 6 (right): Causality-graph of the machine at time 8
using the simpler model Engine1 as submodel.
Both graphs originate from an automatically generated
version, where the gear-model has been omitted. The
graphs have been slightly simplified to increase clarity and
readability.

Logic-dependencies in the causality graph form silent dependencies. This means that an update of the
corresponding Boolean expression does not directly
trigger updates on its logical dependent equations.
Silent dependencies are purposed only to ensure a
correct update flow.
Furthermore, the causality graph contains also relations that own side-effects. Those relations may typically trigger an instantiation or removal of equations.
The condition of an if-branch represents a prime example for this.
4.6

5
5.1

Time-Integration

The evaluation of the system (or a part of it) is triggered by two major sources. One is the insertion of
new relations through instantiation. The other one,
and much more frequent, is the time-integration of
the corresponding state-variables. Currently, only
simple explicit methods for integration are available.
Since the system may reconfigure during an integration step, most integration algorithms with multiple
steps cannot be implemented in a straightforward
manner. It should be ensured that only the final step
may trigger structural changes. Also certain methods
for step-size control need to be adapted for the new
framework.

The Modelica Association

54

Limitations and Efficiency
Current limitations

The current version of Solsim provides a framework
for a more dynamic handling in equation-based
modeling. The language itself enables the statement
of drastic structural changes in a general way. Thus,
the causalization of several equations may change in
dependence of the structure. Also various submodels may be instantiated or removed on run-time
leading to a variable number of instances.
However, there are severe restrictions that consider
the type of equation systems that are currently supported. Solsim is yet unable to treat any equation
system that contains algebraic loops. Also there is no
index-reduction mechanism. And therefore the differential equations are temporarily formulated by the
explicit statement of an integrator.
These restrictions reduce severely the applicability of
the current system. In most practical situations,
structural changes hardly lead to an isolated reconfiguration like a simple causality change. Often a
complete set of tasks has to be accomplished at once
[5]. This concerns, for instance, the dynamic handling of algebraic loops, a dynamic state-selection

Modelica 2008, March 3rd  4th , 2008

Introducing Sol: A General Methodology for Equation-Based Modeling of Variable-Structure Systems

and mechanisms for index-reduction or robust, redundant re-initialization. In mechanics, the problem
of multiple contact points with ideal-friction even
yields to a complicated optimization task [9].
5.2

Efficiency

Whereas it is too early to give serious benchmark
results, this section may at least give an impression
about the current speed of our interpreter on a standard CPU. In general, we can state that the number
of equations that can be evaluated per second is in
the order of magnitude from 105 to 106. The mechanisms for instantiation, flattening and causalization
manage altogether to handle between 104 and 105
equations per second.
Most important is that the efficiency is high enough
to let us exceed the complexity of trivial models. Of
course, the interpreter, like any other interpreter suffers from a certain computational overhead that will
prevent its usage for highly demanding simulation
applications.
Please note that the outlined processing scheme is
not an exclusive solution. It is a very general approach and consequently represents overkill for
many specific applications. However, a declarative
language as Sol is very well suited to enable various
optimization techniques, since the semantics do not
directly stipulate the processing scheme. A number
of optimizations may therefore be developed. For
instance, a potential optimization is a run-time compiler. One might also try to include certain parts of
the causalization, simplification and flattening into
the preprocessing stage. Another interesting topic is
the automatic identification and pre-compilation of
situations where the system can be described by a
finite set of sub-modes.

6

Conclusions

The Sol language is built upon declarative principles
and is strongly influenced by Modelica. It incorporates a general modeling methodology for variablestructure systems. The Sol research project offers a
dynamic framework that enables the convenient acquaintance of knowledge in language design and
processing techniques that we think will be essential
for Modelicas future development.
Such a methodology benefits prevalent application
areas and is likely to enlarge application field for
equation-based modeling. To this end, future developments that concern primarily language design and
processing techniques are required.

Appendix
The following listing of rules in extended BackusNaur form (EBNF) presents the core grammar of the
Sol modeling language. The rules are listed in a topdown manner listing the high-level constructs first
and breaking them down into simpler ones. Nonterminal symbols start with a capital letter and are
written in bold. Terminal symbols are written in
small letters. Special terminal operator signs are
marked by quotes. Rules may wrap over several
lines.
Common fundamental expressions like the model for
the mathematical function sin() or given global variables as time or initial form predefined elements
within the language itself and are therefore not part
of the grammar. The same holds for the fundamental
types in Modelica. These are: Real, Integer, Boolean, String and Void.
Listing 1: EBNF-Grammar of Sol

5.3

Future Tasks

Model

Our primary target is to enhance the general applicability of our approach with respect to the set of DAEsystems that can be properly handled. Therefore we
have a strong incentive to develop algorithms for the
tearing of algebraic loops and index-reduction that
are flexible and can be well integrated into our dynamic framework.
Furthermore the presentation of the core language
omits a number of language elements that have still
remained in the state of design. This concerns, for
example, a general solution for collections of models
(e.g. arrays).

The Modelica Association

55

=

ModelSpec =

ModelSpec Id Header
[Interface] [Implemen] end Id ";"
[redefine] [partial]
(model | package | connector | record)

Header
Extension
Define

=
=
=

{Extension} {Define} {Model}
extends Designator ";"
define (Const | Designator) as Id ";"

Interface
ParDecl
IDecl
ConSpec
IOSpec

=
=
=
=
=

interface ":" {(IDecl | ParDecl) ";"} {Model}
parameter Decl
[redelcare] LinkSpec [IOSpec] [CSpec] Decl
potential | flow
in | out

Implemen
StmtList

=
=

implementation ":" StmtList
[Statement {";" Statement }]

Modelica 2008, March 3rd  4th , 2008

D. Zimmer

Statement

=

[Condition | Event | Declaration | Relation]

Condition
ElseCond
Event
ElseEvent

=
=
=
=

if Expression then StmtList ElseCond
(else Condition) | ([else then StmtList] end [if])
when Expression then StmtList ElseEvent
(else Event)|([else then StmtList] end [when]

Declaration =
LinkSpec
=
Decl
=

[redeclare] LinkSpec Decl
static | dynamic
Designator Id [ParList]

Relation
Rhs

=
=

Expression Rhs
("=" | "<<" | "<-") Expression

ParList
InList

=
=

"{" [Designator Rhs {"," Designator Rhs }] "}"
"(" [Designator Rhs {"," Designator Rhs }] ")"

Expression
Comparis
Term
Product
Power
SElement
Element

=
=
=
=
=
=
=

Comparis {(and|or) Comparis }
Term [("<"|"<="|"=="|"<>"|">="|">")Term]
Product {( "+" | "-" ) Product }
Power { ("*" | "/") Power }
SElement {"^" SElement }
[ "+" | "-" | not ] Element
Const | Designator [InList] [ParList]
| "(" Expression ")"

Designator
Id
Const
Number

=
=
=
=

Text
Letter
Digit

=
=
=

Id {"." Id }
Letter {Digit | Letter}
Number | Text | true | false
["+"|"-"] Digit { Digit }
["." {Digit }] [e ["+"|"-"] Digit { Digit }]
"\"" {any character} "\""
"a" | ... | "z" | "A" | ... | "Z" | "_"
"0" | ... | "9"

[4]

Cellier, F.E., Krebs, M.: Analysis and Simulation of
Variable Structure Systems Using Bond Graphs and
Inline Integration. In: Proc. ICBGM07, 8th SCS
Intl. Conf. on Bond Graph Modeling and Simulation,
San Diego, CA (2007) 29-34.
[5] Enge, O.: Analyse und Synthese elektromechanischer Systeme, Ph.D. Dissertation, TU Chemnitz,
Germany (2006).
[6] Mosterman, P.J.: HYBRSIM - A Modeling and
Simulation Environment for Hybrid Bond Graphs,
In: J. Systems and Control Engineering, 216, Part I
(2002) 35-46.
[7] Nilsson, H., Peterson, J., Hudak, P.: Functional Hybrid Modeling from an Object-Oriented Perspective
In: Proc. of the 1st Intern. Workshop on EquationBased Object-Oriented Languages and Tools, Berlin, Germany (2007) 71-87.
[8] Nytsch-Geusen, C., et al.: Advanced modeling and
simulation techniques in MOSILAB: A system development case study. In: Proceedings of the Fifth
International Modelica Conference, Vienna, Austria
(2006) Vol. 1, 63-71.
[9] Pfeiffer, F., Glocker, C.: Multibody Dynamics with
Unilateral Contacts. John Wiley & Sons, New York
(1996).
[10] Zauner, G., Leitner, D., Breitenecker, F.: Modeling
Structural-Dynamics Systems in Modelica []
Mosilab and AnyLogic. In: Proc. of the 1st Intern.
Workshop on Equation-Based Object-Oriented Languages and Tools, Berlin, Germany (2007) 71-87.
[11] Zimmer, D.: Enhancing Modelica towards variable
structure systems. In: Proc. of the 1st International
Workshop on Equation-Based Object-Oriented Languages and Tools, Berlin, Germany (2007) 61-70.

Acknowledgments

Biography

I would like to thank Prof. Dr. Franois E. Cellier for
his helpful advice and support. This research project
is sponsored by the Swiss National Science Foundation (SNF Project No. 200021-117619/1).

References
[1]

[2]

[3]

Blser, L.: A Component Language for Structured
Parallel Programming. In: Joint Modular Languages
Conference, Oxford, UK (2006) 230-250.
Broman, D., Fritzson, P., Furic, S.: Types in the
Modelica Language. In: Proceedings of the Fifth International Modelica Conference, Vienna, Austria
(2006) Vol. 1, 303-315.
Casella, F., et al.: The Modelica Fluid and Media
Library []. In: Proc.eedings of the Fifth International Modelica Conference, Vienna, Austria (2006)
Vol. 2, 631-640.

The Modelica Association

56

Dirk Zimmer received his MS
degree in computer science from
the Swiss Federal Institute of
Technology (ETH) Zurich in
2006. He gained additional experience in Modelica and in the
field of modeling mechanical
systems during an internship at
the German Aerospace Center
DLR 2005. Dirk Zimmer is currently pursuing a PhD degree with a dissertation related to computer simulation and modeling under the
guidance of Profs. Franois E. Cellier and Walter
Gander. His current research interests focus on the
simulation and modeling of physical systems with a
dynamically changing structure.

Modelica 2008, March 3rd  4th , 2008

OptimicaAn Extension of Modelica Supporting Dynamic Optimization

OptimicaAn Extension of Modelica
Supporting Dynamic Optimization
Johan kesson
Department of Automatic Control
Faculty of Engineering
Lund University
BOX 118, SE-221 00 Lund

Abstract
In this paper, an extension of Modelica, entitled Optimica, is presented. Optimica extends Modelica with
language constructs that enable formulation of dynamic optimization problems based on Modelica models. There are several important design problems
that can be addressed by means of dynamic optimization, in a wide range of domains. Examples include,
minimum-time problems, parameter estimation problems, and on-line optimization control strategies. The
Optimica extension is supported by a prototype compiler, the Optimica compiler, which has been used successfully in case studies.
Keywords: Optimica, Language extension, Dynamic
optimization, The JModelica compiler

1

Introduction

Modelica is becoming a standard format for describing and communicating high-fidelity models of largescale dynamic systems. Expert knowledge is being encoded into Modelica libraries, both in industry and in
academia. The growing body of Modelica models also
represents significant capital investments, and accordingly, Modelica models and libraries represent valuable assets for many companies. As a consequence,
Modelica models are turning into legacy code, which
cannot easily be replaced, simply because the cost of
re-encoding the models in a different format is too
large.
While the primary usage of Modelica models today is
simulation, several other usages are emerging. Since
it is not feasible, for the reasons mentioned above,
to re-encode models for each new model usage, future Modelica tools, and also the Modelica language
itself, should accommodate and promote new usages
The Modelica Association

of Modelica models. This requirement has profound
consequences for software design of Modelica tools,
and also for the language design itself. In particular,
some new usages may require new constructs, at the
language level, in order to enable modeling of particular design problems.
One example of an emerging usage of Modelica models is dynamic optimization. A characteristic feature
of realistic dynamic optimization problems is that the
procedure of formulating such problems is highly iterative. It is common that extensive tuning of the cost
function and constraints is required in order to obtain an acceptable solution. If a numerical algorithm
is used to solve the dynamic optimization problem,
there is an additional dimension that requires attention:
the design of the transcription scheme. The scheme
used to discretize the control and state variables often
strongly influences the properties of the resulting solution. The choice of discretization method also affects
the execution time for solving the problem, which is an
important aspect in on-line applications. For these reasons, dynamic optimization problems are very rich in
the sense that there are several aspects that require attention. Also, the user needs, and should be enabled to,
model, using high-level language constructs, the optimization problem both in terms of cost functions and
constraints and at the transcription level.
Sophisticated numerical optimization algorithms often
have cumbersome APIs, which do not always match
the engineering need for high-level description formats. For example, it is not uncommon for such numerical packages to be written in C, or in Fortran, and
that they require the dynamic system to be modeled
as an ODE/DAE, which is also encoded in C or Fortran. In addition, it may be required to also encode
first and second order derivatives. Although there are
efficient tools for automatic differentiation, encoding

57

Modelica 2008, March 3rd  4th , 2008

J. Akesson

of dynamic optimization problems in low-level lan- 2 Motivation of the Optimica Extenguages1 like C or FORTRAN is often cumbersome and
sion
error-prone. An important goal of developing highlevel languages for dynamic optimization is therefore 2.1 Isnt Modelica Enough?
to bridge the gap between the engineering need for
high-level descriptions and the APIs of numerical al- Although being a very rich language in terms of expressive power for describing complex hybrid dynamgorithms.
ical systems, Modelica lacks important features deThere are several software packages supporting dy- sirable for expressing optimization problems. This
namic optimization, for example Dymola [6] and is quite natural, since Modelica was not developed
gPROMS [12]. However, most available software with optimization in mind. For example, the notion
tools are restricted in the sense that they usually only of cost functions, constraints, variable bounds and inisupport a particular optimization algorithm. While a tial guesses are not included in the Modelica language.
particular algorithm may work well in some cases, the Some of these quantities may indeed be modeled usappropriate choice of numerical algorithm is usually ing standard Modelica, to some extent. For example, a
dependent on the particular problem at hand. An anal- particular variable may be given the meaning of cost,
ogy with differential equation solvers can be made. and the min and max attributes may be interpreted as
Stiff systems call for sophisticated, but potentially variable bounds. However, while this approach may
computationally demanding solvers, whereas less dif- work in simple cases, it becomes intractable for more
ficult systems may be more efficiently solved by a sim- complex optimization problems. For example, compler algorithm. An additional goal in the development plicated constraints, several use cases, and tailoring
of tools supporting high-level formulation of dynamic of the transcription method would be difficult to exoptimization problems is therefore to provide an open press. Further, the min and max attributes are usually
architecture, where several different algorithms can be used to express regions of validity for a model, and
integrated.
giving them a new semantic meaning would be potentially misleading.
In this paper, an extension of Modelica, entitled Optimica, will be presented. Optimica consists of a number of new language elements, which enable high-level 2.2 What About Annotations?
formulation of dynamic optimization problems based Modelica offers a mechanism for adding information
on Modelica models. The syntax as well as the se- to model, which may not be part of the actual mathmantics of Optimica will be described. In addition, ematical description, but which is convenient to store
a prototype implementation of an Optimica compiler, in the model. Typical examples include graphical anwhich is a modular extension of the JModelica com- notations and documentation. Annotations can also be
piler [2, 1], will be presented.
used to supply information that can be used by a particular tool, for example, in order to influence properties of the translation process. In principle, it would
be possible to specify parts of an optimization problem by introducing suitable annotations. For example,
a variable could be marked as a cost function, and the
semantic meaning of the equality operator in an equation could be changed to that of the inequality operator. There are two reasons why it is not a good idea
to strictly use this approach. Firstly, and most importantly, annotations are designed to supply complementary information, whereas in this case, the elements of
an optimization problem are rather primary information, that is essential for solving the actual problem.
Also, since annotations are not intended for formulation of design problems, they do not provide a con1 The term low-level is relative, but is here used in relation to venient modeling environment for the user. Secondly,
domain-specific languages like Modelica.
annotations cannot currently be changed by means of

The paper is organized as follows. In Section 2, issues
related to extensions of languages are discussed. Different options regarding language extensions in Modelica are also treated. In Section 3, the scope of Optimica is discussed, i.e., the class of optimization problems that can be expressed using Optimica is defined.
In Section 4 the syntax and the semantics of the Optimica extension are presented. Implementation issues related to the modular Optimica extension of the JModelica compiler are discussed in Section 5. The paper
ends with a summary and conclusions in Section 6.

The Modelica Association

58

Modelica 2008, March 3rd  4th , 2008

OptimicaAn Extension of Modelica Supporting Dynamic Optimization

modifications. Since modification is one of the cornerstones of Modelica, this is a severe restriction. Also,
it is not currently well defined how annotations are
treated in the case of inheritance. Since one of the
main objectives of the Optimica extension is to enable
convenient formulation of dynamic optimization problems using high-level constructs, using only annotations does not seem to be a feasible alternative.
Whereas the above arguments are applicable to core
elements of an optimization problem, such as cost
function and constraints, annotations may well be used
to specify a solution algorithm, and associated parameters. This type of information is not part of the actual
optimization formulation, but it might still be essential
in order to efficiently solve the problem numerically.
By introducing annotations for specifying, for example, the collocation scheme used in a direct method,
the user is able to model both the actual optimization
problem at hand and the transcription method in a unified high-level description language. This approach is
also in line with the intentions of Modelica annotations, because of the separation between formulation
of the actual problem (by means of dedicated language
constructs), and specification of the solution technique
(by means of annotations).

2.3

Tool-oriented Support for Optimization?

Another potential strategy for enabling dynamic optimization of Modelica models is to develop tooloriented solutions, for example Graphical User Interfaces (GUIs), within a simulation-based software tool.
This approach is used, for example, to enable optimization of Modelica models in Dymola. The user
would then set up the optimization problem by entering information in dedicated fields in the GUI. Using
this approach, the software tool needs to maintain an
internal model of the optimization problem, as specified by the user. While this solution may be an attractive choice for interfacing a particular optimization
method with existing simulation-based tools, it does
not offer the flexibility, or portability, which is inherent in the Modelica language. It is therefore desirable
to define, at the language level, a generic extension,
which has a well defined syntax and semantics. Nevertheless, it may still be desirable to offer GUIs, in
order to increase productivity in the design process, in
the same way as current Modelica tools typically offer
GUIs to simplify critical modeling tasks.
The Modelica Association

2.4 To Extend or to Complement?
A key issue is whether to extend Modelica by introducing new language constructs, or to define a new, separate, language which complements Modelica. By introducing a new language, the syntax and semantics of
Modelica would be kept entirely intact, which may be
advantageous since it makes design and maintenance
of the language simpler. Also, if several extensions are
introduced, defining the interaction between the extensions, both at a syntactic and semantic level, may
be difficult. On the other hand, Modelica has many
generic built-in constructs, e.g., classes, functions and
declarative equations, which are widely applicable in
many contexts. Reinventing such constructs in new
languages does not seem to be an attractive alternative. Another argument in favor of language extension
is that Modelica offers strong support for modularization of models. In the case of dynamic optimization,
the user may construct the model separately from the
formulation of the optimization problem, in which the
model is used. In this way, the same model may still
be used for other purposes than optimization, such as,
for example, simulation.
It is essential, however, that language extensions targeted at particular usages of Modelica models do
not interfere unnecessarily with the original language.
Preferably, extensions should be modular, in the sense
that the new constructs are only allowed in a well defined language environment.

3 Scope of Optimica
3.1 Information Structure
In order to formulate a dynamic optimization problem, to be solved by a numerical algorithm, the user
must supply different kinds of information. It is natural to categorize this information into three levels, corresponding to increasing levels of detail.

59

 Level I. At the mathematical level, a canonical
formulation of a dynamic optimization problem
is given. This include variables and parameters to
optimize, cost function to minimize, constraints,
and the Modelica model constituting the dynamic
constraint. The optimization problem formulated
at this level is in general infinite dimensional, and
is thereby only partial in the respect that it cannot
be directly used by a numerical algorithm without
additional information, for example, concerning
transcription of continuous variables.
Modelica 2008, March 3rd  4th , 2008

J. Akesson

 Level II. At the transcription level, a method for
translating the problem from an infinite dimensional problem to a finite dimensional problem
needs to be provided. This might include discretization meshes as well as initial guesses for
optimization parameters and variables. It should
be noticed that the information required at this
level is dependent on the numerical algorithm that
is used to solve the problem.
 Level III. At the algorithm level, information
such as tolerances and algorithm control parameters may be given. Such parameters are often critical in order to achieve acceptable performance in
terms of convergence, numerical reliability, and
speed.
An important issue to address is whether information
associated with all levels should be given in the language extension. In Modelica, only information corresponding to Level I is expressed in the actual model
description. Existing Modelica tools then typically use
automatic algorithms for critical tasks such as state selection and calculation of consistent initial conditions,
although the algorithms can be influenced by the user
via the Modelica code, by means of annotations, or
attributes, such as StateSelect. Yet other information, such as choice of solver, tolerances and simulation horizon is provided directly to the tool, either by
means of a graphical user interface, a script language,
or alternatively, in annotations.
For dynamic optimization, the situation is similar, but
the need for user input at the algorithm level is more
emphasized. Automatic algorithms, for example for
mesh selection, exist, but may not be suitable for all
kinds of problems. It is therefore desirable to include,
in the language, means for the user to specify most
aspects of the problem in order to maintain flexibility, while allowing for automatic algorithms to be used
when possible and suitable.
Relating to the three levels described above, the approach taken in the design of Optimica is to extend
the Modelica language with a few new language constructs corresponding to the elements of the mathematical description of the optimization problem (level I).
The information included in levels II and III, however,
may rather be specified by means of annotations.

3.2

class is large, since very complex, non-linear and hybrid behavior can be encoded in Modelica. From a
dynamic optimization perspective, the inherent complexity of Modelica models is a major challenge. Typically, different algorithms for dynamic optimization
support different model structures. In fact, the key to
developing efficient algorithms lies in exploiting the
structure of the model being optimized. Consequently,
there are different algorithms for different model structures, such as linear systems, non-linear ODEs, general DAEs, and hybrid systems. In general, an algorithm can be expected to have better performance, in
terms of convergence properties and shorter execution
times, if the model structure can be exploited. For example, if the model is linear, and the cost function is
quadratic, the problem can be obtained very efficiently
by solving a Riccati equation. On the other hand, optimization of general non-linear and hybrid DAEs is
still an area of active research, see for example [3].
As a result, the structure of the model highly affects
the applicability of different algorithms. The Optimica compiler presented in this paper relies on a direct
collocation algorithm in order to demonstrate the proposed concept. Accordingly, the restrictions imposed
on model structure by this algorithm apply when formulating the Modelica model, upon which the optimization problem is based. For example, this excludes
the use of hybrid constructs, since the right hand side
of the dynamics is assumed to be twice continuously
differentiable. Obviously, this restriction excludes optimization of many realistic Modelica models. On the
other hand, in some cases, reformulation of discontinuities to smooth approximations may be possible in
order to enable efficient optimization. This is particularly important in on-line applications. The Optimica
extension, as presented in this paper, could also be extended to support other algorithms, which are indeed
applicable to a larger class of models.

3.3 The Dynamic Optimization Problem
The second part of the scope of Optimica is concerned
with the remaining elements of the optimization problem. This includes cost functions, constraints and variable bounds. Consider the following formulation of a
dynamic optimization problem:
min  (z, p)

Dynamic System Model

The scope of Optimica can be separated into two parts. subject to the dynamic system
The first part is concerned with the class of models
F(x(t), x(t), y(t), u(t), p,t) = 0,
that can be described in Modelica. Arguably, this
The Modelica Association

(1)

u(t),p

60

t  [t0 ,t f ]

(2)

Modelica 2008, March 3rd  4th , 2008

OptimicaAn Extension of Modelica Supporting Dynamic Optimization

and the constraints

tion problems on the form:
min  (x, y, u, p)

cineq (x(t), y(t), u(t), p)  0 t  [t0 ,t f ]
ceq (x(t), y(t), u(t), p) = 0 t  [t0 ,t f ]

p
cineq
(z, p)  0
p
ceq
(z, p) = 0

u,p

(3)

subject to

(4)

F(0, x, y, u, p,ts ) = 0

(5)

cineq (x, u, p)  0

(6)

where x(t)  Rnx are the dynamic variables, y(t)  Rny
are the algebraic variables, u(t)  Rnu are the control inputs, and p  Rn p are parameters which are
free in the optimization. In addition, the optimization is performed on the interval t  [t0 ,t f ], where t0
and t f can be fixed or free, respectively. In addition, the initial values of the dynamic and algebraic
variables may be fixed or free in the optimization.
The vector z is composed from discrete time points
of the states, controls and algebraic variables; z =
[x(t1 ), .., x(tNp ), y(t1 ), .., y(tNp ), u(t1 ), .., u(tNp )]T , ti 
[t0 ,t f ], where N p denotes the number of time points
included in the optimization problem.

(8)

ceq (x, u, p) = 0

In this case, a static optimization problem is derived
from a, potentially, dynamic Modelica model by setting all derivatives to zero. Since the problem is static,
all variables are algebraic and accordingly, no transcription procedure is necessary. The variable ts denotes the time instant at which the static optimization
problem is defined.

3.4 Transcription

In this paper a direct collocation method (see for example [4]) will be used to illustrate how also the transcription step can be encoded in the Optimica extension. The information that needs to be provided by
The constraints include inequality and equality path the user is then a mesh specification, the collocation
constraints, (3)-(4). In addition, inequality and equal- points, and the coefficients of the interpolation polyity point constraints, (5)-(6), are supported. Point con- nomials.
straints are typically used to express initial or terminal
constraints, but can also be used to specify constraints 4 The Optimica Extension
for time points in the interior of the interval.
The cost function (1) is a generalization of a terminal In this section, the Optimica extension will be precost function,  (t f ), in that it admits inclusion of vari- sented and informally defined. The presentation will
able values at other time instants. This form includes be made using the following dynamic optimization
some of the most commonly used cost function formu- problem, based on a double integrator system, as an
lations. A Lagrange cost function can be obtained by example:
Z tf
introducing an additional state variable, xL (t), with the
min
1 dt
(9)
u(t) 0
associated differential equation xL (t) = L(x(t), u(t)),
and the cost function  (t f ) = xL (t f ). The need to in- subject to the dynamic constraint
clude variable values at discrete points in the interior
x(t) = v(t), x(0) = 0
of the optimization interval in the cost function arises
(10)
v(t) = u(t), v(0) = 0
for example in parameter estimation problems. In such
cases, a sequence of measurements, yd (ti ), obtained at
and
the sampling instants ti , i  1 . . . Nd is typically availx(t f ) = 1, v(t f ) = 0
(11)
able. A cost function candidate is then:
v(t)  0.5, 1  u(t)  1
In this problem, the final time, t f , is free, and the objective
is thus to minimize the time it takes to transfer
(7)
 (y(ti )  yd (ti )) W (y(ti )  yd (ti ))
the
state
of the double integrator from the point (0, 0)
i=1
to (1, 0), while respecting bounds on the velocity v(t)
and the input u(t). A Modelica model for the double
where y(ti ) is the model response at time ti and W is a integrator system is shown in Listing 1.
weighting matrix.
In summary, the Optimica extension consists of the
Another important class of problems is static optimiza- following elements:
Nd

T

The Modelica Association

61

Modelica 2008, March 3rd  4th , 2008

J. Akesson

instantiated. With this extension, it would be possible
to solve optimization problems, on-line, during simulation. A particularly interesting application of this
feature is model predictive control, which is a control
strategy that involves on-line solution of optimization
problems during execution.
As a starting-point for the formulation of the optimization problem (9)-(11), consider the optimization
Listing 1: A Modelica model of a double integrator class:
system.

model DoubleIntegrator
Real x(start=0);
Real v(start=0);
input Real u;
equation
der(x)=v;
der(v)=u;
end DoubleIntegrator;

optimization DIMinTime
DoubleIntegrator di;
end DIMinTime;

 A new specialized class: optimization

This class contains only one component representing
 New attributes for the built-in type Real: free the dynamic system model, but will be extended in the
and initialGuess.
following to incorporate also the other elements of the
optimization problem.
 A new function for accessing the value of a variable at a specified time instant

4.2 Attributes for the Built-in Type Real

 Class

attributes for the specialized class
optimization:
objective,
startTime, In order to superimpose information on variable declarations, two new attributes are introduced for the builtfinalTime and static
in type Real2 . Firstly, it should be possible to spec A new section: constraint
ify that a variable, or parameter, is free in the optimization. Modelica parameters are normally consid Inequality constraints
ered to be fixed after the initialization step, but in the
 An annotation for providing transcription infor- case of optimization, some parameters may rather be
considered to be free. In optimal control formulations,
mation
the control inputs should be marked as free, to indicate that they are indeed optimization variables. For
4.1 A New Specialized Class
these reasons, a new attribute for the built-in type Real,
It is convenient to introduce a new specialized free, of boolean type is introduced. By default, this
class, called optimization, in which the proposed attribute is set to false.
Optimica-specific constructs are valid. This approach Secondly, an attribute, initialGuess, is introduced
is consistent with the Modelica language, since there to enable the user to provide an initial guess for variare already several other specialized classes, e.g., ables and parameters. In the case of free optimizarecord, function and model. By introducing a tion parameters, the initialGuess attribute provides
new specialized class, it also becomes straightfor- an initial guess to the optimization algorithm for the
ward to check the validity of a program, since the corresponding parameter. In the case of variables, the
Optimica-specific constructs are only valid inside an initialGuess attribute is used to provide the numeroptimization class. The optimization class cor- ical solver with an initial guess for the entire optimizaresponds to an optimization problem, static or dy- tion interval. This is particularly important if a simulnamic, as specified in Section 3.3. Apart from the taneous or multiple-shooting algorithm is used, since
Optimica-specific constructs, an optimization class these algorithms introduce optimization variables corcan also contain component and variable declarations, responding to the values of variables at discrete points
over the interval. Notice that such initial guesses may
local classes, and equations.
It is not possible to declare components from be needed both for control and state variables. For
optimization classes in the current version of Op- such variables, however, the proposed strategy for protimica. Rather, the underlying assumption is that an viding initial guesses may sometimes be inadequate.
optimization class defines an optimization problem,

2 The

same attributes may be introduced for the built-in type

that is solved off-line. An interesting extension would, Integer, in order to support also variables of type Integer in the
however, be to allow for optimization classes to be optimization formulation
The Modelica Association

62

Modelica 2008, March 3rd  4th , 2008

OptimicaAn Extension of Modelica Supporting Dynamic Optimization

In some cases, a better solution is to use simulation
data to initialize the optimization problem. This approach is also supported by the Optimica compiler. In
the double integrator example, the control variable u is
a free optimization variable, and accordingly, the free
attribute is set to true. Also, the initialGuess attribute is set to 0.0.
optimization DIMinTime
DoubleIntegrator di(u(free=true,
initialGuess=0.0));
end DIMinTime;

what function and variable declarations are visible. An
alternative syntax would have been to introduce a new
built-in function, that returns the value of a variable at
a specified time instant. While this alternative would
have been straightforward to implement, the proposed
syntax has the advantages of being easier to read and
that it more closely resembles the corresponding mathematical notation. This feature of Optimica is used in
the constraint section of the double integrator example,
and is described below.

4.4 Class Attributes
4.3

A Function for Accessing Instant Values In the optimization formulations (1)-(6) and (8), there
are elements that occur only once, i.e., the cost funcof a Variable

An important component of some dynamic optimization problems, in particular parameter estimation problems where measurement data is available, is variable
access at discrete time instants. For example, if a measurement data value, yi , has been obtained at time ti , it
may be desirable to penalize the deviation between yi
and a corresponding variable in the model, evaluated
at the time instant ti . In Modelica, it is not possible to
access the value of a variable at a particular time instant in a natural way, and a new construct therefore
has to be introduced.
All variables in Modelica are functions of time. The
variability of variables may be differentsome are
continuously changing, whereas others can change
value only at discrete time instants, and yet others are
constant. Nevertheless, the value of a Modelica variable is defined for all time instants within the simulation, or optimization, interval. The time argument of
variables are not written explicitly in Modelica, however. One option for enabling access to variable values at specified time instants is therefore to associate
an implicitly defined function with a variable declaration. This function can then be invoked by the standard Modelica syntax for function calls, y(t_i). The
name of the function is identical to the name of the
variable, and it has one argument; the time instant at
which the variable is evaluated. This syntax is also
very natural since it corresponds precisely to the mathematical notation of a function. Notice that the proposed syntax y(t_i) makes the interpretation of such
an expression context dependent. In order for this construct to be valid in standard Modelica, y must refer to
a function declaration. With the proposed extension,
y may refer either to a function declaration or a variable declaration. A compiler therefore needs to classify an expression y(t_i) based on the context, i.e.,
The Modelica Association

tion and the optimization interval in (1)-(6), and in the
static case (8), only the cost function. These elements
are intrinsic properties of the respective optimization
formulations, and should be specified, once, by the
user. In this respect the cost function and optimization
interval differ from, for example, constraints, since the
user may specify zero, one or more of the latter.
One option for providing this kind of information is
to introduce a built-in class, call it Optimization,
and require that all optimization classes inherit from
Optimization. Information about the cost function
and optimization interval may then be given as modifications of components in this built-in class:
optimization DIMinTime
extends Optimization(
objective=cost(finalTime),
startTime=0,
finalTime(free=true,initialGuess=1));
Real cost;
DoubleIntegrator di(u(free=true,
initialGuess=0.0));
equation
der(cost) = 1;
end DIMinTime;

Here, objective, startTime and finalTime are assumed to be components located in Optimization,
whereas cost is a variable which is looked up in the
scope of the optimization class itself. Notice also
how the cost function, cost, has been introduced,
and that the finalTime attribute is specified to be
free in the optimization. This approach of inheriting
from a built-in class has been used previously, in the
tool Mosilab [11], where the Modelica language is extended to support statecharts. In the statechart extension, a new specialized class, state, is introduced,
and properties of a state class (for example whether
the state is an initial state) can be specified by inherit-

63

Modelica 2008, March 3rd  4th , 2008

J. Akesson

ing from the built-in class State and applying suitable
modifications.
The main drawback of the above approach is its lack
of clarity. In particular, it is not immediately clear
that Optimization is a built-in class, and that its contained elements represent intrinsic properties of the
optimization class, rather than regular elements, as
in the case of inheritance from user or library classes.
To remedy this deficiency, the notion of class attributes is proposed. This idea is not new, but has been
discussed previously within the Modelica community.
A class attribute is an intrinsic element of a specialized
class, and may be modified in a class declaration without the need to explicitly extend from a built-in class.
In the Optimica extension, four class attributes are
introduced for the specialized class optimization.
These are objective, which defines the cost function,
startTime, which defines the start of the optimization interval, finalTime, which defines the end of
the optimization interval, and static, which indicates
whether the class defines a static or dynamic optimization problem. The proposed syntax for class attributes
is shown in the following optimization class:
optimization DIMinTime (
objective=cost(finalTime),
startTime=0,
finalTime(free=true,initialGuess=1))
Real cost;
DoubleIntegrator di(u(free=true,
initialGuess=0.0));
equation
der(cost) = 1;
end DIMinTime;

The default value of the class attribute static is
false, and accordingly, it does not have to be set in
this case. In essence, the keyword extends and the
reference to the built-in class have been eliminated,
and the modification construct is instead given directly
after the name of the class itself. The class attributes
may be accessed and modified in the same way as if
they were inherited.

4.5

Constraints

Constraints are similar to equations, and in fact, a
path equality constraint is equivalent to a Modelica equation. But in addition, inequality constraints,
as well as point equality and inequality constraints
should be supported. It is therefore natural to have
a separation between equations and constraints. In
Modelica, initial equations, equations, and algorithms
are specified in separate sections, within a class
The Modelica Association

body. A reasonable alternative for specifying constraints is therefore to introduce a new kind of section,
constraint. Constraint sections are only allowed inside an optimization class, and may contain equality, inequality as well as point constraints. In the double integrator example, there are several constraints.
Apart from the constraints specifying bounds on the
control input u and the velocity v, there are also terminal constraints. The latter are conveniently expressed
using the mechanism for accessing the value of a variable at a particular time instant; di.x(finalTime)=1
and di.v(finalTime)=0. In addition, bounds may
have to be specified for the finalTime class attribute.
The resulting optimization formulation may now be
written:
optimization DIMinTime (
objective=cost(finalTime),
startTime=0,
finalTime(free=true,initialGuess=1))
Real cost;
DoubleIntegrator di(u(free=true,
initialGuess=0.0));
equation
der(cost) = 1;
constraint
finalTime>=0.5;
finalTime<=10;
di.x(finalTime)=1;
di.v(finalTime)=0;
di.v<=0.5;
di.u>=-1; di.u<=1;
end DIMinTime;

4.6 Annotations for Specification of the Transcription Scheme
The transcription scheme used to transform the
infinite-dimensional dynamic optimization problem
into a finite-dimensional approximate problem usually influences the properties of the numerical solution. Nevertheless, transcription information can be
considered to be complimentary information, that is
not part of the mathematical definition of the optimization problem itself. Also, transcription information is
closely related to particular numerical algorithms. It
is therefore reasonable not to introduce new language
constructs, but rather new annotations for specification of transcription schemes. This solution is also
more flexible, which is important in order easily accommodate transcription schemes corresponding to algorithms other than the direct collocation method currently supported.
Following the guidelines for vendor-specific annota-

64

Modelica 2008, March 3rd  4th , 2008

OptimicaAn Extension of Modelica Supporting Dynamic Optimization

syntax of Optimica that is supported by this compiler
is different than the one presented in this paper, although the functionality is essentially the same. The
new, improved syntax and semantics that have been
presented in this paper, were defined based on the
comments and experiences from the users of the very
first version of Optimica. A new version of the Optimica compiler, supporting the revised Optimica syntax
is currently under development, with the intention of
replacing the initial prototype.
Figure 1: The transformation from Modelica/Optimica
code to optimization result.
5.1

Code Generation to AMPL

One of the main features of the Optimica compiler is
that it performs automatic transcription of continuous
tions in the specification of Modelica 3.0 [13, p. 147],
variables, using a direct collocation method. The user
a hierarchical annotation for supplying the informais thus relieved from the burden of encoding the coltion needed to specify a direct collocation method
location equations, which is a tedious and error-prone
based on interpolation polynomials has been introprocedure. Whereas the prototype version of the Opduced. This annotation is defined by the following
timica compiler supported one particular collocation
Modelica record:
scheme, future versions will support the annotation inrecord DirectCollocationInterpolationPolynomials troduced above to specify the transcription method.
parameter Real mesh[:];
In order to solve the transcribed optimization probparameter Real collocationPoints[:];
lem by means of a numerical algorithm, the Optimparameter Real
polynomialCoefficientsAlgebraic[:]; ica compiler generates AMPL [7] code. The transcribed problem is purely static, and can therefore be
parameter Real
encoded using the constructs available in AMPL. The
polynomialCoefficientsDynamic[:];
end DirectCollocationInterpolationPolynomials; AMPL representation of the optimization problem can
This annotation enables the user to influence the par- be viewed as an additional intermediate representaticular properties of the corresponding transcription tion format. The purpose of using AMPL is twofold.
Firstly, AMPL provides an additional debugging level,
scheme. For additional details, see [1].
that is very useful during compiler development. In
particular, the AMPL tool offers a shell, where vari5 The Optimica Compiler
ables and constraints can be inspected. Secondly, the
AMPL solver interface provides solvers with sparsity
A new Modelica compiler, entitled the JModelica information, as well as first and second order derivacompiler is currently under development [2, 1]. The tives. This information may be essential for perforcompiler is developed in the compiler construction mance and convergence of a numerical optimization
framework JastAdd, see [9], and in Java. One of the algorithm. The numerical algorithm IPOPT [14] has
primary targets of the JModelica compiler is to provide been used to solve the non-linear program resulting
an extensible compiler, which is suitable for modular from the transcription procedure. The result is then
implementation of new language features. A funda- written to file for further analysis or implementation.
mental design concept is that of modular extensibility, See Figure 1 for an illustration of the transformation
which enables the core JModelica compiler to be kept steps involved when using the Optimica compiler and
intact, since new extensions may be implemented fully AMPL to solve a dynamic optimization problem.
modularized.
A prototype implementation of the JModelica compiler, that also supports the Optimica extension has 6 Summary and Conclusions
been developed. The extended compiler will be referred to as the Optimica compiler in the following. In In this paper an extension of the Modelica language,
terms of the front-end, the compiler supports a subset Optimica, that enables high-level formulation of dyof Modelica, and an early version of Optimica. The namic optimization problems, has been presented. The
The Modelica Association

65

Modelica 2008, March 3rd  4th , 2008

J. Akesson

Optimica extension enables the user to specify impor- [5] H. Danielsson. Vehicle path optimisation.
tant elements of a dynamic optimization problem such
Masters Thesis ISRN LUTFD2/TFRT--5797-SE, Department of Automatic Control, Lund
as cost functions, constraints and optimization interUniversity, Sweden, June 2007.
val. The dynamic model, upon which the dynamic optimization problem is based, is expressed using standard Modelica. Optimica also supports an annotation [6] Dynasim AB. Dynasim AB Home Page. 2007.
http://www.dynasim.se.
that enables the user to specify the properties of a transcription method, based on direct collocation. Because [7] R. Fourer, D. Gay, and B. Kernighan. AMPL  A
of these properties, Optimica supports formulation of
Modeling Language for Mathematical Programdynamic optimization problems, using high-level conming. Brooks/Cole  Thomson Learning, 2003.
structs, both at the mathematical level and at the nu[8] S. Haugwitz, J. kesson, and P. Hagander. Dymerical transcription level.
namic optimization of a plate reactor start-up
A prototype implementation of the Optimica compiler
supported by Modelica-based code generation
has been used in the work on start-up optimization of
software. In Proceedings of 8th International
a plate reactor [8], in two masters thesis projects (see
Symposium on Dynamics and Control of Process
[5] and [10]) and in the PhD course OptimizationSystems, Cancun, Mexico, June 2007.
Based Methods and Tools in Control, that was given
at the Department of Automatic Control, Lund Univer[9] G. Hedin and E. Magnusson.
JastAdd:
sity in September 2007.
an aspect-oriented compiler construction sysAn important objective of the JModelica compiler is
tem. Science of Computer Programming, 47:1,
to offer a modularly extensible Modelica compiler. In
pp. 3758, 2003.
this respect, the experiences and results from developing the Optimica extension are very promising. In [10] H. Hultgren and H. Jonasson. Automatic calparticular, the coding effort needed to implement the
ibration of vehicle models. Masters Thesis
extension of the compiler front-end, including extenISRN LUTFD2/TFRT--5794--SE, Department
sion of the name analysis framework and the flattening
of Automatic Control, Lund University, Sweden,
algorithm, was very moderate.
June 2007.
[11] C. Nytsch-Geusen. MosiLab Home Page.
2007. http://www.mosilab.de/.

References

[12] Process Systems Enterprise. gPROMS Home
[1] J. kesson. Tools and Languages for OptiPage. 2007.
http://www.psenterprise.
mization of Large-Scale Systems. PhD thesis
com/gproms/index.html.
ISRN LUTFD2/TFRT--1081--SE, Department
of Automatic Control, Lund University, Sweden, [13] The Modelica Association. Modelica  a uniNovember 2007.
fied object-oriented language for physical systems modeling, language specification, version
[2] J. kesson, T. Ekman, and G. Hedin. Devel3.0. Technical Report, Modelica Association,
opment of a Modelica compiler using JastAdd.
2007.
In Seventh Workshop on Language Descriptions,
Tools and Applications, Braga, Portugal, March [14] A. Wchter and L. T. Biegler. On the implementation of an interior-point filter line-search al2007.
gorithm for large-scale nonlinear programming.
[3] P. Barton and C. K. Lee. Modeling, simulation,
Mathematical Programming, 106:1, pp. 2558,
sensitivity analysis, and optimization of hybrid
2006.
systems. ACM Transactions on Modeling and
Computer Simulation, 12:4, 2002.
[4] L. Biegler, A. Cervantes, and A. Wchter. Advances in simultaneous strategies for dynamic
optimization. Chemical Engineering Science,
57, pp. 575593, 2002.
The Modelica Association

66

Modelica 2008, March 3rd  4th , 2008

Session 1c
Automotive Applications

The Modelica Association

67

Modelica 2008, March 3-4, 2008

The Modelica Association

68

Modelica 2008, March 3rd  4th , 2008

Detailed Simulation of Turbocharged Engines with Modelica

Detailed Simulation of Turbocharged Engines with Modelica
John J. Batteh
Charles E. Newman
Ford Motor Company, Research and Advanced Engineering, USA
jbatteh@ford.com, cnewman@ford.com

Abstract
This paper describes the development and application of detailed models for the simulation of
turbocharged spark-ignited engines in Modelica.
Following a brief overview of previously-published
modeling capabilities, a new engine architecture that
provides the flexibility required for simulating
boosted systems is detailed. Techniques for turbocharger modeling are discussed followed by sample
steady state and transient simulations that illustrate
potential model usage in design and control applications.
Keywords: cycle simulation; turbocharging; engine;
thermodynamics

1

Introduction

from the engine is routed through a turbine where
exhaust energy is extracted to drive the compressor.
The compressed air is typically fed through an intercooler before being routed to the engine. When compared with naturally-aspirated engines, turbocharged
engines have increased volumetric efficiency and
specific power output thereby enabling engine downsizing. Benefits from engine downsizing include
reduced pumping (throttling) losses for part load operation, potential friction reductions, and also potential reductions in powertrain system weight. It
should be noted that turbocharging does not come
without cost. A few commonly-cited disadvantages
of turbocharged engines are increased backpressure
to the engine, hardware and controls complexity and
cost, and the potential for "turbo lag", broadly defined as the time required from the initial driver
throttle demand to spin up the turbo, increase the
boost, and deliver the requested torque.

The convergence of increasingly-stringent fuel
economy and CO2 emissions standards and an overall increase in the awareness and impact of global
warming trends have led to increased focus on advanced vehicle concepts for improved fuel economy.
Given the historical growth in market share of large
trucks and sport utility vehicles in the US shown in
Figure 1 [1], the focus on improved fuel economy is
especially acute. Vehicle fuel economy is clearly a
system attribute that is affected by a myriad of different factors, including powertrain system configuration, vehicle weight, aerodynamic drag, rolling
resistance, controls and calibration features, and
various component efficiencies in the system. While
OEMs are exploring opportunities in all aspects of
the fuel economy picture, one area of continued focus is on the fuel consumption of the primary
powerplant.
A potential opportunity for increasing fuel
economy of spark-ignited engines is by turbocharging in combination with engine downsizing. The
first patent [2] for a turbocharger on an internal
combustion engine was filed in 1905 by Alfred Buchi, a Swiss engineer. Figure 2 shows a sample
schematic of a turbocharged engine [3]. The exhaust

The Modelica Association

69

Figure 1. US light vehicle market share, 1975-2006 [1]

Figure 2. Turbocharged engine schematic [3]

Modelica 2008, March 3rd  4th , 2008

J. Batteh, C. Newman

The turbocharger introduces strong feedback
between the exhaust and intake systems. Coupled
with the different time scales in the engine system,
robust design and control of turbocharged engine
systems is challenging, even more so with an intense
scrutiny on fuel economy benefits. Thus analytic
capability for detailed simulation of turbocharged
engines is a key enabler for upfront powertrain system design. Potential simulation applications include analytic turbocharger matching and optimization, advanced engine concept assessment, and assessment of transient turbocharger performance.
This paper describes the development and application of detailed models for simulation of turbocharged spark-ignited engines in Modelica [4]. Following a brief overview of previously-published engine cycle simulation capability, new architecture
changes are detailed that allow for configurable, efficient modeling of turbocharged engines. Modeling
of the turbochargers is also discussed, and some
sample steady state and transient results are shown.

2

Engine Model Architecture

Detailed cycle simulation modeling and applications have been discussed in depth in previous publications [5]-[7]. These publications describe an engine model architecture for flexible modeling of the
intake, mixture preparation, combustion, and exhaust
processes for spark-ignited engines. The crankangleresolved model includes submodels for breathing
past the intake and exhaust valves based on discharge coefficients as a function of valve lift, flowbased turbulence generation and dissipation, mixture
preparation and injection dynamics, predictive combustion with laminar and turbulent flame propagation, and heat transfer and thermal warm-up. These
models have been used in both steady-state and transient applications for design optimization and robustness, performance, fuel economy, and cold start.
2.1

shaft, engine block, and intake and exhaust ambient
reservoirs.
The existing architecture provided highly flexible for naturally aspirated engines but did not provide the necessary configurability for boosted applications. Figure 3 shows the new, restructured engine
model architecture. The new structure divides the
engine
along
the
head
(intake_exhaust_system component) and block
(bottom component). The connection between the
head and block is an array based on the number of
modeled cylinders. The head contains the model of
the intake and exhaust system such as the throttle,
plenum, and individual cylinder heads, which contain the fuel injectors and intake/exhaust ports and
valves. The block component consists of the individual combustion chambers which primarily contain
the respective cylinder volumes and combustion
models. One addition to the engine structure is a
replaceable boost device model situated between the intake and exhaust reservoir connectors
and the head component. The constraining class for
this component is of sufficient generality that it can
be replaced by a class which can simulate naturally
aspirated, supercharged, turbocharged, or turbocompounded behavior.

Restructuring

Previous applications of the engine model were
focused on naturally aspirated applications. The existing engine architecture divided the engine into
cylinders with each individual cylinder model containing the intake, exhaust, and combustion chamber
submodels. The architecture supported both single
and multi cylinder applications via engine templates
with replaceable cylinder models. Inside a
given engine template, the instantiated cylinders
were wired to the external connectors for the crank-

The Modelica Association

Figure 3. New engine model structure

2.2

Surrogate Modeling

Single cylinder models are often used to represent multi-cylinder engines due to their computational efficiency. While this representation is more
appropriate for steady-state applications and some
transient applications with prescribed intake and exhaust conditions, it is typically not appropriate for
turbocharged applications where the transient blow-

70

Modelica 2008, March 3rd  4th , 2008

Detailed Simulation of Turbocharged Engines with Modelica

cycle. The total flow is the superposition of all the
flows. Figure 5b shows a surrogate exhaust flow
representation for a single bank of a V6 engine. The
total exhaust flow is not pictured as it obscured the
ability to see clearly the individual surrogate flows.
The dynamic exhaust events from the individual cylinders that are used to drive the turbine are clearly
captured. Note that the phasing changes appropriately based on the number of replicated cylinders.
primary

surr1

surr2

surr4

surr5

total

surr3

0.09
0.07
Air Flow [kg/s]

down pulses from the cylinders provide the exhaust
energy that drives the turbocharger. Crankangleresolved representation of turbocharged engines requires the modeling of the filling and emptying dynamics of the intake and exhaust manifolds to accurately represent the downstream compressor and upstream turbine conditions respectively.
In an effort to retain the computational efficiency of single cylinder modeling for turbocharged
engines, a new structure is introduced consisting of
both primary and surrogate cylinder-head representations. The detailed breathing calculations are performed in the primary cylinder head, which is connected to the detailed combustion model. The resulting flows of chemical species and energy from
the breathing calculations in the primary cylinder are
then replicated in the surrogate cylinder head representations at the appropriate phasing as surrogates
for the contributions of the missing cylinders. The
implicit assumption is that the manifold conditions
are quasi-steady on the time scale of a single, complete firing cycle of the engine.
Figure 4 shows the surrogate flow structure.
Figure 4a shows an engine head model with a single
cylinder intake system mimicking a multicylinder
engine. The intake and exhaust surrogate models are
positioned between the manifolds and the head
model for the primary cylinder. Figure 4b shows a
single instance of the surrogate model. The primary
flow path is broken by a flow sensor that is used by
the surrogate flow source that is instantiated in parallel.

0.05
0.03
0.01
-0.01

-720

-520

-320

-0.03
-120

80

280

480

680

Crank Angle [deg]

(a) Intake flow (I6)
primary

0.18

surr1

surr2

0.16

Exhaust Flow [kg/s]

0.14
0.12
0.10
0.08
0.06
0.04
0.02
0.00
-720

(a)

-320

-0.02
-120

80

280

480

680

Crank Angle [deg]

(b)

(b) Exhaust flow (single bank V6)
Figure 5. Sample intake (a) and exhaust (b) flows

Figure 4. Surrogate flow structure

Figure 5 illustrates the surrogate flow concept.
Figure 5a depicts a surrogate flow representation for
the intake of an I6 engine. There is a single primary
flow with five replicated and phased surrogate flows.
For clarity, only the primary flow is shown from the
first cycle followed by all the flows in the second

The Modelica Association

-520

Several alternatives for the surrogate flow calculations were implemented in Modelica. The alternatives differ in the way in which the surrogate flows
are calculated and provide slightly different numerical results. The traces shown in Figure 5 are from

71

Modelica 2008, March 3rd  4th , 2008

J. Batteh, C. Newman

the DelayedSurrogateFlow model.
This
model uses the built-in delay operator to phase the
mass flow rates for the surrogate cylinders based on
the primary cylinder calculation. It is worth noting
that this implementation yields numerical Jacobians
in Dymola (and in the authors' opinion should not).

3

Turbocharger Modeling

In addition to the engine restructuring to support
inclusion of boost device models, various boost device models were implemented in Modelica. Figure
6 shows a model for an exhaust-driven turbocharger.
The ConfigurableTurboCompressor model
provides a template for turbocharger modeling. It
consists of a turbine component connected to the
compressor
component
by
the
turbine_shaft. There is also a wastegate component on the turbine side and an intercooler
component on the compressor side. Extensive use of
replaceable models allow for flexibility in configuring the template to simulate specific hardware.

Detailed modeling of turbocharger behavior
based on geometric information typically requires
CFD-type simulations. For lumped systems models,
steady-state mapped data, typically provided by the
component supplier from gas stand testing, is often
used to simulate component model behavior. The
mapped data for the turbine and compressor consists
of mass flow rate and efficiency data over a range of
shaft speeds and pressure ratios [8]. Figure 7 shows
a sample compressor efficiency map with annotations showing the various features of the map
(i.e.surge line, choke line, efficiency islands, speed
lines, etc.) [9].

Figure 7. Sample compressor efficiency map [9]

(a) Diagram

Typically the mapped data exists for a rather
limited range of speeds and pressure ratios and must
be extended analytically to ensure model robustness.
There are a variety of ways to implement and/or fit
the map data for component modeling [10]. The following discussion and figures provide some sample
results from the fitting procedure used by the authors.
To account for differences in inlet conditions,
turbine map data is often provided in reduced form.
The map data gives reduced mass flow and efficiency as a function of reduced speed and pressure
ratio as defined in the following equations:

Nr =
(b) Code excerpt
Figure 6. Turbo model

mr =

N
Tinlet

m Tinlet
Pinlet

(1)

(2)

where N is the shaft speed in RPM, m is the flow
rate through the turbine in kg/s, and the inlet pressure

The Modelica Association

72

Modelica 2008, March 3rd  4th , 2008

Detailed Simulation of Turbocharged Engines with Modelica

and temperature conditions are denoted by Pinlet and
Tinlet, respectively. Blade speed ratio (BSR) is defined as the blade speed divided by the isentropic
enthalpy drop across the turbine and can be computed as follows [11]:

2N D
60 2

BSR =

1

1

(3)
2



2hin 1  PR

Normalized Efficiency [-]

where D is turbine diameter, hin is the inlet enthalpy,
and PR is the pressure ratio across the turbine. Note
that BSR is an independent variable that combines
both the pressure ratio and the shaft speed. In an
attempt to collapse the data onto a single line to facilitate fitting, efficiencies and reduced mass flow
rates are normalized. The normalized variables can
then be fit based on a normalized blade speed ratio as
shown in Figure 8.
1

Raw Data

0.8

Fit

0.6
0.4
0.2
0
0.0

0.5

1.0

1.5

2.0

Normalized Reduced Mass Flow [-]

1.6
1.4

Raw Data

1.2

Fit

0.8
0.6
0.4
0.2
0
1.5

2.0

4.1

2.5

Normalized BSReq [-]

(b) Normalized reduced mass flow
Figure 8. Sample turbine fits for normalized variables

Compressor map data is often corrected to reference conditions to account for differences in inlet
conditions.

N

Nc =

Tinlet
Treference

The Modelica Association

Pinlet
Preference

(5)

Simulation Results

The new engine architecture and turbocharger
modeling capability in conjunction with predictive
combustion cycle simulation provide a tool for upfront assessment of advanced engine concepts.
Simulation results from a few sample applications
are provided. The simulations were performed using
Dymola [12].

1

1.0

Treference

where Preference and Treference denote the reference conditions. Similar techniques to those described previously for the turbine can be used to fit the normalized compressor efficiency. A tabular implementation is used for the corrected mass flow data as a
function of shaft speed and pressure ratio.
To facilitate the modeling of new turbocharger
hardware, an external tool has been developed to
generate the fits to the mapped data. Given the raw
map data from the supplier, the tool calculates the
various required fit coefficients for efficiency and
flow rate using least square regression. As shown in
the code in Figure 6b, the replaceable models
for CompressorRelations and TurbineRelations are used to specify the mapped component behavior. Base classes for various types of raw
data (i.e. corrected, reduced, mass flow, volume
flow) and fitting techniques have been created. By
extending from the appropriate base class and providing the fit coefficients, the component map for a
given piece of hardware can be defined and selected
for use in the ConfigurableTurboCompressor.

4

(a) Normalized efficiency

0.5

mc =

Tinlet

2.5

Normalized BSReq [-]

0.0

m

(4)

Steady State

Early concept assessment typically occurs on an
engine dynamometer long before vehicle work begins. These assessments are usually steady state for
performance, fuel economy, and calibration. Surrogate hardware is often used prior to vehicle hardware
availability thereby necessitating a configurable
modeling environment for maximum flexibility.
Figure 9 compares the results from a simulated
load sweep at a fixed engine speed for two different
turbocharged engine concepts. The model was initially calibrated based on experimental data from an

73

Modelica 2008, March 3rd  4th , 2008

J. Batteh, C. Newman

Table 1. Model validation (depicted as percent difference between model prediction and experimental data)

early hardware iteration of Engine A. Following a
major hardware update, the model was updated to
the latest hardware level, and the original calibration
was validated via prediction at a different engine
operating condition. The percent difference between
the model prediction and the experimental data is
shown in Table 1 for various pressure, temperature,
flow, and combustion statistics. The model agrees
well with the experimental data. The model predictions in Figure 9 are purely analytic based on virtual
hardware changes for Engine A and concept Engine
B over operating conditions which were only simulated. The predicted fuel consumption for Engine B
is roughly 3-4% less than that of Engine A. Figure
9b shows the steady state shaft speeds for the two
engine concepts.

4.2

Normalized Fuel Consumption [-]

1.01
Engine A

1

Engine B

0.99
0.98
0.97
0.96
0.95
0.94
0.93
0.92
0.4

0.5

0.6

0.7

0.8

0.9

Normalized Engine Load [-]

(a) Fuel consumption
140
Engine A

120
Shaft Speed/1000 [RPM]

airflow
BMEP
gIMEP
PMEP
ISFC
BSFC
burn010
ca50
caPmax
MAP
CompoutP
CompoutT
ICoutletT
TurbinP
TurbinT

Engine B

100
80
60
40
20

kg/s/cyl
bar
bar
bar
g/kW.h
g/kW.h
deg
degATDC
degATDC
kPa
kPa
K
K
kPa
K

%err
0.078212
-0.051359
-0.241572
0.430916
0.240178
-0.662252
1.421053
2.137423
-0.676617
-0.620951
-0.393695
-0.099168
3.410164
0.095168

Transient

In addition to steady state characterization, transient performance metrics play a crucial role in concept assessment. The ability to provide analytic assessments of transient response is a key enabler for
upfront powertrain system design and optimization.
In particular, transient response metrics are especially important in turbocharged engine applications
to ensure robust hardware and control system design
to mitigate the impact of any potential turbo lag issues.
Figure 10 shows the results for a simulated
throttle transient with Engine A. The simulations
were run at a fixed engine speed. As the throttle
opens, the engine load quickly increases as the manifold pressure approaches compressor outlet pressure.
The resulting rise in exhaust mass flow drives the
turbine shaft to higher speeds, producing additional
boost and increasing the load even further. The transient behavior results from the inertia of the turbocharger shaft, filling and emptying of the intake and
exhaust manifolds, turbocharger performance dynamics, intercooler dynamics, and combustion phasing dynamics. Given the highly-coupled nature of
turbocharged systems, a transient, physical model is
an extremely valuable tool for understanding the
various feedback mechanisms and key parameters
for robust design and system control.

0
0.4

0.5

0.6

0.7

0.8

0.9

Normalized Engine Load [-]

(b) Shaft Speed
Figure 9. Load sweep at a fixed speed

The Modelica Association

74

Modelica 2008, March 3rd  4th , 2008

Detailed Simulation of Turbocharged Engines with Modelica

Figure 10. Throttle transient, Engine A

5

Conclusions

Development and implementation of a new engine architecture in Modelica for the detailed simulation of turbocharged, spark-ignited engines has been
presented. In conjunction with previously-developed
capability for predictive engine cycle simulation, the
models provide a highly-capable platform for analytic, upfront design assessment and optimization for
turbocharged engines. The model predictions have
been validated with experimental data, and the results from several sample applications provide some
insight into potential model usage.

http://modelica.org/Conference2002/papers/p
17_Newman.pdf
[6] Batteh, J., Tiller, M., and Newman, C., 2003,
"Simulation of Engine Systems in Modelica",
3rd International Modelica Conference Proceedings,
pp.
139-148,
http://www.modelica.org/events/Conference2
003/papers/h34_Batteh.pdf
[7] Batteh, J.J., Tiller, M. and Goodman, A.,
2005, "Monte Carlo Simulations for Evaluating Engine NVH Robustness", Proceedings
of the 4th International Modelica Conference,
p.
385-392,
http://www.modelica.org/events/Conference2
005/online_proceedings/Session5/Session5a1
.pdf
[8] Society of Automotive Engineers, 1995,
Turbocharger Gas Stand Test Code, SAE
Standard J1826, SAE Press: Warrendale, PA.
[9] Garrett,
Turbo
Tech
103,
2007,
http://www.turbobygarrett.com/turbobygarret
t/tech_center/turbo_tech103.html.
[10] Moraal, P. and Kolmanovsky, I., 1999, "Turbocharger Modeling for Automotive Control
Applications", SAE 1999-01-0908, Society
of Automotive Engineers.
[11] Heywood, J.B., 1988, Internal Combustion
Engine Fundamentals. McGraw-Hill.
[12] Dymola.
Dynasim AB, Lund, Sweden,
http://www.dynasim.com.

References
[1]

[2]
[3]
[4]
[5]

Davis, S.C. and Diegel, S.W., 2007, "Transportation Energy Data Book: Edition 26",
ORNL-6978,
http://cta.ornl.gov/data/tedb26/Edition26_Ful
l_Doc.pdf
Buchi, Alfred, 1905, Patent No. 204630 from
the Imperial Patent Office of the German
Reich.
Nice, Karim, 2007, "How Turbochargers
Work",
http://auto.howstuffworks.com/turbo1.htm
Modelica Association, 2006, "Modelica Language Specifications (Version 2.2.1)",
http://www.modelica.org
Newman, C., Batteh, J., and Tiller, M., 2002,
"Spark-Ignited-Engine Cycle Simulation in
Modelica", 2nd International Modelica Conference
Proceedings,
pp.
133-142,

The Modelica Association

75

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

76

Modelica 2008, March 3rd  4th , 2008

Thermal Modelling of an Automotive Nickel Metall Hydrid Battery in Modelica using Dymola

Thermal Modelling of an Automotive Nickel Metall Hydrid
Battery in Modelica using Dymola
Helmut Oberguggenberger Dragan Simic
Arsenal Research
Giefinggasse 2, 1210 Vienna, Austria

Abstract
This paper deals with the thermal modelling of an automotive nickel metall hydrid battery. The thermal
modelling will be done in two different approaches.
The result of the distinct approaches will be the same,
though.
The thermal models are implemented in Modelica simulation language and simulated using the Dymola simulation environment, [1].
Thermal and electrical measurements have been
carried out to validate the simulation results of the
thermal modelling and will be presented in this paper.
Keywords: simulation, modelling, nickel metall hydrid Figure 1: Thermal model of the cubical-shaped cell in
battery, validation
Modelica

1

Simple thermal cell models

The first approach is the thermal modelling of a nickel
metall hydrid battery package taking into account the
geometry and temperature distribution during the operation of a single cell.
In this paper a thermal model of a cubical-shaped
package of a battery will be modelled, simulated
and evaluated. The thermal battery model comprises
algebraic and ordinary differential equations. All
components of the thermal battery model are taken
from the ModelicaStandardLibrary, such as Modelica.Thermal.HeatTransfer.
The thermal model of the battery is modelled by means
of discrete volume elements. In this model the coefficients of heat transfer for each discrete volume are calculated. The cell model, cell in figure 1, represents
the thermal model with all inner thermal behaviors.
The heat flow inside the cell in all three directions was
implemented. The model was parametrized using geometrical and thermal measured data of the cell, such
as length, width, thermal conductivity, density of the
The Modelica Association

material etc. The heat losses of the anode and the cathode of the cell are implemented in the external models (anode and cathode in figure 1). The natural
convection in this model is included. Each discrete
volume, which is located on the surface of the modeled cell, contains heat transfer with the surrounding
air. This heat transfer is identified as convection,
figure 1.
Figure 2 shows the temperature distribution of a
cubical-shaped cell in all three directions, x-length,
y-length and z-length. The model considered
500 discrete volumes. Due to the origin of the losses
in the area of anode and cathode the temperatures are
higher in these discrete volumes.
The thermal model of the cell presented in this case
simulates the thermal behavior of a cubical-shaped cell
until the cell temperature reaches its stationary final
value.
For the investigation of the thermal behaviour of the
battery package which includes cylindrical cells, at
first a detailed thermal model of one cell is implemented. This base model includes the same equations

77

Modelica 2008, March 3rd  4th , 2008

H. Oberguggenberger, D. Simic

Figure 2: Simulation, temperature distribution in the Figure 3: Simulation, temperature distribution in the
cylindrical cell
cubical-shaped cell
and models as the cubical-shaped cell model. The anode and cathode of the cylindrical cell model are used
in this case as spiral plates.
The heat losses distribution of the anode and cathode
in this cell is implemented homogeneously. The heat
flow in x and y direction, cross directions, has the same
size and conductivity coefficents . Therefore the model
of the cell is reduced from a 3D to a 2D problem.
This reduced model of the cylindrical cell is used
in this paper for implementation of a battery package which contains more alike cells. Figure 3 shows
the temperature distribution of a cylindrical cell in
all three directions, x-length, y-length and
z-length. The model considered 400 discrete volumes. The discrete volumes in the centre area have
a higher temperature due to the improved losses heat
from anode and cathode, because the heat losses of
each volume of this cell has the same size. As depicted
in figure 3, the heat flow from the center in y direction
is much higher than in z direction. That ocours, because the heat conduction coefficients in x and y direction are much higher than that in the z direction.

2

Thermal model of a nickel metall
hydrid battery package

The simple thermal cell model was used for the implementation and validation of the nickel metal hydrid battery package. This package contains 153 cells,
which were integrated in a steel housing. The cells
have a cylindrical shape in this case. The housing box
has the following geometrical sizes, length 468mm,
width 108mm and height 65mm.
The Modelica Association

Each component of the battery package such as cells
and housing needs a set of thermal and geometrical
parameters which have to be determined prior to the
simulation. They are used of base from cell and housing material specifications, according to [2], [3], [4]
and [5]. For the parameterisation of the final simulation model the parameters have been adjusted and
corrected through measurements results.
The natural convection coefficient in this model is
4.5W /m2  K and the ambient temperature 20C. The
size of this coefficent is used from quiet ambient air,
according to [2]. The thermal conductivity coefficients of the battery package box housing in length,
width and height direction are 254W /m  K, according to [3]. The thermal conductivity coefficients of the
used cylindrical cells in cross direction are 40W /m  K
and in length direction 4W /m  K, according to [4].
The thermal losses of the entire battery package are determined through measured minimum and maximum
temperatures of the entire battery surface. The battery package model was simulated until the simulated
minimum and maximum temperatures were the same
size as the measured temperatures. Then the heat loss
of the entire battery package was determined to be
105.57W . The heat losses of a cell determined using
simulation is 0.69W . The maximum simulated temperature of the battery package is 56C.
The first model of the battery package was simulated
using more than 2800 discrete volumes. The problem
of this discretization of the battery package was that
each volume has more than 50 equations. The entire
battery model has therefore more than 140000 equations and, hence, the simulation of this model was impossible. The size of the model was reduced remov-

78

Modelica 2008, March 3rd  4th , 2008

Thermal Modelling of an Automotive Nickel Metall Hydrid Battery in Modelica using Dymola

Figure 4: Simulation, temperature distribution in the Figure 6: Thermographic picture of the nickel metal
battery package
hydrid battery package

The cells are electrically connected in such a manner
that the requirements for the given automotive application are fulfilled. In Figure 5 one can see the electrical
and mechanical assembly of the nickel metal hydrid
battery package.
The electrical internal resistance of a single cell depends on the state of charge of the cell, and the temperature of the cell.
The current profile for charging and discharging the
the nickel metal hydrid battery package is a symmetrical current profile. Therefore the average state of
Figure 5: Assembly of the nickel metal hydrid battery charge of the cells stays constant. In this case the elecpackage
trical internal resistance only depends on the cell temperature.
ing surfaces where the heat flow rate was zero. With
this optimization of the battery model the final model
has less than 700 discrete volumes and therefore about
35000 equations.
Afterwards, simulation results were compared with
measurement results of the real battery package. Figure 4 shows the temperature distribution of this simulated nickel metall hydrid battery package.

3

Test setup and testing of the nickel
metal hydrid battery package

Thermal and electrical measurements have been carried out to validate the simulation results of both approaches of the thermal modelling. The nickel metal
hydrid battery package consists of 153 single cells.
The Modelica Association

Several temperature sensors are applied in the battery
package to control the temperature. The maximum
temperature of a single cell must not exceed 60C. The
nickel metall hydrid battery is charged and discharged
until the exponential temperature course reaches its
stationary final value. The amplitude of the charge
and discharge current is 9.66A. With this current profile the mean temperature of the battery package after
reaching the stationary final value is 55C.
During the heating-up of the battery pack a thermocamera takes pictures of the pack to get the temperature distribution within the pack. Figure 6 shows a
picture of the temperature distribution of the nickel
metal hydrid battery package shortly before the mean
temperature within the pack reaches its stationary final
value of 55C.

79

Modelica 2008, March 3rd  4th , 2008

H. Oberguggenberger, D. Simic

4 Electrical and thermal modelling
of the nickel metal hydrid battery
package
The stationary final temperature value of the battery
modelled with this second approach will be the same
as the stationary final temperature value simulated
with the first model approach descriped in chapter 2.
The second model approach takes into account thermal
and electrical components. The nickel metal hydrid
battery package is modelled in Dymola/Modelica as a
lump thermal mass with an internal heat source.
The heat supply is caused by the ohmic loss of the
internal resistance of the nickel metal hydrid battery
package, the temperature distribution is assumed to be
homogeneous.
The internal resistance model is temperature dependent, consequently the generated ohmic loss depends
on the temperature. Heat will be taken away from Figure 7: Temperature dependency of the internal
the nickel metall hydrid battery package due to natural package resistance, Ri
convection.
The solved heat equation for a lump thermal mass with
an internal heat source and heat exchange to the ambience is

P
 = a + A
 1  eBt

where
 is the temperature of the nickel metal hydrid battery
package,
a is the ambient temperature,
 is the heattransfer coefficient,
A is the surface area of the package,
B is the heat up exponent and P is the heating power.
P is given as P = Ri I 2 .
Ri is the temperature dependent internal resistance of
the nickel metal hydrid battery package
and I is the terminal current of the battery package.
The temperature dependence of Ri is approximated
with a cubical function as one can see in Figure 7.
The Dymola/Modelica model of the nickel metall hydrid battery pack is charged and discharged until the
exponential temperature course reaches its stationary
final value. The simulated temperature course is almost identical with the measured temperature course Figure 8: Simulated temperature course and measured
of the nickel metall hydrid battery pack.
temperature course of the nickel metall hydrid battery
Figure 8 depicts the simulated temperature course with pack
a red line and the measured temperature course with a
blue line.
The stationary final value of the battery pack is 56C
which is identical with the simulated results of the
thermal model presented in chapter 2.
The Modelica Association

80

Modelica 2008, March 3rd  4th , 2008

Thermal Modelling of an Automotive Nickel Metall Hydrid Battery in Modelica using Dymola

5 Conclusions
In this contribution two thermal models of a nickel
metall hydrid battery pack were presented. The results
of the distinct approaches were the same, though.
The first model approach took into account the geometry and temperature distribution during the operation
of the battery.
The second model approach took into account thermal and electrical components. Special emphasis was
given to the temperature dependency of the electrical
internal resistance of the battery pack.
Thermal and electrical measurements have been carried out to validate the simulation results of the thermal modelling and were presented.
The thermal models were implemented in Modelica
simulation language and simulated using the Dymola
simulation environment.

References
[1] Peter Fritzson, Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1,
IEEE Press, Piscataway, NJ, 2004.
[2] H.D. Baehr and K. Stephan, Waerme- und Stoffuebertragung, vol. 5. Auflage, Springer, 2006.
[3] Dubbel Interaktiv 2.0, Verlag Springer electronic
media, 2002.
[4] VDI-Gesellschaft, VDI-Wrmeatlas, Springer,
2002.
[5] R. Bosch, Automotive Handbook, Robert Bosch
GmbH, Postfach 30 02 20, D-70442 Stuttgart, 5th
edition, 2000.

The Modelica Association

81

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

82

Modelica 2008, March 3rd  4th , 2008

Object Oriented Modeling of a Gasoline Direct Injection System

Object Oriented Modeling of a Gasoline Direct Injection System
Matteo Corno Francesco Casella Sergio M. Savaresi Riccardo Scattolini
Dipartimento di Elettronica e Informazione, Politecnico di Milano,
Piazza Leonardo da Vinci, 32. 20133 Milano

Abstract
The topic of this paper is the object oriented modeling of a Common Rail Direct Injection System of a
gasoline engine. The injection system of a gasoline
engine is described; the main functional elements are
detailed and an object oriented implementation using
the Modelica language is proposed. The availability
of a fast and easily reconfigurable simulator allows to
study how different parts of the system interact and
notably speeds up the design of the final system. The
use of the Modelica language allows to seamlessly put
together mechanics, fluid dynamics, and control algorithms. The design problem can be therefore approached as a whole, in a genuine and modern codesign approach.
Keywords: automotive; fluid dynamics; common rail
injection system simulation.

1

Introduction

In this work we present an object oriented simulator of
a Direct Common Rail Injection System of a gasoline
engine.
The key to designing a clean and efficient ICE (Internal Combustion Engine) lies in precise control of the
combustion. This can be achieved by accurate control
of the flow of fuel and air in the combustion chambers.
Pre-2000 injection systems (such as mechanical carburetors [10] and Multi Point Injection technology [9])
cannot meet todays stringent pollution regulations [8].
The introduction of the Common Rail Injection System technology for Diesel engines [1, 7] in the 90s
represented a great breakthrough. Now, it is possible
to precisely mix fuel and air directly in the combustion chamber. Only a few years had to pass before
the same technology could be applied to gasoline engines [4, 5, 12], thus increasing fuel efficiency and reduce emissions. The cost of these advantages is a more
complex system, both from the standpoint of mechanics and electronics. The higher complexity makes it
The Modelica Association

more difficult to foretell the effects of a modification
of the elements of the system. The design of such a
complex system can greatly benefit from the availability of a reconfigurable simulator. The design process
can be sped up and the cost cut down.
The goal of this work is to describe an object oriented
simulator of a modern Common Rail Injection System
and to show how it can be helpful in the design of the
injection system.
The work is structured as follows. Section 2 describes
the overall architecture of the system. In Section 3, the
mathematical model of the system is derived and its
Modelica [2] implementation illustrated. In Section 4,
it is shown how the model reconfigurability can be exploited for fast sensitivity studies. Finally, conclusions
are drawn in Section 5.

2

Common Rail Injection System

A Common Rail Injection System schematics is depicted in Fig.1; the injection system goal is to deliver
fuel to the injectors at a desired high pressure. The
system can be divided into two sections; a high pressure circuit and a low pressure one. The low pressure
circuit is composed of the fuel tank, a low pressure
pump, filters and a pipeline. The low-pressure circuit
is not critical for the overall engine performance and
therefore it is out of the scope of this work. From the
system dynamics standpoint, the most interesting part
is the high-pressure circuit; it goes from the the highpressure pump to the injectors. Its main elements are
now briefly described:

83

 HIGH PRESSURE PUMP. It is a volumetric
pump that connects the two main circuits of the
system. It is used to increase gasoline pressure
from 6 bar to [30-150] bar, according to the working load and engine speed. The piston of the
pump is mechanically connected to the engine
camshaft through a cam and follower system. In
modern common rail pressure control system the
control valve is built in the high pressure pump.
Modelica 2008, March 3rd  4th , 2008

M. Corno, F. Casella, S. M. Savaresi, R. Scattolini

Figure 1: The Common Rail Injection System architecture.
Three main elements compose the pump: the
piston, the control valve and the one-way valve.
When the control valve is open, the output of the
pump is redirected back to the low-pressure circuit. It has only two states: open or closed and
the switching instant is the control variable of the
system. The one-way valve is used to avoid unwanted refluxes.

vents the gasoline from flowing back from the
manifold to the pump. The manifold is equipped
with a safety valve that opens whenever the pressure in the manifold reaches a threshold. This
valve is designed to function as a safety device
and its opening should be avoided in nominal
conditions.

 DIAPHRAGM. The common rail and the maniTwo phases are periodically alternated: an aspirafold are connected through a diaphragm that retion and a compression phase. In the first phase,
duces the diameter of the pipeline. This compothe piston moves downward while the control
nent provides for a better damping of the system
valve is open. This allows the gasoline to flow
and a partial decoupling between the pressures of
from the low pressure circuit to the pump chamthe manifold and the pressure of the rail. This is
ber. After the piston has reached its lower dead
achieved at the price of a decreased energy effipoint, the compression phase starts. Initially the
ciency of the whole system.
control valve is open and the gasoline flows back
 COMMON RAIL. It is the core of the system.
to the low pressure circuit. At any time during
It is connected to the manifold through the dithis phase the controller can command the cloaphragm. All the injectors are connected to the
sure of the control valve. When it is done, the
common rail. In order to achieve precise injection
pressure in the chamber increases. As soon as
control, the pressure in the common rail must be
it surpasses the pressure in the high pressure cirregulated at the desired reference value, minimizcuit, the one way valve opens, letting the gasoline
ing oscillations.
flow into the high pressure circuit. Notice that
the control variable of the system is the closing
 PRESSURE SENSOR. It measures the pressure
instant of the control valve. The controller must
in the common rail at its end. It is the only presbe synchronized with the pump: when the piston
sure measure available for control.
is at its upper dead point (end of compression),
the ECU (Electronic Control Unit) samples the
pressure sensor output and computes the control 3 Object Oriented Modeling
action. The control action will be executed, at the
earliest, when the piston reaches its lower dead In this section the mathematical modeling of the syspoint.
tem and its implementation in the Modelica language
are described. First, the core of a simplified fluid dy MANIFOLD. The outlet flange of the high- namics library is described and then it is shown how
pressure pump is connected to the common rail it is possible to use the library (along with the Modelthrough the manifold. The one-way valve pre- ica Standard Library) to implement the injection sysThe Modelica Association

84

Modelica 2008, March 3rd  4th , 2008

Object Oriented Modeling of a Gasoline Direct Injection System

replaceable partial function getDensity
"Return density as function
of absolute pressure"
extends Modelica.Icons.Function;
input AbsolutePressure p "Pressure";
output Density rho;
end getDensity;

tem. Modelica turns out to be well suited for aiding
the design of injection systems. Injection systems are
inherently multi-domain systems and the possibility to
change each element of the system without having to
redesign all the interconnections allows to easily study
the effects of different design choices. The use of such
a fast and user-friendly virtual prototyping system can
save numerous iterations of the design-prototypingtesting cycle.

replaceable partial function getBulk
"Return BulkModulus as function
of absolute pressure"
extends Modelica.Icons.Function;
input AbsolutePressure p "Pressure";
output BulkModulus beta;
end getBulk;

3.1 Simplified Fluid Dynamics Library
Being fluid dynamics the most important dynamic
phenomenon of the system, a new simplified fluid dynamics library has been developed. The library is
built on the two new connectors: the flange_in and
flange_out defined as:

replaceable partial function getViscosity
"Return Viscosity"
output KinematicViscosity vcin;
end getViscosity;

connector flange_in
"Connector for the simplified
fluid dynamics library"

end BaseFluid;
import Modelica.SIunits.AbsolutePressure;
import Gasoline_turbo.Types.MassFlow;
The main properties used in the modeling are density,
bulk modulus and kinematic viscosity. The package
flow MassFlow q
allows to add new properties where needed and rede"Mass flow into the flange";
fine how the properties are computed. For example,
AbsolutePressure p
the designer can choose to use a constant value for the
"Pressure at the flange interface";
density or model it as a function of the pressure. This
gives the user a certain amount of freedom whenever
end flange_in;
the fluid properties are not readily available. In this inThe absence of a temperature variable in the connec- jection system study a gasoline package has been imtor deserves a comment; the library is not designed to plemented assuming a linear dependence of the bulk
model thermal interaction. This choice is based on the modulus on the pressure.
consideration that, although thermal interaction does Similarly the BaseMaterial package is defined as:
take place in the system, the focus of this study is on
partial package BaseMaterial
pressure waves. Wave propagation is faster than any
thermal interaction that may happen in the system and
import Gasoline_turbo.Types.*;
therefore heat exchanges can be neglected.
In addition to the connectors, two partial packreplaceable partial function getYoung
ages have been introduced: the BaseFluid and
extends Modelica.Icons.Function;
BaseMaterial. The former representing the fluid
output Young y;
properties and the second representing the properties
end
getYoung;
of the material of the pipeline.
replaceable partial function getPoisson
extends Modelica.Icons.Function;
output Poisson p;
end getPoisson;

partial package BaseFluid
import
import
import
import

Modelica.SIunits.AbsolutePressure;
Modelica.SIunits.BulkModulus;
Modelica.SIunits.KinematicViscosity;
Modelica.SIunits.Density;

The Modelica Association

end BaseMaterial;
end BaseFluid;

85

Modelica 2008, March 3rd  4th , 2008

M. Corno, F. Casella, S. M. Savaresi, R. Scattolini

The main properties of the material are assumed to be
the Young and Poisson moduli. They characterize the
material elasticity, which plays an important role in
pressure waves propagation. In the final implementation, the two moduli are assumed constant, but the
replaceable feature allows to take into account more
complex models. The partial package has been extended into two different types of steel: the manifold
steel and the common rail steel.

velocity in the fluid expressed in m/s; A is the section
area of the pipe expressed in m2 ; and Ff is the load loss
due to friction. The sound velocity term c depends on
the properties of the fluid and the elasticity of the pipe
and it is given by:
s

1
c=
(2)
1 + K 

where  is the bulk modulus that describes the compressibility of the fluid and K is the stiffness of the
3.2 Models Description
pipe that depends on its material and on its geometric
As already mentioned the most important dynamics af- properties. In addition, assuming turbulent flow (this
fecting the system is the propagation of pressure waves assumption is verified a-posteriori) the frictional load
in narrow, long, circular section pipelines filled with a loss can be written as:
compressible fluid. According to the description given
w|w|
in Section 2, the injection system is obtained by con(3)
Ff = 2 2 f
A D
necting the following elements: pipelines, diaphragm,
high pressure pump, and valves. The closed-loop pressure control and synchronization algorithms also need where D is the inner diameter of the pipe and f is the
pipe Fanning friction factor. The final equations are
to be modeled.
Fig. 2 is a graphical representation of the Common partial differential equations. The infinite-dimensional
Rail Injection System. The most important elements system can be transformed in a finite-dimensional one
of the system are depicted in figure and are described by means of the finite-difference method [3, 6]. The
pipeline is divided in N cells, each assumed to have
in the following.
a uniform pressure and an inflow and outflow. The
finite-difference approximations used herein are (the
3.2.1 Common Rail and Manifold
dependence of P and w on t is omitted for the sake of
The DistributedPipe is constituted by two connec- notational simplicity) :
tors, a flange_in and a flange_out and the two reP(i+1)P(i)
P
placeable packages, BaseFluid and BaseMaterial;
x
x 
(4)
w(i)w(i1) for i = 2...N
w

this allows to specify the fluid and material properties
x
x
independently of the wave dynamics model.
The distributed pipe model equations are derived un- In (4), x represents the cell length; P is the mean
pressure within the i-th cell; and w(i) and w(i  1)
der the following assumptions:
are the inlet and the outlet flows of the i-th cell, re1. single component, single phase fluid;
spectively, and N is the number of cells considered.
The discretization must be completed by boundary
2. one-dimensional spatial model;
conditions; this is done using the flange_in and
flange_out connectors already introduced:
3. negligible heat exchange phenomena;
w(1) = flange_in.q
w(N + 1) = flange_out.q
p(1) = flange_in.p
p(N + 1) = flange_out.q

4. straight and constant section pipelines.

(5)
Under these assumptions, the dynamics of the fluid in
the pipeline are described by mass and momentum balances, which can be written as [11]:
These boundary conditions allow to freely connect dif( A P w
+
=
0
2
ferent elements without having to worry about causalc t   x 

(1)
 w

w2
P
ity of the elements, as one would have to do in a signal
t A +  x A2  +  x + Ff = 0
based modeling environment.
In system (1),  is the gasoline density expressed in The distributed pipe is used to model both the mankg/m3 ; w is the gasoline mass flow expressed in kg/s; P ifold and the common rail. The manifold is simply
is the gasoline pressure expressed in Pa; c is the sound modeled by a long distributed pipe; it is connected to
The Modelica Association

86

Modelica 2008, March 3rd  4th , 2008

Object Oriented Modeling of a Gasoline Direct Injection System

Figure 2: A graphical representation of the Injection System Model.
the high pressure pump on one side and to the orifice on the other. The modeling of the common rail
is more interesting because it must be provided with
the connectors used by the injectors. Fig. 3 is a
graphical representation of the CommonRail model. It
shows the model interface and its components. The

Figure 3: A graphical representation of common rail
model.
model is composed of 5 distributed pipes and 4 injectors. The interface is represented by the two main
flanges of the common rail, the 4 flanges of the injectors (which will be described later) and 4 logical signals representing the command signals to the injectors.
The model encapsulates the geometric properties of
the rail (length, diameter and inclination) and the two
replaceable packages Basefluid and BaseMaterial.
As shown in Fig. 1, in the final assembly, one of the
main flanges of the common rail is connected to the
diaphragm, the other to the pressure sensor. The injectors flanges are connected to a constant pressure representing the piston chambers.
The Modelica Association

3.2.2

Diaphragm

The diaphragm is a choking of the pipe. Its function is to increase the damping and by doing so it
also achieves a certain amount of decoupling between
the manifold and the rail dynamics. The narrowing is
coaxial to the fluid flow; thus it can be modeled as concentrated load loss [11]. Having defined p = P1  P2 ,
the flow characteristic can be written as

q
2
2|p|/
  Di
if p > 0
4
1(Di /Do )4
q
w=
(6)
2
2|p|/
  Di
if p  0
4
1(Di /Do )4

where Di is the diameter of the inlet and Do the diameter of the choking.
The resulting model has two flanges; one is connected
to the manifold and one to the common rail. It is important to notice that this element must manage flow
inversion. Flow inversion happens when the pressure
gradient between the two flanges changes sign. From
equation (6), it is immediate to see that when P approaches 0 the Jacobian of the function approaches
singularity. In order to treat this case a linear junction has been implemented. When |P| < , the flow
characteristic is approximated by a linear function.
3.2.3

Injectors

The injectors are one of the elements of the system
most likely to be subject of study; in order to increase
the configurability of the model, the partial model
BaseInjector has been implemented. Its interface

87

Modelica 2008, March 3rd  4th , 2008

M. Corno, F. Casella, S. M. Savaresi, R. Scattolini

is composed of two flanges and of a boolean signal.
In a standard configuration, one of the flanges is connected to the common rail and the other to the cylinder
chamber.
For this study a simple injector model has been implemented. It is modeled as a valve whose opening
request is assumed to be a two-valued variable (openclose). The dynamics of the orifice area is approximated by a first order filter with a pure delay. The relationship between the actual orifice area and the output
fuel flow is assumed to be a non-dynamic relationship
and modeled by a static customizable map depending
on the pressure difference between the two flanges.
Notice that the cylinder chamber can be modeled as
a constant pressure. Although the pressure in the
chamber changes during a piston revolution; the high
pressure in the common rail guarantees that the flow
through the injectors is independent from the chamber
pressure. It is also interesting to note that the injectors
are not subject to flow inversion and thus their implementation is straightforward.
3.2.4

Engine Carrier

In engine control applications, it is a common practice
to write all the control logic algorithms in term of the
engine crankshaft angle. In order to meet this standard,
a mechanism to relate the time independent variable
(needed to simulate wave propagation) and the engine
crankshaft angle independent variable (needed to simulate injection, spark, pumping and control) is necessary. The EngineCarrier model achieves this goal.
The crankshaft is computed as a function of the instantaneous RPM of the motor (an user supplied variable).
By defining an inner EngineCarrier instance in the
model, the user can conveniently provide all the models with the needed independent variable.
3.2.5

High Pressure Pump and Control Valve

The high-pressure pump is one of the most important elements of the system; and, according to the object oriented paradigm, it has been defined as a partial
model BasePump. The partial model only defines its
interface (2 flanges, a command signal, and a real signal describing the velocity of the piston) and its main
components (the replaceable packages fluid and material). This approach allows to easily define and implement different models of the pump.
For the goals of this study the compression dynamics
inside the pump chamber is neglected along with the
dynamics of the low pressure circuit. This is done beThe Modelica Association

Figure 4: High pressure pump cam profiles (4-lobes,
3-lobes, 2-lobes).
cause the chamber volume is negligible with respect
to the volume of the rest of the system. As described
in Section 2, the piston is driven by a camshaft and
the instantaneous gasoline flow is determined by the
velocity of the piston.
wh = 0,

wl = A pist

wh = A pist

dh
,
dt

dh
,
dt

wl = 0,

if control = open
if control = closed

where wl and wh are, respectively, the flow through the
flange connected to the low and high pressure circuit;
A pist is the area of the piston; h is the height of the
piston and control is the state of the control valve.
The other two models needed in order to have a functional high pressure pump are the PumpCamshaft and
the ControlValve models. These two models require
the crankshaft angle provided by an EngineCarrier
instance. PumpCamshaft computes the velocity of the
piston as a function of the crankshaft angle; this is important because different high pressure pump camshaft
profiles may be available, and the ability to easily
switch between them is helpful. Three different cam
profiles have been implemented: 2, 3, and 4 lobes.
They are depicted in Fig. 4. The ControlValve
model determines the state of the control valve. Its interface is defined by 2 input signals (DC and camshaft
angle) and one boolean output signal which represents
the state of the valve. As explained in Section 3.2.7
the DC signal is the control variable; it is the closing
time of the valve expressed as a ratio to the whole high
pressure pump period. The model can be extended to
define more complex behaviors.
3.2.6

Injection logic

The InjectorLogic model generates the command
signals for the injectors. It is possible to specify a
time variant or constant injection time, in seconds, and
an injection phase, in crankshaft degrees. It is therefore possible to simulate engine steady state or transient regimes. It requires the presence of an inner

88

Modelica 2008, March 3rd  4th , 2008

Object Oriented Modeling of a Gasoline Direct Injection System

EngineCarrier instance in the model. In the present
implementation, which is based on real-world specifications, the four injection times are equal and sequentially delayed by 180 .
3.2.7

Control Algorithm

The goal of the common rail pressure controller is to
regulate the pressure to a set point which is computed
as a function of engine rpm and the throttle position. A
known and steady pressure in the common rail allows
to control the injected gasoline with precision by action of the injection time. This can be explained by the
above considerations regarding the injectors; thanks
to the great pressure difference in the rail and in the
piston chambers, the amount of injected fuel depends
mainly on the pressure in the rail and the injection
time. If the pressure in the common rail is maintained
constant without oscillations, then the injected fuel can
be controlled by varying the injection time. Regulation
of the gasoline pressure in the common rail is achieved
in closed-loop, with an additional feed-forward component. The only measurement available for feedback
is provided by the rail pressure sensor whose reading is
sampled when the high pressure pump piston reaches
its upper dead point (start of the expansion phase).
The sampling time of this sensor hence is time-varying
(whereas it is camshaft-angle-invariant). The control
variable is the closing time of the valve measured as
a Duty Cycle. The Duty Cycle (DC) is referred to the
whole high pressure pump cycle, starting with the aspiration phase; therefore a DC of 50% means that the
control variable is closed as soon as the compression
phase begins, whereas a DC of 75% implies that the
control valve is closed in the middle of the compression phase. Hence, this actuator implements a sort of
Pulse-Width-Modulation (PWM). It is clear that, according to this control strategy, the aspiration phase is
a pure delay. Also in this case, notice that the dutycycle is time-varying but camshaft-angle-invariant.
The control algorithm is implemented in the
Controller model.
It has 3 inputs (pressure
measurement, pressure set point and throttle position)
and one output, the Duty Cycle, an Controller
instance provides the variable for scheduling. Fig.
5 depicts the control system block diagram. The
control algorithm is based on a Proportional + Integral
control action whose parameters are scheduled on the
engine speed. The feed-forward component allows
to compensate for the injected fuel. The injected
fuel can be seen as a load disturbance acting on the
plant; although, technically, this disturbance cannot be
The Modelica Association

Figure 5: Control system block diagram.
measured, it can be estimated by knowing the gasoline
pressure in the common rail and the injection time.
The feed-forward term guarantees a faster disturbance
rejection than the one achievable only by the closed
loop term.

4

A Case Study

The implemented model can be used for different
kinds of sensitivity analysis. In this section the simulation results are presented and commented.
Before doing any sensitivity analysis, the fluid parameters have been identified and the model validated.
The model is characterized by a large number of parameters. They belong to two categories: geometric
and fluid-dynamic parameters. Geometric parameters
are easily known; fluid dynamic parameters cannot be
measured easily and inexpensively and therefore they
were experimentally estimated. The parameters that
have been estimated from data are: the gasoline bulk
modulus and the Fanning friction factor of the manifold and of the rail. Note that, although the bulk modulus of the gasoline is known [11], it must be corrected
to account for the elasticity of the pipes which is hard
to be directly measured. All model uncertainties and
simplifications are concentrated in the identified parameters. Fig. 6 shows the final validation results,
by plotting the manifold and rail pressures. Pressures
are normalized with respect to the set point pressure.
The validation data is the result of a workbench test
on a modern turbocharged direct ignition gasoline engine. It is important to note that only closed loop tests
are available for validation; therefore all the following considerations are to be referred to the closed loop
case. The results show that the model is able to accurately replicate the main resonances and damping.
The relevant dynamics are correctly captured. Spectral analysis confirms that the frequency range of validity of the model is approximately 0-1000Hz. It can
be seen from figure that the model is able to reproduce higher frequency dynamics, but the fitting between the simulated and the measured data is not as

89

Modelica 2008, March 3rd  4th , 2008

M. Corno, F. Casella, S. M. Savaresi, R. Scattolini

Figure 6: Simulated and measured pressures in the manifold and in the rail (time-domain; 4000rpm).
good as with lower frequency dynamics. In order to
improve the model accuracy beyond 1KHz, the Fanning friction coefficient dependence on the Reynolds
number needs to be accounted for. Although the identification of such dependence requires considerable efforts; the model can be easily modified to account for
that dependence.
This validation test also shows that the prototype suffers from high pressure peaks. In fact, the pressure in
the manifold raises to levels up to 1.4 times the nominal pressure. The final system will be equipped with
an exhaust valve set to open at about 1.35 time the
nominal pressure. The opening of the safety valve is
to be avoided.
This problem is well suited to be studied with the described model. The dependence of the pressure peaks
has been studied as a function of the diameter of the
manifold. Results are show in Fig. 7, where pressures
are normalized with respect to the safety valve threshold. Thanks to this analysis, it is possible to draw some
interesting guidelines for the design of the manifold:
 the pressure peak problem is sensitive to the engine speed. The higher the engine speed is the
higher the pressure peak is;
 the maximum pressure depends hyberbolically on
the diameter of the manifold;
 an increase of the manifold diameter of 2mm with
respect to the baseline manifold solves the problem.
This is an example of the kind of possible sensitivity
analyses that can be run using the model. Other elements that can be easily studied are: the radius of the
rail, the number of lobes of the high pressure pump
and the static characteristic of the injectors.
The Modelica Association

Figure 7: Manifold maximum pressure as a function of
the manifold diameter increment for different engine
speeds.

5

Conclusions

In this work an object oriented model of a Common
Rail Injection System for a gasoline engine has been
proposed. The focus has been on providing an easily reconfigurable simulation tool that can help the design process. The system has been described in detail and a 1-Dimensional model of the pressure waves
propagation has been derived from fluid dynamics basic principles. The simulator has been validated using bench tests. A case of study in which the model
is used to study the dependence of the maximum pressures reached in the manifold as a function of the manifold diameter has been presented. The case of study
shows that the proposed model is accurate enough to
help co-design of the system, where mechanics, fluid
dynamics and control logic are looked at as an ensemble. These kind of analyses allowed to draw useful

90

Modelica 2008, March 3rd  4th , 2008

Object Oriented Modeling of a Gasoline Direct Injection System

[10] Covington J. P. Modernizing the fixed-venturi
carburetor.
Automotive Engineering, 82(7),
1974.

guidelines for the design of such a complex system.

6 Acknowledgments

[11] Thomas P. Simulation of Industrial Processes for
Control Engineers. Butterworh Heinemann, OxThe Authors would like to thank Emilio Comignaghi,
ford, England., 1999.
Marco Sofia (from FIAT Powertrain srl), Antonio
Palma and Eduardo Sepe (from lasis SCpa) for the
[12] Li J. Z., Treusch C., Honel B., and Neyrat S.
insightful discussions and valuable suggestions.
Simulation of pressure pulsations in a gasoline
injection system and development of an effective camping technology. SAE Technical Papers,
References
01(1149), 2005.
[1] Kouremenos D. A. and Hountalas D. T. Development and validation of a detailed fuel injection
system simulation model for diesel engines. SAE
Technical Papers, 01(0527), 1999.
[2] Modelica Association. Modelica - a unified
object-oriented language for physical system
modelling. language specification. technical report, 2002.
[3] Bertin D., S. Bittanti, and S.M. Savaresi. The decoupled cushion control in ride control systems
for air cushion catamarans. Control Engineering
Practice, 08, 2000.
[4] Alabastri E., L. Magni, S. Ozioso, R. Scattolini,
C. Siviero, and A. Zambelli. Modeling, analysis
and simulation of a gasoline direct injection system. In Proceedings of the IFirst IFAC Symposium on Advances in Automotive Control, 2004.
[5] DErrico G. and Onorati A. An integrated simulation model for the prediction of gdi engine
cylinder emissions and exhaust after-treatment
system performance. In SAE Int. Congress &
Exp. Detroit, 2004.
[6] Strikwerda J. Finite Difference Schemes and
PDE. Wadsworth Brooks/Cole., 1980.
[7] Chiavola O. and Giulianelli P. Modeling and simulation of common rail systems. SAE Technical
Papers, 01(199), 1999.
[8] Official Journal L 044, 16/02/2000. Directive
1999/96/EC of the European Parliament and of
the Council.
[9] Baker P. and Watson H. Mpi air/fuel mixing
gaseous and liquid plg. SAE Technical Papers,
01(246), 2005.
The Modelica Association

91

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

92

Modelica 2008, March 3rd  4th , 2008

Session 1d
Electric Systems & Applications

The Modelica Association

93

Modelica 2008, March 3-4, 2008

The Modelica Association

94

Modelica 2008, March 3rd  4th , 2008

A Multi Level Approach for Aircraft Electrical Systems Design

A Multi Level Approach for
Aircraft Electrical Systems Design
 Martin R. Kuhn

 Martin Otter

 German Aerospace Center (DLR)
Institute of Robotics and Mechatronics
Department of System dynamics and Control
82234 Wessling, Germany

 Loc Raulin
 Airbus France
Electrics System
EDYNE department
31300 Toulouse, France

Abstract

suited. The simulation time of the simplest, architectural level of a model is usually 2 to 3 orders of magniThis paper describes the needs, ideas, implementation tude faster than the most complicated, behavioral level
and application of a multi-level concept used for air- of the model.
craft electrical systems design. The goal is to eas- The following model levels are taken into account:
ily switch between three model levels in a complex
system model, in order to arrive at dedicated models
 Level 1: Architectural level
for the needed simulation tasks: a simple and super
Steady-state power consumption. Usually, algefast model for energy consumption design, a detailed
braic equations describing the energy balance bemodel for fast network stability analysis and a very
tween ports without dynamic response.
detailed model for network quality assessment. SpeTypical use: power budget.
cial care was spent on the modeling assumptions and
a suitable library concept fitting to the needs. For sim Level 2: Functional level
plified unitary testing and configuration management
Steady-state power consumption and mean-value
of the multi-level models a concept was developed.
transient behavior (e.g. inrush current, consumpThe approach is demonstrated with an aviation equiption dynamics with regard to input voltage tranment use case. The usage of the models for stability
sients). Switching is not included.
and quality studies is sketched.
Typical use: network logic studies, network staKeywords: Multi-level modeling, Electrical Network,
bility studies.
Aircraft, DC-DC buck converter, stability analysis,
quality analysis
 Level 3: Behavioral level
Representing actual wave forms including
switching and HF injection behavior.
Typical use: network power quality studies.
1 Introduction to multi-level model-

ing

For industrial design, evaluation and certification process of energy distribution networks, often several
models exist which represent different modeling accuracies of the same system. It is not always useful
to take the most detailed one, as it may not improve
the overall accuracy but will slow down the simulation drastically. Depending on the desired evaluation
of an electrical network (power consumption, network
stability, network quality), system simulations with
models of different levels of accuracy are much better
The Modelica Association

Note: This nomenclature may be used differently in
the literature.
In Figure 1 on page 2 the tree-level concept is illustrated at hand of simulations of a DC/DC buck converter. The architectural layer input current shows
large simulation steps neglecting the detailed effects
which can be seen at the behavioral layer model simulation. The functional layer model covers the waveform of the detailed model without switching effects.
In order to improve the simulation process for design and validation of the Electrical System, there was

95

Modelica 2008, March 3rd  4th , 2008

M. Kuhn, M. Otter, L. Raulin

1

1

1

0.9

0.9

0.9

0.8

0.8

0.8

0.7

0.7

0.7

0.6

0.6

0.6

0.5

0.5

0.5

0.4

0.4

0.4

0.3

0.3

0.3

0.2

0.2

0.2

0.1

0.1

0

0

0.2

0.4

0.6

0.8

1

a) architectural layer

0

0.1
0

0.2

0.4

0.6

0.8

b) functional layer

1

0

0

0.2

0.4

0.6

0.8

c) behavioral layer

Figure 1: Illustration of the 3 layer concept at hand of simulations of a DC/DC buck converter
identified a need for methods to simplify unitary testing and configuration management of suppliers models in order to enhance the coherency of electrical behavior of the various modeling levels of one single
equipment.

2

Modeling assumptions

formation is the standard way of modeling generators
and motors and used for control but is also applicable to 3phase-line impedances. Asymmetric loads are
allowed but will not result in a steady state condition
for this transformation. For an aeroplane multi-phase
power transmission system the following components
are of importance:

While the architectural layer is defined to contain only
 Power source: The generators supply sinusoidal
static energy balance equations and the behavioral
voltage at net frequency. Calculation of voltage
models are close to the hardware level, the definition
and current is usually performed in a rotor-fixed
of the functional models is not as straight forward.
system (synchronous machine)
These models have to be applicable for linearization
for stability investigations with methods of control theory for linear time invariant systems. For DC systems,
 Loads: For symmetrical resistive, inductive and
those have to be deduced from the complex models by
capacitive loads as well as synchronous moaveraging the switching models on a time interval and
tors current/voltage relations are fixed to net freorder reduction techniques.
quency.
For AC systems, the time variant characteristics of
the sinusoidal alternating currents prevents a time invariant steady state condition and hence linearization.
 Other loads: Switches, diodes, unsymmetrical
Therefore it is proposed to use an equivalent represenloads, time variant loads do not have simple
tation which expresses a rotating electric machine in
steady-state dependencies upon net frequency.
a static rotor fixed system (also called Park transforBut: Calculation of the generator demands the
1
mation) . Transforming the system equations to a netuse of transformations anyway. So, incorporating
frequency fixed system results e.g., in "i(t) = i ( net )
other components to the dq0-system will not nec+ i(t)". The model uses i(t) as state and not i(t). In
essarily essentially speed up the simulation but
stationary operation with constant load and constant
will not break it either.
speed, i(t) = 0 and i(t) = i (). This time invariant system also results in much faster simulation. The
transformation output is a representation in d, q and
zero system. The zero system may be skipped for this Limitations for level-triggered switching devices may
application since it is mainly relevant for asymmetric be circumvented by averaged models. Especially for
loads not treated by functional models. Park trans- self commutating rectifiers there is a need for calculating the mean output voltage/current, averaged on a
1 Some results were inspired by the EU Project Realsim (Realcommutation interval. Theory on electric components,
time Simulation for Design of Multi-Physics Systems). It resulted
in the open source library SPOT of H. J. Wiesmann of ABB the transformation and averaged models can be found
for instance in [1].
Switzerland, http://www.modelica.org/libraries/spot
The Modelica Association

96

Modelica 2008, March 3rd  4th , 2008

1

A Multi Level Approach for Aircraft Electrical Systems Design

3

Library concept

The simulation program selects at compile time the
corresponding if-branch, if the branch is determined
3.1 Comparison of methods
by a parameter expression (i.e., in the generated code,
only the equations of the selected branch is present).
Following the demands from chapter 1, methods for
Advantages:
multi-level modeling were investigated which could
replace the current models (behavioral, functional, ar The level can be set by an Integer expression.
chitectural) by one single multi-level model. This
This allows, e.g., to refer to a global setting of
multi-level model shall integrate the separate layers to
the level.
be activated independently from each other. Therefore a methodology is investigated to join models of
 The parameters of all 3 levels are visible and can
different abstraction levels within a single "container"
be set. They remain present, even if the level is
model and supply tools for the automatic selection of
changed. This alternative is useful for base comthe desired level. Three alternatives were identified to
ponents, such as a capacitor or an inductor, that
meet the demands:
are described by equations and do not contain
other model instances.
Alternative 1: Every level is implemented as a separate sub-model. A "generic" model (or template Alternative 3: This is a variant of alternative 2. Evmodel) is utilized in a user model via the Modelica lan- ery level is a separate model. There is a "container"
guage construct replaceable. Via a selection box the model that is used in a user model. The container
"generic" model can be defined to be one of the level model contains all models of the different levels in
models. The connectors of the different levels are ei- form of conditional models. Via a flag, the desired
ther identical or, if this is not possible, they are also model level is activated and the connect statements to
"replaceable". Details may be found in the Modelica the deactivated submodels are removed automatically.
tutorials. Typical problems are:
Advantages:
 It is not possible to select the level by an expression, i.e. it is not possible to select the model
based on the setting of the global default. Instead, at every component the model level has to
be manually changed to the required one.

 Every model level can be built and tested independently from the other levels. Only the connection interfaces need to be the same.
 When switching between levels, the parameter
settings of the other levels remain.

 Whenever the selection is changed (e.g. from architectural to behavioral and then back to architectural), all parameter definitions from the previous selection are lost.

 Parameters that are common to all levels can
be defined in the container object and can then
be propagated to the level models (via Modelica
modifications)

 All levels need the same connectors or the connectors must be replaceable, which makes the de- Disadvantages:
sign complicated.
 In the plot window there is an unnecessary hierarchy, e.g., motor.level2.flange_a.w (on the other
Alternative 2: All layers are described in the same
hand, it becomes very clear which level is conmodel. Via flags different parts of the model are actitained in the model).
vated. In the simplest case, there is just an if-clause:
parameter Integer level(min=1, max=3) = 1 "Model
level";
...
equation
if (level == 1) then
// equations for architectural model
elseif (level == 2) then
// equations for functional model
else
// equations for behavioral model
end if;

The Modelica Association

 The connection lines from the level models to
the interfaces are redundant information (e.g. not
present in alternative 1)
Due to severe disadvantages with implementing this
so called conditional declaration with existing language constructs, an initiative was started in the Modelica Association to improve this situation. As a result,
in the Modelica language version 2.2 from Feb. 2005,
97

Modelica 2008, March 3rd  4th , 2008

M. Kuhn, M. Otter, L. Raulin

conditional declarations have been introduced into
the Modelica language. This language construct has
been supported in Dymola since March 2005 (Dymola
version 5.3c).

3.2

Implementation

model issue1 "my model with several levels"
extends mylib.interfaces.partial_3_levels;
...
equation //for base components:
if level1active then
...;
else
...;
end if;
public //for hierarchical multi-level models:
componentsIssue1.architecturalModel ModelLevel1
if level1active;
componentsIssue1.functionalModel ModelLevel2 if
level2active;
componentsIssue1.behaviouralModel ModelLevel3 if
level3active;
...
end issue1;

Due to their advantages, it was decided to use alternative 2 for basic components, such as capacitors and
inductors and to use alternative 3 for all other multilevel components (using the new Modelica feature of
which extends partial_3_levels:
conditional declarations). Also test equipment, such
as load resistances as function of time, may depend on partial model partial_3_levels
"Parent class that should be included via extend
the accuracy level as well as the connectors. In this for a multi-level model with 3 levels"
section all the details are explained including library
import Choice = mylib.types.level_choice;
parameter Choice.temp level="global option" ;
structuring.
The basic approach is to use multi-level equipment
components in a system model and select in a global
menu the default accuracy level. At every instance of
an equipment model it is possible to define whether the
default accuracy level shall be used (= default behavior) or another one via the level parameter. Possible
options are
global option:
level 1:
level 2:
level 3:

Use globally defined level
Use architectural model level
Use functional model level
Use behavioral model level

"Model level to use (global setting,
architectural/functional/behavioral level)"
protected
outer mylib.components.global_options
global_options;
parameter String actualLevel = if
(level == Choice.global_options) then
global_options.defaultLevel else level;
parameter Boolean level1active = (actualLevel ==
Choice.level1);
parameter Boolean level2active = (actualLevel ==
Choice.level2);
parameter Boolean level3active = (actualLevel ==
Choice.level3);
parameter mylib.components.global_options
global_options_temp( defaultLevel=level);
end partial_3_levels;

. outer references the "global_options" component
in the enclosing environment. Equations and/or dec- The possible choices are defined in level_choice:
larations of a model are activated and deactivated de- package level_choice
pending on parameter actualLevel or the derived biconstant String global_options="global option";
constant String level1="level 1";
nary flags level1active, level2active or level3active.
constant String level2="level 2";
Since actualLevel is a parameter expression (=
constant String level3="level 3";
an expression depending only on literals, constants
type temp
and parameters), Dymola evaluates conditions of ifextends String;
clauses that depend on actualLevel at compile time
annotation (choices(
choice="global option" "use global option
and therefore selects the corresponding if-branch also
at compile time. This means that any change of actu- setting",
choice="level 1" "level 1 (architectural
alLevel requires re-compilation of the system model. level)",

choice="level 2" "level 2 (functional level)",

In order to simplify the multi-level model developchoice="level 3" "level 3 (behavioral
ment, some partial models and classes can be reused. level)"));
end temp;
Models can inherit the multi-level components like the
outer parameter level to define the desired model- end level_choice;
ing level via extends partialmodel . This is demon- With the future implementation of Modelica enumerastrated hereafter with the multi-level model issue1: tions in simulation environments the need for complex
The Modelica Association

98

Modelica 2008, March 3rd  4th , 2008

A Multi Level Approach for Aircraft Electrical Systems Design

Avionic Ventilation System
global_options

DelayLHHLAvion

global

inertial

delay
1e-4, 1e-4

bus

options
defaultLevel=level 1

L=1.e-6
level=global option

AvionicVentilationSystem

chopper
bus

I_in

duty

DC-DC

converter
level = global option

I_out
L=1.e-6
level=global option

issue = 2
resistanceTable
500e-6

load_r

load_c

r

R=10e-3

naming of the choices will become obsolete.
The global_options object which defines the global
setting has to be dragged to the highest hierarchy
level and set to "inner". This defines a "global"
structure that is accessible by all components on the
same or a lower hierarchical level. To generate the
inner object automatically when dragging (inner
mylib.global_options global_options; ), the following
declaration is used (this property is defined via an annotation in the model):

+

model global_options
level=global option
"Global options settings"
annotation (defaultComponentName="global_options",
defaultComponentPrefixes="inner",
missingInnerMessage="A \"global_options\"
input voltage source
output loads
component was introduced with default options.",
ground
...
);
parameter mylib.types.level_choice_default.temp
Figure 2: Test circuit for chopper use case (for all 3
defaultLevel= "level 1" "Default model level
levels)
(architectural/functional/behavioral level)";
end global_options;
busbar

-

Almost identical to level_choice, the global_options 4 Demonstration
object supports choices for the three levels but of
course no choice for global_option itself:
In the following chapter the library concept shall be
package level_choice_default
demonstrated with a generic chopper model (electriconstant String level1="level 1";
cal non-isolated DC/DC buck converter). The conconstant String level2="level 2";
verter is used for transformation of the 270 Volts DC
constant String level3="level 3";
supply to a 28 VDC load network. It was designed
type temp
to include the most important obstacles, e.g. differextends String;
annotation (choices(
ent levels have different interfaces, components, and
choice="level 1" "level 1 (architectural
load profiles. The behavioral model contains nonlinear
level)",
choice="level 2" "level 2 (functional level)", switching semiconductors. Only with this the ripple
detection for high frequency noise is applicable. The
choice="level 3" "level 3 (behavioral
level)"));
functional model is averaged with the output voltage
end temp;
as the duty ratio times the input voltage. The architecend level_choice_default;
tural model lacks of any dynamics. The converter is
As explained earlier, the multi-level container object modeled with an energy balance. A test model for the
for the alternative 3 has to be the superset of the chopper can be seen in figure 2.
connectors of the single models. To avoid unneces- Base components that are solely described by equasary variables, the concept of expandable connec- tions are implemented with if-clauses that depend on
tors can be employed (e.g. expandable connector parameter actualLevel. For example, the inductor is
positive_plug_expandable "Positive expandable elec- defined by:
tric plug"). The content of this Modelica connector is if level1active then v = 0;
defined by the sum of connected variables. With this, else // level 2 or 3
L*der(i) = v;
non identical connectors of the level-dependent models may be connected to the container object connector end if;
but only the data of the level selected are present after This means, for level 1 the dynamics equation is recompilation. E.g. for the transformed/not transformed moved. In the icon of the inductor, the instance name
three phase system, dq transformed components de- (here: inductor), the inductance (here: 1.2e-6) and
mand one extra variable in the connector: the rotor the value of parameter level (here: global option) are
angle. On the other hand just the dq system uses 2 cur- displayed.
rent/voltage connectors while the non transformed abc Other components are implemented with container obsystem uses three of them.
jects and conditional declarations as sketched in alterThe Modelica Association

99

Modelica 2008, March 3rd  4th , 2008

M. Kuhn, M. Otter, L. Raulin

Figure 3: Multi-level chopper component with conditional declaration
Figure 4: Menu of multi-level chopper component

native 3 above. So, the structure of the chopper model
can be seen from figure 3.
In the left part of the figure, the icon of the chopper
is shown. Besides the model instance name, the value
of parameter level is displayed in the icon. In the
right part of the figure, the container object is present.
It contains models of every level. All models are connected to the connectors (p_in, p_out, m, duty, bus) defined in the icon and are defined by conditional declarations:

model issue2
extends mylib.utilities.interfaces.partial_3_levels;
parameter Modelica.SIunits.Voltage v_out_desired
= 28;
...
mylib.chopper.componentsIssue1.level1 Level1(
v_out_desired = v_out_desired) if level1active;
mylib.chopper.componentsIssue2.level2 Level2
( v_out_desired = v_out_desired, k_integrator
Figure 5: Menu of time_table component
= k_integrator, L_filter = L_filter, R_filter =
R_filter) if level2active;
...
equation
1. It is convenient for the user if the parameters of all
connect(Level1.p_out, p_out);
levels are defined as parameters of the container ob...
ject and are propagated to the corresponding models.
end issue2;

For example, component Level1 is an instance of
mylib.chopper.comonentsIssue1.level1 and is only
present if level1active=true. If a component is
used in a connection, such as connect(level1.p_out,
p_out), this connect statement is automatically removed if one or both of the models referenced in the
connect(..) statement are deactivated. Therefore, it is
no longer necessary to manually include an if-clause
around such connect(..) statement as in previous versions of Modelica. Note that the interface of level 1
does not include the duty pin but for the multi-level
container object the pin is skipped if the level is level
The Modelica Association

For example, when clicking on the icon of the chopper
example above, the menu shown in figure 4 is opened.

When using model level 1, only parameter
v_out_desired is actually utilized.
For model
level 3, all parameters in this menu are taken
into account. If the parameters of the levels are
different, it is useful to display them in different
tabs. For example, in the menu of component
mylib.utilities.components.multi_level_time_table
shown in figure 5, different tables can be defined
for the various levels (the purpose is, e.g., to have
different load resistances for the various levels).

100

Modelica 2008, March 3rd  4th , 2008

A Multi Level Approach for Aircraft Electrical Systems Design

5

Application

Functional model

Without going into detail, this chapter is a short outlook on the usage of the models for stability and quality studies.
A regulated buck converter is a typical critical component in a power system. Due to the negative resistance at low frequencies the regulated buck converter
could be unstable in combination with the input filter. Therefore it is necessary to investigate the stability of the whole electric network both at small signal
level for steady state conditions and large signal level
for transients, impacts and network reconfiguration.
The library concept proposed above is a good tool for
its usage since validity of functional models can first
be demonstrated by comparison of simulation results
with the behavioral models. The Modelica functional
models can be used for stability studies with methods for linear time invariant systems. For eigenvalue
based methods, including modal analysis and eigenvalue sensitivity, the eigenvalues have to be calculated
numerically by the simulation program.  analysis is a
powerful method of robust control for stability investigations of parametric varying systems. The Modelica
functional models can be directly applied for  analysis after extraction of the symbolic code and using it
in Maple and Matlab. Compared with other methods
for small signal stability, e.g. Middlebrook criterion
and Modal Analysis, the  sensitivity approach gives
a much more global and direct result for the influence
of all components on stability. For details on the methods, see [2].
In contrast to these approaches, for industrial use stability of a system often is defined as the ability of a
system to keep a certain system variable within desired
limits given by industrial standards. These are combined criteria of network stability, power quality and
performance. This makes them difficult to proof with
methods of linear control theory. Therefore a simulation based approach often is the only possibility to
proof industrial stability and also large signal stability including failure protection devices. Instead of
random or gridded parameter variation on the varying
environment and system parameters, an other method
is to search for the most critical parameter combination
directly. The basic idea is to use an optimizer to find
the criterion from the standards which is most critical
and make it worst by changing the uncertain parameters in the possible range. In case the criterion is violated, stability/quality/performance can be shown to
be not guaranteed. On the other hand, the tolerable design range for parameters could be investigated as the
The Modelica Association

Behavioural model
Parameters p

Trim for
equilibrium

Numerical
linearisation

Parametric
symbolic
linearisation

Nonlinear
dynamic
simulation

Wort-Case
optimisation

Outputs y
LFT-Model
generation

P-Analysis:
Parametric
stability analysis

Stability analysis
(Eigenvalues)

Simulation scenarios:
 short-circuits,
 degradation of mechanical power to drive
generators,
 decrease of voltage or voltage
interruptions,
 load fluctuations.

Figure 6: Quality and stability studies overview
bounds leading to standard violations.
An overview on the methods is shown in figure 6.

6

Acknowledgment

This work was in parts supported by the EU in the "VIVACE project" (http://www.vivaceproject.com/) under
contract number 502917.

7

Conclusion

In this paper a multi-level concept used for aircraft
electrical systems design based on conditional declarations was shown. The three level concept was explained and modeling demands and methods were proposed, especially using park transformation for AC
systems. The implementation was demonstrated with
a multi level DC/DC chopper use case. The model ling
concept improves modeling of large systems and allows easy comparison of different levels simulation result. An overview on typical applications of the models for stability and quality studies was given..

References
[1] Paul C. Krause, Oleg Wasynczuk, and Scott D.
Sudhoff. Analysis of electric machinery and drive
systems. Wiley-Interscience, Piscataway, New
York, 2nd edition, 1998.
[2] M.R. Kuhn, Y. Ji, and D. Schrder. Stability
studies of critical dc power system component for
more electric aircraft using mu sensitivity. In Proceedings of the 15th Mediterranean Conference
on Control and Automation, Athens, 2007.

101

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

102

Modelica 2008, March 3rd  4th , 2008

Incorporation of Reliability Analysis Methods with Modelica

Incorporation of Reliability Analysis Methods with Modelica
Christian Schallert
German Aerospace Centre (DLR), Institute of Robotics and Mechatronics
82234 Wessling, Germany
Christian.Schallert@dlr.de

Abstract

2

A novel method is being developed to combine techniques of safety and reliability analysis with the
Modelica language, which is now widely used for
the modelling and simulation of technical systems.
The new method allows to perform reliability calculations based on the system model that is created and
used for simulation studies. The reliability analysis
procedure is started at the push of a button and determines the so called minimum path sets and the
failure probability of a system automatically.
The incorporated reliability computation methods are
realised initially by a new modelling and analysis
tool supporting concept design studies of aircraft onboard electric power systems.
Keywords: reliability, fault modelling; model object
structure; minimum path set; failure probability

1

2.1

Component Fault Modelling

A variety of object-oriented model libraries have
been developed in the Modelica language, as generally known. In each component model, the normal
operational behaviour is described by differential
and/or algebraic physical equations.
For the purpose of performing reliability analyses,
the component models have to be enhanced such that
also the failure behaviour is described by physical
equations. Basic examples are given hereafter by the
modelling assumptions made for some common electrical components:
An electric wire can be described as an ohmic resistor. For the normal function of the wire, its nominal
resistance Rnom is in the order of 10-1 . An open circuit failure of the wire is characterised by a very
large resistance, e.g. 106 .
p

Introduction

Much of the information needed for reliability calculations is contained already in compound system
models that are usually built in Modelica [1]. The
specific modelling additions needed, as well as the
fundamentals of an automated reliability analysis
procedure are described by this paper.
The procedure evaluates the physical behaviour of a
modelled system in multiple simulations. An addition needed to the modelling is the faulty behaviour
of components, as described in chapter 2.1.
Prior to evaluating the system model by numerous
simulations, its object structure is appraised in order
to detect those combinations of components, that
represent candidates of so called minimum path sets.
Chapter 2.4 gives an overview of the method and
definitions, as well as a way of minimising the computing effort that is involved with this kind of automated reliability analysis.
The Modelica Association

Modelling Approach and Integrated Reliability Analysis Concept

n

Figure 1: Modelica Object Diagram of an Electric Resistor

In essence, the following code defines the model:
model Resistor "Ideal linear resistor"
Interfaces.Electrical.PositivePin p;
Interfaces.Electrical.NegativePin n;
input Boolean FAILED;
parameter Real lambda = 2e-5 failure
rate;
parameter SI.Resistance Rnom = 0.1;
SI.Resistance R = if FAILED then 1e6
else Rnom;
equation
v = p.v - n.v;
0 = p.i + n.i;
i = p.i;
R*i = v;
end Resistor;

103

Modelica 2008, March 3rd  4th , 2008

C. Schallert

A generator can be represented by its DC substitute
properties and the efficiency of converting mechanical into electric power. A basic description of a generator failure is the loss of output voltage, which
stems from an internal failure of the generator or
from insufficient generator drive speed.

Thus, a new Modelica library of electric component
models, that are augmented with a basic failure behaviour, is being developed. In doing so, the fundamental concept of creating component models that
are usable regardless of the application case or
physical context, is being followed. Compatibility
with exisiting model libraries is maintained as well.

2.2
flange

Figure 2: Modelica Object Diagram of a Generator

The following code basically defines this model:
model Generator "DC generator with
losses"
Interfaces.Rotational.Flange_a
flange;
Interfaces.Electrical.DC_Plug_a plug;
input Boolean FAILED;
parameter Real lambda = 1e-4 failure
rate;
parameter SI.Power Pnom = 5e4;
parameter SI.Voltage Vnom = 270;
NonSI.AngularVelocity_rpm speed;
SI.Voltage v;
SI.Power Pelec;
SI.Power Plosses;
SI.Power Pmech;
equation
speed = max(0.1 ,
to_rpm(der(flange.phi));
v = if FAILED then 0 else (1exp(-speed/1000))^2*Vnom;
v = plug.pin_p.v - plug.pin_n.v;
Pelec = v*plug.pin_n.i;
Plosses = 3000*speed*Pelec/(14600*
Pnom);
Pmech = Pelec + Plosses;
Pmech = -flange.tau*from_rpm(speed);
end Resistor;

Each component model has a boolean input signal
FAILED to control its status, i.e. operation or failure.
The status can be shifted during simulation. Failure
rates lambda are stored in each component model as
modifiable parameters. Using constant failure rates is
adequate w.r.t the assumption of an exponentially
distributed component lifetime. Other hypotheses on
the dependency of failure rates on lifetime can also
be taken into account.
The Modelica Association

Integrated Tool Concept

The new library of electric component models, as
well as integrated reliability analysis procedures are
part of a new developed concept design tool for aircraft on-board electric power systems. Besides reliability, the tool is prepared to evaluate architecture
concepts w.r.t. the electric behaviour and weight, as
illustrated by Figure 3.
Large compound models of electric power systems
can be assembled using the graphical model editor of
Modelica/Dymola [2] in the known fashion.

Figure 3: Elements of Modelica based Concept Design
Tool for Electric Power Systems

Aircraft electric power systems are of particular interest for reliability analysis, since they supply a
multitude of loads, many of which fulfil a function
that is essential for safe flight and landing. Also, the
electric demands tend to increase, due to the recent
trend in the design of transport aircraft to replace hydraulic and pneumatic supplies by electric power [3].
Electric power systems on aircraft are typically split
into several independent channels, each comprising
an engine driven generator, a distribution network
and a number of loads. If failures occur, the electric
power system is reconfigured automatically to isolate
the fault and to secure power supply to most of the
loads, with priority to the essential ones. The redundancies and reconfiguration capability of such systems have to be included in the system model accordingly, by means of open/close logics for the
electric network contactors. Thus, the behaviour in
various operational scenarios, e.g. normal, abnormal
or emergency, can be examined in simulations.

104

Modelica 2008, March 3rd  4th , 2008

Incorporation of Reliability Analysis Methods with Modelica

2.3

Modelling Example: Electric Power System

In the following, the integrated modelling and reliability analysis concept is illustrated by the example
of an electric power system of a generic twinjet
aeroplane. The system model, see Figure 4, has been
devised based on a description available in [4].

The electric system model includes the following,
most important components and features:



2.3.1

System Model Features



indicator lamp



generated
power [W]
mode button
consumed
power [W]








Two integrated drive generators IDG1 and
IDG2, which are driven by Engine1 and Engine2, respectively. Each generator provides
115V / 400Hz AC power (substituted in the
model by 270V DC)
through a dedicated generator contactor, GC1
and GC2
on the generator buses, GBus1 and GBus2.
The main non-essential AC loads, represented by
PowerUser1 and PowerUser2, as well as
the AC transfer buses, TBus1 and TBus2 are
connected to the respective generator buses. In
normal operation with both engines running (as
shown in Figure 4), each transfer bus is supplied
by its associated generator bus through a generator bus contactor, GBC1 and GBC2.
The AC cross transfer contactors, TC12 and
TC21, are open in this normal operating case.
28V DC power is provided by two transformer
rectifier units, TRU1 and TRU2, through dedicated switches TRC1 and TRC2, on the DC busbars DCBus1 and DCBus2.
The two DC busbars can be cross-connected
through the DCBTC switch. In normal operation
(Figure 4), the cross-connection is inactive i.e.
the DCBTC switch is open.
Finally, a stand-by busbar DC_STBY_Bus provides for the essential loads DC_Ess_Loads,
which must operate even after a complete loss of
generated power, to maintain safe flight and
landing. In such a scenario, the essential loads
are powered by a battery BATT through the
DC_STBY_Bus.

DC_STBY_Bus

BATT
FailureTopEvent

Figure 4: Electric System Model of a Twinjet Short-Range
Aeroplane, schematic shows Normal Operation in flight

Figure 4 also shows the object-oriented structure of
the system model, which is commensurate with the
general philosophy of Modelica. Note that the electric connections include two poles.

The Modelica Association

The following apparent features are included in the
system model:
 Each contactor has an animated rocker switch to
depict its open / closed status.
 Each component model is fitted with an indicator
lamp. During simulation of the model, the operational (green), passive (grey) or failed (red)
status of each component is shown by the associated indicator lamp.
A component is defined as operational when turning
(e.g. engine), energised with voltage (e.g. busbar) or
conducting current (e.g. switch), whatever is applicable. The passive status is specified as the component being intact but not energised. If a component

105

Modelica 2008, March 3rd  4th , 2008

C. Schallert

has failed, it cannot be energised with voltage or
conduct current, whatever is applicable.
Each component model is provided also with a mode
button for an interactive control of its operative /
failed status. Pressing the mode button of a component, by mouse-click, during simulation will toggle
the status (operational or passive  failed) of the
component.
By means of the mode buttons and indicator lamps
that are provided with the component models, the
behaviour of a system model can be examined interactively during simulation. This is useful when developing the network switching logics, since the resulting behaviour at system level can be checked
quickly and readily.
Furthermore, the following features are included in
the system model:
 Generic power users, which can be connected to
any busbar as needed. The power users are described by basic resistive properties, which can
be set by parameter entries or interactively: The
PowerUser2 shown in Figure 4 has an adjustable
slider bar, which is set by mouse-dragging during simulation.
 Each power user model, as well as the generator
(IDG) models have a numerical indication of the
generated / consumed power in W(att).
 A FailureTopEvent definition at system level
[5], so that the system reliability w.r.t. this event
can be computed. In the present example shown
by Figure 4, the system failure top event is defined as a loss of voltage on the DC_STBY_Bus.

in the model by pressing the corresponding mode
buttons during simulation.

FailureTopEvent

As can be seen in Figure 4, the definition of the system FailureTopEvent has been implemented by connecting a specific voltage sensor named LossOfVoltage to the DC_STBY_Bus. The sensor will flag a
voltage drop-out below a defined threshold by its
logical output signal. This specific voltage sensor
model class is provided by the model library.
Other system failure event definitions are conceivable, e.g. a loss of voltage on other busbars or combined events, such as the loss of voltage on DCBus1
and DCBus2. Any meaningful failure event definition can be implemented in an accordant manner, by
use of the provided sensor class and logical gates.

2.3.2 Degraded System Operation
In Figure 5, a degraded operational mode of the electric system, caused by failures of Engine2 and TRU1,
is shown. The component failures have been injected
The Modelica Association

Figure 5: Twinjet Aeroplane Electric System Model,
Engine2 and TRU1 have failed

The failure effects are, as can be seen in Figure 5:
 IDG2 does not operate. Consequently, the
GBus2 is de-energised, as well as the connected
PowerUser2.
 TBus2 is now energised by the opposite side
through the TC12 switch, which has been closed
automatically.
 All DC busbars DCBus1, DCBus2 and
DC_STBY_Bus are now supplied by IDG1
through TRU2.
 Although degraded, the system is still operational in the complementary sense of the defined
FailureTopEvent.

106

Modelica 2008, March 3rd  4th , 2008

Incorporation of Reliability Analysis Methods with Modelica

2.4

Reliability Analysis Procedure

The reliability analysis procedure is capable of
automatically determining the so called minimum
path sets for a given system model. A minimum path
set is a combination of operative components that
causes a system to operate in the complementary
sense of the defined failure top event. Further on, the
procedure computes reliability measures, i.e. system
failure probability w.r.t. the defined top event, as
well as component importances. For further illustration, results are shown in chapter 2.5 for the modelling example introduced in chapter 2.3.
The reliability analysis procedure draws on two
kinds of information contained in a system model, as
will be depicted: Chapter 2.4.1 explains a method to
evaluate the system model behaviour in terms of operation or failure by multiple simulations. Then,
chapter 2.4.2 introduces a method to interpret the object structure of the system model. Finally, chapter
2.4.3 describes how the two methods are combined
to an automated reliability analysis procedure.

2.4.1 System Model Evaluation by Simulations
A simulation based method evaluates the system
model for combinations of operative and failed components in a specific order. Minimum path sets are
detected by the occurrence of system operation, i.e.
the logical signal FailureTopEvent flagged as false.
Each system model contains the n components C1,
C2,  , Cn. At first, the system model is simulated
for single (k = 1) intact components. Each row 1, 2,
 , n in Table 1 represents one set of operative (OK)
and failed (-) components to test in the simulation.

tected minimum path set are not tested in the simulation. This way, it is ensured that each detected path
set is minimum, meaning that it does not contain any
subset of other path sets.
Table 2: Intact/Failed Components to Simulate, k = 2

12

1n

2n
...

1
2

n

C2
OK



-

Cn
-


OK

-

OK


-

OK

OK


C1
OK

12n

C2
OK




Cn
OK

Apparently, this simulation based method has a character of systematic trial and error. Yet, the computing effort increases significantly with the number of
components contained in a system model. For a system model comprising n components, a total of up to
N sets (rows) have to be checked by simulations:
n
n
N    
k =1  k 

Cn
-

Table 4: Estimation of Computing Effort

n
N

OK

If the system is operational for a row of Table 1, then
the intact component of that row is stored as a minimum path set.
The method continues with simulating for two (k =
2) intact components, as depicted in Table 2. Again,
each row stands for one set of operative and failed
components to test. If minimum path sets of lower
order (k < 2) were found, then those rows of Table 2
that contain all intact elements of a previously deThe Modelica Association



Table 3: Intact/Failed Components to Simulate, k = n


-

C2
OK

If the system is operational for a row of Table 2, then
the intact components of that row are stored as a
minimum path set.
In an analogous manner, the method continues with
the determination of minimum path sets by simulating the system model for intact components up to an
order of k = n, see Table 3.

Table 1: Intact/Failed Components to Simulate, k = 1

C1
OK
-

C1
OK

1
1

2
3

3
7

4
15



10
1023



20
1048575

Consequently, this method of minimum path set determination is only practical for systems including
relatively few components. On its own, this method
is not suitable for analysing the example model
shown in Figure 4, which represents an electric system including 25 components.
So far, the system model is checked only in simulations. A further possibility is to evaluate the object
structure of the system model, as described in 2.4.2.

107

Modelica 2008, March 3rd  4th , 2008

C. Schallert

2.4.2 Object Structure of the System Model
Another method exploits the object structure of the
system model, i.e. the arrangement of components
and connections. Advantage is taken of the fact that
the structure of object-oriented models is similar, although not exactly identical, to minimum path sets.
Thus, a specific algorithm is devised to analyse the
succession of connected components. As a result, the
algorithm yields the different paths of consecutive
and non-repeating components that exist in a system
model. The paths that are determined in this manner
are considered as minimum path set candidates.
The fundamentals of this kind of algorithm are described hereafter. It is realised as a recursive model
parser in Modelica. In the listing, the notations component1, component2 and path indicate variables.
1. Begin at the FailureTopEvent gate of the system
model and add it as component1 to the path.
2. Find all components connected to component1.
3. If no components are connected to component1
then terminate the actual recursion branch.
4. If one component is connected to component1
then take it as component2 and continue with the
actual recursion branch,
5. else if more than one components are connected
to component1 then start a new recursion branch
for each component taken as component2, respectively.
6. If component2 is not contained in path yet then
add component2 to path and resume at step 2
taking component2 as the next component1,
7. else terminate the actual recursion branch.
The result of this system model object structure
analysis are paths that are considered as minimum
path set candidates. These are illustrated graphically
in Figure 6 for the electric system introduced in
chapter 2.3. A representative selection of the 29
paths determined for this example is shown.

2.4.3

Combination of Object Structure Analysis
with Simulation Based Method
As mentioned, the found paths are considered as
minimum path set candidates. Therefore, these candidates are checked by simulating the system model
accordingly, to eventually extract the minimum path
sets from the list of candidates.
In this method, the system model is simulated for
each candidate, such that the components belonging
to a candidate are switched to the intact mode one
after another, while all other components of the system are failed. System operation or failure is detected in the simulation by evaluating the logical signal FailureTopEvent. If the system operates, then the
causing set of intact components is stored as a minimum path set.
The number of path candidates to be checked in the
simulation is limited, hence conducting an object
structure analysis first and then simulation minimises
the overall computing effort. Thus, the combination
of both leads to a reliability analysis procedure that
is viable even for large systems with many components.
After the minimum path sets of a system have been
determined, reliability measures can be computed.
The probability of occurrence belonging to each
minimum path set, i.e. the system operates, MPi is

P(MPi ) =

 (1  p ) , with the components C
i

i

and

Ci MPi

the individual failure probabilities pi.
Assuming an exponentially distributed lifetime [6]
for the components Ci leads to failure rates i that are
constant over lifetime. The probability of a component failure is

1  e t , t  0
pi (t ) = 
 0 ,t < 0


Figure 6: Model Object Structure Analysis: Graphical Representation of Several Minimum Path Set Candidates

The Modelica Association

108

Modelica 2008, March 3rd  4th , 2008

Incorporation of Reliability Analysis Methods with Modelica

Since the occurrence of at least one minimum path
set causes the system to operate, the probability of
system operation can be calculated according to
Poincars formula [6] as

Psystem operation ( pi ) = P (MP1  MP2  ...  MPn )
n 1

=  (MPj )  
n

j =1

 P(MP  MP ) + ...
n

i =1 j = i + 1

+ ( 1)

n +1

i

j

P (MP1  MP2  ...  MPn )

with n being the number of minimum path sets.
Generally, i.e. for a single component or a complex
system, the following equation holds

2.5

To illustrate the reliability analysis procedure, results
are shown below for the modelling example of 2.3.
Table 5 lists the components that appear in the system model with the related failure rates i.
The exposure time is set to t = 1h for simplicity, so
that the failure probabilities are: pi (t )   i
Table 5: Electric System Model Components List

p failure (t ) + poperation (t ) = 1

which eventually allows to calculate the probability
of system failure.
Another useful reliability measure are component
importances, which help to identify potential weak
points or unnecessary redundancies in a system. Several definitions of importances exist. Here, the definition of marginal importances, that indicate the
structural and probabilistic influence of a component
i in a system, is given by

I m arg (i ) =

Psystemoperation ( pi )
pi

Reliability Analysis Results for Modelling
Example

with 0  I m arg (i )  1

To summarise, Figure 7 gives an overview of the entire concept of incorporating a reliability analysis
procedure with the Modelica language.

i
1
2
3
4
5
6
7
8
9
10
11
12
13

Ci

i
[1/h]
Engine1 10-5
Engine2 10-5
IDG1
10-4
IDG2
10-4
GC1
10-6
GC2
10-6
GBus1
10-7
GBus2
10-7
TBus1
10-7
TBus2
10-7
GBC1
10-6
GBC2
10-6
TC12
10-6

i

Ci

14
15
16
17
18
19
20
21
22
23
24
25

TC21
TRU1
TRU2
DCBus1
DCBus2
TRC1
TRC2
DCBTC
DC_STBY_Bus
BATT
BATC
DCBC1

Figure 7: Concept of Reliability Analysis Incorporation with Modelica

The Modelica Association

109

Modelica 2008, March 3rd  4th , 2008

i
[1/h]
10-6
210-4
210-4
10-7
10-7
10-6
10-6
10-6
10-7
0.001
10-6
10-6

C. Schallert

2.5.1 Scenario 1: DC STBY Bus Energised
In Figure 8, the five minimum path sets determined
for the electric system and the scenario
DC_STBY_Bus energised, which is the complement of loss of voltage on DC_STBY_Bus, are
graphically shown. The system operates, i.e. the
DC_STBY_Bus is energised, if all components of either minimum path set are operational. For the opposite case, the probability of system failure is computed as

2.5.2 Scenario 2: DCBus1 and DCBus2 Energised
In a different scenario, the loss of voltage on
DCBus1 OR DCBus2 (or both) is examined for the
same electric system. Figure 10 shows the implementation of this scenario in the system model. In
the complementary sense, system operation means
that both busbars, DCBus1 and DCBus2, are energised.

Psystem  failure = 1.01210-7
Figure 9 shows a plot of the component importances.
Altogether, the analysis result can be interpreted
such that for the given scenario, the system failure
probability is dominated by a failure of the
DC_STBY_Bus itself, followed by failures of the
DCBus1 and the contactor DCBC1. The influences
of the three redundant voltage sources IDG1, IDG2
and BATT, that can energise this busbar are much
smaller.

DC_STBY_Bus

BATT

FailureTopEvent

Figure 10: Implementation of Scenario 2 in System Model

Figure 8: Graphical Representation of the five Minimum Path Sets for Scenario 1 DC STBY Bus energised

Figure 9: Component Importances for Scenario 1 DC STBY Bus energised

The Modelica Association

110

Modelica 2008, March 3rd  4th , 2008

Incorporation of Reliability Analysis Methods with Modelica

In Figure 12, the eight minimum path sets are depicted that were identified for this scenario. The
probability of system failure has been calculated as

Psystem  failure = 2.53210-7
An interpretation of this result is that again the system failure probability is influenced mostly by busbar failures themselves, as it is indicated also by the
importances shown in Figure 11. Other contributions
arise from the busbar cross contactor DCBTC and
from most of the upstream electric network components. The DC_STBY_Bus and the BATT have no influence since DCBus1 and DCBus2 can be energised

only by the generators IDG1 or IDG2 through the
network.
In summary, the example results demonstrate the capability of the novel reliability analysis procedure
incorporated in Modelica to evaluate complex system architectures. The procedure is started at the
push of a button and automatically computes the
results without any further action required from the
user.

Figure 12: Graphical Representation of
the eight Minimum Path Sets for Scenario
2 DCBus1 and DCBus2 energised

Figure 11: Component Importances for Scenario 2 DCBus1 and DCBus2 energised

The Modelica Association

111

Modelica 2008, March 3rd  4th , 2008

C. Schallert

3

Conclusions and Outlook

Acknowledgements

A new method to enhance Modelica with the capability of conducting reliability analyses is outlined.
The incorporation of automated reliability analysis
methods with Modelica broadens the scope of the
language, thus being able to support design studies
of redundant and safety critical systems, where sufficient system reliablity has to be demonstrated.
The methods are realised initially by a new, Modelica based modelling and analysis tool for aircraft onboard electric power systems. System models can be
built and simulated in the known fashion using components from existing and a specific new model library. Then, a reliability analysis can be performed
for the same system model at the push of a button.
The analysis procedure automatically detects the so
called minimum path sets of a system. Further on,
reliability measures are computed, like system failure probability, e.g. for the partial or total loss of
voltage, as well as component importances. These
give insight to potential weakness or unnecessary redundancy that may exist in the design of a system.
Future work will oriented to
 an extension of the reliability analysis procedure,
such that it can examine models containing differential equations. The procedure is devised initially for system architecture studies, which are
usually carried out on models that solely consist
of algebraic equations.
 the creation of an automated power sizing analysis: Minimum path sets represent the different
operational scenarios of an electric system, so
these scenarios can be evaluated in simulations
to determine the maximum power that each
component carries [7]. This is affecting the sizing and hence the weight of components. Another possibility is to conduct a power availability analysis, i.e. to compute probabilities for the
amount of electric power available on a busbar.
 a widening of the fault modelling, such that each
electric component model can be simulated for
several kinds of malfunction, e.g. open circuit,
short circuit, short circuit to ground etc. This will
permit to run so called minimum cut sets analyses, leading to an even more comprehensive assessment of system safety and reliability.
 developing features for an improved graphical
representation of the analysis results.
 a transfer of the methods to other physical domains, as well as non-aerospace applications.

The Modelica Association

This research is being conducted in the frame of the
MOET project (More-Open Electrical Technologies), a FP6 European Integrated Project [8].
The author wishes to thank the electrical engineering
department of Airbus-France for their support being
the first beta tester of the tool prototype.

References
[1]
[2]
[3]

[4]

[5]

[6]

[7]

[8]

112

Modelica Language. http://www.modelica.org
Dynasim Dymola. http://www.dynasim.se
Moir, I. and Seabridge A. (2001). Aircraft Systems: Mechanical, Electrical and Avionics
Subsystems Integration. AIAA Education Series, ISBN 1-56347-506-5.
Wild, T. W. (1996). Transport Category Aircraft Systems. Jeppesen Sanderson, Inc. ISBN
0-88487-232-7.
Lloyd E. and Tye W. (1982). Systematic
Safety  Safety Assessment of Aircraft Systems.
Civil Aviation Authority (CAA), London,
ISBN 0 86039 141 8.
Meyna A. and Pauli B. (2003). Taschenbuch
der Zuverlssigkeits- und Sicherheitstechnik.
Carl Hanser Verlag Mnchen Wien, ISBN 3446-21594-8.
Schallert, C. (2007). A Novel Tool for the
Conceptual Design of Aircraft On-Board
Power Systems. SAE AeroTech Congress and
Exhibition, Los Angeles, CA.
MOET Project. http://www.moetproject.eu

Modelica 2008, March 3rd  4th , 2008

Simulation of Distributed Automation Systems in Modelica

Simulation of Distributed Automation Systems in Modelica
Florian Wagner
Liu Liu
Georg Frey
University of Kaiserslautern
Erwin-Schrdinger-Str.12
D-67663, Kaiserslautern, Germany
{wagner | liuliu | frey}@eit.uni-kl.de

Abstract
The increasing application of network technologies
and smart embedded devices in the field of automation and control leads to new distributed system architectures. The analysis of the resulting distributed
automation systems requires models that cover physical processes as well as computing and communication devices. Modelica as multi-domain modeling
language offers the necessary support to build such
models. While, for physical systems, there are many
Modelica libraries, only limited support for the modeling of computation and communication is currently
available. This gap is filled by the presented network
and controller libraries. The network library currently
supports switched Ethernet, WLAN, and ZigBee. The
controller library offers different types of controllers
as well as interface devices. Implementation aspects
of the presented libraries are discussed in some detail
and their application is illustrated by examples.

1

Introduction

As automation systems are constantly increasing in
complexity, new methods for controller design have
to be applied. One promising approach is the concept
of Distributed Automation Systems (DAS). Though
distribution simplifies the design of complex control
applications, analysis is more difficult than in traditional monolithic or strictly hierarchical systems.
Distributed systems have a concurrent nature. Hence,
coordination and synchronization are needed between
the individual control devices. This is usually
achieved by means of networks. Because of the inexpensiveness of components, the plug-and-play abilities and the possibility for information access from
higher level business units, standard networks like
Ethernet currently tend to replace special purpose
networks (ASI, ProfiBus, ...) in automation.
To design and analyze an automation system, the
engineer relies on tool support. Individual tools for
The Modelica Association

algorithm analysis, network analysis and process simulation are available. However, the isolated analysis
of any of these aspects does not meet the engineers
requirement of analyzing the closed-loop behavior of
the system where the controller interacts with the
controlled process via the network.
A simulation environment covering all aspects of
distributed automation systems is Matlab/Simulink
with the TrueTime [1] toolbox. Matlab/Simulink is a
well-known tool for controller design and process
simulation. TrueTime adds models for network and
controller hardware. As Matlab/Simulink is used as
platform, the analysis benefits from its advantages
(widely spread, many process models available) but
also inherits its disadvantages. Here, especially the
causal
procedural
modeling
approach
in
Matlab/Simulink complicates the design of complex
process models and hinders the reuse of components.
Modelica, as a multi-domain modeling language,
with the object oriented modeling paradigm and the
non-signal-flow-dependant model causality, which
increases the reusability of process models, is another
adequate basis for overall system analysis.
The paper presents an approach for simulation of
networks and controller hardware in Modelica in
combination with process models, also modeled in
Modelica. Means to analyze both, the functional and
the temporal behavior of the overall system in early
development stages are provided. First analysis results have already been presented in [2].
This paper focuses on the description of the developed libraries, including implementation details. In
the next chapter, the used modeling objective is presented. Chapter 3 describes a library for simulation of
network components. Together with the controller
library, rendered in chapter 4, it is possible to model
distributed automation systems. Both libraries have
been implemented and tested with Dymola 6.1. Application examples of the presented libraries are given
in chapter 5. Finally, conclusions are drawn and an
outlook on future work on the libraries is given.

113

Modelica 2008, March 3rd  4th , 2008

F. Wagner, L. Liu, G. Frey

2

Modeling Objective

As in all simulation applications the initial step of the
designer is to identify components and effects to be
considered in the simulation. Based on this identification the next step is to decide about the modeling
approach for implementation. In the case of distributed automation systems we have chosen a structure
conserving modeling approach, mapping real world
components to individual models. Figure 1 shows an
archetype of a distributed automation system and the
component models provided by the Modelica libraries presented in the following chapters.
Medium
(Cable)
Intermediate
System
(Hub)

Intermediate
System
(Switch)

Medium
(Cable)

Medium
(Cable)

Medium
(Cable)

Transceiver
(NetworkCard)

Transceiver
(IC)

Transceiver
(Network
Extension)

Controller
(IndustrialPC)

I/OBoard
(RemoteI/O)

Controller
(PLC)

Process

Figure 1: Archetype of systems that are to be covered
by the presented librarys.

3

Basically, the components of the archetype can be
divided in three domains:
The first domain (dark shading) covers the network.
A network consists of one or more communication
media (Medium). In the case of Ethernet this is usually a twisted pair cable. If more than one Medium is
used, coupling devices (Intermediate System) have to
be used. In Ethernet an Intermediate System, could be
a hub or a switch. To access the Medium a Transceiver is used. It manages all physical and protocol issues
necessary for proper communication over the network. The network card of a PC is an example of a
Transceiver.
The second domain (light shading) covers components related to data handling and process interfacing.
The components Controller and I/O-Board can be
regarded as embedded devices. The control algorithms are executed in Controllers (e.g. industrial PCs
or PLCs). In general, a Controller has access to the
network via a Transceiver as well as access to the
controlled process via directly connected sensors and
actuators. I/O-Boards are a simplified version of a
The Modelica Association

Controller and allow remote access to sensors and
actuators via the network. Usually, I/O-Boards have
only limited processing abilities and are not used to
execute control algorithms.
Components of the third domain (no shading) are
related to the physical process.
There are three types of interconnections between
components. Network connections (dashed edges)
describe data wrapped in a protocol frame, dependant
on the network type used. Pure data transport is indicated by dotted edges. The exchange of physical values is shown as solid edges.
Based on the domain classification of components in
distributed automation systems, in chapter 3, a Modelica library for network components is presented.
The library described in chapter 4 covers the components related to embedded devices for process control.
Both libraries make intensive use of the object orientation abilities of the Modelica language. Interface
models are used to allow the exchange of components
with similar behavior. Wherever possible and appropriate, components implement a predefined interface
or are extended from other existing models. Along
with the Modelica keyword replaceable, this allows
e.g. a wide variety of controller models based on a
small number of basic components. In the figures of
component models replaceable component models
can be identified by the gray shaded box around them
(e.g. Figure 10 component CPU).

3.1

Network Library
Structure of the library

The network library consists of fundamental components which cover the important issues in the area of
network transmission, e.g. communication media,
intermediate systems, transceiver interfaces, etc. The
rule of structure conserving modeling is held. I.e., the
network is not modeled as a single class but all the
fundamental components are explicitly modeled. The
main advantage of this modeling approach is that the
network topology, which can have significant influences on the network performance, is visible.
Currently, the library (Figure 2) supports three widespread transmission protocols, namely, fully switched
Ethernet [3], WLAN [4] and ZigBee [5]. To increase
simulation speed, the protocols are simplified to some
extent, thus, only the chosen dominant factors related
to the automation system are modeled. Especially
noteworthy is the fact that in the network components, only the physical and data link layers of the
ISO/OSI model are considered and also here some
abstractions have been made. Necessary interfaces for

114

Modelica 2008, March 3rd  4th , 2008

Simulation of Distributed Automation Systems in Modelica

the exchange of events are also included. In the Functions library, external C functions and corresponding wrap functions in Modelica can be found. External functions are used to simplify information exchange, especially for the formatted string communication. In the Examples library, application templates
are given for each protocol, illustrating how to build a
networked system using the models.

ler determines when to read the data from the network message stored in the receiver queue.

Figure 2: Tree view of the network library.

Figure 4: Queuing mechanisms in the Transceiver.

3.2

Application template of the network library

Figure 3 shows a typical application example of a
ZigBee network. The dark shading blocks on the leftmost side represent primary controller models. They
provide the data to be sent and read the data from
network messages regardless of the underlying
transmission protocols. In the middle there are two
transceiver modules connected to the controller and
the shared medium. The transceiver module together
with the medium defines the transmission protocol. In
the example, controller A sends messages to controller B via the network while B does the same to
A.

Figure 3: Application template of a ZigBee network.
The source controller renews the data to be sent cyclically and writes the message into the send queue of
the transceiver module. Based on the network state
and medium access algorithm, the transceiver module
decides when to send the network message. After the
transmission duration has expired, the network medium writes the message into the receive queue of the
destination transceiver. Then, the destination controlThe Modelica Association

3.3

Implementation of the queuing system

As noted above, the transceiver module serves as an
interface between the controller and the network. In
addition to the medium access control, it has to accomplish the information exchange. A transceiver
interacts with both, the controller and the medium (cf.
Figure 4).

Thus the information flow in a transceiver is bidirectional. Furthermore, the information flow in one direction is split into two segments due to the unsynchronized behaviors of controller, transceiver and
network. To manage the information flow, FIFO
queues are utilized. Each information flow segment is
represented as a FIFO queue. The two nodes on both
ends of the same information flow share the access to
the same queue. The FIFO queue system is implemented as external C functions to simplify the
Modelica code and reduce the number of events. The
interface functions in Modelica are given as:
QueueID=CreateQueue(QueueSize);
Enqueue(QueueID,MessageID);
MessageID=Dequeue(QueueID);
Index=ReadQueueIndex(QueueID);

CreateQueue(QueueSize) creates a queue with given
length and returns a unique ID. Enqueue(QueueID,
MessageID) stores the MessageID in the first free
place of the queue. Dequeue(QueueID) reads the first
message from the queue and shifts the rest of the
queue one place towards the beginning position.
ReadQueueIndex(QueueID) returns the current position index. The entries of a queue are message identifiers. Each message (string) is indexed with a
unique integer ID. This utility is supported by a
C++ library.
Figure 5 illustrates the information exchange in
queues for the example from Section 3.2. New data
(string) from the controller is represented by an identifier (ID1). This ID is enqueued in DataSendCache.
In the next step, ID1 is dequeued and the actual content of ID1 is encapsulated to a frame with protocol
header. Thus, a new message (string) is produced and
a new identifier (ID2) is enqueued in FrameSendCache. In the transmission, medium dequeues the

115

Modelica 2008, March 3rd  4th , 2008

F. Wagner, L. Liu, G. Frey

ID2 and makes a copy named ID3. Later after the
transmission, ID3 is enqueued in FrameRcvCache on
the destination side. Finally, ID3 is decapsulated and
a message ID4 is enqueued in DataRcvCache. During
the whole procedure, each time the Dequeue() function is called, a copy of the dequeued message is
made and the original message is deleted. Hence, the
message ID4 and ID1 actually have the same content.
The information exchange is accomplished.
DataSendCache
...

ID1

...

FrameSendCache
...

ID2

Medium

...

ID3
DataRcvCache
...

ID4

...

ID1

Data

ID2

Header+ Data

ID3

Header+ Data

ID4

Data

...

...

FrameRcvCache
...

ID3

...

String repository

Figure 5: Queue operation in a transmission.
3.4

Implementation of Ethernet

The implemented Ethernet protocol is abstracted
from a fully switched, full-duplex Ethernet. The network behavior is illustrated in Figure 6.

Figure 6: State diagram of Ethernet protocol.
A twisted-pair cable is taken as the modeling pattern
for a medium in Ethernet. Since no collisions are
considered, the end of a cable can only be connected
to one transceiver. In a simulation, the cable model
receives request events from connectors on both ends
and sends out notifications on connectors after the
internal processing.
3.5

Implementation of wireless communication

In principle, the network is modeled as a discrete
event system. It reacts on external events with deterministic or non-deterministic delays. The modeling
focuses on the standard MAC layer taking into account random access and conflict handling.
The implementation of the protocol is divided into
software and hardware parts. The software part covers medium access, frame format etc. It is the algorithm integrated in the transceiver and intermediate
The Modelica Association

system. The hardware part is the communication medium. The communication state, the transmission
duration and other relevant variables are decided by
electromagnetic characteristics of the medium. From
this point of view, there is always a clear relation
between the network protocol and the underlying
physical medium. In the presented approach, parts of
the protocol codes from the transceiver model are
moved into the medium model. In other words, the
medium is designed with some extent of intelligence.
In wireless communication, it is not possible to listen
while sending because of the nature of the channel
(frequency band). Hence, the Collision Avoidance
(CA) method is used to improve the performance of
Carrier Sense Multiple Access (CSMA). In principle,
a network node always listens to the channel and
sends only if the channel is sensed as idle. The implementation of this protocol is separated into two
parts, namely, the medium part and the transceiver
part. The interaction between medium and transceiver
is realized by Network_Port which can be found in
Network.Interfaces.
There are two main differences between the
CSMA/CA algorithms for ZigBee and WLAN on the
MAC layer:
1. WLAN has an unlimited number of retries, while
ZigBee is strictly limited on retries.
2. ZigBee assesses the network state only at the end
of the whole backoff time, while WLAN checks
after each single delay unit.
Then again, they do have some important characteristics in common, e.g. listening before sending, random
backoff waiting time before sending, incremental
backoff time after collision.
Therefore, the modeling attempt is to design a common model for these two algorithms. The differences
can be represented by changing model parameters.
The implementation is based on the unslotted
CSMA/CA scheme, which means the network works
without beacon synchronization and all nodes are
working in the Ad-hoc mode. Thus the access to the
network is random and contention prone. Details
about the protocols can be found in [4] and [5].
The common wireless medium model is illustrated in
Figure 7. The shared medium is triggered if any network node sends an attempt of trying. Based on the
sum of trying nodes, it decides to begin transmitting
or to send a collision notification. After successful
transmission, it waits for a certain time before resetting the medium state to idle. This time is given by:
WaitingTime = SIFS + ACK + DIFS
(1)
where SIFS (Short Inter Frame Space), ACK (Acknowledge), DIFS (Distributed Inter Frame Space)
are physic dependent parameters defined in the standard.

116

Modelica 2008, March 3rd  4th , 2008

Simulation of Distributed Automation Systems in Modelica
sm Wireless Medium

Idle
Transmission requests
from nodes

Assess the number of active nodes
/N=sum(active nodes)

[N>1]

Notification
/Medium busy=true,
/collision=true

[N=1]

Transmitting
Entry/ Assess the transmission duration
Do/ waiting
/Medium busy=true
/collision=false
[Finished=true]

[Finished=false]

Notification
Do/ Waiting for SIFS+ACK+DIFS
Quit /Inform the receiver side
Quit /Medium busy=false
Quit /collision=false

Figure 7: State diagram of wireless medium.
The transceiver part algorithm is mainly used to perform the backoff procedure. Here, the separate implementation shows great advantage in the WLAN
protocol considering the simulation performance.
Since the conflict detection is executed by the medium model, the transceiver models do not have to
assess the medium state after each unit delay, but
only to wait for the event trigger from medium notification. By doing so, unnecessary events, which slowdown the simulation dramatically, are avoided. For
instance, 802.11 standard defines the backoff time in
the unit of timeslots:
Backofftime = backoff_counter  slot_time
(2)
where the initial backoff_counter is a random number
in the range [0, 31] and slot_time is 20 s [6]. If no
collision happens, it causes on an average 16 events
with a cycle of 20s per transmission. In the worst
case (4 collisions happen successively), there are
1031 events for a transmission. In the separate implementation, the number of events is reduced to 1.

The designed common model is illustrated in Figure
8. The exact model behavior is predefined by a model
parameter given as 802.11 or 802.15. The common model is a partial model in Modelica, thus in the
application, it is instantiated as a replaceable model
and can be easily parameterized for different protocols.
There are some important assumptions to be noticed:
1. No transmission failure is taken into consideration, i.e. no packet is lost in the transmission and
no re-transmission is needed.
2. The acknowledge message is not modeled.
3. One shared medium model represents one available channel. All nodes connected to the medium
hence operate in the same channel. No dynamic
channel switching is considered. As a consequence, the network capacity is restricted.

4
4.1

Controller components library
Overview of the library

The controller components library contains models to
describe the behavior of an embedded controller device. In comparison to the simulations of automation
systems without detailed controller models, the effects of synchronization, scheduling and queuing are
considered in retrieving system behavior which provides more realistic simulation results.
The library is split into sub-libraries that group controller components by their function (cf. Figure 9).

sm Tranceiver

Idle
New data to transmit

[802.15]

Break backoff procedure

[802.11]

/interrupted backoff=true

Assess the medium state
[Busy]
[Idle]
Failure

[Idle and
interrupted backoff]

Init back off procedure
/BE=BEinit
/NB=NBinit

resume
backoff procedure
/interrupted backoff=false

Assess delay time
[NB>Nbmax
&
802.15 ]

[NB<=Nbmax
or
802.11 ]

Backoff
do/ waiting
Calculate new back off
parameters
/NB=NB+1
/BE=min(BE+1,BEMAX)

Medium busy [802.11]

Delay time expired

Perform CCA
[Medium busy]
[Medium free]

Transmitting
Entry/ Transmitting begin
Do/ Waiting for Notification
Transmission finished

Figure 8: State diagram of wireless transceiver.
The Modelica Association

Figure 9: Screenshot of the controller library.
117

Modelica 2008, March 3rd  4th , 2008

F. Wagner, L. Liu, G. Frey

Board
The basic component of a controller device is a
board. It hosts devices that are needed to run control
algorithms, to interface plants to be controlled and to
interchange information between controller devices.
The library Controller.Board hosts three basic board
models which distinct in the interfaces they provide
(only process interface (IOBoard), only network interface
(NetworkBoard),
combination
of
both(NetworkIOBoard)). The components of the
NetworkIOBoard model, shown in Figure 10, will be
detailed in the following sections.

Figure 10: Component model of a board with process
and network interfaces.

Figure 11: Model of a CPU with network access.

Process Interfaces and Converters
The process interface consists of an array of continuous input (u) and output (y) signals. As in real controllers input and output signals are not directly connected to the CPU. The input signals are first converted by a hardware AD-Converter, and the DAconversion of the output signals is done by means of
a hardware DA-Converter. The converter models can
be found in the Controller.ProcessInterface library.
RAM
The results of the AD-conversions are stored in a
random access memory (RAM) called process image
of inputs (PIInputs), whereas the output signals to be
DA-converted are read from the process image of
outputs (PIOutputs) by the DA-Converter.
The RAM model can be found in Controller.Memory.
It provides means to exchange information between
component models. To attach models to a memory
component the MemoryConnector is used.
Network Interface
The network interface is provided by the network
library. It is regarded as a transceiver IC which performs network operations concurrently. The CPU can
transfer messages to be sent via network to the transceiver IC whereas received network messages can be
read by the CPU from the transceiver IC.
CPU
The central processing unit (CPU) executes the control algorithms. The CPU models can be found in the
library Controller.CPU. There are two different
The Modelica Association

CPU-models in the library, one without network
access (CPU) and one with network access (CPUWithNetwork). The CPU model is instantiated as replaceable in the board models and, thus can be exchanged to other CPU models extending CPU. The
CPU executes the control algorithms wrapped in
Tasks as described in the next section. Figure 11
shows the CPUWithNetwork model.

Task and Scheduler
A task (library Controller.CPU.Task) is a software
process which runs quasi-concurrently to other tasks
in a CPU. A scheduler (library Controller.CPU.Scheduler) allocates processing time to the
tasks according to a certain scheduling policy. The
library provides several scheduler models (e.g. Round
Robin, FIFO) which are all based on the Controller.Interfaces.IScheduler model.
All tasks have access to the process images (PIInputs
and PIOutputs) and share a common memory called
RAM. The RAM can be used to exchange information between tasks inside a CPU. The connections to
the different memory types are drawn in different
colors in Figure 11 (PIInputs: orange, PIOutput: red,
RAM: blue). The connections between the tasks and
the scheduling model are drawn in black. The green
horizontal bars are used as a Modelica bus to reduce
connections to the scheduler.
The CPUWithNetwork model can host up to four
tasks without network access (Task) and two tasks
with network access (NetworkTask). Task and
NetworkTask are implemented as partial models and
serve as generalized task models. The task models are
instantiated as replaceable in the CPUWithNetwork
model and can be easily changed to specialized ones.
The models DummyTask and DummyNetworkTask
can be used to specify that a task is not present. The
library user can easily build his own CPU models
with more Tasks by extending the existing ones.

118

Modelica 2008, March 3rd  4th , 2008

Simulation of Distributed Automation Systems in Modelica

4.2

Implementation details

RAM
The Controller.Memory.RAM model plays an important role in the simulation of an embedded controller.
It provides means to interchange information between
controller components. On the first look, this does not
seem to be a big issue in Modelica, as the connector
type is especially designed for this purpose. But, in
the domain of informational systems a connector is
not a convenient tool to exchange information between components. Due to the fact that the amount of
data exchanged may vary, not all cases can be covered when designing a general information exchange
connector. Instead, it is appropriate to make use of
the external function interface of Modelica to implement an information exchange system in a dedicated
programming language which is then triggered by
Modelica models. In this way the complexity of data
handling is hidden from the Modelica models. To do
so, a C++ library has been developed which emulates
a collection of random access memories that can be
accessed via a unique index. Figure 12 shows a
coarse overview of the C++ library internals and the
interconnection with the Modelica model.
static C++library (.lib)

RAM1

1 2 3 4
RAMIndex=1

Address inMemory

1

5
RAM2

1 2 3 4
2

5 6 7 8

RAMn

1 2 3 4
RAMIndex=n

1:String1
StringRepository
5:String3

2:String4

RAMIndex=2



ModelicaFunction Interface

5 6 7 8

3:String2
Stringrepository

5 6 7 8
3

Memorycollection

Identifierof String

Figure 12: Coarse overview of the C++ library.
Interface functions to use the C++ memory collection
are
provided
in
the
sub-libraries
Controller.Memory.Functions.WrapperFunctions:

In the C++ library, a RAM is organized as a collection of references to strings (character arrays) stored
in a global string repository. Library internal functions provide the mechanism to read and write strings
to the string repository, identified by the RAMIndex,
using the given address which is a local identifier
inside a RAM.
A slightly varied functionality is used to implement
the queuing mechanism in the same library. Instead
of giving random access to values in a queue, the
interface functions only allow reading (dequeueing)
from the first address in the queue and writing (enqueuing) at the end of the queue. The string management is done in the same way as in the case of RAM,
using the string repository.
For maximum flexibility, the values passed to or from
the memory are of type String. This way arbitrary
information can be used in the simulation. When necessary, numerical information contained in the
strings can be parsed by means of functions provided
in the Modelica.Utilities.Strings library. In the case of
real values, the library provides the functions
readReal and writeReal in the sub-library
Controller.Memory.Functions, where parsing is done
automatically.
The RAM model itself is just a placeholder for one of
the memories managed in the C++ library. Its only
dynamic behavior is a function call to create a memory in the memory collection in the initial simulation
step. The unique index of this memory is then stored
in the RAM model and published via the
MemoryConnector, which only consists of the unique
memory index.
To improve debug capabilities, the interface functions
provide the possibility to trace read and write accesses to the RAM model. For this purpose, each
function call, including function parameters, of readRAM and writeRAM can be stored in a textfile or a
database table (cf. Table 1).
Table 1: Dump of a database trace of operations on
RAM models.
id

RAMIndex:=createRAM();
value:=readRAM(RAMIndex,address);
writeRAM(RAMIndex,address,value);

The function createRAM creates a random access
memory in the collection and returns the unique identifier of the memory (RAMIndex) as an Integer. When
reading or writing from or to a memory, the RAMIndex has to be passed to identify the memory.
readRAM is used to read values (as String) from the
memory RAMIndex from the given position address
(as Integer) in the memory, whereas writeRAM is
used to store a value in the given memory RAMIndex
at position address.
The Modelica Association

operation
28
29
30
31
32
33

W
W
R
W
R
R

RAMindex
//
1
2
1
2
2
1
//

address

value
2
5
2
3
2
2

"5"
"-3"
"5"
"3"
"1"
"5"

Tasks
As described above, the control algorithms are organized in tasks to allow multiple algorithms to run
quasi-concurrently on a single CPU. Hence, if multiple tasks are active at once, they are competing for

119

Modelica 2008, March 3rd  4th , 2008

F. Wagner, L. Liu, G. Frey

processing time. The scheduling instance manages
that the processing time is spread among all tasks.
The task models (Controller.Task.*) can be seen as
wrapping units that provide interfaces to access CPUinternal (e.g. Memory, Timer) and CPU-external
components (e.g. process images, network port).
Therefore, all tasks extend the Controller.Intefaces.ITask interface. The behavior is described in Figure 13.

1. algorithm definition in Modelica language
2. algorithm definition in external libraries using the
Modelica external function interface
To define and implement an algorithm in Modelica,
one of the basic Task models (Task or NetworkTask)
must be extended. As intelligence for scheduling is
predefined in the basic Task models, only the values
of the task control variables idle, sleepTime and runTime as well as the reaction on the jobFinished event
must be specified.
The basic structure of tasks using Modelica algorithms is defined as shown below.
model ExampleTask
extends Controller.CPU.Task.Task;
initial algorithm
sleepTime:=0;
runTime:=100/CPUFreq;
algorithm
when (pre(jobFinished)) then
//here, the algorithm semantics are specified
end when;
end ExampleTask;

Figure 13: State diagram of a task.
A task can be in one of three states (Idle, Waiting,
Running), and is controlled by four variables: run,
idle, runTime and sleepTime which enforce state
switches. Depending on the state, the timers runTimer
and sleepTimer are active or inactive and processing
time is requested or not (variable request).
The external variable run is provided by the scheduler and determines if the task is currently the active
task in the CPU. The internal variable idle enforces
the task to go to Idle state if its value is true. runTime
determines the processing time that is needed to
finish the current job of the task, while sleepTime is
used to assign the period to send the task to Idle state.
If a task has no job to do, it is in Idle state. In state
Waiting, the task is requesting processing time, but
currently does not get processing time by the scheduler. In state Running, the task gets processing time
and is thus running. When the runTimer value exceeds runTime the jobFinished event is raised which
indicates that the current job of the task is completed.
This event is used to embed the actual control algorithm in the Task model, just by extending one of the
given template tasks (Task or NetworkTask). The
behavior is given by the extended Task model. This
way the library user can focus on the implementation
of the algorithms itself.
Integration of Algorithms
The Controller library provides basically two different ways to define the algorithms executed in a Task
model:
The Modelica Association

The initial algorithm section assigns start values for
the control variables sleepTime and runTime. In the
algorithm section, the processing of the jobFinished
event is defined by means of a when block. The condition jobFinished must be wrapped by a pre to cut
the algorithmic loop involving the task and the scheduler component.
The semantics of the algorithm is then specified in
the body of the when block, as shown in the following example of a single input single output P controller:

import Functions=Controller.Memory.Functions;

when (pre(jobFinished)) then
//when a job is finished, runTimer is reset
reinit(runTimer,0);
//state==0: read input value
if (state==0) then
//read sensor value from process image
y:=Functions.readReal(PIInputs, 1);
//next state is executing control law
state:=1;
//executing control law takes 5000 cycles
runTime:=5000/CPUFreq;
//state==1: execute control law
elseif (state==1) then
//calculate control error and new set value
e:=w - y;
u:=k*e;
//next state is writing new set value
state:=2;
//execution for writing takes 500 cycles
runTime:=500/CPUFreq;
//state==2: set output value
elseif (state==2) then
//write output value to process image
Functions.writeReal(PIOutputs,1,u);
//next state is reading input values
state:=0;
//reading input signal takes 500 cycles
runTime:=500/CPUFreq;
end if;
end when;


120

Modelica 2008, March 3rd  4th , 2008

Simulation of Distributed Automation Systems in Modelica

The task is divided into three jobs which are executed
sequentially. The job currently processed is indicated
by the Integer variable state (0: read inputs, 1: calculate output, 2: write output). The execution time can
vary among the jobs and is expressed in terms of processor cycles divided by the processor frequency
(CPUFreq in Hz). When the jobFinished event arises,
the semantics of the job is being performed and the
settings for the next job are carried out. This means
that the runTimer variable is reset to zero and that the
runTime for the next job is assigned. The task should
run without breaks and thus is never send to Idle state
(sleepTime:=0, idle:=false).
As described earlier, the tasks do not have direct
access to the environment (input and output signals).
Instead, the algorithms work on images of the input
and output signals by reading from the process image
of inputs (PIInputs) or writing to the process image of
outputs (PIOutputs) using the provided interface
functions.
For complicated algorithms, the Modelica design
language is not the mean of choice. For this case, the
Controller.CPU.Tasks library provides the ExternalTask and ExternalNetworkTask models, which allow
the definition of algorithms in other programming
languages (e.g. C or Java). Using the construct of
replaceable function, the user of the library can easily
access external algorithms by providing Modelica
interface
functions
extending
Controller.CPU.Tasks.externalAlgorithm.

5

Application of the Libraries

Many analysis problems in DAS can be characterized
as runtime or delay investigations. A typical real
world problem is the determination of the response
time distribution on events in the process to be controlled (e.g. emergency stop). Results, elaborated
with an earlier version of the presented library, have
been published in [7].
Including the plant under control in the simulation,
quality analysis can be performed. Reaction delays,
due to the distributed nature of DASs, cause fluctuations in the control quality. As shown in [2], the libraries can be used to analyze the variations of process
values based on a collection of simulation runs.
Another application of overall system simulation is
feasibility analysis. It can be used to perform proofof-concept tests in early development stages of
DASs. The classical example for feasibility analysis
in continuous control is the stabilization of an inverted pendulum in the instable (upper) rest position.
Figure 14 shows the setup of a DAS with an inverted
pendulum using a wireless network. The experimental setup consists of the inverted pendulum with
The Modelica Association

0.5 kg mass for the cart as well as for the pendulum
arm with a length of 1 m. In the initial, state pendulum arm and cart are not moving, but the pendulum
arm is rotated by  = 0.25 rad.

Figure 14: Inverted pendulum experiment.
Attached to the pendulum there are four Controller.Board.IOBoards (sensor1-4) providing information about position and velocity of the cart as well as
angle and angular velocity of the pendulum arm. The
Controller.Board.IOBoard actuator drives the cart
with the translation force calculated by the Controller.Board.NetworkIOBoard microController. The
Controller.Board.NetworkIOBoard SCADA (Supervisory Control And Data Acquisition) is allotted to
collect the overall system status periodically.
The control algorithm on the microcontroller is split
up into three concurrent tasks. The first task cyclically requests sensor values from the sensor boards and
sends the calculated force value to the actuator board.
The second task handles incoming network messages,
and is only active when network messages are available. The third task is the control algorithm itself
working in three sequential steps:
1. reading input signals from the RAM, provided by the remote sensors,
2. calculating the force value (control law),
3. writing the force value to the RAM.
The control law is a state controller, with gains acquired from a linear continuous time state space
model.
The requesting task runs 4 ms and then falls asleep
for 20 ms. The message handling task needs 1 ms to
process each incoming message. The control algorithm task needs 1 ms to read the input signal values
as well as 1 ms to write the force value. To execute
the control law, 11 ms are needed.
Processing of network messages in the sensor and
actuator boards takes 2 ms. As there are no concurrent tasks in these boards execution starts as soon as a
network message is received.

121

Modelica 2008, March 3rd  4th , 2008

F. Wagner, L. Liu, G. Frey

 / rad

The example setup has been simulated with two different networks, ZigBee with 250 kbps transmission
rate and WLAN with 11 Mbps transmission rate. Additionally, the inverted pendulum has been simulated
using the same control law emulating a continuous
controller neglecting all delays imposed by the automation system.
As shown in Figure 15, the pendulum angle varies a
lot among the three simulated scenarios. As expected,
the scenario neglecting delays shows best performance and the WLAN scenario is superior to the
ZigBee scenario.
Continuous controller

0.5
0.4
0.3
0.2
0.1
0
-0.1
-0.2
-0.3
-0.4
-0.5

WLAN
ZigBee

0

2

4

6

8

prietary mechanism, e.g. sampled saving of data to a
file with using Modelica.Utilities.Streams.print.

6

Conclusions and Outlook

Libraries for simulation of Distributed Automation
Systems using the Modelica language have been presented. The libraries allow delay time determination,
quality of control analysis and feasibility analysis in
closed-loop applications. The application of the libraries has been illustrated by an example using wireless
communication.
Future work will focus on improvement of the network models regarding failure behavior (e.g. packet
losses) and the integration of other networks especially in the field of automotive applications (CAN,
LIN, ).
The presented libraries can be downloaded from
http://www.eit.uni-kl.de/frey.

References

10 12 14 16 18 20
time / s

[1]

Figure 15: Pendulum arm angle sequence plot.

F/N

The reason for the differences among the scenarios is
the delayed application of the actuator force caused
by the automation system delays. It can be seen from
Figure 16 that the first update of the actuator value
occurs after approx. 80 ms using WLAN. In the scenario with ZigBee this delay increases to 100 ms.
6
5
4
3
2
1
0
-1
-2
-3
-4

[2]

[3]

[4]

Continuous controller
WLAN
ZigBee
0

0.2

0.4

0.6
time / s

0.8

[5]

1

Figure 16: Zoomed applied translational force
sequence plot.
A 20 s lasting simulation (carried out in Dymola 6.1)
takes 94.2 s CPU time on a PC with 2.8 GHz Pentium
IV HT and 2 GB RAM. Best performance has been
achieved using the Lsodar integration algorithm with
1e-6 tolerance.
Using the common setup for storing variables consumes too much memory and disk space, even for
short simulations (less than 10 seconds). Thus, interesting simulation values have to be stored using proThe Modelica Association

122

[6]

[7]

Cervin, A.; Ohlin, M.; Henriksson, D. Simulation of networked control system using
TrueTime. 3rd International Workshop on
Networked Control Systems: Tolerant to
Faults, Nancy, France, June 2007
Liu, L.; Frey, G. Simulation Approach for
Evaluating Response Times in Networked Automation Systems. IEEE Int. Conf. on Emerging Technologies and Factory Automation
(ETFA), Patras, pp. 1061-1068, Sept. 2007.
IEEE Std 802.3, Part 3: Carrier sense multiple
access with collision detection (CSMA/CD)
access method and physical layer specifications, 1999.
IEEE Std 802.11, Part 11: Wireless LAN Medium Access Control (MAC) and Physical
Layer (PHY) Specifications, 1999.
IEEE Std 802.15.4, Part 15.4: Wireless Medium Access Control (MAC) and Physical
Layer (PHY) Specifications for Low-Rate
Wireless Personal Area Networks (LRWPANs) 2003.
Ferre, P.; Doufexi, A.; Nix, A.; Bull, D.
Throughput analysis of IEEE 802.11 and
IEEE 802.11e MAC. Wireless Communications and Networking Conference (WCNC),
Vol. 2, pp. 783 - 788 March 2004
Greifeneder, J.; Liu, L.; Frey, G. Methoden
zur Antwortzeitanalyse in vernetzten Automatisierungssystemen. SPS/IPC/DRIVES, Nrnberg, Germany, pp. 517 - 525, Nov. 2007.
Modelica 2008, March 3rd  4th , 2008

Session 2a
Language, Tools and Algorithms

The Modelica Association

123

Modelica 2008, March 3-4, 2008

The Modelica Association

124

Modelica 2008, March 3rd  4th , 2008

Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1

Study of a sizing methodology and a Modelica code generator
for the bond graph tool MS1
Audrey Jardin, Wilfrid Marquis-Favre, Daniel Thomasset, *Franck Guillemard, +Francis
Lorenz
AMPERE
INSA-Lyon
25, avenue Jean Capelle
F-69621 Villeurbanne Cedex

*PSA Peugeot Citron
Centre technique de Vlizy
Route de Gisy
F-78943 Vlizy-Villacoublay Cedex

+

LorSim
89, rue Jacob-Makoy
B-4000 Lige

firstname.lastname@insa-lyon.fr
franck.guillemard@mpsa.com
francis.lorenz@lorsim.be

Abstract
Complex systems engineering requires new software tools for virtual prototyping which have to be
more relevant in order to meet, at the same time,
consumer requirements, standardized rules and market law. These have to be more flexible especially
concerning file exchange and reusability. Recently
the modelling language Modelica seems to fulfill
these needs thanks to its concepts of acausality and
multi-disciplinary description.
In parallel, the laboratory AMPERE has developed
a bond graph-based sizing methodology which, by
the use of inverse models, drastically decreases the
number of calculus iterations compared to the classical direct approach.
The aim of this paper is to highlight the importance of acausality and structural analysis in a design
approach and to study to what extent the proposed
sizing methodology can be formulated in Modelica.
Then first software implementations of the methodology are illustrated by examples processed by the
tool MS1 and its Modelica code generator.
Keywords: code generator; Modelica; MS1; bond
graph; acausality; structural analysis; sizing methodology

1

Introduction

Nowadays technological advances have lead to
systems which are more and more complex and thus,
more and more difficult to design. In the new context
of sustainable development, systems have to match
The Modelica Association

ever-increasing pollution standards while engineers
have to take into account both higher consumer requirements (like safety, comfort, equipment,...) and
financial constraints. In few words, engineers have to
conceive faster new safer and cheaper solutions.
One way of doing that is to proceed by simulation
which has the benefit to avoid costly manufactures of
several impertinent prototypes and then favour gain
of time and money.
However virtual prototyping is really efficient only
if the engineer is able to accurately model the system, i.e. only if the system is sufficiently described
for the given problem. In fact, the hardest tasks of
such an approach are:
- finding the good description level;
- being able to express the different physical
phenomena implied by this description;
- and representing these in an unified manner
even if they involve various physical domains.
For all of these reasons, engineers need a modelling
language which:
- allows making connection between all kinds of
physical domains.
 The modelling language has to be multidomain.
- ensures a sort of continuity at every level of
the project cycle. So models have to be usable
as well in oriented system softwares during a
pre-sizing phase as in more specialized tools in
advanced design steps.
 The modelling language has to be recognized as a standard for model exchange.

125

Modelica 2008, March 3rd  4th , 2008

A. Jardin, W. Marquis-Favre, D. Thomasset, F. Guillemard, F. Lorenz

-

reduces wasted time as much as possible. In
fact, it is of the first importance to mutualize
modelling efforts which, as mentioned before,
are the hardest tasks of such an approach. One
way of capitalizing on this is to separate the
system description from the design context and
thus not to depict the system with a priori oriented equations.
 The modelling language has to be object
oriented and to enable acausal description.
- reduces study costs by decreasing dependency
towards exclusive software providers.
 The modelling language has to be a free
and non-owner language.
This is just with this in view that the Modelica language and the OpenModelica simulation environment [1] have been proposed. In fact this can explain
why, today, Modelica language seems to fulfill a real
need for engineers and industrials and seems to present itself as the future standard for model exchange.
As a proof of fact, numerous simulation environnements and computer aided design tools like Dymola
[2], LMS Imagine.Lab AMESim [3] or Scilab/Scicos
[4] can now support Modelica models as well for
import as for export.
Starting from this statement, the aim of this paper
is to compare some Modelica aspects to the bond
graph-based sizing methodology [5]-[12] developed
by the laboratory AMPERE1. In fact, by using the
multi-domain aspect as well as the concept of
acausality, it seems legitimate to ask oneself to what
extent the proposed methodology can be supported
by Modelica language.
The paper is organized as follows. First, section 2
will briefly describe the methodology principles and
its benefits compared to a classical design approach.
Importance of the acausality concept and the use of a
structural analysis will also be highlighted. Section 3
will present one example of the methodology software implementation, the tool MS1 [13], and its
newest functionality: a Modelica code generator.
Then section 4 will conclude by summarizing the
several tackled points and by suggesting future research directions.

1

Since January 1, 2007, the LAI has merged with the
CEGELY and a team of environmental microbiology to
become the laboratory AMPERE (UMR CNRS 5005).

The Modelica Association

2

Bond graph-based sizing methodology towards a Modelica-based
sizing methodology?

To understand how some Modelica features can be
used or be augmented to support the proposed methodology, it is worth first explaining its main principles. Then importance of an unified and acausal description will prove to be a benefit for carrying out a
structural analysis. Finally some reflections will be
conducted about the potential of embedding the
methodology in Modelica.
2.1

Methodology benefits and principles

Up to now a classical approach adopted by the
most of engineering departments consists of a trial
and error procedure. For instance consider an actuated load system (Fig. 1) and suppose that the design
problem is to find an appropriate actuator so that the
load follows a given trajectory (i.e. the hoped-for
specification). Once the system has been modelled,
the first step of a classical approach consists in:
- selecting more or less arbitrarily an actuator
(this depends on the degree of the engineer expertise);
- presupposing the control of this actuator;
- launching a direct calculus in simulation according to these assumptions;
- comparing the calculated load trajectory to the
desired specification.

Fig. 1: The classical design approach

However this approach rarely leads to a good solution at the first attempt: it usually requires numerous
iterations to find a suitable actuator. This is truer in a
technological break context where, by definition,
engineers do not have access to any expertise. Moreover this approach can come up to a greater loss of
time since:
- in the first case where the a priori selected actuator matches the specifications, the engineer
has no idea on the margins he has at his dis-

126

Modelica 2008, March 3rd  4th , 2008

Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1

posal, and thus whether a smaller and cheaper
actuator could be acceptable;
- in the second case where the a priori selected
actuator does not suit the sizing problem, the
result of the simulation does not give any idea
on the causes of underdimensioning. The engineer in charge of the study must choose another actuator admittedly more powerful but
still more or less arbitrarily.
Finally this iterative procedure can even reveal itself
endless as, beforehand, no checking has been made
to conclude whether the specifications can be really
obtainable by the given structure or not. In that case,
most of time, the engineer has to slightly modify the
specifications by relaxing some design constraints if
he wants to solve his problem.

Fig. 2: The laboratory AMPERE design approach for
choosing suitable actuators

Faced to all of these drawbacks and strong of its
research for 15 years, the laboratory AMPERE has
developed an innovative methodology for sizing
mechatronic systems ([5]-[8]). Contrary to the classical approach which uses direct model calculus, the
key idea here is to exploit inverse models described
by bond graph. Considering the same example as
before, the main steps of this approach can be
summed up into the following points (Fig. 2):
- Step 1: Adequacy
As explained in more details in section 2.3,
this step consists in carrying out a structural
analysis. This allows checking if the sizing
problem is well-posed and concluding on the
possible structural invertibility of the load
model (and so on the possibility to inverse the
model).
- Step 2: Specification
Assuming that the load model is structurally
invertible, this step consists in establishing the
inverse load model corresponding to the given
sizing problem (this results in assigning the bicausality on the bond graph model) and simuThe Modelica Association

lating it so as to determine variables required
at the entrance of the load and that match the
specifications2.
- Step 3: Selection
As the variables in input of the load are the
same as the variables in output of the actuator,
the engineer can thus select in a library actuators that appear suitable for the output specifications (e.g. the maximum of the required effort must be inferior to the maximum effort the
actuator can supply) (Fig. 2).
- Step 4: Validation
Finally since actuators have been selected according to criteria only in terms of variables in
output, the engineer has to check if these actuators do not overcome their limitations in input (and anywhere else in the inside). This step
consists in adding the actuator models to the
load model, determining the variables in input
by the use of the new corresponding inverse
models3 and comparing the simulation results
for these variables to the manufacturer data.
Then these four steps of the methodology are repeated to size each stage of a whole actuating chain
(power modulator, energy supplier) and, at the end,
to determine the open loop control.
Now that the principles of the methodology have
been exposed, it is worth noting some remarks.
First, the methodology does not require any supposition on the actuator control and, by this way, facilitates the engineer study.
Secondly, compared to the classical approach, the
inverse methodology drastically decreases the number of calculus iterations. In fact, at the end of the
selection step, as the variables needed in output of
the actuator are directly determined from the specifications, the engineer is able, after only one calculus,
to:
- either eliminate a whole part of the actuator library (whereas each component should have
been tested in the direct approach in order to
be rejected);

2

One can remark that in this way of calculus, the roles of
inputs and outputs are reversed: specified outputs become
the inputs of the calculus while the real inputs are the
variables to determine.
3
For the sake of conciseness and clarity, this step has
been simplified. More rigorously, another structural
analysis must be conducted on the new model including
the actuator model to check, in turn, its structural invertibility.

127

Modelica 2008, March 3rd  4th , 2008

A. Jardin, W. Marquis-Favre, D. Thomasset, F. Guillemard, F. Lorenz

-

or decide to manufacture a made-to-measure
actuator if none of the off-the-shelf actuators is
suitable;
- or slightly modify the specifications if the financial constraints of the project do not allow
special manufactures.
In the validation phase, two cases can also happen:
either the actuator chosen in step 3 suits the inputs
criteria and the actuator is then validated, or the variables needed in input to fulfill the specifications do
not correspond to the actuator use restrictions and the
engineer must go back to the selection step. As it
will be illustrated in section 3.1, in the first case, the
engineer can directly conclude that the actuator is
relevant for the desired behavior (and this after only
two inverse calculations) and can also evaluate the
possible oversizing of the actuator. On the contrary,
in the second case, the engineer must even choose
another actuator but, this time, the comparison between the required variables and the component limitations gives to him the origins of the undersizing
(e.g. the actuator does not support such a high supply
of power). Thus the engineer must go back to the
selection step but with a significant guideline to follow so as to find a suitable actuator.
Thirdly, thanks to the structural analysis, the engineer can check if his problem is well-posed and, if
needed, he can readapt, without any numerical calculus, his specifications to be sure that they can be
reached by the chosen model structure. Thus the engineer is sure that his approach will succeed in finding a solution.
2.2

seems to be infinite while the one of causal models
reduces itself only to what they are prescribed for.
As Fig. 3 shows, if the engineer chooses a causal
approach, he is obliged to formulate one causal
model for each problem. On the contrary, if he
chooses the acausal approach, the same model can be
used for all engineering problems as: analysis, sizing, control design, parametric synthesis, steady state
research, ... (Fig. 4).

Fig. 3: System causal descriptions required for several
engineering objectives

Advantage of an acausal description

From a rigorous point of view, a bond graph model
initially represents a system in an acausal manner:
the equations are oriented only once causality (or
bicausality for inverse models) is assigned. Intuitively, the methodology proposed by the laboratory
AMPERE can be applied not only for sizing problems but for other engineering contexts too: one only
needs to work on the inverse model corresponding to
the given problem.
Now, outside the bond graph context, a causal
model is only a representation of a calculus sequence
(i.e. a set of partially ordered assignments). It thus
depends on the study objective and can only be used
for this objective. On the contrary an acausal model
is only the description of a system (i.e. a set of nonordered implicit equations), totally independent from
what oneself wants to calculate. In this way, the reusability of models described in an acausal form

The Modelica Association

Fig. 4: Only one system acausal description required for
several engineering objectives

In practice, this notion of acausality already
showed its benefits especially in Modelica language
and in bond graph theory.
In the Modelica context, the concept of acausality,
added to the concepts of encapsulation and inheritance, enables modelling efforts to be mutualized and
librairies to be obtained, librairies that are less redundant (since there is no more need to model the
same component in different contexts).
In addition to this, some researches were carried out
on how translating different engineering problems

128

Modelica 2008, March 3rd  4th , 2008

Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1

into bond graph language. In fact one can remark
that each of the proposed procedures starts from the
acausal bond graph model so as to construct the direct (respectively inverse) model corresponding to
the given problem. To quote just some of them, some
works have been done on sizing problem [7][11][12],
steady state research [14], parametric synthesis [15],
control design [16], characterization [17] and sensibility analysis [18].
2.3

Advantage of a structural analysis

As mentioned before the first step of the AMPEREs methodology involves a structural analysis
of the model which the two objectives are checking
if the problem is well-posed and verifying the adequacy between the specifications and the chosen
model structure.
To understand how these checks can be made,
some definitions are introduced and the structural
analysis is explained as well as how it can be conducted.
Concerning the concepts [9]:
- a power line is defined as a path for energy
transmission between two points of the system
(this is an acausal concept);
- a causal path is an ordered sequence of variables connected each one to another by the
equations of the system without that a variable
appears more than once in the sequence;
- an input/output power line (resp. causal path)
is a power line (resp. a causal path) between an
input and an output of the system;
- two power lines (resp. causal paths) are said
disjoint only if there is no power (resp. no
variable) in common;
- when the causality of the whole model has
been assigned in order to obtain the maximum
number of energy storage phenomena in integral causality, the order of a causal path is defined as the difference between the number of
energy storage phenomena in integral causality
and the number of those in derivative causality
along this causal path.
Given a sizing problem with multiple inputs to determine from multiple specified outputs, checking if
the problem is well-posed, in the sense of invertibility, thus consists in finding:
- at least one set of input/output disjoint power
lines;
- and, at least one set of input/output disjoint
causal paths.

The Modelica Association

If the required sets exist, then it can be concluded
that the model is structurally invertible (i.e. invertible assuming that the equations of the system are
locally mathematically invertible): the engineer can
thus be sure that his problem is, at this stage, wellposed.
Now, on the contrary, if no set exists, it proves that
the model is structurally non invertible. In that case,
the procedure stops here until the problem is reformulated. This can be particularly useful for architecture synthesis. In fact if the a priori chosen structure
does not enable the specifications to be reached, one
can imagine another architecture that may satisfy the
design constraints. By analyzing the input/output
power lines, one can then determine the place an actuator must have in order to control a specified degree of freedom.
Finally once a good structure has been chosen and
the model invertibility has been proved, the adequacy, between the specifications and the structure,
can be verified. To proceed with this, one needs to
check if the time derivability of each specified output
is at least equal to the order of the involved input/output causal path. Not only useful for checking,
this can then help to write specifications.
2.4

Methodology translation into Modelica language

If previous articles have proved the feasibility of
translating a bond graph model into a Modelica
model [19]-[22], the key idea here is to study to what
extent a bond graph-based sizing methodology can
be adapted to Modelica language. If the translation
of a bond graph model into a Modelica code can be
done quasi systematically with the BondLib library
[23], the reverse operation is not so easy. Although
the concepts of acausality and multi-disciplinary description seem to establish a parallel between the
bond graph and the Modelica language, the conversion of a Modelica description into a bond graph
model reveals itself like a harder or even impossible
task.
In fact if the bond graph is intrinsically bounded to
the description of the system energetic structure,
nothing imposes to the modeller to depict it into
Modelica language. As a proof of fact, a system can
be totally described by equations gathered together
into the same Modelica class, without any use of
Modelica connect. Moreover if connect classes
appear in the Modelica code, they do not necessarily
represent physical energy exchanges: the Modelica
modeller is totally free of choosing his variables for
description.

129

Modelica 2008, March 3rd  4th , 2008

A. Jardin, W. Marquis-Favre, D. Thomasset, F. Guillemard, F. Lorenz

For these reasons, the study of power lines proves
to be compromised in a Modelica model and Modelica language does not seem to be suitable for the
structural analysis as we have defined it above.
However the interesting think of this translation tentative is to highlight that to manage a structural
analysis, the engineer has to furnish a minimum set
of information about the system and particularly
concerning how the different physical phenomena
are connected the ones to the others. Besides if we
come back to the definitions relative to the structural
analysis (section 2.3), one can remark that they can
be formulated outside the bond graph context on
condition that the concepts of energy storage/dissipative phenomena, power and energy variables be well defined. Thus one can imagine designing a sort of Modelica overlay able to depict the required information of the model.
Actually this way of doing things reveals itself
more relevant since the structural analysis does not
require the system equations (and so equations described in the Modelica code) but only its energy
skeleton. The structural analysis pertains to a step
upstream of the Modelica code writing and concerns
finally directly the modelling step, where the engineer sets up the system structure and formulates the
corresponding problem and specifications. Modelica
can then be viewed as a complementary tool to the
methodology for model exchange and reusability but
not as a tool made for structural analysis.

3

MS1: an example of the methodology software implementation

To illustrate the several concepts previously described and to show how the sizing methodology can
be implemented into a program, this section presents
the software MS1 with its functionnalities [13]. Two
examples processed by it will be used to this objective: the first one concerns the case of a two-link
manipulator whereas the second one involves a load
actuated by a DC motor.
3.1

puts/outputs of the problem are declared, the software MS1 is able to:
- search all existing input/output power lines;
- search all existing input/output causal paths;
- search all existing sets of disjoint input/output
causal paths;
- determine the order of each causal paths or set
of causal paths.
So, instead of doing it manually, the modeller can
automatically analyze the structural properties of his
model. He can conclude on his problem effectiveness
and check the adequacy between the results of the
structural analysis and his specifications.
Selection/validation step
Another functionnality of the software MS1 is the
automation of the selection step. In fact the modeller
can define a place-holder for an actuator in his model
and, then, the sizing functionnality of MS1 enables
a sequence of numerical resolution to be automatically conducted. In fact, during this step, MS1
searches in a component library which actuator will
be suitable for the given specifications. At the end of
the calculus sequence, the engineer has a summary
indicating for each actuator:
- its margins compared to what is required;
- and if the component is validated or not.
To illustrate this functionnality, consider the example of a two-link manipulator (Fig. 5). This system
consists of a robot made from two solid arms. The
first arm is attached to the ground and to the second
arm by two pivot joints which are both actuated. This
robot is supposed to operate in a horizontal plane and
inertias of the actuators as well as the effect of the
gravity are neglected.

Methodology implementation

Structural analysis
One of the MS1 particularities is its module of
structural analysis. This functionnality is of course
only reserved for the models described into bond
graph language since the aforementioned structural
analysis requires a minimum information on the system structure. Once the system is modelled into a
bond graph representation and once the inThe Modelica Association

Fig. 5: Two-link manipulator system

Now consider the problem of selecting an appropriate actuating system for the axis 2 so as to the end-

130

Modelica 2008, March 3rd  4th , 2008

Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1

effector of this robot follows a given profile in velocity4. The selection step, consisting of a research in
the electrical drive library of the MS1 database, leads
to the following two results:
- a case where the selected component does not suit
the specifications (Fig. 6);

Fig. 6: Validation step: case of an undersized actuator

- a case where the selected component limitations
matches with the specified trajectory (Fig. 7).

manufacturer drive characteristics can be taken into
account such as the ones for intermittent operation.
3.2

The Modelica code generator: illustration
of the acausal description advantage

One of the advantages of the software MS1 is its
concept of multi-language platform. Actually, models can be depicted into MS1 in different ways like:
bloc diagram, bond graph, NMF network or algorithm. Moreover these models can also be numerically simulated by different solvers: for example,
users can lead their numerical resolution by EsacapTM [24], Matlab [25] or MapleTM [26]. Today
one of the newest MS1 functionnalities is its capability to understanding Modelica language. The software MS1 can thus:
- generate automatically Modelica code from
any model described into one of the modelling
languages previously quoted;
- call for the OpenModelica solver in order to
proceed to the numerical resolution.
In fact the generated Modelica code is what is called
a flat model in the sense that it only consists of the
whole equations gathered into the same class object.
Thus neither heritance nor encapsulation are used
here. However this model can be interpreted by any
existing Modelica compiler and respects, by this
way, the wish of the Modelica Association to be proprietary independent.

Fig. 7: Validation step: case of a suitable actuator

By representing in an (effort,flow) plane the variables required for reaching the specified output and
by superimposing this curve to the manufacturer
drive characteristics, one obtains a very convenient
way for selecting components and for visualizing
causes of under/oversizing. Moreover, as the needed
variables are calculated for every instant of the dynamic specification, the engineer is able to detect at
which instant the actuator overcomes its limitation
and for which duration. Then he can size its component according to the dynamic criteria and, some

Fig. 8: DC motor actuated load system

The following example will illustrate different Modelica results generated by MS1. Consider a system
consisting of a load actuated by a DC motor (Fig. 8)
and suppose that the rotor shaft and the load shaft are
both infinitely stiff.

4

Even if these steps are not explicitly described here, it is
assumed that the model is invertible and that the velocity
profile is enough time differentiable.

The Modelica Association

Fig. 9: Acausal bond graph model of a DC motor actuated
load system

131

Modelica 2008, March 3rd  4th , 2008

A. Jardin, W. Marquis-Favre, D. Thomasset, F. Guillemard, F. Lorenz

The system is modelled in terms of an acausal bond
graph as shown in Fig. 9. In more details:
- the Se-element stands for the voltage source;
- the three I-elements represent the three energy
storage phenomena respectively associated to
the magnetic energy and the kinetic energies of
the rotor and the load respectively;
- the three R-elements enable the dissipative
phenomena involved respectively in the electrical circuit, on the shaft and on the load viscous type friction to be described;
- the GY-element depicts the electro-mechanical
coupling;
- and the TF-element is associated to the power
conserving coupling in the ideal reduction
gear.

Fig. 10: Causal bond graph model of a DC motor actuated
load system

Now consider a first engineering problem which
the aim is to analyze the behavior of the load under a
given control. Translating this problem into the bond
graph language consists only just in starting from the
acausal bond graph, defining the effort variable on
the MSe-bond as the input, adding a Df-element representing the ideal measure of the load angular velocity and defining the corresponding flow variable
as the output. This operation enables to declare
which variables are known and which are to be calculated according to the given problem. The causality assignment leads to the bond graph given in Fig.
10 and the Modelica code corresponding to this
problem is presented in Fig. 11.

Real
P1(start = G1), P2(start = G2);
equation
U = 10*sin(5*time+0.0);  INPUT
E6 = der(P3);
I = P1/L; E4 = I*R; CM = I*KC;
WM = P2/JM; E1 = WM*1.0;
WC = WM*(1/N); CF = WC*RC;
P3 = WC*JC; E2 = EC+CF+E6;
E7 = E2*(1/N); E5 = CM-(E1+E7);
E = WM*KC; E3 = U-(E4+E);
der(P1) = E3; der(P2) = E5;
end ActuatedLoad;

Fig. 11: Modelica code associated to an analysis problem
for the DC motor actuated load system

Fig. 12: Bicausal bond graph model of a DC motor actuated load system for open loop control determination

Finally consider a sizing problem where the question is to determine the open loop control of the voltage source so that the load follows a given trajectory.
This time the bond graph model corresponding to
this inverse problem consists in replacing the MSeelement (resp. the Df-element) by a double detector
element (resp. double source element) since the roles
of inputs/outputs are here reversed. Assigning bicausality results in the Fig. 12 bond graph model.
The corresponding Modelica code is shown in Fig.
13.

class ActuatedLoad
parameter Real
L = 0.001, R = 8.0, KC = 0.031,
JM = 1.8E-6, N = 20.0, RC = 0.0001,
JC = 2.E-4;
parameter Real
G1 = 0.0, G2 = 0.0;
Real
EC = 0.0;
Real
U, I, E4, CM, WM, E1, WC, CF, P3,
E2, E7, E5, E, E3, E6;

The Modelica Association

class ActuatedLoad
parameter Real
N = 20.0, JM = 1.8E-6, KC = 0.031,
RC = 0.0001, JC = 2.E-4, L = 0.001,
R = 8.0;
Real
EC = 0.0;
Real
WC, WM, E1, P2, E, CF, P3, E2, E7, CM,
I, P1, E4, U, E5, E6, E3;
equation
WC = 0.00193681*sin(5*time);  INPUT
WM = WC/(1/N); E1 = WM*1.0;
P2 = WM*JM; E = WM*KC;
CF = WC*RC; P3 = WC*JC;

132

Modelica 2008, March 3rd  4th , 2008

Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1

E5 = der(P2); E6 = der(P3);
E3 = der(P1); E2 = EC+CF+E6;
E7 = E2*(1/N); CM = E1+E5+E7;
I = CM/KC; P1 = I*L;
E4 = I*R; U = E3+E4+E;
end ActuatedLoad;

Fig. 13: Modelica code associated to a problem of an open
loop control determination for the DC motor actuated load
system

One can then observe that both Modelica codes
differ only by the equations concerning the input
variables (respectively U for the analysis problem
and WC for the sizing problem). When the Modelica
connect class will be implemented in MS1, we will
obtain a model split into four classes (respectively
for the dc motor, the load, the input and the output)
and only those classes relative to the input and output will change between both problems.

4

Conclusion

Compared to the classical design approach, the sizing methodology, developed by the laboratory AMPERE, offers numerous benefits. In fact with the use
of inverse models and structural analysis, this methodology enables the engineer to check if his problem
is well-posed and to verify the adequacy of the specifications with his model structure. Moreover this
tremendously decreases the number of calculus iterations since it gives, at the selection and validation
steps, enough information in order to select another
component in the case of an undersized one or to
choose an optimal one in the case of several suitable
actuators by comparing the margins of sizing.
By emphasing the roles of acausality and multidomain description, the aim of this paper is to ask if
the methodology, originally based on the bond graph
tool, may be supported by another modelling language like Modelica. After having proved the importance of acausality and structural analysis in a design
approach, it has been concluded that finally the concepts used in the methodology can be defined outside
the bond graph context but are not well adapted to
Modelica language. In fact the notion of structural
analysis requires the description of the system energy structure and thus must be conducted upstream
of the Modelica code.
Here the tool MS1 enabled the feasibility of the
methodology software implementation to be proved.
Functionalities, like the one of automation of the
structural analysis or of the component selection in
an actuator library, are available. Besides this a
The Modelica Association

Modelica code generator was implemented in order
to convert automatically a bond graph model into a
Modelica flat model.
In the context of the RNTL-SIMPA2 project,
which the aim is to develop a Modelica compiler and
integrate it into Scicos and LMS Imagine.Lab AMESim softwares, some researches are currently under
progress for designing a module of structural analysis totally independent from any modelling language.
Integrated into Scicos and more focused on the GUI,
it will rely on the analysis of XML files describing
the model structure. Through the GUI, the engineer
will thus be guided to formulate his problem in a
textual manner, describe his system in terms of energy exchanges and declare which are the known
variables and the unknowns of the problem. The engineer will then be able to conduct a structural analysis (and then to apply the methodology) starting from
this description, and this without knowing the bond
graph theory. Results of the structural analysis will
be appear in a textual manner too and a Modelica
code of the problem will be eventually created.

Acknowledgement
The authors gratefully acknowledge the partial
support of the French National Research Agency
(ANR) through the RNTL-SIMPA2/C6E2 project.

References

133

[1]
[2]
[3]
[4]
[5]

[6]

http://www.modelica.org/
http://www.dynasim.com/index.htm
http://www.lmsintl.com/
http://www.scilab.org/
Ngwompo R.F., Scavarda S., Thomasset D. Physical model-based
inversion in control systems design
using bond graph representation,
Part 1: theory, Proceedings of
ImechE Journal of Systems and Control Engineering, 2001, vol. 215, pp.
95-103.
Ngwompo R.F., Scarvada S., Thomasset D. Physical model-based
inversion in control systems design
using bond graph representation,
Part 2: applications, Proceedings of
ImechE Journal of Systems and Control Engineering, 2001, vol. 215, pp.
105-112.
Modelica 2008, March 3rd  4th , 2008

A. Jardin, W. Marquis-Favre, D. Thomasset, F. Guillemard, F. Lorenz

[7]

[8]

[9]

[10]

[11]

[12]

[13]
[14]

[15]

Ngwompo R.F., Scavarda S.,
Thomasset D. Bond graph methodology for the design of an actuating
system: application to a two-link
manipulator, IEEE International
Conference on Simulation, Man and
Cybernetics, Orlando, USA, 1997,
pp. 2478-2483.
Ngwompo R.F. Contribution au dimensionnement des systmes sur des
critres dynamiques et nergtiques
 approche par Bond Graph. Lyon,
France: PhD thesis, INSA-Lyon,
1997.
Ngwompo R.F., Bideaux E.,
Scavarda S. On the role of power
lines and causal paths in bond graphbased model inversion, in proceedings of the International Conference
on Bond Graph Modeling and
Simulation, New Orleans, USA,
2005, pp. 78-85.
Ngwompo R.F., Scavarda S. Dimensioning problems in system design
using bicausal bond graphs, Simulation Practice and Theory, 1999, vol.
7, pp. 577-587.
Laffite J., Bideaux E., Scavarda S.,
Guillemard F., Ebalard M., Moutou
C. Modeling in order to size an
automotive power train, in proceedings of the 13th European Simulation
Symposium, Marseille, France,
2001, pp. 806-812.
Mechin O., Marquis-Favre W.,
Scavarda S., Ferbach P. A dynamic
sizing methodology in the context of
an automotive application, in proceedings of the ASME International
Mechanical Engineering Congress &
Exposition, New Orleans, USA,
2002.
http://www.lorsim.be/Default.htm
Bideaux E., Marquis-Favre W.,
Scavarda S. Equilibrium set investigation using bicausality, Mathematical and Computer Modeling at Dynamical Systems Special Issue on
Bond Graph Modeling, Taylor &
Francis, 2006, vol. 12, pp.127-140.
Ngwompo R.F. Dveloppement
dune mthodologie de dimensionnement des lments dun systme :

The Modelica Association

134

[16]

[17]

[18]

[19]

[20]

[21]

[22]

[23]

[24]
[25]
[26]

application au cas dune suspension
hydropneumatique. Lyon, France:
Technical report, INSA-Lyon, 1999.
Bideaux E., Smaoui M., Brun X.,
Thomasset D. Design of a compliant
positionning control using an inverse
method, in proceedings of the Power
Transmission and Motion Control
Conference, Bath, UK, 2003, pp.
147-162.
De Giorgi R., Sesmat S., Bideaux E.
Using inverse models for determining orifices mass flow rate characteristics, Sixth Japan Symposium on
Fluid Power, Tskuba, Japan, 2005.
Borutzky W., Granda J. Determining
sensitivities from an incremental true
bond graph, in proceedings of the International Conference on Bond
Graph Modeling and Simulation,
Phoenix, USA, 2001, pp. 3-8.
Borutzky W., Barnard B., Thoma
J.U. Describing bond graph models
of hydraulic components in Modelica, Mathematics and Computer in
Simulation, 2000, vol. 53, pp. 381387.
Borutzky W. Bond graph modeling
from an object oriented modeling
point of view, Simulation Practice
and Theory, 1999, vol. 7, pp. 439461.
Broenink J.F. Object-oriented modeling with bond graphs and Modelica, in proceedings of the International Conference on Bond Graph
Modeling and Simulation, San Francisco, USA, 1999, vol. 31, pp. 163168.
Broenink J.F. Bond-graph modeling
in Modelica, European Simulation
Symposium, Passau, Germany,
1997.
Cellier F.E., Nebot A. The Modelica
Bond-Graph Library, in proceedings
of the 4th International Modelica
Conference, Hamburg, Germany,
2005, pp. 57-65.
http://www.ecs.dtu.dk/esacap.htm
http://www.mathworks.com/
http://www.maplesoft.com/

Modelica 2008, March 3rd  4th , 2008

Integrating Models and Simualtions of Continuous Dynamics into SysML

Integrating Models and Simulations
of Continuous Dynamics into SysML
Thomas Johnson1

Christiaan J.J. Paredis1

Roger Burkhart2

1

Systems Realization Laboratory
The G. W. Woodruff School of Mechanical Engineering
Georgia Institute of Technology
Atlanta, Georgia 30332
tjohnson6@gatech.edu
chris.paredis@me.gatech.edu
2

Deere & Company World Headquarters
Moline, Illinois 61265
BurkhartRogerM@johndeere.com

Abstract
In this paper, we combine modeling constructs
from SysML and Modelica to improve the support
for Model-Based Systems Engineering (MBSE).
The Object Management Group has recently developed the Systems Modeling Language (OMG
SysML). This visual modeling language provides
a comprehensive set of diagrams and constructs for
modeling many common aspects of systems engineering problems, such as system requirements,
structures, functions, and behaviors. Complementing
these SysML constructs, the Modelica language has
emerged as a standard for modeling the continuous
dynamics of systems in terms of hybrid discreteevent and differential algebraic equation systems. In
this paper, the synergy between SysML and Modelica is explored at three different levels: the definition of continuous dynamics models in SysML; the
use of a triple graph grammar to maintain a bidirectional mapping between these SysML constructs and the corresponding Modelica models; and
the integration of simulation experiments with other
SysML constructs to support MBSE. Throughout
the paper, an example of a car suspension is used to
demonstrate these contributions.
Keywords: SysML; Modelica; model-based systems
engineering; continuous dynamics; graph transformations

1
1.1

Introduction
Managing System Complexity with SysML

Contemporary systems engineering projects are
becoming increasingly complex as they are handled

The Modelica Association

by geographically distributed design teams, constrained by the objectives of multiple stakeholders,
and inundated by large quantities of design information. Accordingly, problems encountered during the
system development process generally have more to
do with the organization and management of complexity than with the direct technological concerns
that affect individual subsystems and specific physical science areas [1]. If engineers cannot efficiently
manage project complexity, they might overlook important design details and dependencies. Such mistakes can compromise stakeholder objectives and
lead to costly design iterations or system failures.
According to the principles of model-based systems engineering (MBSE) [2], engineers can overcome these problems by replacing document-centric
design methods with model-based approaches for
representing and investigating their knowledge during system decomposition and definition. Models
can be used to represent formally all aspects of a systems engineering problem, including the structure,
function, and behavior of a system [3]. Additionally,
experiments can be performed on models to eliminate poor design alternatives and to ensure that a preferred alternative meets the stakeholders objectives.
Models also facilitate collaboration by providing a
common, unambiguous protocol for communicating
design information.
To support MBSE, the Object Management
Group has recently developed the Systems Modeling
Language (OMG SysML). SysML is a generalpurpose systems modeling language that enables systems engineers to create and manage models of engineered systems using well-defined, visual constructs
[4]. Instead of developing SysML as an original design, the OMG adapted the successful Unified Modeling Language (UML) to the systems engineering

135

Modelica 2008, March 3rd  4th , 2008

T. Johnson, C. Paredis, R. Burkhart

field. UML is most commonly used during the development of large-scale, complex software for various domains and implementation platforms [5]. To
support an application base that extends beyond software engineering, SysML reuses and extends a subset of UML 2.1 constructs:







it extends UML classes into blocks;
it enables requirements modeling;
it supports parametric modeling;
it extends UML dependencies into allocations;
it reuses and modifies UML activities;
it extends UML standard ports into flow ports.

Through these extensions, SysML is capable of representing many common, yet essential aspects of
both system hardware and software.
1.2

Modeling System Behavior with SysML

The knowledge captured in a SysML model is
intended to support the specification, analysis, design, and verification and validation of any engineered system [4]. As a result, SysML is commonly
used to model system requirements, tests, structures,
functions, behaviors, and their interrelationships.
Although all of these models are important for ensuring project success, behavioral models are arguably
the most important. If the system does not behave in
a way that satisfies stakeholder objectives, then it is
useless regardless of its other aspects.
SysML currently depicts system behavior using
the following language constructs:








Activity diagrams describe the inputs, outputs,
sequences, and conditions for coordinating
various system behaviors;
Sequence diagrams describe the flow of
control between actors and a system or its
components;
State machine diagrams are used for modeling
discrete behavior through finite state transition
systems;
Parametric diagrams allow users to represent
mathematical constraints amongst system
properties.

The first three of these modeling constructs promote
causal behavioral modeling in terms of discrete
events. The last one enables a user to model equations (called constraints in SysML) that establish
mathematical relationships between system properties. In this paper, the focus is on parametric diagrams and specifically on the representation of the
continuous dynamics of engineered systems within
parametric diagrams. Such models are composed of

The Modelica Association

differential algebraic equation (DAE) systems that
represent the exchange of energy, signals, or other
continuous interactions between system components.
By relying on Modelica syntax and semantics, we
demonstrate how such DAE systems can be modeled
with only a few extensions to the basic SysML constructs (see Section 4). SysML then serves as an integration framework in which detailed Modelica
models can be related to other types of systems engineering knowledge (see Section 6). The integration
between SysML and Modelica creates a significant
synergy: SysML benefits from the detailed Modelica
semantics for representing DAE systems combined
with discrete events; Modelica benefits from the
broader information modeling context provided in
SysML, a context that is crucial for establishing formal, unambiguous communications between systems
engineers, disciplinary designers and systems analysts. To maintain consistency between the Modelica models and their corresponding abstractions in
SysML, we introduce the use of triple graph grammars (TGGs) [6] to specify transformations between
the two forms of models (see Section 5).

2

Related Work

The need to describe system behavior in terms
of equations or constraints has been previously recognized in the work on Constrained Objects (COBs)
[7, 8]. COBs provide both a graphical and lexical
representation of algebraic relationships that can be
used to tie design models to analysis models in a parametric fashion. These COBs recently served as the
basis for the development of the SysML parametric
diagrams [4]. By establishing a mapping between
COBs and SysML, the integration and execution of
engineering analyses (such as structural finite element analyses) within the context of SysML has
been demonstrated [9]. This paper extends this past
work on COBs by focusing on the modeling and
simulation of the continuous dynamics of systems as
defined in Modelica models.
Recently, Fritzson and Pop [10] have worked on
the integration of UML/SysML and Modelica to
provide support for modeling and simulating continuous dynamics. They have created a UML profile
called ModelicaML that enables users to depict a
Modelica simulation model graphically alongside
UML/SysML information models. The ModelicaML
profile reuses several UML and SysML constructs,
but also introduces completely new language constructs. Such constructs are the Modelica class diagram, the equation diagram, and the simulation diagram.

136

Modelica 2008, March 3rd  4th , 2008

Integrating Models and Simualtions of Continuous Dynamics into SysML

Nytsch-Geusen [11] developed a specialized version of UML called UMLH. This version is used in
the graphical description and model-based development of hybrid systems in Modelica. The author
presents hybrid system models as Modelica models
that are based on DAEs combined with discrete state
transitions modeled with the Modelica statechart extension. Using a UMLH editor and a Modelica tool
that supports code generation, Modelica stubs can be
automatically generated from UMLH diagrams so
that the user must only insert the equation-based behavior of the system in question. In this paper, the
capabilities of ModelicaML and UMLH are further
extended by demonstrating the integration of continuous dynamics models with other SysML constructs for requirements, structure, and design objectives, and by demonstrating the translation between
SysML and Modelica through the use of TGGs.

3

An Introduction to SysML: The
Car Suspension Model

Before discussing the approach for modeling
continuous dynamics and simulations in SysML, this
section reviews some important SysML constructs
and introduces the example problem used throughout
this paper.
3.1

SysML Blocks

The primary modeling unit in SysML is the
block. As described in chapter 8 of the SysML
specification [4], a block is a modular unit of a system description. A block can represent anything,
whether tangible or intangible, that describes a system. For instance, a block could model a system,
process, function, or context. When combined together, blocks define a collection of features that describe a system or other object of interest. Hence,
blocks provide a means for an engineer to decompose a system into a collection of interrelated objects.
All block declarations occur in a Block Definition Diagram (BDD). A BDD is used to define
block features and the relationships between blocks
or other SysML constructs. Figure 1 depicts the
definition of a car and its suspension. A car is obviously composed of more subsystems and components, but Figure 1 is sufficient for the sake of demonstration. SysML allows a modeler to omit elements of the underlying information model that detract from the main intent of a diagram.

The Modelica Association

Figure 1. The SysML car suspension model.

3.2

SysML Properties

A SysML property describes a part or characteristic of a block and consists of a named value of a
specified type. In Figure 1, two important categories
of properties are depicted. The first kind of property
is a part property. Part properties represent a subsystem or component of a system and must be typed
by a block. Part properties can be depicted in the
parts compartment of a block or using a composition
association. A composition association is depicted
using a black diamond with a tail. The property
name appears at the tail end of the association. For
example, the block Car in Figure 1 owns a part property named suspension of type WheelSuspension.
The second kind of property is a value property.
A value property appears in a blocks values compartment and represents a quantifiable characteristic
of a block (e.g. mass, length, velocity) and must be
typed to a SysML value type. A value type is a special modeling element (similar to a block) used to
assign the units of measure and dimension declared
in its definition. For example, Car in Figure 1 has a
value property mass which is typed to the value type
SI.Mass to supply units of kilograms.
3.3

UML Stereotypes

A stereotype is a UML construct used to create
customized classifications of modeling elements.
Stereotypes are defined by keywords that appear inside of guillemets. These customization constructs
extend the standard elements to identify more specialized cases important to specific classes of appli-

137

Modelica 2008, March 3rd  4th , 2008

T. Johnson, C. Paredis, R. Burkhart

cations. Most SysML constructs have been defined
as UML stereotypes, and users are allowed to create
additional stereotypes to capture the specialized semantics of a particular application domain. An example of a stereotype is illustrated in Figure 1. The
stereotype moe applied to the WheelSuspensions
value property settlingTime indicates that it is a
measure of effectiveness.
3.4

SysML Requirements

A SysML requirement is used to represent a textual requirement or objective for a system, subsystem, or component. Requirements are shown with
the requirement stereotype and optionally have a
compartment for displaying text and identification
fields. Requirements are related to other modeling
elements using various dependencies such as the satisfy and verify dependencies.

4

Modeling Continuous Dynamics in
SysML

In this section, the approach to modeling continuous dynamics in SysML is presented. The approach builds on the initial modeling foundation outlined in [12]. Rather than elaborating upon every
detail, only the most important modeling constructs
are discussed.
4.1

Objectives

A model is valuable if it increases a decision
makers ability to design a better system at an acceptable cost [13]. As explained later in this section,
the continuous dynamics modeling constructs will
provide value if they meet the following objectives:





Enable the integration of continuous dynamics
models into broader SysML models;
Facilitate the execution (i.e., simulation) of
these continuous dynamics models;
Encourage model reuse;
Facilitate efficient stakeholder communication.

The intent of these objectives is to strike an appropriate balance between the benefits expected from
developing a model and the costs of encoding the
required information.
Model integration is essential for managing system complexity through recognition and establishment of dependencies and associations between
models of continuous dynamic system behavior and
other models of system behavior, structure, or func-

The Modelica Association

tionality. SysML is a language for describing systems engineering information and knowledge, but is
by itself not executablemodel execution is relegated to an editing and execution tool. To be effective, it is therefore important to establish seamless
connections between SysML and simulation tools.
Model reuse is another imperative for realizing significant reductions in project resource expenditures.
Finally, using a unified approach for representing
continuous dynamics in SysML establishes a protocol for unambiguous communication of behavioral
information between designers operating in various
engineering disciplines.
4.2

Modelica as a Foundation

When creating a formal approach for representing continuous dynamics in SysML, Modelica provides a strong foundation. Modelica has emerged as
the language of choice for expressing continuous
dynamic system behavior. It is better structured and
more expressive than most alternatives such as
VHDL-AMS [14] or ACSL [15]. In addition, both
SysML and Modelica are similar in that they use
base modeling elements that adhere to the principles
of object-oriented modeling. Both languages also
encourage model reuse through acausal equationbased modeling. Unfortunately, enough differences
exist such that a direct one-to-one mapping is not
possible. Since SysML is intended to be a general
modeling language, some of the specialized semantics of Modelica do not have a direct equivalent in
SysML. To overcome these differences, our approach has been to find a good balance between converting some implicit Modelica semantics into explicit constraints in SysML or, when that is not possible, extending the SysML constructs through
stereotypes.
4.3

Model Declaration

When modeling continuous dynamic system behavior, a modeler must first declare the model that
represents the system of interest. This involves
specifying the blocks and properties needed to decompose the system to an appropriate level of abstraction. The level of abstraction is determined by
the amount of detail needed to perform an acceptable
system analysis. This declaration approach is analogous to creating Modelica classes that own components and variables typed to other class definitions.
To illustrate model declaration, Figure 2 displays
the declaration of a continuous dynamics model of a
Mass-Spring-Damper (MSD) system. This model
will be used in Section 6 to perform a behavioral

138

Modelica 2008, March 3rd  4th , 2008

Integrating Models and Simualtions of Continuous Dynamics into SysML

To illustrate the declaration of a model interface,
Figure 2 depicts a block named MechJunction. This
is a reusable block that encapsulates position and
force value properties corresponding to translational
across and through variables. To define the interfaces for each component of MSD, the appropriate
number of part properties are declared for each component and then typed to MechJunction. For example, Mass has one part property j typed to MechJunction.
4.5

Figure 2. BDD of the MSD continuous dynamic system
behavior model.

analysis on the car suspension model from Figure 1.
The MSD system is composed of a mass, spring,
damper, fixed position (i.e. ground fixture), and a
detector that determines system settling time. The
block MSD represents the declaration of the MSD
system while the other blocks (Mass, Spring,
Damper, SteadyStateDetector, Fixed, and MechJunction) represent the definitions of the system components.
Upon declaring the necessary models, their
properties must be identified. Figure 2 depicts the
declaration of both the part and value properties.
MSD is attributed with the mass, spring, damper,
ground, and detect part properties typed to the Mass,
Spring, Damper, Fixed, and SteadyStateDetector
block definitions, respectively. While MSD has no
value properties, most of the block definitions to
which its part properties are typed contain value
properties. For example, Mass contains a value
property m typed to the value type SI.Mass.
4.4

Model Interface

To interact with other models, a given model
must have a well-defined interface. Models used in
the description of a systems continuous dynamic
behavior generally interact using exposed across and
through variables [16]. Since across and through
variables are the only means of interaction, they
should be encapsulated inside of reusable blocks that
are typed to the part properties of another block.
These part properties are then exposed to other system components and subsystems. This type of interface is similar to the usage of Modelica connectors.

The Modelica Association

DAE-Based Internal Behavior

To define a models DAE-based internal behavior, Modelica relies on equations declared in the
equation clause of a given class. Similarly, this is
accomplished by placing SysML constraints on a
given block. A constraint is simply the representation of an equation that constrains a blocks value
properties. Constraints appear between braces and
are displayed in a blocks constraints compartment.
To model initial conditions, a constraint can be assigned the initial stereotype. This stereotype is an
extension to SysML; it can only be assigned to constraints and implies that the constraint only holds
true at the beginning of a simulation.
Usages of constraints and the initial stereotype
are shown in Figure 2. The internal behavior of the
block Mass is defined using four regular constraints
and one initial constraint. Note that the constraints
explicitly refer to the Modelica language, but other
syntax could be used according to the modelers preferred executable language.
4.6

Energy and Signal Flow between System
Components

To model the flow of energy through a system
and its components, a means of interaction must be
provided to the interface part properties described in
Section 4.3. Generally, the flow of energy in a system is described using the equivalent of Kirchhoffs
circuit laws: at a connection, all across variables are
equal, while all the through variables add up to zero.
While this is modeled implicitly in Modelica using
connect clauses, our SysML modeling approach explicitly models the interaction with reusable constraint blocks. As defined in the SysML specification [4], a constraint block is a specialized form of
the SysML block and is intended to package commonly used equations in a reusable, parameterized
fashion. Constraint blocks can be identified by the
constraint stereotype that appears in their namespace compartment. To use the definition of a constraint block, another block or constraint block can

139

Modelica 2008, March 3rd  4th , 2008

T. Johnson, C. Paredis, R. Burkhart

declare a constraint property and assign the type to a
constraint block. Using a SysML parametric diagram, the parameters used in the definition of the
constraint can be bound to the properties of another
block or constraint block using binding connectors.
A binding connector implies a pure equality constraint between two objects. If the objects are part
properties, then all of the sub-properties belonging to
each part are equal. It is this difference between the
semantics of SysML binding connectors and Modelica connections that necessitates the inclusion of an
explicit node constraint block in SysML.
Figure 2 shows the definition of a constraint
block named MechNode. This constraint block has
three parameters j1, j2, and j3 of type MechJunction.
The across and through variables of these parameters
are subject to the three packaged constraints that describe Kirchhoffs circuit laws for a translational
mechanical system. MSD owns three constraint
properties typed to MechNode to enable the interaction of its part properties. Figure 3 displays a parametric diagram that depicts the part interactions as a
result of binding usages of MechJunction.

5

Figure 3. Parametric diagram of the MSD model.

SysML and Modelica Integration

Currently, system engineering problems are
solved using a wide range of domain-specific modeling languages. Moreover, it is unlikely that a single
unified modeling language will be able to model in
sufficient detail the large number of system aspects
addressed by current domain-specific languages.
One should not reinvent the wheel by creating an
all-encompassing systems engineering language capable of modeling and simulating every aspect of a
system. On the other hand, managing a large number of models in different languages also poses problems, including communication ambiguity and the
preservation of information consistency. To alleviate these problems, a model integration framework is
needed for managing the various modeling languages
used to solve systems engineering problems.
SysML can provide an answer to this need for
model integration. Using SysML, a modeler can
abstract a domain-specific language to a level that
permits its interaction with other system models. For
example, a Modelica model is an excellent way to
capture hybrid discrete/DAE-based system behavior,
but is not capable of modeling system structure or
requirements. Using the modeling approach outlined
in Section 4, a modeler can abstract a Modelica

The Modelica Association

model into SysML syntax to represent dependencies
and associations with other system models1.
While SysML is a valuable integration tool,
much of that value could be detracted if engineers
must manually transform domain-specific models
into SysML and vice-versa. In the case of continuous dynamics models, we need an approach for accomplishing automated, bidirectional transformations between the SysML and Modelica languages.
Many methods exist for completing model transformations between two or more modeling languages
(metamodels). Two common transformation tools
are OMGs Queries/Views/Transformations (QVT)
[17] and TGGs [6].
The QVT specification provides a set of languages for querying a source model that complies
with a source metamodel and transforming it into a
target model that complies with a target metamodel.
Two QVT languages, Relations and Core, are used
1

Dependencies and associations are UML constructs
for expressing types of relationships between information
objects.

140

Modelica 2008, March 3rd  4th , 2008

Integrating Models and Simualtions of Continuous Dynamics into SysML

to declaratively model the relationships between
source and target metamodels at different levels of
fidelity. The Operational Mappings language is then
used to perform imperative transformations based on
the relationships depicted in the Core or Relations
languages. Overall, QVT is a powerful and widely
accepted model transformation tool; however, the
imperative nature of the Operational Mappings language hampers bidirectional transformations.
TGGs are similar to QVT in intent but are declarative by nature. Accordingly, TGGs are particularly useful for completing complex, bidirectional
model transformations. In a TGG, the metamodels
for the source and target languages are defined as
graphs. The mapping between the two languages is
then represented as a set of graph transformation
rules applied to a third graph: a correspondence
graph. For example, a SysML block would be related to a Modelica class using a correspondence
entity named block2class with one relation pointing
to the block entity (in the SysML metamodel graph)
and one to the class entity (in the Modelica
metamodel graph). By querying a model space containing SysML or Modelica models, transformations
are performed until the model space complies with
the specified TGG.
Due to the declarative, bidirectional nature of
TGGs, one set of graph transformation rules can be
used to transform SysML models into Modelica and
vice-versa. Although a TGG is used for this transformation, others have shown that QVT is equally
expressive and capable [18]. The TGG and graph
transformation rules have been encoded in the Visual
Automated Model Transformations (VIATRA) [19]
framework. VIATRA enables modelers to create
models in a declarative fashion and use pattern recognition to complete graph transformations in a sequential fashion using machines. To demonstrate
this TGG, a Java plug-in for Eclipse has been implemented to transform SysML models developed in
the Embedded Plus (E+) modeling environment into
Modelica models using the OpenModelica [20] compiler (OMC) and Modelica Development Tooling
(MDT) plug-in for Eclipse. The functionality of this
plug-in is depicted in Figure 4.

6

Modeling Simulations in SysML

In the context of model-based systems engineering, models and simulations allow systems engineers
to investigate and predict the behavior of system alternatives without the need for physical prototyping.
For example, a continuous dynamics model of a

The Modelica Association

Figure 4. Functionality of the SysML-to-Modelica
transformation Eclipse plug-in.

MSD can be used to simulate and predict the behavior of a car suspension alternative. This section describes how a continuous dynamics model can be
related to other relevant design information in
SysML: binding of model parameters in a model
context; defining an experiment performed on a
model in a simulation; defining a measure of effectiveness as the result of a simulation; and using an
abstracted simulation in the context of design optimization.
6.1

Defining the Model Context

In systems engineering, a continuous dynamics
model is always used in a particular model context.
Within this model context the elements of the system
structure are bound to the corresponding elements of
the analysis model. In current practice, engineers do
not always distinguish between the physical structure
or system topology and the corresponding system
behavior. For instance, it is common practice to use
an electric circuit diagram as the representation for
defining both the circuit topology as well as the behavior of the circuit in a SPICE simulation. As systems become more complex there often is a need to
represent a system by multiple simulation models,
corresponding to different levels of abstraction or
different disciplinary perspectives. The use of an
explicit model context as suggested here facilitates
the preservation of consistency amongst all the separate models.
To relate the structure to the behavior, a model
context block is defined with two part properties: one
usage of the system model and one usage of the
analysis model. If mathematical relationships be-

141

Modelica 2008, March 3rd  4th , 2008

T. Johnson, C. Paredis, R. Burkhart

yond simple equivalence exist between the known
elements of the system model and the corresponding
elements of the analysis model, additional constraint
blocks can also be defined. Finally, a parametric diagram of the model context block is created to bind
the known system elements to the corresponding
analysis elements.
In the lower portion of Figure 5, the block
ModelContext is defined as owning usages of MSD,
Car, and a constraint block named MassRelation. In
Figure 6, a corresponding parametric diagram is
shown establishing a relationship between the MSD
and car masses. Inside of this parametric diagram,
msd.mass.m is defined as one quarter of the mass of
mcCar.mass by connecting them to the appropriate
parameters on the constraint property massRel.
6.2

Modeling the Simulation

A simulation is an experiment performed on a
computational model [21]. Before a simulation can
be performed, the experiment needs to be completely
defined: the initial values and boundary values, the
outputs to be observed, and potentially the process
steps one should go through in the experiment (e.g.,
time traces of external inputs). From a modeling
perspective, all of these aspects can be captured in
the model itself or in extensions of the model defined
using the same Modelica/SysML constructs described in Section 4. One can therefore assume that
the model as defined in the model context is fully
specified  all the parameters are bound to values
and the set of system equations is non-singular.
Under those assumptions, the only additional information that needs to be provided is the start and end

Figure 5. BDD of the SuspensionSimulation block.

The Modelica Association

Figure 6. Parametric diagram of the ModelContext.

time of the simulation.
To make the semantics of a simulation explicit in
SysML, we have defined a simulation stereotype.
As is illustrated in Figure 5, this stereotype requires
the inclusion of a time property, which represents the
simulation time; startTime and stopTime properties;
and a simModel block. The meaning of the stereotype is then that all the properties in the simModel
are evaluated as a function of time from startTime to
stopTime. Note that this stereotype completely defines a simulation experiment in a fashion that is independent of any particular simulation solver. In
addition, note that Modelica semantics differ from
SysML semantics which require the explicit definition of a local simulation time property to which all
time-varying system properties can be bound.
6.3

Abstracting the Simulation

A simulation as defined in the previous section
allows a systems engineer to define an experiment in
which the system behavior can be observed. However in systems engineering, simulations are often
used to make decisions. In that case, the same experiment is often performed on multiple variations of
the same system  the design or decision alternatives. It then becomes important to abstract this
simulation formally by clearly defining the inputs
(the properties that can take on different values from
one simulation run to the next), and the outputs (the
properties that are of interest to the design, for instance, a measure of effectiveness that drives a design optimization). The relationship between inputs
and outputs of the simulation can then itself be considered as a model. Unlike the model of the system,
this input-output model is an algebraic relationship,
albeit a very complex one that requires running the
entire simulation to compute the outputs from the
inputs. When abstracting (or wrapping) a simulation in this fashion in support of decision making, it
is justifiable to assume that the outputs of the simulation are scalar quantities (decisions can only be made

142

Modelica 2008, March 3rd  4th , 2008

Integrating Models and Simualtions of Continuous Dynamics into SysML

Figure 8. BDD of the SuspensionAnalysis block.

Figure 7. Parametric diagram of SuspensionSimulation.

based on scalars because vectors cannot be rankordered [22]). Sometimes this requires that one include additional modeling elements in the continuous
dynamics model to define these scalar measures of
effectiveness. For instance, in the BDD in Figure 5
and the corresponding parametric diagram in Figure
7, the suspension simulation has been abstracted into
an input-output model with inputs as the decision
variables, dInput and kInput (bound to the damping
and stiffness of the suspension), and an output as the
measure of effectiveness, ssTimeOutput (the steadystate time of the mass-spring-damper system). The
output has been bound to a model property through a
sample and hold constraint property, sample&hold,
making explicit that the output takes on the value of
the time-varying property detect.ssTime when the
simulation time equals stopTime. In general, more
complex models may be necessary to relate scalar
outputs to time-varying simulation properties.
6.4

Embedding a Simulation into an Analysis

Once a simulation has been abstracted into an
input-output model, it can be used in support of analyzing system alternatives with respect to stakeholder
requirements and measures of effectiveness, as is
illustrated in Figures 8 and 9. Analyses generally
verify that a system alternative meets a certain system requirement, which can be modeled explicitly
using the verify dependency. A parametric diagram of that block can be used to connect the system
alternative to the simulation, as is illustrated in Figure 9. Instead of binding the simulation inputs and
outputs directly to the corresponding value properties
of the system alternative, one could also define an
optimization problem in which the stiffness and
damping are optimized with respect to one or more

The Modelica Association

Figure 9. Parametric diagram of SuspensionAnalysis.

measures of effectiveness. Whenever there is a need
for repeated evaluation of the simulation with different inputs, it is desirable to embed the simulation
explicitly in an analysis context as is shown in Figure 8.

7

Discussion and Closure

In this paper, we have introduced an approach
for combining SysML and Modelica in a synergistic
fashion. No single language or formalism can possibly capture all of the knowledge and information
needed to solve systems engineering problems.
While Modelica is well-suited for describing the dynamic behavior of complex systems, it offers no
support for relating that behavior to stakeholder requirements. Similarly, SysML allows one to define
the high-level relationships between requirements
and functional, physical and operational architectures
of a system, but lacks the detailed semantics to capture for instance geometry. It is therefore crucial that
capabilities are developed for relating in a formal
framework the different knowledge representations
commonly employed in systems engineering problems. SysML provides the foundation for making a
first step in that direction. The general-purpose and
adaptable nature of the language enables system engineers to interrelate their preferred knowledge representations. In addition, formal metalevel mappings
as described by TGGs provide a promising founda-

143

Modelica 2008, March 3rd  4th , 2008

T. Johnson, C. Paredis, R. Burkhart

tion for bidirectional mappings between the different
knowledge representations.
Using the modeling approaches described in this
paper, engineers will be more capable of managing
system complexity through the modeling of dependencies between continuous dynamic system behavior
and other system aspects. Additionally, the mapping
of SysML to Modelica and the resulting transformation abilities enable engineers to describe their systems at a higher level of abstraction while still maintaining the benefits of executable knowledge representations.
In this paper, the intent has been to take advantage of SysMLs adaptability and to make a step towards the unification of various modeling formalisms. While the continuous dynamics modeling approach described in this paper builds on the Modelica language, it still maintains a certain language
independence thanks to the general, declarative nature of Modelica. TGGs could be developed to map
SysML to the syntax of other languages, with the
restriction that when mapping to a causal, procedural
modeling language, a compiler must be used to assign causalities and sort the equations.
The ongoing efforts towards the unification of
engineering knowledge representations in SysML are
exciting steps for the systems engineering community. Utilizing and increasing the abilities of SysML
promises to improve the current state of systems engineering and bring to fruition the benefits of MBSE.

This work has been funded by Deere & Company. Additional support was provided by the ERC
for Compact and Efficient Fluid Power, supported by
the National Science Foundation under Grant No.
EEC-0540834. The authors would also like to thank
Sandford Friedenthal, Leon McGinnis and Russell
Peak for the discussions that helped crystallize the
ideas presented in this paper.

References

[2]

[5]

[6]

[7]

[8]

[9]

[11]

[12]

Sage, A. P., and Armstrong Jr., J. E., 2000,
Introduction to Systems Engineering, John
Wiley & Sons, Inc., New York, NY.
Fisher, J., 1998, "Model-Based Systems Engineering: A New Paradigm," INCOSE Insight, 1(3)

The Modelica Association

[4]

[10]

Acknowledgements

[1]

[3]

[13]

144

Gero, J. S., 1990, "Design Prototypes: A
Knowledge Representation Schema for Design," AI Magazine, 11(4), pp. 26-36.
Object Management Group, 2007, "OMG
Systems Modeling Language Specification,"
http://www.omg.org/cgi-bin/doc?ptc/07-0901.
Booch, G., Jacobson, I., and Rumbaugh, J.,
2005, The Unified Modeling Language User
Guide, Addison-Wesley Professional.
Schrr, A., 1994, "Specification of Graph
Translators with Triple Graph Grammars,"
in WG'94 Workshop on Graph-Theoretic
Concepts in Computer Science.
Peak, R. S., and Wilson, M. W., 2001, "Enhancing Engineering Design and Analysis
Interoperability Part 2: A High Diversity Example," First MIT Conference Computational Fluid and Structural Mechanics
(CFSM), Cambridge, Massachusetts, USA.
Peak, R. S., Burkhart, R. M., Friedenthal, S.
A., Wilson, M. W., Bajaj, M., and Kim, I.,
2007, "Simulation-Based Design Using
SysML-Part1: A Parametrics Primer," in
INCOSE Intl. Symposium, San Diego, CA.
Peak, R., Friedenthal, S., Moore, A.,
Burkhart, R., Waterbury, S., Bajaj, M., and
Kim, I., 2005, "Experiences Using SysML
Parametrics to Represent Constrained Object-Based Analysis Templates," 7th NASAESA Workshop on Product Data Exchange
(PDE), Atlanta, GA, USA.
Pop, A., and Akhvlediani, D., and Fritzson,
P., 2007, "Towards Unified Systems Modeling with the ModelicaML UML Profile," in
International Workshop on Equation-Based
Object-Oriented Languages and Tools,
Linkping University Electronic Press, Berlin, Germany.
Nytsch-Geusen, C., 2007, "The Use of UML
within the Modelling Process of ModelicaModels," in International Workshop on
Equation-Based Object-Oriented Languages
and Tools, Linkping University Electronic
Press, Berlin, Germany.
Johnson, T. A., Paredis, C. J. J., Burkhart, R.
and Jobe, J. M., 2007, "Modeling Continuous System Dynamics in SysML," in 2007
ASME International Mechanical Engineering Congress and Exposition, ASME, Seattle, WA.
Keeney, R. L., 1994, "Creativity in Decision
Making with Value-Focused Thinking,"
Sloan Management Review, 35(4), pp. 3341.

Modelica 2008, March 3rd  4th , 2008

Integrating Models and Simualtions of Continuous Dynamics into SysML

[14]

[15]

[16]

[17]

[18]

Christen, E., and Bakalar, K., 1999, "VHDLAMS - A Hardware Description Language
for Analog and Mixed-Signal Applications,"
IEEE Transactions on Circuits and Systems
II: Analog and Digital Signal Processing,
40(10), pp. 1263-1272.
Mitchell, E. E. L., and Gauthier, J. S., 1976,
"Advanced Continuous Simulation Language (ACSL)," SIMULATION, 26(3), pp.
72-78.
Paynter, H., 1961, Analysis and Design of
Engineering Systems, MIT Press, Cambridge, MA.
Object Management Group, 2007, "Meta
Object
Facility
(MOF)
2.0
Query/View/Transformation Specification,"
http://www.omg.org/docs/ptc/07-07-07.pdf.
Greenyer, J., Kindler, E., 2007, "Reconciling
TGGs with QVT," in Model Driven Engi-

The Modelica Association

[19]

[20]

[21]

[22]

145

neering Languages and Systems, MoDELS
2007, Springer, Berlin / Heidelberg.
Varr, D., 2003, VIATRA: Visual Automated
Model Transformation, Thesis, Department
of Measurement and Information Systems,
University of Technology and Economics,
Budapest.
Fritzson, P., et al., , 2007, "OpenModelica
System
Documentation,"
http://www.ida.liu.se/labs/pelab/modelica/O
penModelica/releases/1.4.3/doc/
OpenModelicaSystem.pdf.
Fritzson, P., 2004, Principles of ObjectOriented Modeling and Simulation with
Modelica 2.1, IEEE Press, Piscataway, NJ.
Keeney, R. L., and Raiffa, H., 1976, Decisions with Multiple Objectives: Preferences
and Value Tradeoffs, Jon Wiley and Sons,
New York.

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

146

Modelica 2008, March 3rd  4th , 2008

Modelica Library for Logic Control Systems written in the FBD Language

Modelicalibraryforlogiccontrolsystems
writtenintheFBDlanguage
AlbertoLeva,FilippoDonida,MarcoBonvini*,LorenzoRavelli*
DipartimentodiElettronicaeInformazione,PolitecnicodiMilano
ViaPonzio,34/520133Milano,Italy
{donida,leva}@elet,polimi.it
*
formerstudentatthePolitecnicodiMilano

Abstract
ThepaperdescribesaModelicalibraryforthesimulationoflogiccontrolsystemswrittenin
theFBD(FunctionalBlockDiagram)languageasdefinedintheIEC61131.3standard.The
library containsnotonlystrictlylogicblocks,butalsothemaintypesofindustrialPID
controllers.Modelsofdifferentcomplexitylevelsareincluded,sothattheusercanspecifya
controlsystemasacontinuoustimemodel(forfastsimulationtocheckwhetherornota
controlstrategysolvestheproblemathand)oraneventbasedone(forpreciseevaluationof
thealgorithms'behaviour).

SequentialFunctionalChartorSFC,Functional
BlockDiagramorFBD,StructuredTextorST,
InstructionListorLD)basicallyorientedtologic
control,althoughmost systems  adheringto the
standardalsooffermodulatingcontrolfunctions.
In  the  last  years,  the  IEC61131.3  standard  has
become  very  popular  in  the  arena  of  PLC
programming,thereforespreadingoutinavast
numberofcontextsandapplications[2,10,8,16,
15,5].

1.Introduction
Inmanycontroldomains,particularlybutnot
exclusively    in  the  process  control  field,  a
correct  representation  of  the  control  system
connected to  the  plant  being  investigated is  of
paramountimportance[7,1,3,18,19,8,9,4,11,
13,17,21,15].Inmanycases,thestructuringand
the subsequenttuningofthatcontrolsystemis
eventhemaingoalofthesimulationactivity;and
alsoifcontrolcommissioningisnottheprimary
purposeofthesimulation,havingacorrectand
realistic  control  representation  is  always
important  in  order  to  draw  meaningful
conclusions.

As  such,  having  the  IEC61131.3  standard
availableintheModelicaenvironmentisofgreat
help,foratleasttworeasons.First,ifanindustry
standardis uniformly adopted,thereis(ideally)
no room for ambiguities in the communication
betweenthepeoplewhoownand/orruntheplant,
and the  analysts  who create the  simulator  and
realise the necessary  studies (some issues may
stillariseowingtothefactthatvirtuallyevery

Nowadays,  more and more  control  systems  are
implementedadheringtotheIEC61131.3standard
[1,2,6,7,20,10,11,14,16],thatdefinesfive
programminglanguages(LadderDiagramorLD,

The Modelica Association

147

Modelica 2008, March 3rd  4th , 2008

A. Leva, F. Donida, M. Bonvini, L. Ravelli

standard  is  the  result  of  a  compromise,  and
thereforeveryfrequentlyexistsalsointheform
of  socalled  dialects,  but  addressing  that
problemisapparentlybeyondthescopeofthis
research).  Second,  the  solutions  found  at  the
simulationlevelaredeployedtothetargetcontrol
architectureinaverystraightforwardway.

up/downcounters,

For  the  reasons  above,  a  free  (GPL)  FBD
Modelica  library  is  being  developed  at  the
PolitecnicodiMilano.Thepresentstateofthat
libraryisdescribedinthispaper,thatisorganised
asfollows.Section2describestheorganisationof
thelibrary,brieflylistitscontents,andpresents
someselectedblockswithaminimumofdetail.
Section3discussestwoexamples.Thefirstaims
at  showing  the  importance  of  having  the
regulators  described  both  at  a  simplified
(continuoustime)andatadetailed(eventbased)
level.  The  second  shows  some  library  blocks
appliedtothecontrolofasmallmanufacturing
system,toillustratehowtheobtainedModelica
schemes  are  easily  understood  by  people
developingcodeforthetypicalindustrialcontrol
architectures.  Finally,  section  4  reports  some
conclusions,andthefutureplansoftheresearch.
2Libraryorganisation

the FBD.OneBitOperation subpackage
implementsbasiclogicaloperations,



the FBD.CompareOperation subpackage
implementscomparisons(the<,>,>=,<=
,=  operators)  on  the  Integer  and  Real
types,



the FBD.Counter  subpackage provides

The Modelica Association

the FBD.MathOperation subpackage
implements  the  basic  mathematical
instructions,



the FBD.Timer subpackage  provides
timers(andissimilartotheCounterone),



the FBD.NBitOperation subpackage
implementslogicaloperationonarraysof
bits,



the FBD.LinearSystems subpackage
provides  linear,  time  invariant  dynamic
systems  in  the  continuous  and  discrete
time,  as  typically  specified  in  IEC
compliant  control  code  development
environments,



the FBD.IndustrialController subpackage
contains  several  industrial  controllers,
includingofcourseseveraltypesofPID,



the FBD.Test subpackage  contains  test
simulators  for  each  FBD  block,
individually,  to  allow  for  a  precise
comprehensionofitsfunctionalities,



and  finally  the FBD.Applications
subpackage  provides  some  examples  of
useoftheFBDblocksofthelibrary.

Forobviousspacereasonswedonotdescribethe
blockshere,referringtheinterestedreadertothe
librarydocumentation.Acoupleofremarksare
howeverworthsomelines.

ThelibrarycomesinasingleModelicapackage
named FBD,  and  organised  in  subpackages  as
sketchedbelow:




First,  for every component  a  test  model  is
provided, to allow the user to fully  understand
how  that  component  works,  and  possibly
disambiguate  situations  where  the  available
specifications  are  not  fully  univocal;  everyone
wishingtoextendthelibrary(contributionsareof
course welcome in  the  GPL spirit)  is  strongly

148

Modelica 2008, March 3rd  4th , 2008

Modelica Library for Logic Control Systems written in the FBD Language

discreteRealsp_d;
discreteRealpv_d;
discreteRealp_d(start=0);
equation
whensample(0,Ts)then
sp_d=sp;
pv_d=pv;
p_d=p;
p=Pr(pre(sp),pre(pv),K,b);
endwhen;
endProportional;

encouragedtodothesame.
Second,  especially  for  regulators,  both
continuoustime  and  eventbased  models  are
present.  The  former  type  of  model  allows  for
faster simulation, and is  the choice of  election
whenthepurposeistocheckthecorrectnessofa
control strategy.  The  latter  is  apparently  less
timeefficient,butallowstocheckthebehaviour
of  a  control algorithms.  The  library  therefore
allowstoperformbothtypesofsimulation,and
eventomixthetwo,e.g.byconvenientuseof
modelreplaceability,andtoplevelvariables.To
limit  the  performance  loss,  equations  (not
algorithms)wereusedineventbasedmodels,so
astoallowthosemodelstobemanipulatedwith
therestofthesimulator.Doingsoinvolvessome
limitationswhenportingapreexistingalgorithm
into  the  library,  since  for  example  multiple
assignments  are  not  allowed.  It  is  the  authors'
opinion,however,thatanaccuratetranslationin
the  form  adopted  by  the  presented  library  is
possible for  of  any  control  algorithm one  may
comeacross.

modelIntegral
RealInputsp"setpoint";
RealInputpv"processvariable";
RealOutputi"controlsignal";
parameterRealTs=0.1"sampletime[s]";
parameterRealTi=5"integraltime";
protected
discreteReali_d(start=0);
discreteRealsp_d(start=0);
discreteRealpv_d(start=0);
equation
i_d=i;
whensample(0,Ts)then
sp_d=sp;
pv_d=pv;
i_d=Int(pre(sp),pre(pv),Ti,Ts,pre(i_d));
endwhen;
endIntegral;
modelDerivative
RealInputsp"setpoint";
RealInputpv"processvariable";
RealOutputd"controlsignal";
parameterRealTs=0.1"sampletime[s]";
parameterRealTd=5"derivativetime";
parameterRealN=10"derivativefilter";
protected
discreteReald_d(start=0);
discreteReald_d2(start=0);
discreteRealpv_d(start=0);
discreteRealpv_d2(start=0);
discreteRealsp_d(start=0);
equation
d_d=d;
whensample(0,Ts)then
pv_d=pv;
sp_d=sp;
d_d2=pre(d_d);
pv_d2=pre(pv_d);
d_d=Der(pre(sp_d),pre(pv_d),pre(pv_d2),Td,Ts,N,pre(d_d2));
endwhen;
endDerivative;
modelPID_parallel_AW_Tr_AutoMan
RealInputsp"setpoint";
RealInputpv"processvariable";
RealInputtr"signalfollowedduringthetrackingmode";
RealInputCSman"controlsignalformanualmode";
BooleanInputTS"flagforthetrackingmode";
BooleanInputMAN"flagforthemanualmode";
RealOutputcs"controlsignal";
ProportionalP(Ts=Ts,K=K,b=b)"Proportionalblock";
DerivativeD(Ts=Ts,Td=Td,N=N)"Derivativeblock";
IntegralI(Ts=Ts,Ti=Ti)"Integralblock";
parameterRealTs=1"sampletime[s]";
parameterRealTi=8"integraltime";
parameterRealTd=5"derivativetime";
parameterRealK=10"proportionalconstant";
parameterRealb=1"weightofthesetpointinthePaction";
parameterRealN=10"derivativefilter";
parameterRealCSmax=1"Maxcsvalue";
parameterRealCSmin=0"minCsvalue";
protected
Realcontrol;
equation
P.sp=sp;
D.sp=sp;
I.sp=sp;
P.pv=pv;
D.pv=pv;
I.pv=pv;
control=if(MAN==false)
thenI.i+P.p+D.d
elseCSman;
cs=if(TS==trueandMAN==false)
thentr
elsemax(CSmin,min(CSmax,control));
endPID_parallel_AW_Tr_AutoMan;

Forexample,thefollowingModelicacodeisthe
eventbasedimplementationofanISAPIDwith
antiwindup,  manual  and  tracking  modes,  and
bumplessmodeswitch[17,18].
functionDer"Thisfunctionrepresentsaderivativeaction"
inputRealsp;
inputRealpv;
inputRealpv_old;
inputRealTd;
inputRealTs;
inputRealN;
inputReald_old;
outputReald;
algorithm
d:=Td/(Td+N*Ts)*d_oldTd*N/(Td+N*Ts)*(pvpv_old);
endDer;
modelProportional
RealInputsp"setpoint";
RealInputpv"processvariable";
RealOutputp"controlsignal";
parameterRealTs=0.1"sampletime[s]";
parameterRealK=5"proportionalconstant";
parameterRealb=1"setpointweight";
protected

Wenowreporttwosimulationexamples.thefirst
is  aimed  at  showing  the  usefulness  of  the

3Examples

The Modelica Association

149

Modelica 2008, March 3rd  4th , 2008

A. Leva, F. Donida, M. Bonvini, L. Ravelli

possibility  of  simulating  the  same  regulator  as
continuoustimeandaseventbasedmodel,while
the  second  shows  a  small  but  realistic
applicationofthepresentedlibrary.

3.1Example1
This  example  refers  to  some  PI/PID  control
loops,  and deals with  set  point  step  and ramp
responses where the  antiwindup  mechanism  of
theregulatorcomesintoplay.Theprocesstobe
controlledisdescribedbythetransferfunction

Figure1:resultsofexample1.

Figure 1  above  shows  the comparison between
the  continuoustime (R1) and eventbased (R2)
controllerimplementationinthecaseofaramp
response (left  column  of  plots)  and  of  a  step
response(rightcolumn):SP,PVandCSstandfor
Set  Point,  Process  (controlled)  Variable,  and
Control  Signal,  respectively.  Apparently,
simulatingthesamecontrollerasacontinuous
time  or  an  eventbased model  (i.e.,  as  it  will
really  be  implemented) can give  very  different
results,  depending  not  only  on  the  controller
parametrisation,thesamplingtimeandothervery
well  known  facts, but  also on  the  control  law
being  incremental  or  positional,  of  the
antiwinduptype,andsoon(factsthatconversely
arefrequentlyoverlooked).Theexampletherefore
backsuptheusefulnessofthepresentedlibrary
as  far  as  the  control  behaviour  evaluation  is
concerned.

1
P s =
12ss 2 /0.016
andthePIDregulator



R s=10 1

1
3s

30s 10.3s



is applied to it,  in the continuoustime version
and  as  an  eventbased model with  a  sampling
timeof0.01s.

3.2Example2
This  example  shows  the  control  of  a  small
manufacturingsystemwherepartsarefedtothe
workingareabyaconveyor,machined,andthen
taken  away  by  another  conveyor.  The  detailed
sequenceofoperationsisasfollows:

The Modelica Association

150

Modelica 2008, March 3rd  4th , 2008

Modelica Library for Logic Control Systems written in the FBD Language



lead  one  part  near  the  machining  area
entrancewithaninputbelt,



pushthepartintothemachiningareawith
aninputpiston,



machine  the  part  (drill  a  hole  with  a
controlledspeedmachininghead)



pushthepartoutofthemachiningarea
withanoutputpiston,

Figure2:schematicdrawingofthemachineconsideredin
example2.

and  finally  lead  the  part  away  with  an
outputbelt.
The  considered  machine  is  synthetically
describedinfigure2


Figure3showstheModelicaschemeusingsome
libraryblocks(mostlysetpointgenerators,PIDs,
andlogicelements),whileasampleofsimulated
transientsisgiveninfigure4.

Figure3:theModelicaschemeusingthepresentedFBDlibraryusedinexample2.

The Modelica Association

151

Modelica 2008, March 3rd  4th , 2008

A. Leva, F. Donida, M. Bonvini, L. Ravelli

Figure4:somesimulatedtransientsreferringtoexample2;theupperplotshowsthedrillingheadxposition(red)andset 
point(blue),thelowerplotshowsthedrillingdepth(red)andsetpoint(blue).

The  similarity  of  figure  3  with  the  schemes
encounteredinmanycontrol codedevelopment
systems  are  apparent.  The  example  therefore
backsuptheusefulnessofthepresentedlibrary
asfarastheclarityofthecontrolspecification(in
termsofawidelyacceptedindustrialstandard)is
concerned.

PIDtype.Theadoptionofanindustrialstandard
facilitates  information  sharing  and  greatly
reducesambiguities.

With  the  presented  library,  that  the  user  can
specifyacontrolsystemasacontinuoustimeor
aneventbasedmodel,formaximumflexibility
infulfillingthesimulationneeds.

4Conclusions
Somesimulationswerepresentedtoillustratethe
usefulnessofthelibrary,whichwillbeextended
inthefuture,withrespecttobothFBDandother
IECcompliantlanguages.

Afree(GPL)Modelicalibraryforthesimulation
of  logic  control  systems  written  in  the  FBD
(Functional  Block  Diagram)  language  was
presented.
ThelibraryadherestotheFBDspecificationsas
definedintheIEC61131.3standard,andcontains
notonlystrictlylogicblocks,butalsothemain
typesofindustrialcontrollers,particularlyofthe

The Modelica Association

152

Modelica 2008, March 3rd  4th , 2008

Modelica Library for Logic Control Systems written in the FBD Language

[7]
M.Bonfe',C.Fantuzzi,L.Poretti, PLC
ObjectorientedprogrammingusingIEC611313
norm  languages:  an application to  manufacture
machinery,inProc.ofIEEE/ASMEInt.Conf.on
Advanced  Intelligent  Mechatronics,  vol.  2,  pp.
787792,2001.

References
[1]
T.  Sato,  E.  Yoshida, Y.  Kakebayashi, J.
Asakura,N.Komoda,ApplicationofIEC611313
For Semiconductor  Processing  Equipment,
EmergingTechnologiesandFactoryAutomation.
Proceedings.  2001  8th  IEEE  International
Conferenceon,2001.

[8]
[Online].
http://www.plcopen.org.

[2]
J.Huang,Y.Li,W.Luo,X.Liu,K.Nan,
The  Design  of  NewType  PLC  based  on
IEC611313,  Proceeding  of  the  Second
Internadonal Conference on  Machine  Learning
andCybernetics,Xi,25,November2003.

Available

[9]
J.RogerFolch,J.Prez,M.Pineda, R.
Puche,  Graphical Development of  Software for
Programmable  Logic  Controllers,  12th
International  Power  Electronics  and  Motion
ControlConference.

[3]
D.  E.  Rivera,  M.  Morari,  and  S.
Skogestad,  Internal  model  control  4.  pid
controllerdesign,Ind.Eng.Chem.Res.,vol.25,
pp.252265,1986.

[10] [Misc].  DeltaV:  Monitor  and  control
software.
[11] [Misc].

http://www.ni.com/labview.

[4]
 H.Takada,H.Nakata, S.Horiike,A
Reusable Object Model  for  Integrating  Design
Phases  of  Plant  Systems  Engineering,
Proceedings  of  the  Fourth  International
Conference  on  Computer  and  Information
Technology(CIT04).

Labview:

[12] A.Nobuo,I.Kenichi,Y.Eiji,Application
portfoliosforstardom,12thInternationalPower
ElectronicsandMotionControlConference.
[13] M.  Otter,  K.  E. rzn,  I.  Dressler,
StateGraphAModelicaLibraryforHierarchical
State  Machines,  4th  International  Modelica
Conference,March78,2005.
[14] O.  Johansson,  A.  Pop,  P.  Fritzson,
Engineering  Design  Tool  Standards  and
InterfacingPossibilities toModelicaSimulation
Tools,  5th  International  Modelica  Conference,
September45,2006.

[5]
H.Taruishil,S.Kajiharal,J.Kawamotol,
M. Ono, H. Ohtani, Development  of  Industrial
ControlProgrammingEnvironmentEnhancedby
Extensible  Graphic  Symbols,  SICEICASE
International  Joint  Conference 2006  in  Bexco,
Busan,Korea,Oct.1821,2006.
[6]
Y.Qiliang,X.Jianchun,W.Ping,Water
Level  Control  of  Boiler  Drum  Using  One
IEC611313BasedDCS,Proceedingsofthe26th
ChineseControlConference,Zhangjiajie,Hunan,
China,July2631,2007.

The Modelica Association



[15] E.Tisserant,L.Bessard,M.deSousa,An
Open  Source  IEC  611313  Integrated
Development  Environment,  Industrial
Informatics, 5th  IEEE  International Conference
on,2007.

153

Modelica 2008, March 3rd  4th , 2008

A. Leva, F. Donida, M. Bonvini, L. Ravelli

1995.
[16] [Online].

ISaGRAF:
http://www.icpdas.com/products/PAC/i
8000/isagraf.htm

[20] L.  Desbourough,  R.  Miller,  Increasing
customervalueofindustrialcontrolperformance
monitoring    Honeywells  experience,  Sixth
International  Conference  on  Chemical  Process
Control,AIChESymposiumSeriesNumber326
(Volume98),2002.

[17] [book].O'DwyerAidan,HandbookofPI
and  PID  Controller  Tuning  Rules,  Imperial
CollegePress.
[18] [book].  K.  J. strm  and T.  Hgglund,
Advanced  PID  control,  ISA    The
Instrumentation,  Systems,  and  Automation
Society,2005.

[21] O.  Johansson,  A.  Pop,  P.  Fritzson,  A
functionality  Coverage  Analysis  of  Industrially
used  Ontology  Languages,  in  Model  Driven
Architecture:  Foundations  and  Applications
(MDAFA), 2004, 1011 June, 2004, Linkping,
Sweden.

[19] [book].  K.  J.  strm  and T.  Hagglund,
PID  Control  Theory,  Design  and  tuning,  ISA,

The Modelica Association

154

Modelica 2008, March 3rd  4th , 2008

Session 2b
Thermodynamic Systems & Applications

The Modelica Association

155

Modelica 2008, March 3-4, 2008

The Modelica Association

156

Modelica 2008, March 3rd  4th , 2008

ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica

ExternalMedia: A Library for Easy Re-Use of
External Fluid Property Code in Modelica
1

Francesco Casella1
Christoph Richter2
Dipartimento di Elettronica e Informazione, Politecnico di Milano, Italy
2
Institut fr Thermodynamik, TU Braunschweig, Germany
casella@elet.polimi.it
ch.richter@tu-bs.de

Abstract
The modeling of thermo-physical fluid properties is
of great importance when modeling thermo-fluid
systems. The Modelica Standard Library provides a
number of medium models that can be used in component models but are not sufficient in many applications. This paper presents a new interface library
with a Modelica front-end that allows for an easy
inclusion of external fluid property code in Modelica
using the standard interfaces provided in the Modelica.Media library. The new library was developed as
an open-source project and is available for free from
the Modelica website including an interface to the
FluidProp software developed and maintained at TU
Delft. The new library can easily be extended to
other external fluid property code.
Keywords: external fluid property code; Modelica.Media; thermo-fluid systems

1

Introduction

Modelica is finding more and more applications in
the field of thermo-fluid system modeling due to the
many advantages of the object-oriented equationbased approach. A fundamental problem in this field
is the availability of good Modelica models for the
computation of fluid properties. The Modelica.Media
library was included in the Modelica Standard Library in version 2.2. It currently provides several
ready-to-use models for ideal gases, mixtures, water/steam, moist air, table-based incompressible fluids, and generic linear fluid models which can be
used in a wide range of applications. The library and
some applications are described in [1] and [2]. However, there exists a large class of engineering systems
such as refrigeration systems, heat pumps, or organic
Rankine cycles that require accurate models of application-specific two-phase fluids which are currently not provided in the Modelica Standard Library.
The Modelica Association

One possibility to overcome this limitation is to write
the required medium models in Modelica, possibly
by conforming to the Modelica.Media interfaces for
greater compatibility. The advantage of this approach is that self-contained Modelica models are
obtained that can be optimized for efficiency. The
major drawbacks are that writing such code requires
a sizable investment in terms of time and effort, and
that the developed code can only be re-used in a
Modelica context.
The other possibility is to take advantage of existing
fluid property code developed for general-purpose
applications and to interface that code to Modelica.
This approach offers a couple of unique advantages
compared to a Modelica-internal solution:
 Many existing fluid property codes are welltested and used in a number of commercial
applications and products.
 Many existing fluid property codes provide
fast and robust solvers for the inverse iteration of fluid properties.
 External fluid property codes can be used in
a number of different software tools such as
simulators, office programs, and postprocessing tools.
Some existing publications such as [3] show that
interfacing external fluid property code from Modelica is a feasible alternative to Modelica-internal solutions. This solution becomes extremely interesting
if the effort of developing the interface for any given
external fluid property code is kept to a minimum.
The ExternalMedia library was developed with this
objective in mind. The current implementation considers two-phase, single-substance fluids since this
combination already covers many interesting applications that cannot be developed using existing
Modelica.Media models. Fluid mixtures might be
supported in the future.
The goals of the ExternalMedia library can be summarized as follows:

157

Modelica 2008, March 3rd  4th , 2008

F. Casella, C. Richter



The new medium models shall be 100%
compatible to the Modelica.Media interface.
 The new interface library that handles all external fluid property codes should work with
all available Modelica tools and C/C++
compilers.
 The effort to interface new external fluid
property codes should be kept as little as
possible.
 The new approach shall be numerically efficient to be comparable with current Modelica-internal solutions.
The new library including all source code will be
released on the Modelica website and will be made
available under the Modelica license.

2

Architecture of the Library

The new fluid property library consists of three main
parts: A Modelica front-end called ExternalMedia,
an interface layer written in C, and an objectoriented interface library called ExternalMediaLib
written in C++ that handles a number of external
fluid property codes.
The Modelica front-end of the new library is the ExternalMedia library, whose class structure is illus-

trated in Figure 1. This Modelica library contains a
package named ExternalTwoPhaseMedium that extends from PartialTwoPhaseMedium defined in
Modelica.Media.Interfaces. The ExternalTwoPhaseMedium package is generic. The actual external fluid
property code used is specified by setting the values
of suitable string constants in the medium package.
The libraryName specifies the name of the external
fluid property code to be used whereas the substanceName defines the name of the substance from
this external fluid property code. The mediumName
defined in the PartialMedium package in the Modelica.Media library is also passed to the interface library but is not used for the specification of the fluid.
The new external medium model can be used in any
component model that uses a medium package extending from PartialTwoPhaseMedium.
A set of functions in the ExternalTwoPhaseMedium
package corresponds one-to-one to C-functions defined in the C interface layer. These functions are
called according to the external function mechanism
as defined in the Modelica language specification.
The interface layer functions manage a collection of
C++ objects that define the interface to the external
fluid property codes. A class diagram of this part of
the new library is shown in Figure 2.

Figure 1: UML class diagram of packages in Modelica.Media and ExternalMedia library.

The Modelica Association

158

Modelica 2008, March 3rd  4th , 2008

ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica

Figure 2: UML class diagram of C++ objects in the ExternalMediaLib library.

The first fundamental object is the Solver object that
encapsulates the external fluid property code. In order to manage several different solvers at the same
time, the interface layer defines the map SolverMap
which is a collection of Solver objects indexed by
the strings defined in the ExternalTwoPhaseMedium
package. Each time an external function is called,
these strings are passed as arguments. This allows
for an instantiation of the corresponding solver when
the function is called the first time and for the interface layer to point to the correct solver in any subsequent function call.
The second fundamental object is the TwoPhaseMedium object which corresponds with a point in a
thermodynamic phase diagram such as a pressureenthalpy diagram or a point on the saturation curve
for saturation properties. Each TwoPhaseMedium
object contains a pointer to the corresponding Solver
object and a record of type TwoPhaseMediumProperties which is used as a cache record containing all
possible thermodynamic properties including transport properties. All instances of these objects are
stored in the map MediumMap which is indexed by
an integer called uniqueID.
In order to understand how the library works, consider the following code snippet:

The Modelica Association

import SI = Modelica.SIunits;
package Toluene
extends ExternalTwoPhaseMedium(
mediumName=Toluene,
libraryName=REFPROP,
substanceName=Toluene);
end Toluene;
model Example
Toluene.ThermodynamicState state;
SI.Density d;
SI.SpecificEnthalpy h;
equation
state = Toluene.setState_pT(1e5,300);
d = Toluene.density(state);
h = Toluene.specificEnthalpy(state);
end Example

The setState_pT() function of the medium package
calls the corresponding C function of the interface
layer, passing the values of pressure and temperature
as well as the three medium identification strings. If
those strings are not already present in the SolverMap, an instance of the corresponding solver (in this
case REFPROP [4]) is added to the SolverMap. Subsequently, an instance of TwoPhaseMedium is added
to the MediumMap and the setState_pT() function of
the Solver is called to compute all fluid properties.
The computed fluid properties are stored in the TwoPhaseMediumProperties object that acts as a cache
record. Finally, a unique identification number is
returned to identify the TwoPhaseMedium object in
the MediumMap. This number is stored in the ThermodynamicState record together with the values of
pressure, temperature, density, specific enthalpy, and

159

Modelica 2008, March 3rd  4th , 2008

F. Casella, C. Richter

specific entropy. Note, that the setState_pT() function in Modelica is an impure function since it returns a different uniqueID each time it is called.
When the density() function is called, the corresponding interface layer function is called with the
uniqueID stored in the ThermodynamicState record.
This allows for retrieving the already computed
value for the density from the TwoPhaseMedium
object in the MediumMap. The same thing happens
when the specificEnthalpy() function is.
At the next simulation step, when the setState_pT()
function is called again, a new TwoPhaseMedium
object is allocated in the MediumMap and a new
unique identification number is returned. In order to
avoid running out of memory, the MediumMap is
used as a circular buffer with a predefined maximum
number of TwoPhaseMedium objects. The size of
the buffer must be large enough to accommodate all
setState_XX() function calls during a single simulation step.
The most straightforward implementation of the
Solver objects computes all possible fluid properties
at once when a setState_XX() function is called. This
often is a reasonable option since most of the CPU
time is often spent on the inverse iteration while the
additional cost of computing all fluid properties is
small. However, it is always possible to decide that
the setState_XX() functions of the Solver only compute and store some of the properties and that the
additional computations are triggered when the functions to retrieve these additional properties are
called. This is very often a good idea for the transport properties. This mechanism allows for avoiding
unnecessarily repeated computations in a flexible
way that is 100% compatible with the existing structure of the Modelica.Media package.
Note, that the call of the setState_XX() functions
will usually be performed before the other function
calls because of the BLT partitioning of equations
performed by the Modelica compiler. If this does not
happen (e.g., due to the presence of implicit equations), the property functions could be called before
the unique identification number has been set, thus
with a default uniqueID=0. In this case it is still possible for the interface layer to select the correct
solver by using the medium identification strings and
to compute the required property using the values of
pressure, temperature, etc. stored in the ThermodynamicState record. The uniqueID argument is thus
introduced for efficiency reasons, i.e. to avoid unnecessarily repeated computations, but is not required for the correctness of the results.
If the BaseProperties model defined in the Modelica.Media library is used to compute the medium
The Modelica Association

properties, the circular buffer for the MediumMap
can be avoided. A unique identification number is
instead stored in each instance of the BaseProperties
model. This number is set once and for all during the
initialization phase. The setState_XX() functions are
then called within the BaseProperties model by explicitly supplying the uniqueID. The same TwoPhaseMedium object in the MediumMap is thus used
for all computations in the corresponding BaseProperties object. In order for the MediumMap to distinguish between these static unique identification
numbers and the transient unique identification numbers discussed in the previous paragraphs, the former
are given positive values while the latter ones are
given negative numbers.

3

Implementing new Medium Models

Implementing the interface to a new external fluid
property code is a straightforward task requiring a
limited amount of time.
First of all a new Solver must be defined, extending
from the BaseSolver. This new Solver has to implement all abstract setState_XX() functions defined in
the base class. These functions will actually call the
external fluid property code and store the retrieved
properties in the TwoPhaseMediumProperties cache.
Then, a few lines of code must be added to the getSolver() function of the SolverMap object in order to
recognize the new identification strings of the additional external fluid property code. All remaining
functionality is already provided by the library
framework.

4

Current Status and Future Development

The framework of the new library for the support of
external two-phase single-substance medium models
is complete. Two Solvers are already implemented.
The first Solver, TestSolver, is a dummy fluid model
roughly corresponding to cold water which can be
used to troubleshoot the C/C++ and Modelica compiler setup without worrying about the actual external code. It can also be used as a starting point for
new user-defined fluid property codes.
The second available Solver is an interface to the
FluidProp software [5] developed and maintained at
TU Delft which provides a common interface to several external fluid property codes including StanMix,
TPSI, and the whole REFPROP database. FluidProp
can be downloaded for free even though the REF-

160

Modelica 2008, March 3rd  4th , 2008

ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica

PROP module requires purchasing a license from
NIST. Since FluidProp is based on the proprietary
COM architecture by Microsoft, the corresponding
solver can only be compiled under MS Windows
using a MS Visual Studio compiler, even though an
extension based on open-source architectures is envisioned for the near future.
The library framework is fully compliant with standard Modelica (2.2 and 3.0) and with standard ANSI
C/C++. New Solvers can thus be implemented and
used within any Modelica tool, using any C/C++
compiler.
The library, including all source code, will be released under the Modelica License and will be made
available on the Modelica website. The C/C++
source code is fully documented, using the Doxygen
tool. Future development might include the development of new general-purpose Solvers as well as
the development of an external media interface for
fluid mixtures.
Furthermore, the object-based fluid property library
TILFluids developed at TU Braunschweig and presented in [6] uses the code of the presented external
fluid property library and provides a different Modelica interface. TILFluids also provides interfaces to
other software tools such as MS Excel or MATLAB/Simulink that might be included in a future
release of the ExternalMedia library.

5

[2]

[3]

[4]

[5]

[6]

Systems. In Proc. of 3rd International Modelica Conference, pages 269-286, Linkping,
November 2003.
F. Casella, M. Otter, K. Prl, C. Richter,
and H. Tummescheit. The Modelica Fluid
and Media library for modeling of incompressible and compressible thermofluid pipe
networks. In Proc. of 5th International Modelica Conference, pages 631-640, Vienna,
September 2006.
H. Tummescheit and J. Eborn. Chemical Reaction Modeling with ThermoFluid/MF and
MultiFlash. In Proc. of 2nd International
Modelica Conference, pages 31-39, Oberpfaffenhofen, March 2002.
E. W. Lemmon, M. Huber, and M. McLinden. NIST Standard Reference Database 23:
Reference Fluid Thermodynamic and Transport Properties-REFPROP, Version 8.0. National Institute of Standards and Technology,
Standard Reference Data Program, Gaithersburg, 2007.
FluidProp: A software for the calculation of
thermophysical
properties
of
fluids.
http://fluidprop.tudelft.nl/
C. Richter. Proposal of New Object-Oriented
Model Libraries for Thermodynamic Systems. Doktorarbeit, TU Braunschweig, to be
published in 2008.

Conclusions

This paper presents a new fluid property library for
two-phase single-substance fluids that allows for an
easy inclusion of external fluid property code in
Modelica, using the standard interfaces for twophase media defined in the Modelica.Media library.
Any model designed to use models derived from
these standard interfaces can therefore be used without any modification. The new library is freely available under the Modelica license, and can easily be
extended by including other external fluid property
codes. Further development might extend the interface to single-phase pure substances and mixture
media, as well as two-phase mixture media. Interested users are welcome to use the new library in
their applications and are invited to contact the authors for contributions to the project.

References
[1]

H. Elmqvist, H. Tummescheit, and M. Otter.
Object-Oriented Modeling of Thermo-Fluid

The Modelica Association

161

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

162

Modelica 2008, March 3rd  4th , 2008

ThermoBondLib - A New Modelica Library for Modeling Convective Flows

ThermoBondLib  A New Modelica Library for
Modeling Convective Flows

Franois E. Cellier
ETH Zrich
Switzerland
FCellier@Inf.ETHZ.CH

Jrgen Greifeneder
Technische Universitt Kaiserslautern
Germany
Greifeneder@EIT.Uni-Kl.DE

Abstract
This paper describes a new library designed for
modeling convective flows in physical systems. The
library is based on bond graph technology. Thermobonds are introduced as a means to capture the convective flow of the internal energy of matter through
a physical system. ThermoBondLib is a companion
library to the BondLib and MultiBondLib libraries
that were released in 2005 and 2006, respectively.
Keywords: Bond Graph, Thermo-bond Graph,
Convective Flow

1

Introduction

1.1

Introduction to Thermo-bond Graphs

Bond graphs [1] describe the flow of power through
a physical system. Each power flow can be written
as the product of two variables, one extensive, the
other intensive. For example, electrical power can
be written as the product of voltage and current,
whereas mechanical translational power can be written as the product of force and velocity.
Since all physical systems have to comply with
energy conservation laws, a tool that balances all
power flows in a physical system can, in principle,
be used to model any such system.
A Modelica library based on bond graph technology, BondLib [2], was released in 2005 and presented at the 4th Modelica conference in HamburgHarburg. The library won the 1st price for a free
Modelica library at that conference.
Whereas bond graphs are capable of describing
all types of physical systems, it may not be convenient to do so. Bond graph models are rather primitive, low-level descriptions of a physical system, and
therefore, a bond graph representing a complex

The Modelica Association

physical system will necessarily be large and poorly
readable.
However, bond graphs are nevertheless very useful, because they represent the lowermost graphical
interface to a physical system model that is still fully
object-oriented. Thus, by wrapping other, higherlevel modeling methodologies around a bond graph
implementation, the semantic distance between the
lowermost graphical layer and the bottom equation
layer can be reduced. This makes a library that is
based on bond graph technology easily maintainable.
BondLib contains several wrapped sub-libraries
for modeling particular classes of physical systems.
For modeling electronic analog circuits, BondLib
offers a complete implementation of Spice built on
bond graph technology [3]. For modeling 1D mechanical systems, BondLib offers two sub-libraries,
one for translational, the other for rotational motion,
that are similar in nature to the corresponding sublibraries of the Modelica standard library, but are
built upon bond graph technology. For thermal systems, BondLib offers a heat transfer sub-library, etc.
Since its inception, BondLib has been updated
several times to include new wrapped sub-libraries.
For example, the mechanical and thermal sublibraries became available only in 2007.
However, it may still be too inconvenient to
model a complex physical system down to the bond
graph layer in a single step. For example, the semantic distance between a multi-body system description
of a 3D mechanical system and a bond graph description thereof is still too large. Another intermediate layer is needed to be inserted between these
two layers.
To this end, a second bond graph library, MultiBondLib [5], was released in 2006 and presented at
the 5th Modelica conference in Vienna. The library

163

Modelica 2008, March 3rd  4th , 2008

F. Cellier, J. Greifeneder

won the 1st price for a free Modelica library at that
conference.
When dealing with 2D or 3D mechanical systems, the dAlembert principle needs to be formulated several times, once for each spatial direction.
Also, the principle needs to be formulated separately
for translational and rotational motions. This calls
for a vector representation of bonds, which is precisely the framework that MultiBondLib has been
based upon.
MultiBondLib also offers several wrapped libraries for higher-level descriptions of 2D and 3D mechanical systems. These higher-level descriptions
are internally implemented as multi-bond graphs.
The multi-bond graphs are then directly translated to
the equation layer using the matrix/vector notation of
Modelica. This was simpler and more efficient than
translating the multi-bond graphs first down to regular bond graphs in a graphical fashion.
When dealing with convective flows, there is yet
another complication to be considered [4-7]. When
considering a mass moving macroscopically from
one place to another, that mass carries along with it
its internal energy of matter, U:
U=TSpV+gM

(1)

where T denotes temperature, S is the entropy, p
represents pressure, V stands for the volume, g symbolizes the Gibbs potential (specific enthalpy), and
M finally captures the mass.
The flow of internal energy, Udot = dU/dt, can
be written as:
Udot = T  Sdot  p  q + g  Mdot

(2)

where q = Vdot represents the volumetric flow rate.
Consequently, a mass flow is always accompanied
by a heat flow and a volumetric flow.
For this reason, mapping convective flows directly down to regular bond graphs is once again
cumbersome. The size of these bond graphs would
grow too fast.
The ThermoBondLib library presented in this
paper provides another vector bond graph representation, whereby each thermo-bond is composed of
three regular bonds, one representing mass flow, a
second representing volumetric flow, and a third representing heat flow. A thermo-bond can be envis-

The Modelica Association

aged as a parallel connection of three regular bonds,
as shown in Fig.1:

Figure 1: Representation of a thermo-bond

For reasons of efficiency, the thermo-bond
model has not been composed in ThermoBondLib in
a graphical fashion, but rather by equations directly.
Hence the bond graph of Fig.1 offers only a conceptual decomposition of a thermo-bond.
1.2

The Thermo-bond Connectors

The thermo-bond connectors would, in analogy to
the regular bond connectors have to carry at least
seven variables: the three effort variables, T, p, and
g; the three flow variables, Sdot, q, and Mdot; and
finally, the directional variable, d, that assumes a
value of d = 1 at the connector at which the bond
emanates and a value of d = +1 at the connector to
which the bond leads.
In reality, the thermo-bond connector is an 11tuple. It also carries (for convenience) the three state
variables, S, V, and M, and in addition a Boolean
variable, Exist, that is set true when there is mass to
be transported, and is set false when the mass is
close to zero. The Boolean variable is useful, because the models often operate on specific flows, i.e.,
flows per unit of mass, and Modelica becomes agitated when we attempt to divide a flow rate by zero.
The thermo-bond connector is depicted in Fig.2.

Figure 2: Thermo-bond connector

The measurement unit of entropy flow is currently
set to ThermalConductance rather than the dimensionally compatible EntropyFlowRate, because the

164

Modelica 2008, March 3rd  4th , 2008

ThermoBondLib - A New Modelica Library for Modeling Convective Flows

latter unit is still missing in the Modelica Standard
Library.
Just like in the case of the regular bond connectors, the thermo-bond connectors come in three varieties, one used for a-causal thermo-bonds, and the
other two used for the two types of causal thermobonds.

Hence a correct model of the thermal conductor
would have to look as depicted in Fig.5:

1.3

where the heat exchanger, HE, is internally represented as shown in Fig.6.

Advantages of Bond Graph Modeling

Why is it useful to represent component models of a
Modelica library internally by means of bond
graphs?
To demonstrate the usefulness of this approach
to modeling physical systems, let us consider the
model of a heat conduction element offered as a
component model of the heat transfer sub-library of
the Modelica standard library. The model is shown
in Fig.3.

Figure 3: Conduction model of Standard Library

The thermal conductor is modeled in the same way
as a regular electrical resistor. Unfortunately, this
model is incorrect.
To demonstrate the problems with this model, let
us look at the bond graph representation of a resistor,
as shown in Fig.4.

Figure 4: Bond graph representation of a resistor

Figure 5: Bond graph model of thermal conductor

Figure 6: Bond graph model of heat exchanger

The generated heat is divided in two at the top 0junction, and the two halves of the generated entropy
flows are rerouted to the nearest 0-junctions to the
left and the right of the 1-junction.
Using the bond graph approach, the shortcomings of the model contained in the Modelica Standard Library became obvious at once.

2

In convective flows, each of the three sub-flows can
equilibrate its potential variable separately.
When two bodies are in contact with each other,
heat diffusion takes place between them. Heat diffusion is modeled by the thermal conductor discussed
earlier. However in the new model, the two connectors to the left and the right are now thermo-bond
connectors. The enhanced heat exchanger model is
shown in Fig.7.

The electrical power leaving the positive terminal equals vai, whereas the power arriving at the
negative terminal equals vbi. At the 1-junction, the
potential drop is being calculated, and the difference
in power, ui, gets sent to the resistor.
What happens to the power as it arrives at the resistor? It cannot vanish. It gets dissipated into heat.
In an electrical resistor model, it may make sense
to ignore (exclude from the model) the thermal phenomena. However in a thermal resistor, this makes
no sense whatsoever.
Thus, the dissipated heat (generated entropy)
needs to be routed back into the thermal network.

The Modelica Association

Potential Equilibration

165

Figure 7: Thermo-bond graph model of heat exchanger

Modelica 2008, March 3rd  4th , 2008

F. Cellier, J. Greifeneder

The resistive source, RS, was replaced by a conductive source, GS. The thermal conduction, , is
imported as a modulating signal, rather than being
treated as a parameter value, and finally, heat conduction only takes place if both neighboring substances exist.
The red 0-junctions are special junctions that
take the red vector bond apart and make the individual component flows available.
The second type of potential equilibration is the
volume work, represented in ThermoBondLib by the
pressure/volume exchanger, PVE. The pressures in
two neighboring volumes will equilibrate, if the two
volumes are separated by a movable membrane. The
corresponding model is shown in Fig.8.

Figure 8: Thermo-bond graph model of volume work

Volume work is a dissipative phenomenon. In
the process of pressure equilibration, entropy is being generated that is fed back into the thermal ports
of the neighboring 0-junctions.
The conductance values of the volume work
element are negative, because a positive pressure
difference leads to a negative volume flow: if the
pressure on the left side is larger than that on the
right side, the membrane is pushed to the right,
thereby making the volume to the left larger and not
smaller.
The two bonds to the left and the right of the
conductive sources are pointing in opposite direction, because a negative volume flow leads to a positive entropy flow in accordance with Eq.(2).
The third type of potential equilibration is the
mixing element, represented in ThermoBondLib by
the mass exchanger, ME. The Gibbs potentials in
two neighboring volumes may equilibrate, if the two
masses are able to mix. The corresponding model is
shown in Fig.9.

The Modelica Association

Figure 9: Thermo-bond graph model of mixing

Also mixing is a dissipative phenomenon. In the
process of mixing two fluids, mixing entropy is being generated.
The ME model is a bit more problematic than the
other two potential equilibration models, because
mass cannot really flow without taking its volume
and heat along. The model can be used to explain
the cause of mixing entropy, but in practice, more
complex models will be needed in most cases to describe mixing phenomena.
The three potential equilibration elements have
in common that they dont require state information.
All three elements equilibrate one potential only, i.e.,
they dont lead to associated flows of the other two
types. All three phenomena are dissipative in nature,
i.e., generate entropy in the process of potential
equilibration.

3

The Substance Models

Whereas the transport models, such as the potential
equilibration models, are responsible for computing
the flows in and out of volumes, the substance models compute the three potentials of a volume. They
also compute the three state variables by means of
integrating over the difference between inflows and
outflows. In bond graph terminology, the substance
models are capacitive fields, CF.
Unfortunately, the substance models cannot be
coded in a fully substance-independent fashion.
Separate models need to be created for different
types of substances. Of course, these models have a
lot in common with each other, and inheritance
schemes can be set up that restrict the recoding between similar models to the bare minimum, but this
hasnt been accomplished yet. At the current time,
substance models have only been made available for
air, water, and water vapor.

166

Modelica 2008, March 3rd  4th , 2008

ThermoBondLib - A New Modelica Library for Modeling Convective Flows

The air model shall serve here as an example. It
is depicted in Fig.10. The model is fully coded by
means of equations. It computes the three potentials,
T, p, and g, and determines the values of the three
state variables, S, V, and M, by integrating the three
flow variables, Sdot, q, and Mdot.

ers are reversible. Evaporation and condensation are
reversible transport phenomena. In the process of
evaporation, the activation energy is taken out of the
thermal domain. Sensible heat gets converted to latent heat. However in the reverse process of condensation, the previously borrowed latent heat gets converted back to sensible heat1.
How much evaporation/condensation takes
place, i.e., where the flow equilibriuam is between
the liquid and the gaseous forms of a fluid, is determined by minimizing the overall energy of the system. However in practice, this energy minimization
problem is hardly ever solved on-line. The ThermoBondLib code, like most other such programs,
computes the amount of evaporation/condensation
using steam tables.

5

Figure 10: Model of air storage

Since air can be considered an ideal gas, the
pressure may be computed from the ideal gas equation. All fluids are subject to an equation of state,
and that equation is being used to determine the
pressure.
All fluids are also subject to a caloric equation
of state. That equation is being used to determine
the temperature. Once the temperature and the specific entropy are known, the Gibbs potential can be
determined as well.
Additional code has been added to prevent the
model from dividing by zero in case the volume gets
completely emptied out.

4

We are now able to code a first example using the
ThermoBondLib library. To this end, we shall
model a pressure cooker.
Inside the pressure cooker, there are three types
of substances: water, air, and water vapor. As the
pressure cooker is being heated, more water boils
off, producing additional water vapor. The water
vapor would like to occupy more space than the water in its liquid form, but it cannot, because the total
volume of the pressure cooker is fixed. Consequently, the pressure values inside the pressure
cooker are rising. Fig.11 depicts a preliminary
model representing the pressure cooker.

Figure 11: Basic pressure cooker model

Evaporation and Condensation

A second class of transport phenomena beside from
potential equilibration is the phase change of a fluid.
Water can boil off (evaporate), and it can condensate
out, either in the bulk or on a cold surface.
Whereas some transport phenomena are dissipative, like the potential equilibration phenomena, oth-

The Modelica Association

The Pressure Cooker

There are three different volumes containing
three different substances. Potential equilibration in
the form of heat exchange and volume work is al1

In the classical model, sensible heat is taken out of the
liquid phase during evaporation, but gets added to the
gaseous phase during condensation.

167

Modelica 2008, March 3rd  4th , 2008

F. Cellier, J. Greifeneder

lowed to occur. Furthermore, there is evaporation
and condensation taking place between the water
volume and the steam volume.
An improved model takes into account that heating and cooling take place not only through the bottom of the pot, but also through the metal walls, i.e.,
we need to add boundary layers representing the air
and the steam in the vicinity of the metal walls. The
enhanced model is shown in Fig.12.

Figure 12: Enhanced pressure cooker model

Special volume work elements are used between
the bulk and the two boundary layers. These models
ensure that the volume of the boundary layers
doesnt change.
We are now ready to encode the model using
ThermoBondLib, as shown in Fig.13.
There are five separate 0-junctions representing
the five different substances. In some cases, individual 0-junctions had to be split into two or even three
0-junctions to provide for a sufficiently large number
of connectors.
At each of these 0-junctions, a capacitive field is
attached, modeling the properties of the five substances. Between the 0-junctions, there are placed
all the transport models representing the exchange of
mass, volume, and heat between the five substances.
Whereas this model is still fairly simple, it already occupies an entire screen. Model wrapping
techniques ought to be used to represent the model at
a yet higher level, below which the thermo-bond
graphs can be hidden.

Figure 13: Coded pressure cooker model

The Modelica Association

168

Modelica 2008, March 3rd  4th , 2008

ThermoBondLib - A New Modelica Library for Modeling Convective Flows

Such a wrapped model might represent the
control volumes as containers, and the transport
models between them as pipe segments. Yet, the
wrapping of thermo-bond graphs representing
convective flows hasnt been accomplished yet.
Wrapped sub-libraries shall be added to ThermoBondLib at a later time.
Some simulation results are shown in Figs.14
and 15. The pressure cooker is placed on a hot
surface at time 0. Cold water is poured over it
after 10,000 seconds. Whereas the five temperature values are significantly different, the pressure
values are almost indistinguishable.

Figure 16: Air storage under isochoric conditions

The isochoric air storage model is built hierarchically from a regular air storage model. The
volumetric flow coming out of the storage is
measured using a flow sensor, Df. A counterflow of equal magnitude is generated by the
modulated flow source, mSf. It takes its energy
from the thermal domain. Hence the bottle keeps
a constant volume. Instead of shrinking in size,
the bottle cools down.
We are now ready to model the air balloon
system. The model is shown in Fig.17.

Figure 14: Temperature values of pressure cooker

Figure 15: Pressure values of pressure cooker

After approximately 1300 seconds, the water
begins to boil, which leads to a knee in the pressure curves.

6

Figure 17: Air balloon model

The CF element to the left of Fig.17 represents the bottle. It is modeled using the isochoric
air storage element of Fig.16. The CF element in
the center represents the balloon. It is modeled
using the regular air storage element of Fig.10.
The effort source, Se, to the right represents
the ambient air. Between the balloon and the ambient air, potential equilibration (heat exchange
and volume work) are allowed to take place.
The transport of a fluid across a pipe satisfies
the wave equation. When cutting the pipe into
individual segments, each segment can be modeled using a container, a capacitive field, representing the compressibility of the fluid, and using
a transporter, an inductive field, representing the
inertia of moving mass.

The Air Balloon

As a second example, we shall consider a bottle
containing compressed air, from which an air balloon is to be filled.
Here, we are facing a new complication. If
we were to model the bottle containing compressed air by means of the same capacitive field
as before, the volume of the bottle would shrink
as air is allowed to escape from it. Hence we
need to create a new capacitive field that models
the storage of air under conditions of constant volume. This model is shown in Fig.16.

The Modelica Association

169

Modelica 2008, March 3rd  4th , 2008

F. Cellier, J. Greifeneder

In the model of Fig.17, the volume flow element, VF, represents the transporter. A volume
flow is obtained that is caused by the pressure difference between the two connectors. The volume
flow induces a proportional mass flow and a proportional heat flow.
The volume flow element is depicted in
Fig.18. The top portion of the bond graph represents the volumetric flow. The volumetric flow is
being computed inside the inductor, I. A flow
sensor, Df, measures the flow and induces proportional mass and entropy flows using internal flow
sources, mSf. The center portion of the bond
graph represents the entropy (heat) flow portion of
the model, whereas the lowermost part calculates
the mass flow.

Figure 19: Temperature values of bottle and balloon

Figure 20: Volumes of bottle and balloon

Figure 21: Air masses of bottle and balloon

The temperature in the balloon changes only
temporarily, whereas the bottle cools down significantly. The volume of the balloon grows,
whereas that of the bottle remains constant. Finally, mass is being transported from the bottle to
the balloon. The sum of masses in the two containers remains constant.
Figure 18: Inductive field representing transporter

7

As a third example, we shall consider a closed
water loop. Such water loops are found frequently in heating systems. They may represent
either water that circulates between a water heater
and a set of radiators; alternatively, such a loop
may represent water (or glycol) circulating between a water heater and a set of (thermal) solar
collectors; and finally, it may represent glycol
circulating between a heat pump and the well of a
geothermal system.
The water loop is represented in the model by
four pipe segments and four water storages. The

As is to be expected, the temperature, pressure, and mass in the bottle decrease, whereas the
volume remains constant. In contrast, mass and
volume in the balloon increase, whereas temperature and pressure remain almost constant.
Some simulation results are shown in Figs.1921. Fig.19 shows the temperature values in the
bottle and the balloon; Fig.20 depicts the volumes
of the two storages; and Fig.21 presents the two
air masses.

The Modelica Association

The Water Loop

170

Modelica 2008, March 3rd  4th , 2008

ThermoBondLib - A New Modelica Library for Modeling Convective Flows

water storages are modeled as isochoric capacitive
fields. Three of the four pipe segments are specified as inductive fields, whereas the fourth one
represents the pump.
The overall model is shown in Fig.22. The
pipe segment containing the pump, depicted in the
model as a forced volume flow, FVF, is built up
internally in essentially the same way as the free
volume flow, VF, used to represent regular pipe
segments. The only difference is that the inductor
is eliminated from the model and replaced by an
external (regular) bond connector at which the
mechanical pump can be connected. The pump
itself is represented by a small DC motor.

the capacitive field immediately above (i.e., at the
exit of) the pump, whereas the lowest pressure is
p1, the pressure of the capacitive field below (i.e.,
at the entrance of) the pump. After the pump is
turned on, the pressure values oscillate for a little
while, before they stabilize at new values.

Figure 23: Pressure values in the four water storages

Fig.24 shows the mass flows in the three
regular pipe segments. They are virtually indistinguishable one from another. At time 1 sec, the
pump is switched on. It takes roughly 1 sec for
the mass flow to fully build up.

Figure 24: Mass flows in pipe segments
Figure 22: Water-loop model

The three examples presented in this paper are
included in the ThermoBondLib library, a free
Modelica library downloadable from the Modelica
website.

The (black) effort source at the lower right
corner of Fig.22 represents the armature voltage.
The I and R elements next to it model the armature inductance and the armature resistance. The
GY element higher up describes the transformation of electrical to mechanical (rotational) power.
The I and R elements yet higher up represent the
inertia of the rotor and the friction of the mechanical bearings. The TF element to their left
transforms mechanical into hydraulic power.
The black (right) portion of Fig.22 is a regular
bond graph, modeled using BondLib, whereas the
red (left) portion of Fig.22 is a thermo-bond
graph, modeled using ThermoBondLib.
Some simulation results are shown in Figs.23
and 24. Fig.23 shows the pressure values in the
four water storages. The pump generates a high
pressure value at its exit that is then successively
reduced again by the subsequent regular pipe segments. The highest pressure is p2, the pressure of

The Modelica Association

8

Conclusions

In this paper, a new free Modelica library for
modeling and simulating convective flows in
physical systems has been introduced.
ThermoBondLib has been designed as a
graphical modeling library based on the thermobond graph methodology. Thermo-bond graphs
were formally introduced by Greifeneder in his
Diploma thesis [4].
Contrary to other types of systems, convective
flows cannot be modeled in a completely abstract
fashion. Different storages (capacitive fields) will
look slightly different one from another. At the
current time, storage (substance) models have
only been made available for air, water, and water

171

Modelica 2008, March 3rd  4th , 2008

F. Cellier, J. Greifeneder

vapor. Urgently needed are storage models for
different types of glycol as well as for different
types of industrial oils.
Although thermo-bond graphs are quite well
readable, once a user has gotten familiarized with
the methodology, bond graphs in general offer a
fairly low-level interface to modeling. Bond
graphs offer the simplest (lowest-level) interface
to modeling physical systems that is still fully object-oriented.
Hence wrapped thermo-bond
graphs are more suitable for the description of
complex systems involving convective flows.
Wrapped thermo-bond graph sub-libraries shall be
added to ThermoBondLib in due course.
Finally, thermo-bond graphs can also be used
for the thermodynamic description of chemical
reaction systems. First thermo-bond graph models of a few chemical reaction systems (hydrogen
bromide and ammonia synthesis) were successfully coded in [4]. However, these models have
not yet been added to the officially released version of ThermoBondLib.

Cellier, F.E.: Continuous System Modeling.
Springer-Verlag, New York, 1991

[2]

Cellier, F.E., Nebot, A.: The Modelica Bond
Graph Library. In: Proceedings of the 4th International Modelica Conference, HamburgHarburg, Germany (2005) Vol. 1, 57-65

[3]

Cellier, F.E., Clau, C., Urqua, A.: Electronic
Circuit Modeling and Simulation in Modelica.
In: Proceedings of the Sixth Eurosim Congress on Modelling and Simulation, Ljubljana,
Slovenia (2007) Vol. 2, 1-10

[4]

Greifeneder, J.: Modellierung thermodynamischer Phnomene mittels Bondgraphen. Diploma Thesis, University of Stuttgart, Germany, 2001

[5]

Greifeneder, J., Cellier, F.E.: Modeling Convective Flows Using Bond Graphs. In: Proceedings of ICBGM01, 5th SCS Intl. Conf. on
Bond Graph Modeling and Simulation, Phoenix, Arizona (2001) 276-284

[6]

Greifeneder, J., Cellier, F.E.: Modeling Multiphase Systems Using Bond Graphs. In: Proceedings of ICBGM01, 5th SCS Intl. Conf. on
Bond Graph Modeling and Simulation, Phoenix, Arizona (2001) 285-291

The Modelica Association

Greifeneder, J., Cellier, F.E.: Modeling Multielement Systems Using Bond Graphs. In:
Proceedings of ESS01, 13th European Simulation Symposium, Marseille, France (2001)
758-766

[8]

Zimmer, D., Cellier, F.E.: The Modelica
Multi-bond Graph Library. In: Proceedings of
the 5th International Modelica Conference,
Vienna, Austria (2006) Vol. 2, 559-568

Franois E. Cellier received his
BS degree in electrical engineering in 1972, his MS degree in
automatic control in 1973, and his
PhD degree in technical sciences
in 1979, all from the Swiss Federal Institute of Technology (ETH) Zurich. Dr.
Cellier worked at the University of Arizona as
professor of Electrical and Computer Engineering
from 1984 until 2005. He recently returned to his
home country of Switzerland. Dr. Cellier's main
scientific interests concern modeling and simulation methodologies, and the design of advanced
software systems for simulation, computer aided
modeling, and computer-aided design. Dr. Cellier
has authored or co-authored more than 200 technical publications, and he has edited several
books. He published a textbook on Continuous
System Modeling in 1991 and a second textbook
on Continuous System Simulation in 2006, both
with Springer-Verlag, New York.

References
[1]

[7]

Jrgen Greifeneder received a
diploma degree in Engineering
Cybernetics from the University
Stuttgart, Germany in 2002. Dr.
Greifeneder then switched to the
University of Kaiserslautern,
where he received a Ph.D. in Electrical and Computer Engineering
in 2007 with a dissertation on the formal analysis
of temporal behavior of Networked Automation
Systems (NAS) by use of probabilistic model
checking. Scientific stays at the University of
Arizona (USA), at the Ecole Normale Suprieure
de Cachan (F), and at the Universidade de Braslia
(BR) completed his education. Dr. Greifeneder's
primary research interests concern modeling,
simulation, and control methodologies.

172

Modelica 2008, March 3rd  4th , 2008

FluidDissipation - A Centralised Library for Modelling of Heat Transfer and Pressure Loss

FluidDissipation - A Centralised Library
for Modelling of Heat Transfer and Pressure Loss
Thorben Vahlenkamp Stefan Wischhusen
XRG Simulation GmbH,
Harburger Schlossstrae 6-12, 21079 Hamburg
{vahlenkamp, wischhusen}@xrg-simulation.de

Abstract
A new Modelica library centralising heat transfer and
pressure loss calculations of energy systems called
FluidDissipation will be presented. The goal of the
library is to deliver a broad range of heat transfer and
pressure loss correlations independent of the thermohydraulic framework and easy to implement (functional approach) for industrial use. Concept and numerical challenges of the library development will be
described as well as first applications (Pipe flow; Environmental control system).
The FluidDissipation library is developed within the
European research project Eurosyslib-D of ITEA2
funded by the Federal Ministry of Education and Research (BMBF) for 30 month started in November
2007.
Keywords: heat transfer; pressure loss; simulation;
dissipation

1 Introduction

to evaluate existing energy systems and to find out optimising potentials.
Therefore the target of the FluidDissipation library is
to deliver a centralised open source Modelica library
including verified and validated correlations describing heat transfer and pressure losses of fluids for energy systems. Applications of the FluidDissipation library (e.g. incompressible pipe flow; Air conditioning
heat exchanger with compressible moist air) will be
developed with the use of the Modelia.Fluid library.

2 Library concept
The main goal of FluidDissipation as an open source
library is to allow the usage of dissipation models in
every thermo-hydraulic framework. Also the FluidDissipation library can be used as a multi domain base
library to achieve a maximum of flexibility in implementation and further application to energy systems.
The way to obtain an overall use of the FluidDissipation library is to build up the library according to the
following implementation methods:

Energy conversion in any thermo-hydraulic process
 Library development with functional approach
[1] is declined due to unwanted heat transfer (as a re(literally use of function calls)
sult of temperature difference) and pressure losses (as
 Input and output arguments of function calls dea result of friction) of a working fluid. Both physilivered by records (like geometric parameters and
cal phenomena increase entropy and decrease exergy
fluid properties)
of an energy system. Therefore the amount of energy
of a working fluid to be transformed into mechanical
 Implementation of continuous functions for effiwork is dissipated.
cient numerical simulation
These fluid dissipation effects (e.g. pressure loss of
pipe network) have to be compensated by higher energy supply of other system components (e.g. deliv- 3 Numerical aspects of transient fluid
ery height of pumps). A reduction of fluid dissipation
flow modelling
effects is a way to optimise efficiency of a thermohydraulic process with a corresponding minimisation In literature there are a lot of heat transfer and presof operation costs. Thus modelling fluid dissipation sure loss correlations within restricted boundary coneffects are necessary for thermo-hydraulic processes ditions. In order to get dissipation functions applicable
The Modelica Association

173

Modelica 2008, March 3rd  4th , 2008

T. Vahlenkamp, S. Wischhusen

for a broad region of fluid conditions every restricted
mathematical description has to be numerically improved for efficient simulation.
Numerical improvement of dissipation functions will
be verified by the authors under the following aspects:
 Enlargement of heat transfer and pressure loss
functions with restricted boundary conditions to Figure 1: Implementation of a new base pipe model
a broader region via numerical interpolation with out of FluidDissipation functions - Structure
respect to physical correctness
 Use of pressure loss functions in dependence of According to the proposed structure in Figure 1 the
user needs to concentrate only on the following steps
functional output targets like:
to implement the missing dissipation calculations sucMass flow rate for compressible fluid flow or cessfully. In the following the new base pipe is modPressure loss for incompressible fluid flow
elled adiabatic and the further implementation is explained with respect to pressure losses.
 Inverting of documented pressure loss functions
for compressible fluid flow according to mathe1. Create a new model with inherited hydraulic and
matical feasibility
thermal connectors of chosen thermo-hydraulic
 Linearisation of pressure loss functions for compressible fluid flow at small mass flow rates and
reverse flow to avoid numerical difficulties
 Usage of inline integration [2] to improve numerical behaviour (if supported by modelling software)

library
2. Inheritance of a control volume
3. Instantiation of the medium model
4. Add corresponding records of dissipation calculation on diagramm layer of model (see Figure 2)
5. Assign record variables to input and output arguments of chosen function in equation layer of
model (see Figure 3)

4 Implementation

The concept of the FluidDissipation library allows
both the interoperability with other thermo-hydraulic The diagram layer of this implementation of pressure
framework as well as an easy implementation in- loss with the used records is shown in Figure 2.
tended for further industrial use as a result of the functional approach (using literally function calls with
records for input/output arguments).
The principle of the easy to use implementation for a
new base pipe model is pointed out in Figure 1 to Figure 3. In Figure 1 the structure to build a new base
pipe model is shown as example for this implementation. The new base pipe model consists of the following components of a chosen thermo-hydraulic library
(Modelia.Fluid):
 Hydraulic and thermal connectors for data exFigure 2: Implementation of a new base pipe model
change
out of FluidDissipation functions - Diagram layer
 Control volume for calculation of thermodyFinally the pressure loss variables of the records in the
namic state
diagram layer have to be assigned to the pressure loss
 Medium model (e.g. Modelia.Media) for calcu- function in the equation layer according to Figure 3. In
lation of fluid properties
this example an inline function for the mass flow rate
The Modelica Association

174

Modelica 2008, March 3rd  4th , 2008

FluidDissipation - A Centralised Library for Modelling of Heat Transfer and Pressure Loss

is used. The advantage of an inline function is that ei- in dependence of the Reynolds number Re and relative
ther the mass flow rate or the pressure loss can be cal- roughness k with the following behaviour:
culated in dependence of desired target variable in the
 Laminar regime (I) at small Reynolds number
current model. The medium variables are calculated
(Hagen-Poisseuille equation):
for a design flow direction from the upstream control
volume. Therefore the designed flow direction has to
D independent of k
be ensured by the thermo-hydraulic process itself.
Decrease of D with increasing Re
 Transition regime (II) for Reynolds number in between 2300 to 4000 (Smoothing function):

D slightly dependent of k
Increase / decrease of D with increasing Re
 Turbulent regime (III) at high Reynolds number
(Numerical Colebrok-White equation):
Increasing D with increasing k

D independent of Re
For very high absolute roughnesses (average height
Figure 3: Implementation of a new base pipe model of asperities inside pipe) an additional numerical imout of FluidDissipation functions - Equation layer
provement has to be done for the calculation of the
pressure loss. In Figure 4 the laminar regime (I) is calculated independent of the roughness. Nevertheless a
5 Example application of FluidDissi- numerical abortion of the solver occurs if the absolute
roughness of a straigth pipe is very large. In this case
pation
the difference from the end of the laminar regime to
the start of the turbulent regime is not stable even if
5.1 Pressure loss in straight pipes
a smoothing function is used. A numerical improveStraight pipes are one of the most frequently used de- ment of this problem is found in [3] with the modvices in the modelling of an thermo-hydraulic process. elling of D from the Hagen-Poiseuilles calculated in
Therefore also the development of the FluidDissipa- dependence of the relative roughness k according to
tion library starts with the modelling of pressure loss Samoilenko with an variable end of the laminar regime
in a straight pipe using the functional approach for im- and corresponding Reynolds number Reend
laminar :
plementation. The result of the pressure loss calcula

0.0065
end
tion in a straight pipe in terms of the Darcy friction
(4)
Relaminar = 754  exp
k
factor D is shown in Figure 4. The pressure loss calculation for straight pipe flow is based on the following The end of Hagen-Poisseuilles law in dependence of
basic correlations:
relative roughness leads to an variable upper boundary
for laminar fluid flow and a better numerical stability.
This numerical improvement is based on the physical
(1) behaviour shown in corresponding measurements according to [3] for commercial tubes and it is now im(2) plemented in the FluidDissipation library (e.g. bends).



tot
|{z}
2
Total pressure loss coefficient
tot =
 f ri
loc
+
|{z}
|{z}
Frictional pressure loss Local pressure loss
5.2 Simple environmental control system
L
 f ri =
D

(3)
|{z}
The second example demonstrates the feasibility of usdh
Darcy friction factor
ing heat transfer and pressure loss functions from the
FluidDissipation library for system simulation. In FigThe typical behaviour of the Darcy friction factor D ure 5 a simple environmental control system of an airin a straight pipe can be divided into three flow regimes craft is modelled.
p =

The Modelica Association

 u2

175

Modelica 2008, March 3rd  4th , 2008

T. Vahlenkamp, S. Wischhusen

Figure 5: Model of a simple environmental control system for aircrafts
 Air chiller required for temperature control of inlet air for cabin
 Flow control valve for pressure control of inlet air
for cabin
 All models apply FluidDissipation heat transfer
and pressure loss functions

Figure 4: Darcy friction factor D in dependence of
Reynolds number Re with relativ roughness k as parameter
The simple example of an environmental control system for an aircraft consists of the follwing features:
 Varying ambient conditions according to flight or
ground case of aircraft
 Moist air of Modelica.Media library used as
medium
 Compressed fresh air (bleed air) is precooled by
ambient air (ram air)
 50% of hot cabin air is recirculated and mixed
with precooled a fresh air
The Modelica Association

The boundary conditions for a flight test with the simple environmental control system (ECS) in Figure 5
are listed in Table 1. A flow diagram for the main part
of the ECS-model is shown in Figure 6. The aim of
the shown ECS is to deliver 2 kg/s of moist air with an
inlet temperature of 12 C and an ambient pressure of 1
bar with the temperature and pressure control through
chiller and control valves.
The most important results of a flight test under the
boundary conditions listed in Table 1 are commented
in the following. According to the high pressure of 2
bar of the bleed air out of a turbine from an aircraft
the flow control valve has to adjust the pressure loss to
achieve the desired inlet pressure of 1 bar to the cabin
in the ground case. The pressure loss function inside
the flow control valve adjusts the needed pressure loss
via opening. In Figure 7 the transient pressure of compressed bleed air is shown from the inlet and achieves
ambient condition after the chiller.

176

Modelica 2008, March 3rd  4th , 2008

FluidDissipation - A Centralised Library for Modelling of Heat Transfer and Pressure Loss

Cool air
inlet

Flow control
valve

Table 1: Boundary conditions for simulation
Compressed air inlet
p
bar
2.0

C
140

Xi kg/kg 0.012 . . . 0.001

Return air inlet

Cool air outlet
Chilled air
outlet

Cool air inlet
p
bar
1.5 . . . 1.2
C

30 . . . -10
Xi kg/kg 0.012 . . . 0.001

Flow control
valve
Air chiller

Compressed
air inlet

Cool air outlet
p
bar

Figure 6: Example air conditioning system layout

Return air inlet
m
kg/s
C

Xi kg/kg

5

2.1

x 10

2
1.9

Pressure in Pa

1.0 . . . 0.5

1.8

1.0
24
0.008

1.7
1.6

Chilled air outlet
m
kg/s

1.5
1.4
1.3
1.2
0

2.0

Comp air in
HX air in
HX air out
Mixer air out
10

20

30

40

50

60

70

80

Time in s

Figure 7: Transient pressures of compressed air from
inlet to mixer

The Modelica Association

Friction factor

The pressure control for the cabin is realised due to
the relative opening of the flow control valve and corresponding pressure loss according to Figure 8. The
total pressure loss coefficient tot is increasing as result of a decreasing opening of the flow control valve
(higher local pressure losses loc ).
Also the effect of heat transfer losses to the environment have been considered in a straight pipe in between the mixer and chiller unit with a konstant heat
transfer coefficient. Finally in Figure 5.3 the inlet temperature of moist air to the cabin as main task of the
environmental control system is simulated. It is shown
that the existing environmental control system of the
aircraft under ground conditions is not able to fulfill
the default inlet temperature of 12 C to the cabin. To
reach the set temperature for the ground case the cooling capacity of the chiller has to be raised. However
during the flight case the ram air reaches the set value
of 12 C for inlet temperature due to the decreasing
ambient pressure and temperature leading to higher
precooling. Therefore all models applying pressure
loss calculation (e.g. Flow control valve, precooler

15

10
Comp air valve
Cool air valve
5

0
0

200

400

600

800

1000

1200

1400

1600

1800

Time in s

Figure 8: Friction factors of valves due to decrease of
relative opening
,straight pipe, etc.) fulfill the requirements of being
used in large thermo-hydraulic systems like environmental control system.

5.3

Summary

The concept of the a new Modelica library called
FluidDissipation has been presented. FluidDissipation is developed in the European research project

177

Modelica 2008, March 3rd  4th , 2008

T. Vahlenkamp, S. Wischhusen

approach for solving differential-algebraic equation systems. In Proceedings of European Simulation MultiConference, Prague, 1995. ESM95,
ESM95.

60
HX air out
Mixer out
HeatL Pipe out
Chiller out

Temperature in C

50

[3] I. E. Idelchik. Handbook of hydraulic resistance.
Jaico Publishing House, Dehli (India), 3. edition,
2006.

40
30
20
10
0

200

400

600

800
1000
Time in s

1200

1400

1600

1800

Figure 9: Transient temperatures of compressed air
from HX outlet to chiller outlet
Eurosyslib-D and will be a free library for calculation
of heat transfer and pressure losses of energy systems.
First examples like fluid flow in straight pipes and a
simple environmental control system have shown possible applications for energy systems. Further tasks
are the enhancement of more heat transfer and pressure loss calculations of energy devices. For the verification and validation measurement results have to be
supplied.
The project underlying this report is funded by the
German Federal Ministry of Education and Research
under the grant no.[IS07003C]. The authors bear the
sole responsibility for the content of this publication.

References
[1] St. Wischhusen. Dynamische Simulation zur
wirtschaftlichen Bewertung von komplexen Energiesystemen. PhD thesis, Technische Universitt Hamburg-Harburg, AB Technische Thermodynamik, Hamburg, 2005.
[2] H. Elmqvist, M. Otter, and S. E. Cellier. Inline integration: A new mixed symbolic/numeric
The Modelica Association

178

Modelica 2008, March 3rd  4th , 2008

Session 2c
Mechanical Systems & Applications

The Modelica Association

179

Modelica 2008, March 3-4, 2008

The Modelica Association

180

Modelica 2008, March 3rd  4th , 2008

Development of an Aircraft and Landing Gears Model with Steering System in Modelica-Dymola

Development of an Aircraft and Landing Gears Model
with Steering System in Modelica-Dymola
Gianluca Verzichelli
Airbus UK Ltd.
BS99 7AR, Filton. United Kingdom
gianluca.verzichelli@airbus.com

Abstract

which is an expensive, uncompetitive, unpredictable 
and ultimately prone to failures, paradigm of product
This paper describes one of the first uses of Modelica, development.
with Dymola, for modelling and simulation activities
of landing gears in Airbus. The application of Dymola
was for the development of a model of the whole Air- 2 Aircraft Library
craft and the auxiliary and main landing gears, includThe following sections highlight the main features
ing tires, wheels, oleo-pneumatic shock absorbers, airof the sub-models developed for the Aircraft Library.
frame, etc.
Any of them can be placed in a super-model to create
The suitability of Modelica for describing model at
a detailed architecture of a desired aircraft which then
system level has been exploited. In this case, it has
can be tested under the foreseen simulated operative
provided steering functions for the whole Aircraft,
conditions, see Figure 1.
with the development of the Nose and Body Wheel
Hydraulics Steering System connected to the mechanical domain. Furthermore, most of the electrical components, part of the Control and Monitoring System of
the Aircraft, have been taking into account, so that the
interaction between the electrical, hydraulics and mechanical domains forms a close link using one modelling language. The model has been developed using
mainly the free library Mechanics and the commercial
library HyLib.
Keywords: aircraft; landing gear; steering system;
simulation; modelling.

1

Introduction

Over the last three decades, civil aircraft systems have
become progressively more integrated, encompassing
several different domains: structure, power, control
and software. In a such tightly coupled environment
the use of one modeling and simulation language like
Modelica, can provide tangible advantages for the engineers. In particular, it can decrease the lead-time to
develop several ready-to-use architectures of the Aircraft model, with different levels of detail, so that the
engineers can investigate many more what-if strategies with high level of accuracy of the analysis, thus
minimizing the risks of the design-build-test-fix cycle,
The Modelica Association

Figure 1: Snapshot of the full model in Dymola

2.1

Airframe Model

The Airframe Model contains the mass, inertia tensor and the main geometrical characteristics of the
Aircraft (A/C) like wheelbase, track, etc. The mass is
lumped and concentrated at the Centre of Gravity (CG)
location and the inertia tensor is calculated with respect to the CG. The user can define the position of
the CG (yellow sphere) with respect to the Mean Aerodynamic Chord (MAC) of the A/C (purple segment),

181

Modelica 2008, March 3rd  4th , 2008

G. Verzichelli

typically between 35% and 42% of the MAC, see Fig- the sub-model can be verified and validated in isolation.
ure 2.

2.2

Figure 2: Airframe Model in Dymola with parameterized attachment points
In addition the user can define the attachment points of
the Nose, Wing, Body Landing Gears, the Engines and
the Vertical Tail Plane Pressure Centre with respect to
the Aircraft Datum, see Figure 3.

Shock Absorber Model

The Shock Absorber is represented by means of an
oleo-pneumatic suspension model. Its characteristics
vary with relative displacement, velocity and direction of travel of the sliding cylinder with respect to the
outer cylinder. The model contains characteristics for
stiffness and damping for each of the landing gears as
supplied by the vendors (polytropic dynamic curves).
Stiffness force is calculated as a function of oleo extension displacement via evaluation of spring stiffness
curves, see Figure 4.
Damping force is calculated as a function of oleo extension displacement, the rate of change of oleo extension displacement and oleo extension displacement
direction. To achieve this, two damping coefficient
curves are used, one defining the compression stroke
coefficient against oleo extension displacement and
one defining rebound stroke, see Figure 5 and Figure 6.
Oleo damping force is then calculated by multiplying
this coefficient by velocity squared.
At the top-level, the user can define the rake angle of
the shock absorber and other key characteristics (maximum stroke, sliding cylinder length, etc.).

Figure 3: GUI for definition of the Airframe Model
main parameters
The approach to lump the whole mass and inertia tensor of the A/C at the CG location is quite common and
straightforward, it is also typical of the models built
with a top-down approach. This method implies an
extensive use of the FixedTranslation Block, with no
mass and inertia: the only mass and inertia are in the
Airframe Model. Though this is theoretically correct,
Modelica could experience problems solving the equation of motions in all the cases where there is a local
translation or rotation of two parts: for instance, the
rotation of the steerable aft axle of the Body Landing
Gear with respect to the Bogie. This method is also unadvisable in all those cases when the models are built
with a bottom-up approach (many sub-models which
will be used to develop a top level model): in these
cases, each part of the sub-models should have its own
correct, or at least realistic, mass and inertia, so that
The Modelica Association

Figure 4: Stiffness force vs. shock absorber closure at
20 Celsius (Normalized)

2.3

Bogie Model

The main functionality of the Bogie model is to provide attachment points for the wheels and the bottom
of the shock absorber so to create a correct load path
distribution of the weight of the A/C on the ground.
The user can choose between a Dual, a Dual Tandem
a Tri-Twin Tandem Bogie. Obviously other types of

182

Modelica 2008, March 3rd  4th , 2008

Development of an Aircraft and Landing Gears Model with Steering System in Modelica-Dymola

Figure 7: Tri-Twin Tandem Bogie Model with steerFigure 5: Compression damping force vs. shock ab- able aft axle and lock system
sorber closure at 20 Celsius (Normalized)
to retract the lock actuator is sent.
The Lock system uses a wedge beam that pivots a one
end attached to the bogie whilst the other end is attached to the locking actuator, see Figures 7 and 8.

Figure 6: Rebound damping force vs. shock absorber
closure at 20 Celsius (Normalized)
Landing Gears Wheel Layouts model can be easily developed: Dual Twin, Dual Twin Tandem, etc. In the
case of the Body Wheel Steering (BWS), the aft axle
is steerable, see Figure 7, so the model provides extra
functionalities: these are explained in  2.3.1.
The user can define the main geometrical characteristics like track and wheelbase and whether consider it
as massless and with zero inertia or not.
2.3.1

Body Landing Gear Model

Figure 8: Lock System
As the lock beam is drawn towards the aft axle via
the Return springs (retraction of the lock actuator) it
engages its wedge into a V-shape aperture in the axle
causing it to be locked. As the lock beam is deployed
away from the aft axle (extension of the lock actuator)
the wedge becomes free from the aperture in the axle
allowing the axle to rotate freely. The return springs
not only reduce the closing force needed to lock the
locking wedge but also maintain the locking wedge in
its closed position.
At the moment, given a certain part, Modelica does not
recognize the surface of it but only frame a and frame
b, together with the position of the CG with respect to
frame a, the mass and inertia tensor of the part. So the
simulation of surfaces contact/collision is not possible
unless the point, or points, of contact/collision remain
known during the whole simulation.

The Body Landing Gear (BLG) Model has extra functionality because of its characteristic of having the aft
axle steerable. It includes the LineForceWithTwoMasses Block for the inclusion of the steering actuator
and lock actuator characteristics (lumped masses of
cylinder and piston) and connection to the hydraulics
actuator of the Steering System Model, as well as Return springs. In addition, a brake Block has been used
2.4 Tyre Model
to simulate the status of locked condition of the aft
axle. When the Avionic System commands to lock the The modelling and simulation activity of a tyre, and
aft axle, supposed to be initially unlocked, a command in particular of an aircraft tyre  subject to higher slip
The Modelica Association

183

Modelica 2008, March 3rd  4th , 2008

G. Verzichelli

angles with respect to automotive tyres  represents a
difficult task. Many different tyre models have been
developed in Modelica: Magic Formula model, Rill
Model, Brush Model, see [1], with different level of
accuracy and computational effort. The model developed for the Aircraft Library represents a good compromise between accuracy and simulation time and
it seems to be suitable for on ground manoeuvrability studies. Obviously, thanks to the modularity development feature of the Modelica language, when a
more detailed model of the tyre will be developed, this
can be easily and quickly implemented in the full A/C
model.
The model developed makes use mainly of look up tables with empirical data extracted from tyre suppliers
manufacturers. The model calculates Lateral Slip Angle, Side and Drag Forces, Vertical Reaction and Self
Aligning Torque. The point of application of the Side,
Drag Forces and Self Aligning Torque is fixed and it is
coincident with the vertical projection of the axle hub
at a vertical distance equal to deformed radius of the
tyre. The runway and taxiway are assumed to be flat
and the camber angle is neglected. The model allows
the user to chose the value of the coefficient of rolling
resistance, the tyre deformed radius, the inflation pressure, the tyre damping coefficient, the mass and inertia
of the tyre.

2.4.1

Lateral Slip Angle Computation

Figure 9: Tyre axis system as defined by the SAE
2.4.2

Vertical Reaction Computation

The Vertical Reaction is calculated by means of a nonlinear spring behavior using the following equation:
Max(0, k  (q  q0 )e  c  q)

(2)

where k is the stiffness coefficient, c is the damping
coefficient, e is a coefficient depending on the type of
material, q is the actual displacement variable, q0 is the
tyre deformed radius, q is the actual velocity variable.
Another model computes the dynamic Vertical Reaction of the tyre using (2) but substituting the stiffness
behavior k  (q  q0 )e , with the look-up table of Figure 10, which takes into account the inflation pressure
and the actual deflection of the tyre.

The Lateral Slip Angle is the angle formed by the
plane of rotation of the wheel and the tangent to the
wheels path, see Figure 9. Mathematically can be expressed as:
y = arctan(Vy /Vx )

(1)

where Vy and Vx are the velocities of the footprint of the
resultant of the pressure distribution forces between
tyre and ground. The model uses the simplified assumption explained in  2.4, so it assumes that there is Figure 10: Dynamic Vertical Load vs. Vertical Deflecno elastic deformation of the tyre belt for the compu- tion for different Inflation Pressures (Normalized)
tation of the lateral slip angle.
The value of (1), computed by the model, is different from zero only when there is contact between tyre
and ground and the lateral and longitudinal velocities
of the tyre footprint are above a certain threshold. In
addition, the model assumes an instantaneous development of steady state reaction forces and momentum.
The Modelica Association

The user can choose between the two different methods of computation because the model has been made
replaceable.
The Vertical Reaction sustained by each tyre and the
lateral slip angle are used to calculate the tyre forces
and torques as explained in  2.4.3.

184

Modelica 2008, March 3rd  4th , 2008

Development of an Aircraft and Landing Gears Model with Steering System in Modelica-Dymola

2.4.3

Side, Drag Forces and Self Aligning Torque
Computation

The equations which compute the drag and side forces
are as follow:
D = R  Fz + D0 cos(y )  S0 sin(y )

(3)

S = S0 cos(y ) + D0 sin(y )

(4)

where R is the rolling friction coefficient, Fz is the
Vertical Load, D0 and S0 are the drag and side forces
Figure 12: Side Force vs. Slip Angle for different Verresolved in the wheel plane reference system and y is
tical Load (Normalized)
the slip angle. Notably, there is no need to manipulate
them if y changes sign, because of the trigonometric functions sin and cos and the shape of the curves
of Figures 11 and 12. Differently, if the A/C changes
the direction of motion, i.e. instead of moving forward, moves backward, during push-back manoeuvres
for instance, there is the need to change the sign of the
previous equations. For this reason, the RHS of (3)
and (4) is multiplied by ( tanh(  Vx )), where  is a
time constant chosen by the user and the tanh is used to
assure a smooth transition around zero (the A/C is assumed to move forward when Vx < 0). The final equations are:
Figure 13: Self Aligning Torque vs. Slip Angle for
different Vertical Load (Normalized)

D = [  Fz + D0 cos(y )  S0 sin(y )]  [ tanh( Vx )]
S = [S0 cos(y ) + D0 sin(y )]  [ tanh( Vx )]

2.5

Engine Model

The torque developed by the Self Aligning Torque can
be simply computed using the look-up table of Figure 13. A snapshot of the tyre model in Dymola is
given in Figure 14.

The Engine Model is simply represented by a PID
Controller. The user can define the desired steady state
velocity and the spool time: the engine forces change
accordingly to maintain the value of the demanded velocity. In fact during a turn, the A/C speed tends to decay because of the development of the centripetal force
at the tyre contact footprint which counterbalances the
centrifugal force. The user can also decide when to
switch the engine on (T hrust 6= 0) or off (T hrust = 0)
due to conditions linked either to time-based events or
boolean-based events. Furthermore, in order to simulate an instantaneous loss of thrust, due for instance to
an engine failure for the simulation of a rejected takeoff case, the TriggeredMax block is used. It samples
the continuous input signal whenever the trigger input
signal is rising (i.e., trigger changes from false to true).
The maximum, absolute value of the input signal (EnFigure 11: Drag Force vs. Slip Angle for different gine Thrust) at the sampling point is provided as outVertical Load (Normalized)
put signal. So the Thrust on the remaining functioning
engines is assumed to be constant and its value equal
The Modelica Association

185

Modelica 2008, March 3rd  4th , 2008

G. Verzichelli

Figure 14: Tyre Model in Dymola
to the one at the instant when the failure occurred.

Figure 15: Rudder Force at 30 Rotation vs. A/C
Speed (Normalized)

2.6 Aerodynamic Model

2.7

Hydraulics Steering System Model

The Aerodynamic forces and momenta are lumped at The Hydraulics Steering System Model consists of a
the CG location. The equations used are as follows:
Nose Wheel Steering (NWS) and a BWS system. For
the first one the kinematics of the actuation consists of
a push-pull actuator arrangement which is capable to
1 2
FxA = VCG
S Cx
steer the A/C from a straight ahead position (NW S =
2
0
deg) to a full powered steering rotation of the Nose
1 2
S Cy
FyA = VCG
Wheel (NW S = NW Smax ). For the second one, the
2
kinematics consist of a single linear actuator, which
1 2
(5) steers the BWS accordingly to the actual position of
FzA = VCG S Cz
2
the NWS angle and ground speed of the A/C (BW S =
1 2
MxA = VCG S b Cl
f (NW S , GSA/C )). An overview of the NWS and BWS
2
Steering System models is given hereafter.
1 2
S c Cm
MyA = VCG
2
1 2
2.7.1 NWS Hydraulics Steering System Model
MzA = VCG
S b Cn
2
At the top-level, the system briefly consists of a Norwhere S is the wing wet area, b the wing span, and c the
mal Selector Valve Manifold (NSELVM), an Alternate
mean aerodynamic chord. These equations are multiSelector Valve Manifold (ASELVM), a Local Electroplied with a positive or negative sign to account for
hydraulic Generation System (LHEGS), Nose Landthe axes reference system. The computation of some
ing Gear (NLG) Shutoff-Swivel Valve, an Hydraulic
of the angles necessary for the evaluation of the coefControl Block (HCB), a servo-valve electro-hydraulic
ficients of (5) is as follow:
NWS, two Change Over Valves and two steering actu

u
ators. In addition, the system is connected to the hyv
 = arctan
 = arcsin
draulic power distribution system via the High Presw
|VCG |
sure ( 350 bar) and Low Pressure Manifolds (
Other angles and their rate of change are computed us- 5 bar). All the electrical signals necessary to enering a similar approach.
gize and de-energize the various selector valves and
The rotation of the Rudder is taken into account sep- command the servo-valve are sent by/to COM/MON
arately using the look-up table of Figure 15. It is as- to the Hydraulics System. In turn, the latter transsumed that the rudder has full authority when its ro- mits all the signal necessary to monitor the system
tation reaches 30 , and it increases linearly from zero to COM/MON, for instance the value of the pressure
to 30 . The rotation of the rudder implies also a rota- downstream NSELVM, via Pressure Transducer (PT)
tion of the nose wheel, this has been implemented in PT4.
the Steering Laws in the Monitoring and Commanding In the model, all the previous elements have been modModel.
eled, except the ASELVM and the LHEGS, which are
The Modelica Association

186

Modelica 2008, March 3rd  4th , 2008

Development of an Aircraft and Landing Gears Model with Steering System in Modelica-Dymola

mainly necessary only if particular faults in the system
occur (Reversion from Normal to Alternate Mode) and
they will be modeled in the future, see Figure 16.

COV = 0  arctan(Fry /Frx )
with 0 being the angle between the x axis of the nose
landing gear reference frame and the vector Sr ON , Frx
and Fry equal to the x and y coordinates of Fr. These
coordinates given in a reference system with the x  y
plane orthogonal to the strut axle (if the rake angle is
different from zero).

Figure 16: NWS Hydraulics Steering System Model
in Dymola
The model of COM/MON does not pretend to be exhaustive nor representative of the whole COM/MON
system, its principal task is to support the functioning
of the Hydraulics System Model. The Model has been
built keeping a net interface between the hydraulic domain, the mechanical domain and the avionic domain:
the green flanges represent the interface with the attachment points of the mechanical steering actuators
and the blue and purple signals the interface with the
avionic domain, see Figure 16.
The position of the spool of the servo-valve is controlled by a PI controller which modulates the current in order to minimize the error between NWS
commanded angle (NW Scom ) and actual NWS angle
(NW S ). The position of the servo-valve spool allows
the hydraulic flow to differentially pressurize the four
chambers (Left and Right, Annulus and Full Bore) of
the steering actuators, so to create push or pull forces
on the pistons ends.
The attachment points of the actuators are fixed: to
the stationary flange for the cylinders and to the rotating sleeve for the pistons, respectively. This, and their
position with respect to the upper strut of the shock
absorber, are such to create a steering torque, which is
transmitted, via the torque links, to the bottom of the
shock absorber strut (piston fork) allowing the A/C to
steer, see Figures 17, 18 and 19.
Of particular interest is the situation when one of the
two actuators stalls: the line of action of the hydraulic
force intersects the axle of rotation of the strut, creating no moment arm. The angle at which this happens
is called Change Over Angle (COV ), and it is equal to:
The Modelica Association

Figure 17: Actuators-rotary sleeve assembly
When NW S = COV , one of the two Change Over
Valve receives the command to change its position, see
Figure 16, either the left or the right one depending
if the A/C is performing a clockwise turn or counterclockwise turn, so that the corresponding actuator begins to push or pull and viceversa.
2.7.2

BWS Hydraulics Steering System Model

At the top-level, the system briefly consists of a Steering Selector Valve Manifold (SSELVM), a left and
right BWS Hydraulic Control Block including Selector Valves and Steering Actuator, a left and right lock
actuator, a left and right BWS electro-hydraulic servovale, an High Pressure supply line (HP) and Low Pressure supply line (LP) Manifolds and ATA 29 ElectroMotor Pump (EMP), see Figure 20.
Whilst the steering functions of the BWS is similar to
the NWS, except the fact that there is one linear steering actuator per side, the additional challenge has been
in modelling the lock/un-lock mechanism and un-lock
actuator, as already explained in  2.3.1, see Figure 8.

2.8

Monitoring and Commanding Model

The Monitoring and Commanding Model developed at
this stage has the main purpose of allowing the correct
functioning of the hydraulic and mechanical Model.

187

Modelica 2008, March 3rd  4th , 2008

G. Verzichelli

Figure 19: NLG driven by hydraulics actuators at 70
with side, drag and vertical forces (blue) and selfaligning torque (green) in Dymola

Figure 18: NLG Model with Actuators-rotary sleeve
assembly in Dymola
The signals to energize or de-energize the several selector valves are sent accordingly to the actual conditions of the A/C, so to create a closed loop between the
main three domains. The implementation of the Steering Laws has been also developed in this model, see
for instance the command of the BWS angle in accordance with the actual NWS angle, Figure 21.
A more comprehensive model will be developed in a
second stage: in doing that, an extensive use of the
StaeGraph Library will be pursued.

3

Simulation Results

The following sections highlight the Dymola set up
used to run simulations and the results obtained from
a simulation of a Rejected Take Off (RTO) scenario.

3.1

Simulation Settings

The type of integration algorithm used depended upon
the model that was tested. In the case of pure mechanical model, the Dassl or the Lsodar algorithms performed in an excellent manner. When it came to simulate the full model, combining avionic, hydraulic and
mechanical domains, the best performance has been
achieved using the Sdirk34hw method. Notably, the
increase of tolerance of the integrator did not improve
The Modelica Association

Figure 20: BWS Hydraulics Steering System Model
in Dymola
the simulation time: as explained in [2], a condition of
optimum should exists, in the case of the full model
a tolerance of 105 was used. Quite challenging has
been the identification of the right initial conditions:
Dymola by default, assigns arbitrary values for the initial conditions of certain variables. The assumption
made by the software should always be validated by
the user. In the case of the full A/C model, at the beginning of the simulation, there are many events that occur: the A/C is settling down on the soil (impact force
different from zero and the shock absorber starts to be
compressed), the A/C speed begins to reach the steady
state value, and especially, the hydraulic circuit tends
to find the steady state condition. All this could be
quite time consuming from a simulation point of view.
Ideally the user should try to find the value of the variables in the steady state condition which would like
to use as starting point of his/her investigation, record
those values, and use them as initial conditions for all
the following simulations. When this is done, he/she

188

Modelica 2008, March 3rd  4th , 2008

Development of an Aircraft and Landing Gears Model with Steering System in Modelica-Dymola

Figure 21: BWS Steering Laws
Figure 22: Snapshot of the A/C, five seconds after a
could simulate the model up to the steady state con- left outer engine failure with highlighted CG trajectory
dition and then used this final condition, as a starting (in blue)
point for a new simulation. This method can be used
only if the model has reached an high level of maturity
and many changes are no longer necessary.

3.2

RTO simulation test

The test has been carried out with the following preconditions and assumptions: A/C speed at the instant
of the left outer engine failure equal to 130 kt, mass
equal to 560 t, CG position equal to 37.5 %, rolling
friction coefficient R , equal to 6 e3 , all the steering
controllers active, (NW Scom = 0) with no pilots correction after engine failure, no aerodynamic forces and
rudder force.
The main outputs of interest are the trajectory of the
nose and CG, Figures 23 and 24, A/C heading , Figure 27; A/C CG lateral linear and angular accelerations, ayCG and zCG respectively, Figures 25 and 26.
Notably, It takes 1.25 s before the CG linear acceleration along y direction starts to become negative, see
Figure 25, in fact the CG first moves towards the positive x  z half plane and then after a while, it starts to
move towards the negative x  z half plane, following
the nose. After three seconds from the instant of the
simulated engine failure, the nose has moved of circa
37.22 cm towards the left.

4

Future Work

The future work will be mainly based on the enhancement of the Aircraft Library with the development of
more comprehensive models and new models as well;
on the investigation of Modelica capability to produce
code to run models in a Real Time environment for
hybrid simulations on the landing gear test rig and, finally, on the validation of the models with Flight Test
The Modelica Association

Figure 23: CG and Nose trajectory (engine failure at
x = 382.47 m. A/C moves forward when x < 0)
and Test Rig Data.

5

Conclusions

Though the work presented in this paper is one of the
first large-scale application of Modelica for the simulation of landing gears and aircrafts, its findings made
clear the power and potentiality of the language to
model and simulate so tightly coupled systems such
the ones which equip new modern airplanes.
The fact that the source code is completely open to the
user implies a huge potentiality to increase the level of
accuracy of every model component/assembly/system.
The acasuality feature of the language implies a real
opportunity to develop a re-usable library of models
which is not truly possible with models built with a casual language. Furthermore, the system modeled with
Modelica provides a unique feature which is the capability of the model to look like the real system undergoing the design process: in a large enterprise this

189

Modelica 2008, March 3rd  4th , 2008

G. Verzichelli

Figure 24: CG and Nose trajectory (engine failure at Figure 26: A/C angular acceleration along z at CG lox = 382.47 m. A/C moves forward when x < 0) cation
(Magnified)

Figure 27: A/C heading angle 
Figure 25: A/C linear acceleration along y at CG location (Magnified)

6

represents a point of convergence between designers
and modelers. No particular skills are necessary to be
able to read the model which faithfully should represent the system, so that feedbacks, critics, enhancements, approvals can be easily agreed between several
actors not necessarily experts of modelling and simulations techniques, even before any type of simulation
is performed.

The Author would like to acknowledge Airbus for giving the opportunity to attend the Modelica 2008 Conference and present this work, Mr. Sanjiv Sharma for
the continuous support and for reviewing the paper,
Miss. Serena Simoni for having accepted the challenge of learning Modelica and Dymola and started
this work and finally Claytex Services Limited and
Dynasym AB for solving technical issues related to
the use of the software.

If Modelica is used in a large industrial environment
some enhancements are advisable, though these issues
may not be necessarily attributable to Modelica itself:
the capability of creating geometry (with mass, inertia, CG location and surface shape information) directly from a Computer-Aided Drawing (CAD) software in an automated manner; a flexible body simulation capability, including contacts and conditional
connection/dis-connection of bodies/joints during the
same simulation.
The Modelica Association

Acknowledgments

Acronyms
A/C Aircraft
ASELVM Alternate Selector Valve Manifold
BLG Body Landing Gear
BWS Body Wheel Steering
CAD Computer-Aided Drawing

190

Modelica 2008, March 3rd  4th , 2008

Development of an Aircraft and Landing Gears Model with Steering System in Modelica-Dymola

References
[1] M. Beckman and J. Andreasson. Wheel model
library for use in vehicle dynamics studies. KTH
Vehicle Dynamics, Sweden
mb.johang@fkt.kth.se
[2] C. Clau and P. Beater. Electronic, Hydraulic,
and Mechanical Subsystems of a Universal Testing Machine Modeled with Modelica. 2nd International Modelica Conference, Proceedings, pp.
25-30, Germany
Figure 28: A/C demanded and actual speed [m/s]

Figure 29: A/C demanded and actual speed [m/s]
(Magnified)
CG Centre of Gravity
EMP ATA 29 Electro-Motor Pump
GUI Graphical User Interface
HCB Hydraulic Control Block
HP High Pressure supply line
LHEGS Local Electro-hydraulic Generation System
LP Low Pressure supply line
MAC Mean Aerodynamic Chord
NLG Nose Landing Gear
NSELVM Normal Selector Valve Manifold
NWS Nose Wheel Steering
PT Pressure Transducer
RTO Rejected Take Off

The Modelica Association

191

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

192

Modelica 2008, March 3rd  4th , 2008

The New DLR Flight Dynamics Library

The New DLR Flight Dynamics Library
Gertjan Looye
German Aerospace Center (DLR), Institute of Robotics and Mechatronics
Oberpfaffenhofen, 82234 Wessling, Germany

Abstract
An overview of the new Modelica Flight Dynamics Library of the German Aerospace Center DLR is
given. This library is intended for construction of
multi-disciplinary flight dynamics models of rigid and
flexible flight vehicles. The environment models provide the functionality to cover on-ground operations
up to flight at high speeds and high altitudes. The resulting models may be used in various fields and stages
of the aircraft development process, like flight control
law design, as well as for real-time flight simulation.

 Single source modelling: Especially in flight controls various types of analysis methods are used
that require aircraft models to be available in various forms. Examples are nonlinear models for
simulation, (symbolic) linear models for stability
and robustness analysis, inverse models for control law synthesis, etc. Various forms of models often involve independent implementations of
the same model data. Modelica allows for the
construction of a single model from which appropriate analysis models may be generated with the
help of a model translator.

Keywords: flight dynamics; flight control; simulation; Back in 1995 the DLR institute of Robotics and
aeroelasticity
Mechatronics developed a first library (at the time,
based on the Dymola language) for modelling of aircraft flight dynamics [26]. Objective was to build a
1 Introduction
solid basis for constructing integrated dynamic aircraft
models, including flight dynamics, detailed on board
Dynamic simulation plays an important role in the system dynamics, structural dynamics, etc. First appliaircraft design and certification process. Typical ex- cations were a generic transport and a fighter aircraft
amples are development of flight control laws, flight [20] and a first flexible aircraft shortly thereafter [15].
loads analysis, specification and testing of on-board Since then, the library has been expanded and applied
systems, aircraft handling qualities and system assess- to complex aircraft models that include e.g. system
ment in real-time manned flight simulators. DLR has hydraulics and electronics [25, 27, 24]. In the frame
developed an extensive Modelica library that allows of the international projects REAL (Robust and Effor construction of suitable aircraft flight dynamics ficient Autopilot control Laws design, funded by the
models for the various stages and applications in the EU in the fifth frame work programme [31]) and the
aircraft development process. The following strengths GARTEUR action group AG-11 on clearance of flight
of Modelica have hereby been exploited particularly: control laws [11], the automatic generation of inverse
models for fast trim computation and nonlinear control
 Multi-disciplinary modelling: multi-disciplinary laws was applied for the first time. Recent application
interactions play an important role in flight dy- examples are the thrust-vectored X-31A high-angle of
namics. Especially when flight control laws are attack experimental aircraft and a real-time capable ininvolved, aspects like flight mechanics, structural tegrated flight dynamics and aeroelastic transport airdynamics, and systems may show considerable craft model, including unsteady aerodynamics, strucdynamic interactions that must be appropriately tural dynamics, control system, etc.
addressed in the model used for design analy- The latest version of the Flight Dynamics Library inses. Modelica provides an ideal basis to develop cludes various major enhancements as compared with
such models, since a large amount of discipline- previous versions. Firstly, it exploits more recent
specific libraries is available that may be used to Modelica features, like the bus concept and the matured inner-outer concept. Secondly, the library is
construct components of the integrated model;
The Modelica Association

193

Modelica 2008, March 3rd  4th , 2008

G. Looye

now compatible with the Multibody Library (part of
the Modelica standard library), allowing for easy construction of airframes. Thirdly, its world model has
been enhanced to comply with inertial standards like
WGS84 [4] for position reference.
This paper discusses these latest developments, new
features, and example applications of the Flight Dynamics Library. In the following section the selection
of a generic aircraft model structure is discussed (Section 2), based on which the Flight Dynamics Library
has been organised (Section 3). In Section 4 the automatic generation of model code for model simulation
and analysis is discussed, followed by some example
applications. Finally, a summary is given in Section 6.

ically makes sense. Using the so-called inner-outer
feature of the Modelica language, these models provide field functions. For example, the aircraft may request its surrounding atmospheric conditions from the
atmosphere model by sending its local inertial position. Any other aircraft (or e.g. sensor) object in the
model may do this as well. This is an advantage as
compared with most block-oriented libraries, where an
atmospheric model is directly linked to, and thus occupied by, the one aircraft. The ability to easily include
multiple air vehicles is useful for applications involving mutual interactions, like towed gliders, wake vortexes, air-to-air refuelling, release of missiles, etc.

2.1

2

The aircraft model structure

In the following subsections the environment models
in Figure 1 (world, atmosphere, terrain, airport) will
be discussed. These components determine validity
of the over-all model to a large extent. Most important is the world model (in this case the Earth, but the
underlying base class may be extended to implement
models of other planets), since it provides the inertial
reference in the form of the so-called Earth-Centred
Inertial (ECI) reference frame. Its origin is attached
to the Earths centre of mass, its orientation is fixed
with respect to reference stars. In addition, the model
component has the following functions:

Figure 1: Top-level of model: aircraft and environment
The objective of this section is to introduce and motivate the basic structure of an aircraft model as it may
be composed from the Flight Dynamics Library. The
structure of this library will be discussed thereafter.
In constructing complex models the choice of hierarchy is crucial, since this largely determines how model
components interact. For the Flight Dynamics Library
a top-level model structure as shown in Figure 1 has
been adopted. It consist of one or more aircraft, and
environment objects (The avionics component and input and triangular-shaped output connectors will be
discussed in Section 4). The environment objects include a world, atmosphere, terrain, and airport model.
Note that the (in this case, single) aircraft model has no
direct link with the environment models, which physThe Modelica Association

The world model

194

 Provide the geodetic reference. As indicated in
Figure 1, to this end the World Geodetic System
1984 [4] (WGS84) is used. The object implements an Earth-Centred Earth-Fixed (ECEF) reference frame, which has the same origin as the
ECI, but rotates with the Earth. The attitude of
the ECEF (w.r.t. ECI) is available in a connector.
A set of functions transform ECI and ECEF referenced position vectors into geodetic longitude,
latitude, and height co-ordinates (w.r.t. WGS84
ellipsoid) and vice versa. For a given longitude
and latitude, another function provides the local
undulation of the so-called EGM96 (Earth Gravitational Model 1996) geoid with respect to the
WGS84 ellipsoid, providing the Mean Sea Level
(MSL) reference [14].
 Implement a model of the Earths gravitation.
The gravitational model to be used with WGS84
is the Earth Gravitational Model 1996 (EGM96),
provided in the form of tables describing equipotential surfaces a function of longitude and
latitude. Currently, a more simplified height
and geocentric latitude-dependent (Ref. [33] Modelica 2008, March 3rd  4th , 2008

The New DLR Flight Dynamics Library

Eqn.(1.4-16)) and a constant gravity model are ifications [10]. The location, elevation, direction, and
slope of a runway may be specified, as well as slopes
available.
and steps in the terrain below the approach path. A
 Implement a model of the Earths magnetic field. simple function call from e.g. an aircraft sensor then
This field is required to compute indications of returns the corresponding local terrain elevation above
compass models. The model is based on the US MSL or the WGS84 ellipsoid, allowing for computaNational Geo-spatial-Intelligence Agency (NGA) tion of for example the reading of the radio altitude
World Magnetic Model (WMM), which is pub- sensor.
lished every five years and predicts the timevarying intensity and direction of the magnetic
2.4 The airport infrastructure model
field as a function of WGS84 longitude, latitude
and height. The current model covers 2005 till The airport object implements earth-fixed navigational
2010 [23].
equipment (e.g. VOR, DME, ILS systems at specified
locations). In the figure the ILS equipment of the one
Double-clicking on the world object in Figure 1 al- runway as positioned in the EASA CS-AWO terrain
lows a number of parameters to be set, like whether the model is included. Specific characteristics like glide
Earth is rotating or in rest, initial day time, and the type slope angle and antenna transmitter positions may be
of gravity model (approximate EGM96, height inde- specified via parameters. Any other model object may
pendent, or constant). The features of the object may obtain its local glide slope and localiser deviation via
be overkill for many applications, but provide suffi- a simple function call.
cient generality for use with for example high speed
and high altitude flight vehicles. Furthermore, the
2.5 Rigid and flexible aircraft models
applied WGS84 ensures compatibility with standard
GPS equipment, with most flight simulator vision sys- The core of the model structure is of course the compotems, navigation system models, etc. Obviously, any nent that represents the actual aircraft. The Flight Dyparameter set in the world and other environment mod- namics Library foresees the implementation of rigid
els applies to all components in the aircraft model.
just as well as flexible ones. A typical model structure
for a flexible transport aircraft is shown in Figure 2.
The components resemble physical parts an aircraft
2.2 The atmosphere model
consists of (airframe, engines, actuators, sensors), and
The second environmental object in Figure 1 is the at- phenomena it is influenced or driven by (kinematics,
mosphere. Normally, the International Standard At- aerodynamics, wind).
mosphere (ISA) as a function of the height above MSL
is used. Alternatively, parameters for constant atmo- Component interconnections
spheric conditions may be entered. The air mass is For mechanical interconnections the connectors from
nominally assumed to be in rest with respect to the the Multibody standard library [28] are used. For use
ECEF, explaining why a connection with the world with flexible airframes an extended version has been
ECEF-connector exists. However, the component also implemented that includes generalised co-ordinates
foresees implementation of wind fields. Currently, and forces. For the engines and sensors the connecwind components in northern and eastern directions tor represents the point at which the device is attached
may be entered at a reference altitude of 100 ft above to the airframe. Aerodynamic forces actually act all
the Earth surface. A simple Earth boundary layer over the airframe. However, in flight mechanics usumodel logarithmically reduces the wind velocity to ally only the summed effect with respect to some refzero on the ground.
erence point, like the Aerodynamic Centre (AC), is of
interest. Also for the aerodynamic forces in the aeroelastic aerodynamic model (to be discussed shortly) in
2.3 The terrain model
fact only their summed effect is considered due to soTo the right in Figure 1 a terrain model has been added. called left-generalisation with rigid and flexible eigenA component containing highly detailed, or simple modes, see Ref. [19]. Therefore, the aerodynamic
parametrised models of the Earths surface may be se- models need a single connector only.
lected from the library. Depicted in Figure 1 is a terrain
model as used for automatic landing control law de- Kinematics
sign and certification, based on EASA CS-AWO spec- The backbone of the model depicted in Figure 2 are the
The Modelica Association

195

Modelica 2008, March 3rd  4th , 2008

G. Looye

Figure 2: Structure of the Flexible Aircraft model in Figure 1
kinematics and airframe components. The first defines
a North-East-Down (NED) local vertical frame with
its origin moving with a fixed position in the aircraft,
preferably the centre of gravity. The object also defines a right-handed body-fixed reference frame with
its origin at the same location, but with a fixed attitude w.r.t. the airframe (x-axis towards the nose, zaxis down). The attitudes and inertial positions of both
reference systems are available in the two connectors.
The one on top represents the aircraft body reference
system, the one belows represents the vehicle-carried
NED reference frame.

in modal form augment the Newton-Euler equations
[34, 30]. The body axes system is hereby considered as
a so-called mean axis system. The momentary shape
of the airframe is characterised by states in the form of
generalised co-ordinates (also called mode shape multipliers). The underlying data (modal mass, damping,
stiffness, and mode shape matrices) are automatically
read from a specified file prior to simulation. More details on nonlinear equations of motion of flexible aircraft can be found in Refs. [19, 30].

Connection of the airframe object to the kinematics
object (see Figure 2) makes that the reference systems
in both connectors merge, i.e. from then on the airframe is moving freely with respect to the inertial refAirframe
The difference between a rigid and a flexible aircraft erence, according to kinematic equations described in
is, in fact, only in the airframe object. In case of a the kinematics object.
rigid airframe, it contains the standard Newton-Euler The airframe object has a second connector on top (see
force and moment equations with respect to a body ref- Figure 2). This connector may contain a different reference system [7] (attitude and position in lower con- erence frame with a constant offset, or may simply be
nector). Although the origin of this reference system is identical to the body frame (to be specified via an offpreferably the centre of gravity (for compatibility with set parameter). It is intended for interconnection of
standard flight dynamics models), a fixed point w.r.t. for example external force model components, sensor
the undeformed airframe shape may be more useful models, etc. As mentioned before, in case of a flexible
for referencing reasons. The local gravity acceleration airframe also generalised co-ordinates and generalised
is obtained by a call to the world object (Figure 1). forces are included in the connector definition.
Note that the computation of gravity depends on the
method that is selected in the world object. In case of External forces and moments
a flexible airframe, linear elastic equations of motion The airframe equations of motion are primarily driven
The Modelica Association

196

Modelica 2008, March 3rd  4th , 2008

The New DLR Flight Dynamics Library

by aerodynamic and propulsion forces and moments.
These are computed in corresponding model components in Figure 2. These components often need to be
prepared for each aircraft type individually, since application rules and data (sources) behind aerodynamics and propulsion models may strongly differ. For this
reason, a base class is available that already defines
interfaces and the connector, as well as equations for
computation of key variables like the angle of attack,
side slip, and true airspeed. Local wind velocities are
hereby requested from the atmosphere model in Figure 1. The user may develop own model components,
inheriting this base class.
Besides the airframe, each component may be developed around its own local reference frame. In case of
aerodynamics, these may for example be the stability
or wind axes. Interconnection with the airframe follows via a transformation object (e.g. AeroRef in Figure 2). This object has two connectors representing
two reference systems. The offset (position, orientation) in between may be specified via parameters that
become visible and can be edited by double-clicking
on the object. The object also relates the forces and
moments that act along the connector reference systems. When connecting a model with the airframe
object, the transformation object makes sure that the
kinematics between the local component and the airframe reference systems are correctly related, as well
as forces and moments are applied correctly.
The aircraft model in Figure 2 has two aerodynamics
models (right hand side). The upper one (Aero) contains forces and moments as induced by the over-all
motion of the aircraft (rigid aerodynamics), usually
also corrected for quasi-steady deformation of the airframe. The underlying model may be based on complex application rules, table look-ups, etc. In case a
data set is not available or incomplete, computational
tools as described in [13] are used. The lower aerodynamics component (aerodynamicsFlex) computes unsteady (generalised) forces and moments as induced
by flexible deformation of the airframe. For this component extensive pre-processing tools have been developed, involving application of the Doublet-Lattice
Method, axis transformations, Rational Function Approximation and removal of quasi-steady effects (already accounted for in the rigid aerodynamics model),
see Refs. [19, 13] for more details. The unsteady aerodynamic data are read from a user-specified data file at
simulation start.

whereby the latter describes the offset between the airframe body axes and the aerodynamic reference system. The upper aerodynamics component is directly
connected with the upper airframe connector, making
use of generalised co-ordinates declared therein. In
case kinematics and the balance between aerodynamic
and actuation forces are relevant, a direct interconnection between the actuators and aerodynamics models
may be added.
The engine models (top left) are connected to the airframe via a slightly different type of transformation.
Instead of an offset, the number of a structural grid
point, where the object is to be attached, may be specified. At simulation start the transformation object
requests the rows of the modal matrix that apply to
the grid point from the airframe object, allowing it to
continuously compute the kinematic relation and force
balance between its connectors as a function of the offset from the airframe reference and the local deformation [19, 30]. This for example implies that directional
thrust variations due to local deformation at the engine
attachment point are automatically taken into account.
Sensor models
The very same principle as used for interconnecting
engine models with the airframe structure also applies
to the sensor models, located in the top-right corner of
Figure 2. A set of sensor types is available in the library. For example, accelerometers compute local accelerations at their point of attachment (specified via
grid point number, or offset) as a function of the inertial motion of the airframe, its position in the airframe
reference, as well as the local airframe deformation.
The ILS, GPS, and radio altimeter sensors obtain
their values by making a function call to the airport,
world, and terrain environment models respectively
(Figure 1), passing on their momentary inertial position as an argument. In this way, for example multiple
GPS sensor objects may be included at various locations on the airframe. Each object can request its very
local co-ordinates from the world object.

Local wind effects
As already discussed in Section 2.2, mean winds are
computed in the atmosphere block at the top level of
the model in Figure 1. However, turbulence models
are usually described in aircraft body axes, whereby
delays as gusts travel along the airframe, are taken
into account. This is described in the localWind object (lower left, in this case based on EASA CS-AWO
Note that the Aero component is connected to the specifications for autoland assessment). Random turlower airframe connector via the AeroRef object, bulence velocities are obtained from dedicated filters
The Modelica Association

197

Modelica 2008, March 3rd  4th , 2008

G. Looye

(Dryden, Karman) that use white noise signals as inputs. This noise is provided via an external connector.

or add components from the Flight Dynamics or
any other Modelica library.

Systems
On-board systems are included in the actuators component. This component may describe actuators and
hydraulic / electric systems using simple transfer functions, as well as highly detailed physical models, constructed from hydraulics and electronics libraries. The
library currently only provides the first variant, since
detailed on-board system models are unique for each
type or family of aircraft and are usually provided by
systems specialists. A recent example of on-board
system model implementation using Modelica can be
found in [5].

 Aerodynamics contains example aerodynamic
models for use in rigid and flexible aircraft models, as well as base classes that the user may extend (inherit) to develop his own aircraft-specific
model components. Each aircraft type or family
namely tends to use unique application rules. For
this reason, newly implemented aerodynamics
components are stored within the aircraft project
(see ProjectTemplate).

Avionics bus
Finally, the thin bar at the top of Figure 2 represents
a so-called data bus, implemented using Modelicas
expandable connector concept. The data bus includes
signals that one would typically find on avionics buses
in the aircraft, like the readings of all sensors, command signals to engine and control surface actuators,
gear status, etc. For this reason, the sensor, actuator,
and engine models have been attached to the bus object. The bus is also accessible from outside and allows direct connection to elements from the Modelica
block diagram library. This enables a control system
composed using this library to directly communicate
with the aircraft data bus.

3

The Flight Dynamics Library

The top-level structure of the DLR Flight Dynamics
Library is depicted in Figure 3. The Modelica branch
in the depicted tree (top) contains the principal standard libraries delivered with Modelica. The branches
of the Flight Dynamics Library will be briefly described below:
 ProjectTemplate contains a basic library structure for an aircraft. Each aircraft type has its own
models for aerodynamics, propulsion, systems,
landing gears, etc. These models are built on
base classes that already compute all basic variables (e.g. for aerodynamics, angle of attack, calibrated airspeed, etc.) and are stored in this structure. The project template contains a very simple, but readily working aircraft model. The user
may copy this template into an own project and
start implementing aircraft-specific components,
The Modelica Association

198

 Airframes contains rigid and flexible airframe
model objects. The rigid ones may have constant
mass and inertia tensor (entered via parameters),
or these may change at a given rate (e.g. as a
function of fuel consumption). The flexible airframe component loads its mass, and modal data
from an external file (e.g. a Matlab mat-file [21]).
 Environment contains all environment-related
models as described at the beginning of Section 2.
 Examples contains example implementations of
various (basic) aircraft models.
 Gear currently contains a simplified landing gear
model for which basic properties may be set and
which may be attached to the airframe object in
Figure 2. A base class containing a standard interface for interconnection with the airframe is provided for implementation of detailed landing gear
models, e.g. composed with help of the multibody library by specialists in the field.
 Interfaces contains all library-specific connector
types, as well as the data bus that was discussed
Section 2.5.
 Kinematics contains the Kinematics object as described in the previous section.
 Propulsion contains, as for the aerodynamics,
example engine model implementations, as well
as base classes that allow the user to implement
his own propulsion models.
 Systems mainly contains sensor models (accelerometers, ILS, GPS, etc.) with time constants
and noise if desired, and simple transfer functionbased actuator models.
 Transformations contains standard transformations between reference systems.
Modelica 2008, March 3rd  4th , 2008

The New DLR Flight Dynamics Library

Modelica standard
multi-engineering
library

Modelica
Flight Dynamics Library

{

Aircraft project library

Figure 3: Top-level structure of the Flight Dynamics Library
 Types contains type definitions for internal vari- 4.1 Specification of inputs and outputs
ables, to which the user may add his own.
A simple way of specifying model inputs and outputs
is shown at the top of Figure 1. Here a so-called Avion Utilities contains miscellaneous functions e.g.
ics block has been connected to the bus connector of
for reading external data files.
the aircraft. At this main model level, also input and
output connectors have been defined. The Avionics
Within a dedicated Modelica modelling and simula- block injects pilot throttle and control surface input
tion environment, like Dymola (Dynamic Modelling commands (from Throttle, Controls connectors) into
Library [3]) aircraft models may be composed from the data bus. Output variables of interest, in this case
the library using drag and drop.
navigation and air data, are read from the bus and
passed on to output connectors (NavOut, Airdata).

4

Automatic code generation

After model composition has been finished, a model
translator sorts and solves all model equations according to specified inputs and outputs into Ordinary
Differential Equations (ODEs) or Differential Algebraic Equations (DAEs), suitable for use in simulation. A modelling tool that is well capable of doing
this is Dymola [3]. Besides a graphical modelling
environment and advanced symbolic algorithms, the
tool offers extensive simulation and data analysis capabilities. However, the model code may be used in
other engineering environments and simulation tools
as well, like for example Matlab/Simulink [22]. For
this environment an additional tool set has been developed that automatically generates trimming and linearisation scripts, allowing the user to easily specify Figure 4: Reversal of inputs and outputs for NDI conand accurately compute initial conditions prior to sim- trol law generation
ulation [15].
The Modelica Association

199

Modelica 2008, March 3rd  4th , 2008

G. Looye

4.2 Inverse model generation
Probably one of the most attractive features of Modelica, in combination with a model compiler like Dymola, is the possibility to generate inverse models just
as easily as normal simulation models. Inverse models
are extremely useful for fast and accurate trim computation, systems and control surface sizing, as well
as for automatic generation of control laws that are
based on inverse model equations, like Nonlinear Dynamic Inversion (NDI [9]). Ref. [18] describes various
types of inverse model-based control laws and their automatic generation from Modelica models. Figure 4
shows the addition of an FCS block, which contains
the basic structure for an NDI controller, see Figure 5.
Like the Avionics block, the FCS communicates with
the aircraft model via the expandable bus. Compared
with Figure 1, the Controls input has become an output, and command variables pqbC (roll rate pb , pitch
rate qb , side slip angle  ) have been added as inputs instead. This is basically all that is needed to generate an
inverse model. For practical reasons, additional modifications have been made, like the removal of most
environment models: variables like radio altitude and
ambient pressure can be directly obtained from measurement instead.

Aviator Visual Design Simulator (AVDS), described in
Ref. [29]. An interface with the Flight Dynamics Library has been described in [24]. Interfaces with public domain simulator programs like FlightGear [2] are
to be developed, whereby the internal flight dynamics model in this program is overwritten by the model
constructed from the Flight Dynamics Library.

5

Application examples

Since its first version in 1995, the Flight Dynamics Library has been applied in several projects at DLR, especially involving model development for design and
evaluation of flight control laws. A number of these
applications will be briefly discussed in this section.
REAL  Automatic Landing
In the frame of the EU-project REAL (Robust and Efficient Auto pilot control Laws design [31]) for the first
time inverse model equations for a transport aircraft
were automatically generated from the model implementation in Modelica. These inverse equations were
used as the core of an automatic landing system that
was developed in the frame of this project [16]. The
control laws were successfully flight tested on DLRs
test bed ATTAS (Advanced Technologies Testing Aircraft System [6]) during six automatic landings.

X-31A with reduced vertical tail
The same procedure for automatic generation of Nonlinear Dynamic Inversion control laws was applied
to the thrust-vectored experimental fighter aircraft X31A in the frame of the project VECTOR (Vectoring,
Extremely short take-off and landing, Control, Tailless Operations Research [12]), in order to investigate reduced vertical tail configurations of this aircraft
[32]. The control laws were exported from Dymola
Figure 5: NDI control law with command variables for and implemented in the ground-based flight simulator
in Patuxent River, MD, USA, and successfully evalumanual aircraft control
ated by five test pilots and one fleet pilot.

4.3

Desktop visualisation

Easy access to high-quality desktop visualisation tools
becomes more and more important in the flight control
law design process. This helps the engineer to better
understand the (closed-loop) dynamics of the aircraft,
and allows her or him to interactively "fly" the aircraft to qualitatively assess control law performance
and to find weaknesses before implementation in the
full flight simulator. One of the first commercial environments offering this visualisation capability is the
The Modelica Association

3D-Flexible aircraft flight simulator
From the example flexible aircraft model as presented
in Section 2 simulation code was generated for use
in interactive real-time simulation. The model was
augmented with automatically generated Dynamic
Inversion-based control laws, the automatic landing
system as developed in the project REAL, as well as
load alleviation control laws. An engineering visualisation environment called VisEngine, developed by
AeroLabs AG [1], simultaneously visualises aircraft
flight dynamics and structural dynamics in real-time

200

Modelica 2008, March 3rd  4th , 2008

The New DLR Flight Dynamics Library

interactions;

in very high quality, see Figure 6. As exclusive features for DLR, VisEngine was extended with on-line
visualisation of airframe deformation, as well as the
capability of visualising the aircraft and its environment using 3-D stereo projection. The visualisation of
structural deformation greatly helped to qualitatively
assess performance of structural control laws.

 construction of rigid just as well as fully flexible
aircraft models, including unsteady aerodynamic
effects;
 easy implementation of multiple aircraft models
using the same set of environment models (earth,
atmosphere, etc.);

GARTEUR FM(AG17) Control law design for aircraft on ground
In the future, transport aircraft may be equipped with
drive-by-wire control laws to reduce pilot workload
during landing roll-out, taxiing, and take-off. In addition, this technology will provide the basis for development of functions for automatic ground manoeuvring [8]. In the frame of this GARTEUR project a
complex aircraft model, including landing gears, was
implemented using the Flight Dynamics Library. In
order to study various possible command variables for
the pilot, automatic model inversion was used to develop control laws based on nonlinear dynamic inversion. More details can be found in Refs. [19, 17].

 automatic generation of efficient simulation code
for various engineering environments (using a
Modelica tool like Dymola);
 automatic generation of inverse model code, e.g.
for use in nonlinear control laws;
 automatic generation of trimming and linearisation scripts for use with the model in Matlab/Simulink;
 easy integration with desktop visualisation.

References
[1] Aerolabs AG  Professional Solutions for the Engineering
Industry: http://www.aerolabs.de.
[2] Flight Gear web site: http://www.flightgear.org.
[3] Dynasim AB.
Dymola  Users
http://www.dynasim.se/, 19942006.

Figure 6: 3D-stereo visualisation of aircraft flight and
structural dynamics, and aerodynamic loads

6

Conclusions

In this paper an overview of the Modelica-based Flight
Dynamics Library has been given. This library allows
for intuitive construction of multi-disciplinary models
for use in the aircraft and flight control laws design
process. To this end, the library offers the following
unique features:
 full compatibility with other libraries based on
the Modelica language, allowing for development
of truly multi-disciplinary aircraft models on a
common modelling platform;
 intuitively structured models due to a physicsoriented break-down into model components and
The Modelica Association

201

Manual.

[4] anon. Department of Defence World Geodetic System
1984  Its Definition and Relationships with Local Geodetic Systems, Third Edition, Amandment 1. Technical Report
NIMA TR8350.2, National Imagery and Mapping Agency,
Bethesda, MD, January 2000. Third Edition.
[5] J. Bals, G. Hofer, A. Pfeiffer, and C. Schallert. Virtual
Iron Bird  A Multidisciplinary Modelling And Simulation
Platform For New Aircraft System Architectures. In DGLR
Luft- und Raumfahrtkongress 2005, Friedrichshafen, DGLRJahrbuch 2005, 2005.
[6] M. Bauschat, W. Mnnich, D. Willemsen, and G. Looye.
Flight Testing Robust Autoland Control Laws. In Proceedings of the AIAA Guidance, Navigation and Control Conference 2001, Montreal CA, 2001.
[7] Rudolf Brockhaus. Flugregelung. Springer-Verlag, Berlin
Heidelberg, 1994.
[8] J. Duprez, F. Mora-Camino, and F. Villaum. Control of the
Aircraft-on-Ground Lateral Motion During Low Speed Roll
and Manoeuvers. In IEEE Aerospace Conference Proceedings, pages 2656 2666, 2004.
[9] Dale Enns, Dan Bugajski, Russ Hendrick, and Gunter
Stein. Dynamic Inversion: An Evolving Methodology for
Flight Control Design. In AGARD Conference Proceedings
560: Active Control Technology: Applications and Lessons
Learned, pages 71  712, Turin, Italy, May 1994. NATOAGARD.

Modelica 2008, March 3rd  4th , 2008

G. Looye

[10] European Aviation Safety Agency (EASA). Certification Specifications for All Weather Operations CS-AWO,
2003. Available from http://www.easa.europa.eu/
home/certspecs_en.html.

[24] D. Moormann and G. Looye. The modelica flight dynamics library. In Proceedings of the 2nd International Modelica Conference, pages 275284. The Modelica Association,
2002. Available from http://www.modelica.org.

[11] Christopher Fielding, Andras Varga, Samir Bennani, and
Michiel Selier (Eds.). Advanced Techniques for Clearance
of Flight Control Laws. Lecture Notes in Control and Information Sciences 283. Springer Verlag, London, 2002.

[25] D. Moormann, P.J. Mosterman, and G. Looye. Objectoriented computational model building of aircraft flight dynamics and systems. Aerospace Science and Technology,
3(3), April 1999.

[12] H. Friehmelt and P. Huber. Vector- Die X31A fliegt zu neuen
bahnbrechenden Technologiedemonstrationen. In DGLR
Luft- und Raumfahrtkongress 2001, Hamburg 17.-20. Sept.
2001.

[26] Dieter Moormann. Physical modeling of controlled aircraft.
In Proceedings of the CESA96 IMACS Multiconference on
Computational Engineering in Systems Applications, pages
970975, Lille-France, July 1996.

[13] Thiemo Kier, Gertjan Looye, Moriz Scharpenberg, and Marion Reijerkerk. Process, methods and tools for flexible aircraft flight dynamics model integration. In Proceedings of
the International Forum on Aeroelasticity and Structural Dynamics (IFASD), 2007.

[27] Dieter Moormann.
Automatisierte Modellbildung der
Flugsystemdynamik. VDI Verlag, Reihe 8, Dissertation
RWTH Aachen, Institut fr Flugdynamik, Dsseldorf, 2002.

[14] F. G. Lemoine, S. C. Kenyon, J. K. Factor, R.G. Trimmer,
N. K. Pavlis, D. S. Chinn, C. M. Cox, S. M. Klosko, S. B.
Luthcke, M. H. Torrence, Y. M. Wang, R. G. Williamson,
E. C. Pavlis, R. H. Rapp, and T. R. Olson. The Development of the Joint NASA GSFC and NIMA Geopotential
Model EGM96. Technical Report NASA/TP-1998-206861,
NASA Goddard Space Flight Center, Greenbelt, Maryland,
July 1998.
[15] Gertjan Looye. Integrated Flight Mechanics and Aeroelastic Aircraft Modeling using Object-Oriented Modeling Techniques. In Proceedings of the AIAA Modeling and Simulation Technologies Conference, Portland, USA, August 1999.
AIAA-99-4192.
[16] Gertjan Looye. Design of Robust Autopilot Control Laws
with Nonlinear Dynamic Inversion. at  Automatisierungstechnik, 49(12), 2001.
[17] Gertjan Looye. Rapid prototyping using inversion-based
control and object-oriented modelling., chapter 8. Lecture
Notes in Control and Information Sciences. Springer Verlag,
Berlin, 2007.
[18] Gertjan Looye, Michael Thmmel, Matthias Kurze, Martin
Otter, and Johann Bals. Nonlinear Inverse Models for Control. In Proceedings of the third international Modelica conference, Hamburg, March 2005.
[19] Gertjan H.N. Looye. An Integrated Approach to Aircraft
Modelling and Flight Control Law Design. 2008. Doctoral thesis Delft University of Technology. Available from
http://repository.tudelft.nl.

[28] Martin Otter, Hilding Elmqvist, and Sven Erik Mattsson.
The new modelica multibody library. In Peter Fritzson, editor, Proceedings of the 3rd International Modelica Conference, Linkping, Sweden, pages 311  330. Modelica Association, 2003.
[29] S.J. Rasmussen and S.G. Breslin. AVDS: a Flight Systems Design Tool for Visualization and Engineer-in-theLoop Simulation. AIAA 97-3467. 1997.
[30] Christian Reschke. Flight loads analysis with inertially coupled equations of motion. In Proceedings of the AIAA Guidance, Navigation, and Control Conference, 2005. AIAA
2005-6026.
[31] W.F.J.A. Rouwhorst. Robust and Efficient Autopilots control
Laws design, demonstrating the use of modern robust control
design methodologies in the autoland system design process
 the REAL Project. In Proceedings of the Aeronautics Days
2001, Hamburg Germany, January 2001.
[32] R. Steinhauser, G. Looye, and O. Brieger. Design and Evaluation of Control Laws for the X-31A with Reduced Vertical Tail. In Proceedings of the AIAA Guidance and Control
Conference, Providence, Rhode Island, USA, August 2004.
AIAA-2004-5031.
[33] Brian L. Stevens and Frank L. Lewis. Aircraft Control and
Simulation. Wiley-Interscience Publication. John Wiley &
Sons, Inc., New York, 2000.
[34] Martin R. Waszak and Dave K. Schmidt. Flight Dynamics of
Aeroelastic Vehicles. AIAA Journal of Aircraft, 25(6):563
571, June 1988.

[20] Jean-Franois Magni, Samir Bennani, and Jan Terlouw
(Eds). Robust Flight Control  A Design Challenge. Lecture
Notes in Control and Information Sciences 224. Springer
Verlag, London, 1997.
[21] The Math Works Inc. MATLAB  External Interfaces Reference  Version 7, March 2005.
[22] The Math Works Inc. Simulink Reference, 2005.
[23] Susan McLean, Susan Macmillan, Stefan Maus, Vincent
Lesur, Alan Thomson, and David Dater. The US/UK World
Magnetic Model for 2005-2010. Technical Report NOAA
Technical Report NESDIS/NGDC-1, NOAA National Geophysical Data Center, British Geological Survey Geomagnetism Group, December 2004.

The Modelica Association

202

Modelica 2008, March 3rd  4th , 2008

Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica

Implementation of the Hertz Contact Model and Its Volumetric
Modification on Modelica
Ivan Kosenko Evgeniy Alexandrov
Russian State University of Tourism and Service, Department of Engineering Mechanics
Glavnaya str. 99, Cherkizovo-1, Moscow reg., 141221, Russia

Abstract
The Hertz model of an elastic bodies contact and its
volumetric modification are analyzed for the proper
implementation on Modelica. Computational algorithms applied aim to accelerate the simulation process
and make it more reliable.
The algorithm tracking the surfaces of the bodies
which are able to contact was improved using its differential version and showed an accuracy high enough.
Simulation of the Hertz model was accelerated due to
use of the differential technique to compute the complete elliptic integrals and due to the replacement of
the implicit transcendental equation by the differential
one.
To have a reliable model for the simulation of the contact especially in case of the contact spot ellipses of
an eccentricity high enough the volumetric modification of Hertz model is introduced. The model showed
a reliable behavior and an acceptable accuracy.
Finally an implementation of the ball bearing model as
an example of the contact models application is under
consideration. The particular bearings being analyzed
can have different number of balls and different types
of raceways. The bearing models created using the
library of classes developed earlier and have an outside
look exactly like a mechanical constraints and behave
in some degree similar to the revolute joints.
Keywords: Hertz contact model, volumetric approach,
ball bearing model

low the classical Hertz approach, and the normal force
computation method is a main topic of our analysis.
To handle with the surfaces at the contact we apply
an approach mentioned in [4] as variant 2: algebraic
constraint surfaces, which we frequently use in our
models. For definiteness and simplicity to simulate the
tangent contact force one uses a regularized model of
the Coulomb friction [6]. This is sufficient enough to
simulate the dynamics over time of the machine under
simulation lifecycle. May be some additional complications for the friction model, e. g. an account of the
lubrication of any type, will be needed.

2 Reduction in Vicinity of Contact
Keeping a frame of the formalism applied previously
to simulate a unilateral constraint [6] consider its particular case corresponding to mechanics of contact interaction for two elastic bodies, identified hereafter as
A and B. Their outer surfaces, see Figure 1, being at
contact supposed sufficiently regular.

1 Introduction
It is known [1] to compute a force of the elastic bodies interaction at a contact several different approaches
are applied: (a) the classical Hertz model [2], (b) the
model based on the polygonal approximation of the
contacting surfaces [3] applied to cases of the surfaces
Figure 1: Vicinity of the Contact Area
of a complex shape and implemented on Modelica [4],
(c) the volumetric model [1, 5]. In our model we fol- Applying the same notations as ones used in [6] we
The Modelica Association

203

Modelica 2008, March 3rd  4th , 2008

I. Kosenko, E. Alexandrov

start here by reproducing the system of eight scalar and their gradients connected by


algebraic equations
grad g (rP ) = T grad f TT (rP  rO ) ,
grad gA (rPA ) =   grad gB (rPB ) ,
where TA , TB are the orthogonal matrices defining currPA  rPB =   grad gB (rPB ) ,
(1) rent orientation of the bodies.
gA (rPA ) = 0,
Surely, in case of the DAEs use one has to provide a
gB (rPB ) = 0.
consistent initial values for all the additional state varidefining the coordinates xPA , yPA , zPA , xPB , yPB , ables introduced here for each object of the compliant
zPB of the outer surfaces opposing points PA , PB , contact being under construction in the sequel.
see Figure 1. Here the coordinate vectors rPA = Unlike our previous approach [6] now we suppose the
(xPA , yPA , zPA )T , rPB = (xPB , yPB , zPB )T are defined with bodies A and B dont create any obstacles for their relrespect to (w. r. t.) the absolute coordinate frame ative motion. If 3D-regions bounded by the bodies
O0 x0 y0 z0 of reference (AF) usually connected to the outer surfaces dont intersect then the object of a conmultibody system base body B0 . Note the functions straint, rather of a contact, generates a zero wrench in
gA (r0 ) = gA (r0 ,t), gB (r0 ) = gB (r0 ,t) are really a time the direction of each body. Simultaneously this object
dependent ones, and define the outer surfaces current has to generate the radius vectors rPA , rPB of opposing
spatial position of the bodies at a contact w. r. t. AF. with each other points PA , PB .
Based on (1) note the variable  indicates the contact
The values ,  are an auxiliary variables.
It turned out by the computational practice with Dy- of the bodies A and B. Indeed, for definiteness suppose
mola the most suitable approach to implement a sys- the outer surfaces in vicinities of the points PA , PB are
tem of algebraic equations like (1) is to replace it by such that vectors of gradients grad gA (r), grad gB (r)
the system of DAEs properly derived from (1). It can are directed outside the each body. Then we have the
be done by introducing an additional variables which following cases at hand: (a)  > 0 means the contact
the time derivatives and thus compose the differential absent; (b)   0: the contact takes place. If  < 0 then
the bodies supposed to penetrate each other, though resubsystem
ally begin to deform in a region of the contact. In the
(2) sequel we follow the simplest elastic contact model
rPA = uPA , rPB = uPB ,  = ,  = ,
originating from Hertz [2]. Computational analysis
completed by the algebraic one
will be performed for the case of contacting only, see
A , grad gA ] + TA Hess fA TAT (uPA  vPA ) 
[
Figure 2. For simplicity and definiteness the surfaces
 grad gB 
are showed convex in Figure 2 though it is not necesB , grad gB ] + TB Hess fB TB (uPB  vPB )) = 0,
 ([
sary at all in general for our implementation.
u

u


grad
g

PA
PB
B 

B , grad gB ] + TB Hess fBTBT (uPB  vPB ) = 0,
 [
(grad gA , uPA )  grad fA , TAT vPA  = 0,
(grad gB , uPB )  grad fB , TBT vPB = 0.
(3)
where the vectors vPA , vPB are a velocities of the bodies physical points currently located at the geometric
points PA , PA and are to be calculated according to the
Euler formula
 , rP  rO ] ( = A, B),
vP = vO + [

Figure 2: Local Coordinate System

where OA , OB are the bodies masscenters,  A ,  B are
the angular velocities of the bodies. Matrices Hess fA ,
Hess fB are the Hesse ones of the functions fA , fB
defining the bodies outer surfaces w. r. t. the bodies
central principal coordinate systems. The the functions fA , fB relate to the ones gA , gB according to the
equations


g (r0 ) = f TT (r0  rO ) ( = A, B),

To represent the Hertz contact model in its classical
form first of all we have to construct an auxiliary base
in vicinity of the contact. First base is composed by
three unit vectors  ,  ,  such that  = nA , where nA is
the unit vector along the gradient grad gA (r) collinear
to the z-axis in Figure 2. As it was for the derivation of
the opposing points the most appropriate move to com,  ,  } is to construct a relevant
pute the proper base {

The Modelica Association

204

Modelica 2008, March 3rd  4th , 2008

Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica

subsystem of DAEs. First of all start with differential Further bring the equations (4) to the form suitable to
equation for  . It has the form
analyse the contact problem in vicinity of the corresponding points
 = |grad gA |1 [(grad gA ) (nA , (grad gA )) nA ] ,
 P =  O + R   ( = A, B),
where the time derivative of the gradient reads
on the surface of the body . Here the vector   deA , grad gA ] + TA Hess fA TAT (uPA  vPA ) .
(grad gA )= [
fines the position of the point PA w. r. t. the body 
own coordinate system. Supposing the surfaces reguNow we can right down the chain of equations
lar enough we have the expansions
 = [, ] , 
 = [
, ] ,  = [, ] ,
 ) + (grad f (
 ) , r ) +
f (r ) = f (


defining successively the angular velocity  of the unit
1
 ) r , r ) + O |r |3 ,
(Hess f (
vector  (t) rotation, the differential equation for the
2

 
  
h (r) = h  P + gradh  P , r +
unit vector  , and the unit vector  completing the lo 



1
cal base under construction. Actually the vector  is
Hessh  P r, r + O |r|3 ,
2
, , } w. r. t.
an angular velocity of the base triple {
AF.
 . Since r = R r
P , r = r 
where r = r
Note once more we have to provide the consistent ini- then it is easy to verify that
tial data for the vectors  ,  which became now a vec 
 )
gradh  P  = R grad f (
tor valued state variables. And of course browsing the
(5)

 ) RT .
Hessh P = R Hess f (
equations represented above it is transparent enough
which Modelica code stands behind the algorithm outlined here.
,  ,  } built up above it is easy
Using the base {
,  ,  ] consistenough to compose the matrix T = [
ing of the columns composed themselves by the coordinates of the unit vectors. Actually T is the transfer matrix between coordinates of AF and the current
, , }. Let us first express the outer surlocal base {
faces equations in coordinates of the local system (LF)
having an origin at the point PA , see Figure 2.
Because the matrix T is orthogonal its inverse is derived by the transposition of T . Then to compute the
matrix of coordinate transformation from the LF to
one of the bodies we can represent it as follows
R = T T T ( = A, B).

Because at the body  outer surface point  P the function h is zero-valued then up to the terms of the third
order in the coordinate system P xyz the equation (4)
can be represented as follows

 

 a c
h
x
z+ x y
= 0,
(6)
c b
y
z

where the Hesse matrix elements are to be expressed
by the formulae
a =

1 2 h 
1 2 h
1 2 h
,
,
b
=
,
c
=


2 x2
2 y2
2 xy

where in turn one should use the results of (5). Note
the equation (6) has such a simple representation because at the point  P the choice of the base causes the
conditions

Introducing new temporary notation r = (x, y, z)T for
h  
h  
the coordinate vector of the current geometric point
(7)
 P = 0,
 P = 0.
x
y
w. r. t. local system PA xyz one can easily deduce the
dependence
Supposing the surfaces are nondegenerate at the points
P we have the condition
r =  + R r ( = A, B),
O

 

|gradh (r )| > 0,
where  O = (O , O , O )T is the coordinate vector
of the body  mass center w. r. t. LF.
and because of (7) it causes the condition
Let the body  outer surface is defined by the equation
h
(r ) 6= 0.
h (r) = 0 ( = A, B),
(4)
z
w. r. t. current position of LF. Then it is easy to see Therefore, the equation (6) can be resolved w. r. t. the
variable z in explicit form as
the function h can be computed by the formula
 T

h (r) = f R r   O
( = A, B).
z = a0 x2 + 2c0 xy + b0 y2 ,
(8)

The Modelica Association

205

Modelica 2008, March 3rd  4th , 2008

I. Kosenko, E. Alexandrov

where the new coefficients of the second order terms Using the substitution  7  ( = ) in elliptic integrals of (11) we can separate the last two equations
are computed in the form
of (11). Indeed, introducing new scaled unknown varia
b
c
ables 0 , 0 according to formulae 0 = /, 0 = /
a0 = 
, b0 = 
, c0 = 
.
h
h
h
we can deduce the two mentioned equations to the
z
z
z
closed system
The further reduction comes to a transformation to
I1 (0 , 0 ) = P, I1 (0 , 0 ) = Q,
(12)
canonical view of the quadratic form
q(x, y) = ax2 + 2cxy + by2 ,

(9)

if the scaling factor  satisfies the norming condition
FD 1

= 1.
 3/2

derived as a difference between the forms (8) such that

(13)

Here the elliptic integral I1 (, ) is defined by

a = a0B  a0A , b = b0B  b0A , c = c0B  c0A .



Z
The transformation is implemented simply as a rotad
p
I1 (, ) =
tion about the z-axis of the system PA xy to achieve
( + ) ( + )( + )
0
the coefficient c vanishes. Finally the function (9) becomes having the form
causing clearly verified equations

q(x, y) = Px2 + Qy2

(10)

with the additional condition 0 < P  Q.

3 The Hertz Model

I(0 , 0 )
I(0 , 0 )
0 0
,
I
(
,

)
=
2
,
1
0
0
(14)
0
0
where taking into account that    , which is equivalent to the condition P  Q satisfied above, we may
have the relations
I1 (0 , 0 ) = 2

According to the known technique [7] to compute the
total normal force at the contact we have to solve the
system
FD

FD


Z

FD


Z

0

0

Z
0

d

p

( + )( + )

d
p
( + ) ( + )( + )
d
p
( + ) ( + )( + )

I( ,  ) =
0

0

Z
0

d
2
p
=  K(k),
0
(0 + )(0 + )

where in turn K(k) is the complete elliptic integral of
the first kind with the modulus defined by the formula
r
0  0
k=
.
0
= P, (11)
= h,

= Q,

Here one can see the value k actually has a geometric
sense exactly of the contact spot ellipse eccentricity.
Using the work [8] as a pattern we introduce the value
c = k2 of the elliptic integral modulus square. Taking
into account that elliptic integrals are regular functions
of c = 1  0 /0 we obtain using the rule of the compound function differentiation


2
dK(c)
0
0
,
I1 ( ,  ) =
K(c)  2(1  c)
dc
03/2
4 dK(c)
I1 (0 , 0 ) =
.
03/2
dc


of three transcendental equations provided the coefficients P, Q from the representation (10) and depth
of mutual penetration, so-called mutual approach, h =
|rPB  rPA | are already have been computed. The system (11) has three unknown variables: , , F, where
the values ,  are the semi-major axes squared of the
contact spot ellipse, and F is the total normal elastic
force really distributed over the contact area. The paDividing then the first equation of (12) by the second
rameter


one and using the last derived expressions we reduce
3 1  2A 1  2B
D=
+
finally the whole problem to the one-dimensional tran4
EA
EB
scendental equation
summarizes elastic properties of the contacting bod

ies: A , B being Poissons ratios, and EA , EB being
1
dK(c) 1
P
K(c)
 (1  c) =
(15)
corresponding Youngs moduli.
2
dc
Q
The Modelica Association

206

Modelica 2008, March 3rd  4th , 2008

Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica

where while changing the value h the values P, Q dont
w. r. t. the unknown value c.
Once the solution of the equation (15) had been found change, we conclude the potential energy of elastic deformations is represented by the expression
we can obtain immediately the values


2
4 dK(c) 2/3
Uelast = e(P, Q)h5/2 .
0 = 0 (1  c).
0 =
5
Q dc
Using the first equation of (11) and normalizing de- On the other hand using the volumetric approach [5]
pendence (13) we then find the value of the scaling one can try to represent the same potential energy as
follows
 
factor
b
h
Uelast = f
V  S p ,
=
(16)
a
0
0
I( ,  )
thus arriving to the Hertz problem solution: the normal where V is the volume of the bodies undeformed material intersected, S is the area of the intersection proforce and the contact ellipse semi-major axes values
jection onto the xy-plane of the LF, p is the perimeter

p
 
0
0
of that projection. It turned out if  = 2,  = 7/4,
F =  , a =  , b =  .
D
 = 1/2 then the function
Nevertheless an implementation on Dymola requires a
V 2 p1/2
8
further reduction of the model in a manner we already
Velast = 0.357469
,
151/4 (A + B ) S7/4
mentioned above twice: use preferably the differential
equations (probably to overcome the potential probdiffers from Uelast by 0.5% of its value in wide range
lems for the analytical processor when differentiating
of the contact ellipse shapes: surely for b/a  [0.1, 1].
the transcendental expressions on the DAE system inHere
dex reduction stage when compiling and indirectly and
1  2
, ( = A, B).

=

more rarely when running the model). To this end we
E
have to remind the known ODEs connecting the comSince in the case of the Hertz model the contact spot is
plete elliptic integrals of the first K(c) and the second
the ellipse then the values V , S, p are to be computed
E(c) kind between one another [8]
by the expressions
dK E  (1  c)K dE E  K

2
=
,
=
.
h
4
h(Q/P)1/4 E(c1 )
h
dc
2c(1  c)
dc
2c
,
V =  , S=  , p=
2 PQ
2 PQ
(PQ)1/4
Furthermore instead of (15) then we should use its difwhere the elliptic integral modulus squared this time
ferential version
"  
#
has the expression c1 = 1  P/Q. Then taking into
 2
dK 2
d2K
dK
account that
3
 K 2 c = 2
C,
Uelast
dc
dc
dc
,
Felast = 
h
where C = P/Q, and
we get the Vilke formula for the approximate value of
the normal force at the contact
2
d K (1  c)(2  3c)K  (2  4c)E
p
=
.
dc2
4c2 (1  c)2
E(c1 ) 3/2
2
Felast = 0.357469
h .
3 (A + B ) P3/8 Q3/8
In this way the complete integrals become an additional state variables such that
K =

dK
dE
c, E =
c,
dc
dc

and simultaneously we have yet another way to compute elliptic integrals in dynamics, note: exclusively
fast and sufficiently accurate way.
Staying in frame of the traditional Hertz model and
taking into account that the expression for the normal
force has the form
Felast = e(P, Q)h3/2 ,
The Modelica Association

Numeric experimental verification showed an application of the above expression for the normal force
indeed causes the relative error near the value 0.5%
for the contacting bodies configuration coordinates in
compare with exact Hertz model over long time of
simulation. Anyway to estimate with the proper quality the fatigue processes in machines while the lifecycle simulation it is sufficient enough to have an acceptable approximation for the contact forces.
The Vilke formula is essentially simpler than computations in the Hertz model requiring the solution of the

207

Modelica 2008, March 3rd  4th , 2008

I. Kosenko, E. Alexandrov

transcendental equation. Volumetric derived algorithm
is more reliable than the Hertz one though sometimes
due to the differential techniques arranged for the elliptic integrals the Hertz algorithm works even faster
than one of Vilke.

4 Implementation

extends CompliantConstraintAddOn;
SI.Velocity[3] drA;
SI.Velocity[3] drB;
ConstraintDetectorRate dmu;
Real lambda;
LambdaRate dlambda;
GradientRate[3] dgradgA;
GradientRate[3] dgradgB;
Real Active(start = 1);
Hessian[3, 3] HessgA;
Hessian[3, 3] HessgB;
equation
der(Active) = 0;
der(rA) = Active*drA;
der(rB) = Active*drB;
der(lambda) = Active*dlambda;
der(mu) = Active*dmu;
dgradgA = cross(InPortA.omega, gradgA)
+ HessgA*(drA - vrA);
dgradgB = cross(InPortB.omega, gradgB)
+ HessgB*(drB - vrB);
dgradgA = lambda*dgradgB +
dlambda*gradgB;
drA - drB = mu*dgradgB + dmu*gradgB;
0 = gradgA*(drA - vrA);
0 = gradgB*(drB - vrB);
HessgA = InPortA.T*HessfA*
transpose(InPortA.T);
HessgB = InPortB.T*HessfB*
transpose(InPortB.T);
end SurfacesOfConstraintDifferential;

The procedures described above to compute the normal force of an elastic interaction were implemented
on Modelica in frame of general approach to construct the objects of mechanical constraint [9]. Strictly
speaking in case of the compliant connection the constraint itself is absent. Instead we have an elastic
compliance implementing the Hertz contact model.
Though the general architecture of the objects interaction conserves completely. Thus for future purpose
retain the term constraint.
When implementing a class of the compliant interaction it turned out to be useful to split its base classes
in two different lines of inheritance: (a) the first one
contains mainly the geometric properties, (b) the second line is responsible for the normal force calculation. Thus in the last derived class we use the multiple
inheritance allowed in Modelica. An example of the
classes hierarchy in the case under consideration see
in Figure 3.
The example is one of the simplest ones to test an implementation of the Hertz model: the contact of the where the variables correspond to ones in (2), (3) in an
ellipsoid and the plane. The left line of inheritance, evident way by use of their names.
see Figure 3, concerning mainly with the contact geo- In the line of the force properties inheritance
metric properties
NormalForce

NormalForceHertzDiff

Constraint

CompliantConstraint

CompliantConstraintAddOn

SurfacesOfConstraintDifferential

the class NormalForce plays a role of the base class
for any implementation of the normal force. In the
class NormalForceHertzDiff the normal force besides the elastic Hertzian term has the term of viscosity
of the form
has a common use and doesnt depend on the type of
Fvisc = d(h)h,
the contacting surfaces. The variables which do depend on such that gradients and the Hesse matrices are where h is the mutual approach. This latter term supevaluated in the class
posed to arise due to the plasticity properties of the
EllipsoidAndHorizontalPlaneDifferential . material the bodies made of. It is fair natural to consider the coefficient at h to depend upon h [10] since
The class SurfacesOfConstraintDifferential as the mutual approach increases from zero then the
is here the most essential derived one. It is responsible
contact spot area also increases from zero. Therefore
for the points PA and PB permanent tracking, implements the DAE system (2), (3), and has the following it is quite natural for the plastic resistance to increase
continuously from zero.
Modelica code
The class NormalForceHertzDiff Modelica code
is long enough thus let us highlight some of its main
partial model
features, namely the implementation of the auxiliary
SurfacesOfConstraintDifferential
The Modelica Association

208

Modelica 2008, March 3rd  4th , 2008

Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica

Figure 3: Example of Compliant Constraint Classes Hierarchy
,  ,  } tracking and equations to compute
local base {
the solution of the system of the transcendental equations
model NormalForceHertzDiff

initial equation
K = CompleteEllOfFirstKind(k2);
E = CompleteEllOfSecondKind(k2);
0.5*CompleteEllOfFirstKind(k2)/
dKdk2(k2) - (1 - k2) = C;
equation
dgamma = (dgradgA1 normA1*(normA1*dgradgA1))
/sqrt(gradgA1*gradgA1);
der(gamma) = dgamma;
OmegaA = cross(gamma, dgamma);
der(alpha) = cross(OmegaA, alpha);
beta = cross(gamma, alpha);

der(k2) = dk2;
dK = if k2 < Accuracy then dKdk2(k2)
else 0.5*(E - (1 - k2)*K)/k2
/(1 - k2);
dE = if k2 < Accuracy then dEdk2(k2)
else 0.5*(E - K)/k2;
der(K) = dK*dk2;
der(E) = dE*dk2;
C = A1/B1;
dC = der(C);
ddK = if k2 < Accuracy then
d2Kdk22(k2) else 0.25*((1 - k2)*
(2 - 3*k2)*K - (2 - 4*k2)*E)/k2^2

The Modelica Association

/(1 - k2)^2;
(3*dK^2 - K*ddK)*dk2 = 2*dK^2*dC;

end NormalForceHertzDiff;

where the variables K, E, k2, dK, dE, ddK, A1, B1,
C stand correspondingly for the values K(c), E(c),
c, dK/dc, dE/dc, d 2 K/dc2 , P, Q, C from previous section. The functions dKdk2(k2), dEdk2(k2),
d2Kdk22(k2) are used if the modulus is small enough,
i. e. regular expressions become inoperative. These
functions are computed via expansions of series with
the fast convergence for the small modulus. Section of
initial equations is needed to initialize a state variables
being computed using known expansions for the complete elliptic integrals. These expansions work only
once when starting the simulation.
A tangent force at the contact in our case is computed
in the class CompliantConstraintAddOn and for
the simplicity is implemented as a regularized model
of the Coulomb friction [6]. Obviously, one can create
here even far more complicated models for the tangent
force at the contact.

5 Example of the Ball Bearing
The ball bearing model is built up using the architectural principle mentioned above. On the Icon-level
of its representation it looks exactly like the model
209

Modelica 2008, March 3rd  4th , 2008

I. Kosenko, E. Alexandrov

Figure 4: Visual Model of the Ball Bearing

The Modelica Association

210

Modelica 2008, March 3rd  4th , 2008

Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica

of any constraint: it has two ports of the connector
type KinematicPort to import the twists of the rigid
bodies connected by the bearing, and two ports of the
WrenchPort type to export the wrenches in directions
of the bodies mentioned. Visual model of the ball bearing see in Figure 4
For definiteness the bearing was equipped by eight
balls. Each ball has two elastic contacts: one with
the inner ring, and one with the outer one. In both
cases when contacting the ball simultaneously rolls
over the surfaces of the toroidal tubes corresponding
to the raceways of the inner and outer rings.
Describe in brief the specifications of the contact between the ball and one of the toroidal raceways. The
ring always supposed to be denoted as a body A in the
contact object of the ball bearing model, while the ball
Figure 5: Animation of the Model
always denoted as B. All we need to complete the constraint specifications is to define the functions fA , fB .
simplified expression of the form
In our case we have


fA (x, y, z) = 4R2A x2 + y2 
Felast = eh3/2 ,
 2
2
2
2
2
2
x + y + z + RA  rA ,
2
fB (x, y, z) = x + y2 + z2  R2B ,
with the constant coefficient e for the normal elastic
force
at the contact [11]. But it is possible only if the
where rA is the toroidal pipe radius, RA is the radius of
the circle being an axis of that toroidal pipe, RB is the geometric properties (curvatures etc.) dont change
while simulating the model. Moreover, for different
ball radius.
Paying an attention to the ball bearing visual model, cases of contacting the coefficient e would have differFigure 4, note the central column represents eight ob- ent values. Then its value can be computed using the
jects B1, B2, . . . , B8 of elastic balls. Left and right numerical experiment, or even better using the natural
columns of objects composed by the contact objects physical experiment. If the motion under simulation is
between the balls and the outer ring (left column) and perturbed from its pure case with the constant e then
inner ring (right column), all implemented using the immediately its value begins change in time.
Hertz model described above. The objects representing in the model the inner and outer rings have the
names IR and OR correspondingly. At left and right extreme sides of the class the objects of rigid constraints
are located. These constraints connect the outer and
the inner rings objects with the objects of the bodies,
outer and inner shafts in our case, attached one with
another by the bearing. In the example under consideration the body connected with the outer ring rests
w. r. t. AF while the body connected to the inner ring
rotates uniformly about z-axis of AF both thus performing the prescribed motion, see the animation image in Figure 5.
The visual model of the example testbench see in Figure 6. To verify the quality of the Hertz model implementation we compared the vectors  and nA as functions of time. The computational experiments showed
that their coordinates coincide with a very high accuracy. At last yet another remark: to make the simulation even more faster, at least twice, one can apply the
The Modelica Association

Figure 6: Visual Model of the Testbench

6 Conclusions
Summarizing the results presented above we can split
them to the several main remarks influencing the potential directions of future work:
(1) According to an experience accumulated while developing the models simulating the multibody dynamics one can resume the usefulness of the approach
when the differential formulations proper applied are
preferable in several aspects. It is a real way to han-

211

Modelica 2008, March 3rd  4th , 2008

I. Kosenko, E. Alexandrov

dle the transcendental equations in frame of dynamical problems using the ODEs derived from the transcendental ones in combination with the linear solver
w. r. t. derivatives of the new state variables.
(2) In particular it turned out an introduction of the
component of the ODEs system for the elastic bodies
outer surfaces tracking for the contact problem conserves an accuracy and simultaneously improves the
reliability of the models. To implement the tracking
in case of the complex shape surfaces we have to rearrange only one derived class at the end of the inheritance chain to define an equations for the gradients and
Hessians of the surfaces A and B w. r. t. LFs of the bodies. The surfaces supposed smooth enough and without sharp edges but can be described by if-constructs
properly arranged.
(3) Implementation of the complete elliptic integrals
using ODEs subsystem also was useful: the models
became more reliable and faster. For instance, the
Hertz algorithm improved as described above turned
out to be even faster than the V. G. Vilke one in case
of the almost circular contact area.
(4) The algorithm of V. G. Vilke is more reliable and
suitable for wide range of the contact area eccentricities simultaneously providing an accuracy of 0.5%
with respect to the Hertz-point algorithm.
Regarding the directions of the future work it is evident enough an interest to apply the developed models to different types of appliances with the rotary motions, or to the problems essentially including the effects of friction when contacting.

7 Acknowledgement
The paper was prepared with partial support of
Russian Foundation for Basic Research, projects
05-01-00308-a, 05-08-65470, 05-01-00454, SS6667.2006.1.

[3] Hippmann G., An Algorithm for Compliant Contact Between Complexly Shaped Bodies // Multibody System Dynamics, 2004, Vol. 12, pp. 345
362.
[4] Otter M., Elmqvist H., Lopez J. D., Collision
Handling for the Modelica MultiBody Library //
Proceedings of the 4th International Modelica
Conference, Hamburg University of Technology,
HamburgHarburg, Germany, March 78, 2005,
pp. 4553.
[5] Vilke V. G., On Non-Hertzian Contact of Wheel
and Rail // Research on Problems of Stability and
Stabilization of Motion. Reports of the Computing Center of the Russian Ac. of Sc., (in press).
[6] Kossenko I. I., Implementation of Unilateral
Multibody Dynamics on Modelica // Proceedings
of the 4th International Modelica Conference,
Hamburg University of Technology, Hamburg
Harburg, Germany, March 78, 2005, pp. 1323.
[7] Landau L. D., Lifshitz E. M., Theory of Elasticity. 3rd Edition. Landau and Lifshitz Course of
Theoretical Physics. Volume 7.  Reed Educational and Professional Publishing Ltd.: Oxford
 Boston  Johannesburg  Melbourne  New
Delhi  Singapore, 1999.
[8] Whittaker E. T., Watson G. N., A Course of Modern Analysis,  Cambridge University Press:
Cambridge  New York  Melbourne  Madrid
 Cape Town, 2002.
[9] Kosenko I. I., Loginova M. S., Obraztsov Ya. P.,
Stavrovskaya M. S., Multibody Systems Dynamics: Modelica Implementation and Bond Graph
Representation // Proceedings of the 5th International Modelica Conference, arsenal research,
Vienna, Austria, September 45, 2006, pp. 213
223.

References

[10] Wensing J. A., On the Dynamics of Ball Bearings. PhD Thesis.  University of Twente: En[1] Gonthier Y., Lange C., McPhee J., On Imschede, The Netherlands, 1998.
plementing a Bristle Friction Model in a Contact Model Based on Volumetric Properties // [11] Lee S., Park T., Park J., Yoon J., Jeon Y., Jung
Multibody Dynamics 2007, ECCOMAS TheS., Fatigue Life Prediction of Guideway Vehimatic Conference, Proceedings, Politecnico di
cle Components // Multibody Dynamics 2007,
Milano, Milano, Italy, June 2528, 2007.
ECCOMAS Thematic Conference, Proceedings,
Politecnico di Milano, Milano, Italy, June 2528,
[2] Hertz H. ber die Berhrung fester elastischer
2007.
Krper // J. reine und angewandte Mathematik.
B. 92. 1882. S. 156171.

The Modelica Association

212

Modelica 2008, March 3rd  4th , 2008

Session 2d
Electric Systems & Applications

The Modelica Association

213

Modelica 2008, March 3-4, 2008

The Modelica Association

214

Modelica 2008, March 3rd  4th , 2008

Modelling of Electric Drives using freeFOClib

Modelica2008

Modelling of Electric Drives using freeFOClib
Dietmar Winkler Clemens Ghmann
Technische Universitt Berlin
Chair of Electronic Measurement and Diagnostic Technology
{Dietmar.Winkler|Clemens.Guehmann}@TU-Berlin.de

Abstract
The freeFOClib (short for free Field-Oriented Control library) provides a framework for simulations of
electric drives with different application purposes. The
library can be used to simply build a field-oriented
control system for existing machine models from the
Modelica Standard Library, investigate the impact of
electric faults (battery faults, inverter faults, machine
faults) on a electric drive system, and run simulations
to estimate the fuel consumption of hybrid electric vehicles. The library structure and some of its main components are presented. Simulation results of an electric fault are given as an application example of this
library. The freeFOClib will be publicly available in
Spring 2008.
Keywords: Modelica, free library, electric machines,
field-oriented control, fault simulation, hybrid electric
vehicle

1

Introduction

Will the faults cause serious damage or just minor inconveniences?
All these question could be answered by using simulations to investigate the normal and faulty behaviour.
For the creation of such simulation models we need
both, appropriate machine models and the suitable machine controllers. The overall simulation model will
contain signals from different physical domains (i.e.,
electrical and mechanical).
The modelling language Modelica1 was especially developed to simplify the simulation in different physical
domains in one simulation model. The multi-domain
capability allows us to build simulation models of hybrid electric vehicles easier than than with other simulation tools.
So far our Chair of Electronic Measurement and Diagnostic Technology has investigated different aspects of
Modelica with real-time applications and hybrid electric vehicles ([1, 2]).

2

Purpose of the library

The Modelica language is specified in the so called
Modelica Specifications [3] and comes with the free
Modelica Standard Library (MSL) [4] which contains
a huge collection of models for different physical domains (e.g., electrical, mechanical, thermodynamical).
For the simulation of machines the Modelica
Standard Library contains a sub-library called
Modelica.Electrical.Machines [5]. This library
contains basic three-phase models of asynchronous
and synchronous machines as well as DC machine
models. To control these machines the modeller still
has to provide his own controllers since currently there
is no free Modelica library available to provide complete electric drive models.

In automotive applications the number of electric motors used is increasing rapidly. Most of them are doing
their work without us  the car owners/users  actively
noticing it. When a power window is still a quite obvious application for an electric motor, the active controlled throttle valve might not be. And with more and
more tasks going to be performed by-wire (e.g., braking, steering) the number of electric motors used is due
to increase even more. But not only small electric motors are present. With the electric motor being used
for active propulsion in hybrid electric vehicles (HEV)
also the power rating of motors used grows bigger.
But how do all these little and large motors work toR
1 Modelica
gether? How should the manufacturer develop the conis a free modelling language developed by the
troller? What happens if there is a fault in the system? Modelica Association  www.modelica.org
The Modelica Association

215

Modelica 2008, March 3rd  4th , 2008

D. Winkler, C. Guhmann

So in order to simulate more complex electric drive ap- Controllers In here controllers for the control of
plications a new free Field-Oriented Control Library
electric drives together with the necessary flux
models are placed.
(freeFOClib[6]) is being developed.

3

Library structure

Functions Custom functions which are used by the
freeFOClib.

Icons Special icons for the models.
The freeFOClib should allow the user to model and
simulate all aspects of the an electric drive. A stan- Interfaces The Interfaces sub-package includes
dard electric drive normally consist of components like
different interface models. Mostly they are made
power sources, power electronics, controllers, electric
of a partial type so that one can simply extend
machines, and interfaces. The communication of the
from the interface model which fits the applicablocks can be done either via the classic approach by
tion most.
use of input and output connectors or by the use of bus
signals. The bus structure orients itself on the new bus Inverters These models are used to transform the
control signals into electrical signals which can
structure of the Vehicle Interfaces Library [7]. This
then be applied to the machine models.
should allow easier simulation of power-train simulations of hybrid electric vehicles, for example.
Machines This library contains models of synchronous and asynchronous machines of different
types.

Figure 1: Top-level packages of the freeFOClib

In addition to the different controller types for the
field-oriented control as well as the battery models
(important for automotive applications) also new machine models for fault-simulations have been developed. These are using the m-phase presentation where
the faults can be introduced directly into the components without the need of a d  q  0-transformation
(see also [8]).

Figure 1 shows a graphical representation of the up- 4 Library contents
permost hierarchy level of the library.
After a first quick overview of the library we like to
The library consists of:
explain some the librarys content in more detail.
UsersGuide Every Modelica library should contain
this. It gives the user information on how to use 4.1 Batteries
the library as well as some information about the
In the current version of the freeFOClib there are two
release history and participating developers.
different types of batteries present. One very simple
Examples To get the user going some example sim- model consisting of an internal resistor and a conulation models are included. There are sub- trolled signal voltage only. As this is normally not
packages of examples for the different parts (e.g., sufficient for more advanced simulations (e.g., simucomplete drive systems, batteries, inverters, ma- lations of driving cycles of hybrid electric vehicles)
an advanced battery model was added. This model
chines)
R
is based on models from the Advisor 2002 Simulink
Batteries This is a sub-package that contains differ- model. It contains three main sub models: SOC,
VocRint, and BatteryECU (see Figure 2).
ent battery models.
The advanced battery model includes an active energy
Components Models which are library-wide used and management. The state of charge is calculated by SOC.
therefore do not fit exclusively into any of the The simple internal resistor of the ideal resistor is replaced by a variable resistor. The value of resistance is
other sub-packages are placed here.
The Modelica Association

216

Modelica 2008, March 3rd  4th , 2008

Modelling of Electric Drives using freeFOClib

of interest. This gives the ideal voltage and current
signals and does not need much computing power.
When effects of the power electronic are of interest
than there are two different types of voltage controlled
inverters available:
Space Phasor modulation Depending on the control
signal an appropriate voltage space phasor is calculated. The position of the space phasor can then
be transformed into firing signals for an m-phase
inverter bridge (where m could be any number of
phases  3).

Figure 2: Advanced battery model

Sinus-Delta modulation Here a sin-wave signal is
compared with a high-frequency triangular wave.
A logic circuitry then generates the firing signals
for the m-phase inverter bridge.

Both non-ideal inverter types have the drawback that
they need a lot of computational power. This has
controlled by look-up tables and depends on the charg- caused by the need to restart the numerical solver
ing/discharging current, the state of charge, and the whenever an event (e.g., switch from one inverter leg
temperature. Currently the characteristic behaviour of to the other) is triggered.
a Nickel-Metal-Hydrid battery type is implemented.
Also included is a switch which acts as a battery pro- 4.4 Machines
tection system and is controlled by the BatteryECU
Fortunately, if a modeller tries to build a
and the SOC models.
standard electric drive with standard 3-phase
machines he can just pick them out of the
4.2 Controllers
Modelica.Electrical.Machines library. These
This package provides models for the regulation of standard machines can be used in combination with
the control variables flux, speed, torque, and current. our controllers and inverters.
There is a series of different control strategies. Which Unfortunately, there is a restriction on the number of
of these strategies is the best applicable depends on phases (i.e. m = 3). The freeFOClib provides asynthe application. In field-oriented control the used flux- chronous and synchronous induction machine modmodel represents a crucial part of the controller. De- els for m-phases and different architectures. The subpending on the machine and the operational range of package for synchronous machines contains m-phase
models with electrical excited and permanent magnet
speed the correct flux model has to be chosen.
The freeFOClib offers a small variety of flux-models rotors. The sub-package for asynchronous machines
(see, for example, [9, 10] for more information on con- contains m-phase models with squirrel-cage and slipring rotor. In each of the models the stator inductance
trol of electric drives):
can be changed during simulation time to investigate
 Current models (I   , I  )
fault impacts.
In contrast to the machine models from the Mod Current-voltage models (UI, UI  )
elica Standard Library the m-phase models of the
freeFOClib are not modelled in the so called d  q 
 Voltage models
0-frame but in the m-phase system. This might seem
odd since the d  q  0-frame was actually introduced
4.3 Inverters
to reduce the computational demand of machine simuThis sub-package contains different inverter models. lations. However when developing the freeFOClib
For a start there is an IdealInverter which can be one of the requirements was to be able to simulate
used if effects of the power electronic circuitry are not faults and therefore unsymmetrical systems. As soon
The Modelica Association

217

Modelica 2008, March 3rd  4th , 2008

D. Winkler, C. Guhmann

as an electrical m-phase system becomes unsymmetri- 5.2 Machine faults
cal all the computational benefit of the d  q  0 transIn the electric machine models of our library the folformation is lost. More about the underlying theory of
lowing fault scenarios can be simulated:
the machine models can be found here [8].

5

 open-circuit of a stator phase (e.g., a connecting
cable is broken)

Library applications

 short-circuit phase to ground (e.g., insulation failure because of mechanical damage)

The development of the freeFOClib was started with
specific purposes in mind:

 short-circuit of one or more phase windings (e.g.,
insulation failure because of thermal stress within
the stator or rotor)

 field-oriented control of induction machines
 fault-simulations to investigate electrical and mechanical impacts of machine faults

Each of these faults will have some influence of the
 state of charge estimations for batteries in HEV torque produced by the electric drive.
applications
 investigate adaptive controller algorithms for 5.2.1 Short-circuit phase to ground
electric machines
In Figure 3 you can see the simulation results of a synIn automotive applications, for example, often the chronous machine with an electric excited rotor. At
term drivability of a car is used. With drivability the the time of T = 2 sec one stator phase is connected to
car manufacturers often relate to the overall operating ground. The figure shows all three phase currents and
qualities of the power train. This could include things the mechanical torque over time.
like idle mode characteristics, throttle response, and
Torque
acceleration capability. In a hybrid electrical vehicle
200
for example we got an electric motor acting directly or
100
indirectly on the drive train.
T[Nm]
The freeFOClib contains an example model which
0
allows for simulation of three different types of faults,
-100
i.e., faults of the battery, faults in the inverter, and
1.6
1.8
2
2.2
2.4
2.6
Time[s]
faults in the machine (see Figure 4).
Currents
200

5.1

Inverter and battery faults

100

To simulate faults in the battery and/or in the inverter,
the example model in Figure 4 contains a fuse component fuse_DC. This model disconnects the DC current
when a surge current is detected that violates the maximum rating of the battery. The surge-proof fuse is not
triggered right away but after a first order delay time
which can be parametrised. Whenever the fuse is triggered the inverter gets a signal which will switch of
the firing signals for the inverter bridge in turn.
Another kind of battery fault would be a short circuit
of the supply side of the inverter. This is accomplished
by a simple switch that is triggered by a boolean signal
and which connects both support voltage connectors of
the inverter.
And at last a fault of firing signals can be applied directly via a signal inverter_fault. The combination of the different switches gives the abbility to build
even more fault scenarios.
The Modelica Association

i[A] 0

-100

-200

1.6

1.8

2

Time[s]

2.2

2.4

2.6

Figure 3: Fault scenario: short-circuit of one stator
phase to ground
At the beginning the electric machine runs at a constant speed and with a constant load torque applied
to the shaft end. When the short-circuit occurs the
controller tries to keep the torque at a constant level
but can only do so for a certain amount of time until
the fuse finally gets triggered because of over-current.
With such kind of simulation model one could for
example try to find the optimum kind of fuse which

218

Modelica 2008, March 3rd  4th , 2008

Modelling of Electric Drives using freeFOClib

Figure 4: Example model of an electric drive system.

is sluggish enough to withstand short power surges
whilst still protecting the drives power electronic.

80

Torque

70
60
50

5.2.2 Short-circuit within a phase winding

40
T[Nm]
30

In Figure 5 a fault of the insulation between the phase
20
10
windings of a stator coil is modelled. Such a fault can
0
2
2.5
3
3.5
4
4.5
5
be caused by, for example, over-temperature or overTime[s]
Currents
load which in turn leads to an overheated stator wind100
ing. This behaviour is modelled by reducing the induc50
tance value abruptly by 20 percent. In Figure 5 you can
see the three phase currents and the mechanical torque i[A] 0
over time just before and after the connection of one
-50
phase was opened at the time of T = 2 sec.
-100
2
2.5
3
3.5
4
4.5
5
Time[s]
At first sight the electrical impact seems not to be very
drastic. However since the field-oriented control now
calculates the wrong control values the torque starts Figure 5: Fault scenario: short-circuit of phase windto oscillate quite considerable. If this electric drive is ings
applied in a hybrid electric vehicle, for example, this
could lead to reduction of drive comfort. But not only
this, depending on the mechanical system such oscilla- 6 Future work
tion could become unstable and cause major damage.
The main task for the future is the extension of the
freeFOClib. Here is a short collection of ideas we
5.3 Field-oriented control loop
are currently having:
Having a variety of different flux-models available al further clean up of the structure so that the usage
lows the modeller to investigate different kind of conis more intuitive
trol strategies for electric drives. So for example by
varying some of the controllers parameters (e.g., the
machine rotor resistance) one can test how robust the
drive control behaves at a certain rotor speed when using different flux-models for the estimation of the flux
position.
The Modelica Association

219

 add more controller types which allow also the
investigation of different control architecture not
just pure parameter variations
 enhance battery models with temperature models
Modelica 2008, March 3rd  4th , 2008

D. Winkler, C. Guhmann

(at the moment only look-up tables are used to
calculate the resistance)
 verification of machine models
 investigate simplifications to make the machine
and inverter models real-time capable
A pure estimate of the simulated values might give
some clues on the general behaviour during faults.
However to actually use the simulation to gain useful information (e.g., for programming a controller for
the power electronics) we need more than just estimates. So the simulation model has to be verified by
doing real measurements using a real electric motor.
It is planned to set up test-bench system consisting of
a asynchronous induction machine of from currently
available hybrid electric vehicle and an electric load
machine.
The first public official (pre)release is due in spring of
2008. There will be a public development repository
available. For any news on the freeFOClib see www.
freefoclib.org. On that site a mailing-list is also
available to keep you up to date automatically.

7

Acknowledgements

We hereby like to acknowledge that a lot of work on
the library was done by students as part of their student
research projects:
 Stefan Rinderer, Development of a Modelica Library for the Field-Oriented Control of Electric
Machines, student research project, supervisor:
Dietmar Winkler, Chair of Electronic Measurement and Diagnostic Technology, TU Berlin, 16th
April 2007
 Eduard Bakhach and Florian Dring, Modelling
of a Field-Oriented Synchronous Inductionn Machine with Modelica, student research project,
supervisor: Dietmar Winkler, Chair of Electronic
Measurement and Diagnostic Technology, TU
Berlin, 31st August 2007

References

pp. 275281, Modelica Association, arsenal research, 4-5 Sep 2006.
[2] D. Winkler and C. Ghmann, Hardware-in-theLoop simulation of a hybrid electric vehicle using Modelica/Dymola, in The 22nd International Battery, Hybrid and Fuel Cell Electric Vehicle Symposium & Exposition (E. . Secretariat,
ed.), (Yokohama, Japan), pp. 10541063, EVS,
Japan Automobile Research Institute, 23-28 October 2006.
R
[3] Modelica Association, Modelica
 A Unified
Object-Oriented Language for Physical Systems Modeling  Language Specification, version
3.0 ed., 5th September 2007.
R
[4] Modelica Association, Modelica
- Free library
from the Modelica Association, version 3.0 ed.,
2008.

[5] C. Kral and A. Haumer, Modelica libraries for
dc machines, three phase and polyphase machines, in Proceedings of the 4th International
Modelica Conference (G. Schmitz, ed.), pp. 549
558, Modelica Association, March 7-8 2005.
[6] D. Winkler, E. Bakhach, F. Dring, and
S. Rinderer, freeFOClib - A free FieldOriented Control library for Modelica. unreleased, see www.freefoclib.org for any news.
Due in, Spring 2008.
[7] M. Dempsey, M. Gfert, P. Harman, C. Kral,
M. Otter, and P. Treffinger, Coordinated Automotive Libraries for Vehicle System Modelling,
in Proceedings of the 5th International Modelica
Conference (D. C. Kral and A. Haumer, eds.),
vol. 1, (Vienna), pp. 3341, Modelica Association, arsenal research, September 2006.
[8] D. Winkler and C. Ghmann, Modelling of
Electrical Faults Using Modelica, in Proceedings of The 48th Scandinavian Conference on
Simulation and Modeling (SIMS 2007), Scandinavian Simulation Society, 30th - 31st October
2007.
[9] W. Leonhard, Control of Electrical Drives.
Springer, 3rd ed., 2001.

[1] D. Winkler and C. Ghmann, Synchronising a
Modelica Real-Time Simulation Model with a [10] D. Novotny and T. Lipo, Vector Control and DyHighly Dynamic Engine Test-Bench System, in
namics of AC Drives. Clarendon Press Oxford,
5th International Modelica Conference (D. C.
1996.
Kral and A. Haumer, eds.), vol. 1, (Vienna),
The Modelica Association

220

Modelica 2008, March 3rd  4th , 2008

Electromagnetic Actuator Modelling with the Extended Modelica Magnetic Library

Electromagnetic Actuator Modelling with the Extended
Modelica Magnetic Library
Thomas Bdrich
Dresden University of Technology, Institute of Electromechanical and Electronic Design
01062 Dresden, Germany
Thomas.Boedrich@mailbox.tu-dresden.de

Abstract
Recently, an improved and extended version of a
Modelica library for lumped network modelling of
electromagnetic devices has been released [1]. This
library is intended for both rough design of the magnetic circuit of those devices as well as for their system simulation. Improvements compared to a first
realisation of this library [2] will be discussed and
utilization of the extended library for modelling of
electromagnetic actuators will be illustrated. To support the work with this library, focus will be on
newly-implemented features and on peculiarities of
lumped network modelling of electromagnetic actuators rather than on an introductory explanation of the
underlying concept of magnetic flux tubes.
Keywords: lumped magnetic network; electromagnetic/electrodynamic actuator; system design

1

Introduction

The well-established concept of magnetic flux tubes
enables the modelling of magnetic fields with
lumped networks. In the decades prior to the broad
availability of software packages based on finite
element techniques, this was the only efficient means
for model-based design of the magnetic circuit of
electromagnetic devices such as transformers, motors
and electromagnetic or electrodynamic actuators.
The method of magnetic flux tubes, its utilization for
the design of electromagnetic devices as well as
derivation of the permeance of many flux tube
shapes are explained in-depth for example in [3], [4]
and [5] and in condensed form in the documentation
of [1].
Even though finite element techniques allow for
more accurate calculation of magnetic fields, lumped
magnetic network models are still an efficient means
for initial rough design of electromagnetic devices
and for simulation of their dynamic behaviour during
system design. This is due to the relatively little efThe Modelica Association

fort needed for creation of rough magnetic network
models and to the low computational effort for dynamic simulation compared to finite element techniques.
A first realisation of a Modelica library for lumped
network modelling of electromagnetic devices was
presented in [2]. This library was improved and extended and is now available [1]. Some of the important improvements of the extended library compared
to the prior version are:
 a more general approach for calculation of magnetic reluctance forces (section 2),
 redesigned and extended components for representation of typical flux tube shapes (section 2),
 additional soft magnetic and permanent magnetic
materials (section 3),
 more accurate modelling of magnetic leakage
fields for dynamic simulation by splitting of the
magnetomotive force imposed by a coil into separate sources (section 4) and
 additional examples of different modelling depths.

2

Reluctance Force Calculation

Generally, the thrust F developed by a translatory
electro-magneto-mechanical actuator (similar for the
rotational case with torque and angular position) is
equal to the change of magnetic co-energy Wm* with
armature position x according to

F=



 di = Wm*

x ( i )
x

(1)

( flux linkage, i actuator current) [4]. In lumped
magnetic network models, the above equation simplifies to

F=

1 nlinear 2 dGm i
 Vmag i dx
2 i =1

(2)

where nlinear is the number of flux tube elements with
constant relative permeability that change their per-

221

Modelica 2008, March 3rd  4th , 2008

T. Bodrich

meance Gm i with armature position (index i), Vmag i
the magnetic voltage across each respective flux tube
and dGm i/dx the derivative of the respective permeances with respect to armature position. Transition from the general formula based on magnetic
co-energy (Eq. (1)) to Eq. (2) is outlined in [4] for
the reciprocal of the permeance, i.e. for the magnetic
reluctance. Compared to the reluctance force calculation with Maxwells formula used in [2], the
newly-implemented approach according to Eq. (2)
simplifies force calculation for air gaps different
from a simple cylindrical or prismatic shape with
axial magnetic flux (see below).
The usability of Eq. (2) is not restricted solely to network models with constant relative permeabilities r
of the flux tubes. However, it is required that flux
tubes with a dependency of the permeability on the
flux density B such as ferromagnetic components
with non-linear characteristics r(B) do not change
their shape with armature motion (e.g. portion of a
solenoid plunger where the magnetic flux passes
through in axial direction). This limitation is not a
strong one, since the permeance of non-linear, high
permeable ferromagnetic flux tube elements and its
change with armature position compared to that of
air gap flux tubes can be neglected in most cases.
Because of this constraint, the dimensions of possibly non-linear flux tube elements in sub-package
FluxTube.FixedShape are fixed, whereas the
dimension l in direction of motion of the linear flux
tube elements in sub-package FluxTube.Force
can vary during simulation. Elements with fixed
shape are intended e.g. for modeling of transformer
cores or ferromagnetic sections of actuators. Force
elements are to be used for modelling of working air
gaps or for moving permanent magnets of actuators.
In order to fulfill Eq. (2) in a magnetic network
model of a translatory actuator, the reluctance force
Fm of each flux tube with force generation is calculated in the respective element accordingly:

1 2 dGm
.
(3)
Vmag
2
dx
Vmag denotes the magnetic voltage across the flux
tube and dGm /dx is the derivative of flux tubes permeance Gm with respect to armature position x.
Summation of all particular reluctance forces to the
actuators net force F according to Eq. (2) is induced
by connecting the translatory flange connectors of all
flux tube elements with force generation in an actuator model (see example in Figure 4b).
In a particular actuator model, the derivative dGm /dx
of the models flux tubes with force generation and
hence the sign of the generated reluctance force de-

pends on the design of the actuators magnetic circuit
and on the definition of the armature coordinate x.
To cover all possible conditions in a uniform way,
the above derivative is calculated as follows for all
flux tubes with force generation of sub-package
FluxTube.Force:

dGm

dGm dl
.
(4)
dx
dl dx
For the flux tubes defined in this package with their
rather simple shapes, the derivative dGm /dl is given
analytically (Table 1). l is the flux tube dimension
that changes with armature motion. dl /dx is an integer parameter that must be set to +1 or -1 according
to the magnetic circuit and the definition of the armature coordinate x of an actuator. For more complex shapes and variations of dimensions with armature motion, the derivative dGm /dl must be provided
analytically during model development, preferably by extending the partial model FluxTube.Force.PartialForce.
Table 1: Selected flux tube elements with reluctance
force generation (subset of FluxTube.Force),
permeance Gm and analytic derivative dGm /dl
(Hollow) cylinder with axial magnetic flux

Gm =

0 r A
l

dGm
  A
=  0 2r
dl
l

(

with A =  ro2  ri 2

)

Hollow cylinder with radial magnetic flux

Gm =

0 r 2  l
ln (ro ri )

dGm  0  r 2 
=
dl
ln(ro ri )

Fm =

The Modelica Association

=

Simple leakage flux tube around cylindrical or prismatic poles

222

Gm =

2 0 t



dGm
=
dl

  rleak 
ln 1 +

2 l 


 0 t rleak
 rleak 
2 

l 1 +

2 l 


Modelica 2008, March 3rd  4th , 2008

Electromagnetic Actuator Modelling with the Extended Modelica Magnetic Library

3
3.1

Modelling of Magnetic Materials
Soft Magnetic Materials

The characteristics of the relative magnetic permeability versus flux density r(B) of various steels,
electric sheets (Figure 1) and high permeable materials are included in Material.SoftMagnetic.
These characteristics are uniformly approximated
with a function adapted from [6]:

r = 1 +

 i  1 + ca B N
1 + cb BN + B

n
N

with BN =

B
B  =
r

7000
6000

M330-50A (machined, packeted)
M350-50A (sheet sample)
M530-50A (sheet sample)
M700-100A (sheet sample)
M940-50A (sheet sample)

5000
4000
3000
2000
1000
0
0.0 0.2 0.4 0.6 0.8 1.0 1.2 1.4 1.6 1.8 2.0

Flux density B in T

Figure 1: Approximated magnetization characteristics (solid lines) and original data points of included
electric sheet materials (all valid for 50 Hz)
Magnetization characteristics that are simulated with
Eq. (5) are shown for an electric sheet as an example
in the familiar form of flux density vs. field strength
B(H) in Figure 2.

max

max

dition of new soft magnetic materials requires determination of the function parameters with a nonlinear curve fit outside of the library. For the included materials, attention was paid to accurate fits
of r for data points at high flux densities
(B > 0.8 T). This is because of the large influence of
saturated ferromagnetic materials on the behaviour
The Modelica Association

8000

. (5)

This approach assures proper behaviour throughout
the complete range of flux density. Overshoot and
extrapolation errors especially at high flux densities
as possible with spline interpolation or with the
Modelica Standard Librarys table interpolation with
continuous derivative can not occur with properly
chosen parameters. Two of the five parameters of
Eq. (5) have a physical meaning, namely the initial
relative permeability i at B = 0 and the magnetic
flux density at maximum permeability B  =  . Adr

of a device. It must be noted that a measured characteristics r(B) strongly depends on the shape, machining state and heat treatment of a sample, and on
the measurement conditions. Hence, different characteristics are possible for similar materials as Figure
1 indicates.

Relative permeability r

The leakage flux tube shown in Table 1 provides a
simple but efficient means to account for leakage
around prismatic or cylindrical poles. In the latter
case, depth t is equal to the circumference of a circle
given by the average radius of the flux tube. Due to
the constant radius rleak of the leakage field, the
model is rather simple. In reality, rleak is approximately constant for air gap lengths l greater than this
radius, but decreases with air gap lengths less than
rleak. This decrease for small air gaps is neglected in
the model since the influence of the leakage flux
tube compared to that of the enclosed main air gap
(connected in parallel, see example in Figure 4b)
decreases for decreasing air gap length l.
The sub-package FluxTube.Leakage contains
flux tube shapes typical for leakage flux around
prismatic or cylindrical poles that do not change their
shape with armature motion. Hence, the permeance
of these flux tubes does not depend on armature position and these elements do not contribute to the
thrust of a reluctance actuator.

Figure 2: Simulated magnetic flux density vs. magnetic field strength B(H) of electric sheet M350-50A
3.2

Hard Magnetic Materials

For common permanent magnetic materials, typical
values for remanence Br ref and coercivity HcB ref at a
reference temperature Tref and the temperature coefficient Br of remanence are provided in sub-package
Material.HardMagnetic (Figure 3). Records
for additional materials can be defined as needed.
Linear demagnetization curves are modelled. The
characteristic, temperature-dependent "knee" of
many permanent magnetic materials is not considered, since proper design of permanent magnetic cir-

223

Modelica 2008, March 3rd  4th , 2008

T. Bodrich

cuits should avoid operation of permanent magnets
"below" that point due to partial demagnetization. As
a result, the temperature coefficient of coercivity is
not considered. Only the temperature coefficient of
remanence Br is accounted for, since this describes
the dependency of the demagnetization curve on the
temperature sufficiently for the region "above the
knee-point". Remanence Br and coercivity HcB that
are effective at a given operating temperature T are
calculated according to
Br = Br ref (1 +  Br (T  Tref )) ,
(6a)
H cB = H cB ref (1 +  Br (T  Tref ))

(6b)

in the model Material.HardMagnetic.PermanentMagnetBehaviour. Thus, the demagnetization curves shown in Figure 3 are shifted depending on the operating temperature T and the temperature coefficient of remanence Br. Usage of the
above-mentioned component and modelling of a permanent magnet are demonstrated in the library in
Examples.ElectrodynamicActutor.MagneticCircuitModel (Figure 9).
Exemplary characteristics for 20C

accuracy can be gained from an AdvancedSolenoidModel in which the coil-imposed magnetomotive force (mmf) is split into two separate mmf
sources and the radial leakage flux between armature
and yoke is accounted for with leakage permeance
GmLeakRad (Figure 4). This leakage affects the static
force-stroke characteristic and the inductance of an
actuator and hence its dynamic behaviour especially
at large air gaps, as discussed below.

a)

Remanence Br in T
1.4

NdFeB
Sm2Co17
SmCo5
PlasticNdFeB
PlasticSmCo
HardFerrite
PlasticHardFerrite

1.2
1.0
0.8
0.6
0.4
0.2
0.0

1000 900 800 700 600 500 400 300 200 100

0

Coercivity HcB in kA/m

b)
Figure 4: Magnetic network model of an exemplary
solenoid actuator: a) Permeances superimposed on
FEA field plot (half-section) for illustration; b) Complete actuator model including electrical subsystem

Figure 3: Modelled demagnetization characteristics
of included common permanent magnetic materials

4

Modelling of Electromagnetic
Actuators

As an example of a reluctance actuator, a simple axisymmetric lifting magnet with planar end planes of
armature and pole is modelled in sub-package Examples.ElectromagneticActuator of the
library. Two lumped magnetic network models of
different modelling depth are included. In a SimpleSolenoidModel, radial leakage that is typical
for tubular reluctance actuators is neglected. Higher
The Modelica Association

Simulation of lumped magnetic network models with
multiple mmf sources is easily possible for the stationary case where the coupling between the electrical and the magnetic domain according to Faradays
law
d
u = w
(7)
dt
(u voltage induced in a coil at change of magnetic
flux d/dt, w number of turns) needs not to be considered. For dynamic simulation, however, split mmf

224

Modelica 2008, March 3rd  4th , 2008

Electromagnetic Actuator Modelling with the Extended Modelica Magnetic Library

Force F [N]
Static inductance Lstat [H]

(Vmag magnetic voltage across mmf source, i current).
Eq. (7) and Eq. (8) are implemented in the electromagnetic converters coil1 and coil2 of Figure 4b.
The parasitic capacitances cpar1 and cpar2 are required
to ensure definite voltages across both halves of the
coil. The values of the auxiliary resistors Rpar1 and
Rpar2 have been chosen so that simulation is numerically stable and fast.
In order to evaluate the accuracy in static and dynamic behaviour to be achieved with the above-mentioned lumped network models, a dynamic model of
the example actuator based on more accurate finite
element analysis (FEA) has been created as a reference (Figure 5). In this model, one of several possibilities to describe an electromagnetic actuators dynamic behaviour with look-up tables obtained from
stationary FEA is implemented. Here, the actuator
force F(x, I) and the flux linkage (x, I) were calculated for different fixed armature positions x and stationary currents I with FEA. The derived tabular
function (x, I) was inverted to I(x, ) as required in
the model. The voltage across the current source
iCoil is according to Kirchhoffs voltage law for the
actuators electrical subsystem, which is given by
d ( x, i)
u = iRcoil +
(9)
dt
(u voltage across coil terminals p and n, i current,
Rcoil coil resistance).

radial leakage between armature and yoke and the
more accurate FEA-based model of Figure 5 is compared. All curves were derived from a quasi-static
forced movement of the models armature at a given,
constant voltage. The negative sign of the actuator
force is due to the definition of the armature coordinate x which is equal to the length of the working air
gap.
The static force-stroke characteristics F(x)|i = const of
all three models are similar. However, differences
between both network models can be observed for
the magnetic flux through the armature and for the
static inductance Lstat =  / I, especially at large air
gaps where the leakage permeance GmLeakRad is large
compared to the net permeance GmAirWork + GmLeakWork
of the air gap region. The differences in static inductance between both network models will result in
different dynamic behaviour of both models, as
Figure 7 indicates.

Armature flux [Wb]

sources are challenging due to the strong interactions
between the electrical and magnetic domain given by
Faradays law (Eq. (7)) and Amperes law
Vmag = i w
(8)

(saturation)

different behaviour
of network models
at large air gap

Armature position x [m]

Figure 6: Comparison of stationary behaviour of a
simple lumped magnetic network model without radial leakage, the network model of Figure 4b with
radial leakage and the FEA-based model of Figure 5

Figure 5: Dynamic model of sample actuator based
on look-up tables obtained from stationary FEA
In Figure 6, the accuracy in stationary behaviour to
be achieved between the network model of Figure 4,
the above-mentioned simple network model without
The Modelica Association

Differences in model behaviour during a simulated
pull-in stroke of the armature are shown in Figure 7.
At time t = 0, a voltage step is applied to both lumped
network models and to the FEA-based model of the

225

Modelica 2008, March 3rd  4th , 2008

T. Bodrich

actuator. The characteristic current drop during
pull-in is due to the motion-induced emf and to the
increase of the inductance with decreasing air gap.
One can see that the simulated current rise of the
network model with radial leakage is closer to that of
the FEA-based reference model than the current rise
of the simple network model without radial leakage.
As a result, the magnetic force of latter model shows
the fastest rise and simulated armature motion is
faster than that of the FEA-based model.

density of the permanent magnetic field were calculated with FEA as a reference (Figure 8b, half-section). Figure 9 shows a Modelica model of that actuator intended for dimensioning of the actuators magnetic circuit and winding and for subsequent dynamic simulation at the system level. This example
is included as MagneticCircuitModel in package Examples.ElectrodynamicActuator of
the library.
RmFeBot RmFeOut RmPM leakage

Current i [A]

S
N

(non-exponential rise
due to non-linear material)
differences in current rise due to radial leakage
xmin

xmax

RmFeCore

x

RmAir

ferromagnetic permanent concentric coil
stator
magnet ring
= armature

Armature position x [m]

a)

b)

Figure 8: Translatory electrodynamic actuator:
a) Structure; b) FEA field plot of permanent magnetic field and partitioning into flux tubes
(bouncing at stopper)

time t [s]

Figure 7: Comparison of the models dynamic behaviour with a simulated pull-in stroke (voltage step applied at time t = 0)

5

Modelling of Electrodynamic
Actuators

Similar to the well-known behavioural model of a
rotational DC-Machine, the electro-mechanical conversion process of translatory electrodynamic actuators (either moving coil or moving magnet type) can
be described with a motor constant cm:
FL = cm i ,
(10a)
u i = cm v .

(10b)

FL denotes the electrodynamic or Lorentz force, i the
current, ui the induced back-emf and v the velocity of
the armature. During design of such actuators, the
motor constant as well as the motor inductance can
be determined by means of a lumped magnetic network model of an actuators magnetic circuit.
As an example, Figure 8a shows the principal structure of an axisymmetric translatory electrodynamic
actuator with moving coil. The flux lines and the flux
The Modelica Association

Figure 9: Dynamic model of the electrodynamic
actuator of Figure 8 with lumped magnetic network
for determination of motor constant and inductance
Although the formula for estimation of the total
magnetic reluctance Rm tot perceived by the coil is
rather simple in this model, comparison with FEA
showed that it is well-suited for initial rough design
and system simulation of the actuator. The relative
difference of the inductance

226

Lcoil = w2 Rm tot

(11)

Modelica 2008, March 3rd  4th , 2008

Electromagnetic Actuator Modelling with the Extended Modelica Magnetic Library

(w number of turns) compared to more accurate FEA
is -12% for the armature in mid-position. For useful
operating currents, the relative differences of the air
gap flux density and the resulting Lorentz force to
the values obtained with FEA are within -5% to -8%.
This accuracy is sufficient for both initial actuator
design and system simulation.

tube elements can be extended so that hysteresis is
considered.
It is planned to include the developed library into the
Modelica Standard Library after an evaluation period.

References
6

Summary and Outlook

New features and improvements of a Modelica library for lumped network modelling of electromagnetic devices [1] were presented. Two examples, an
electromagnetic and an electrodynamic translatory
actuator showed that magnetic network models can
be used efficiently for the rough design of such devices. These examples are included in the respective
sub-packages of the library and can thus be examined in depth.
Despite the simplicity of the presented models, their
accuracy is sufficient for preliminary design, as comparisons with more accurate FEA revealed. The dimensions, cross-sections and winding parameters
found with magnetic network models can be input
data to a subsequent detailed design with FEA or
similar techniques, if necessary.
A suitable approach for lumped network modelling
of leakage fields for dynamic simulation was discussed in detail. Insertion of appropriate leakage permeances into a magnetic network model requires
splitting of a devices coil into separate mmf sources.
This is challenging due to the multiple couplings
between the electrical and the magnetic domain in
such a model.
For some electromagnetic devices, lumped network
modelling is not possible or reasonable due to distinct leakage fields, complex pole shapes or - with
certain actuators - flux tubes and network structures
that vary considerably with armature motion. Examples of such devices are inductors without a closed
core or proportional solenoids. In this case, dynamic
models for system simulation can be created with
look-up tables obtained from stationary FEA or similar techniques. One of several possible structures of
such a model is shown in section 4.
At present, network modelling of translatory actuators is supported by the library. If needed, the provided model components can be adapted to network
modelling of rotational devices. Hysteresis of ferromagnetic materials is currently neglected, since the
intention of the library is to support the rough design
of electromagnetic devices where a limited accuracy
is often sufficient. If necessary, the provided flux
The Modelica Association

227

[1] Bdrich, T.: Modelica_Magnetic library.
http://www.modelica.org/libraries/ (Oct 11,
2007)
[2] Bdrich, T.; Roschke, T.: A Magnetic Library
for Modelica. Proc. of 4th International Modelica Conference, Hamburg, March 7-8, 2005,
pp. 559-565
[3] Roters, H.: Electromagnetic Devices. New
York: John Wiley & Sons 1941
[4] Kallenbach, E.; Eick, R.; Quendt, P.; Strhla,
T.; Feindt, K.; Kallenbach, M.: Elektromagnete: Grundlagen, Berechnung, Entwurf und
Anwendung. 2nd ed. Wiesbaden: B.G. Teubner 2003
[5] Hendershot, J.R. Jr.; Miller, T.J.E.: Design of
Brushless Permanent-Magnet Motors. Magna
Physics Publishing and Oxford University
Press 1994
[6] Roschke, T.: Entwurf geregelter elektromagnetischer Antriebe fr Luftschtze. Fortschr.Ber. VDI Reihe 21 Nr. 293. Dsseldorf: VDI
Verlag 2000

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

228

Modelica 2008, March 3rd  4th , 2008

Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors

Quasi-Stationary Modeling and Simulation of Electrical Circuits
using Complex Phasors
Anton Haumer

Christian Kral Johannes V. Gragger Hansjrg Kapeller
arsenal research
Giefinggasse 2, 1210 Vienna, Austria
anton.haumer@arsenal.ac.at

Abstract
This paper presents how complex phasors are used
for quasi-stationary analysis of electrical circuits, i.e.
with sinusoidal excitation neglecting dynamic transients. The theoretical background of complex
phasors is elaborated and a Modelica implementation
 the AC Library  is presented. Additional examples demonstrate the possibilities of the application
of complex phasors.
Keywords: electrical circuit, sinusoidal excitation,
quasi-stationary analysis, complex phasors

1

quencies, however. Each frequency with respect
to a sub-circuit is known due to the respective excitation. Fast dynamic transients are not considered. In a quasi-stationary analysis the unknown
voltages and currents, with respect to their phase
shift and amplitude, have to be determined. Regarding the consideration of exactly one frequency for each sub-circuit it has to be assumed
that the only linear circuits are investigated.
This paper will demonstrate how complex phasors
simplify the quasi-stationary analysis, and how complex phasors could be modeled using Modelica. Considering some limitations in the current Modelica
version will lead to suggestions for improvement.

Introduction

In the simulation of physical systems described by a
system of algebraic and ordinary differential equations we distinguish different types of simulation
analysis:
 The transient analysis is the most general analysis, showing both the dynamic transients as well
as steady-state solutions (if steady-state is
reached).
 A stationary analysis (sometimes also called DC
analysis) eliminates the derivatives with respect
to time, determining steady-state solutions.
 The so-called small signal AC analysis linearizes
a non-linear model in a certain point of operation
(which is found by a stationary analysis), only
applying excitations with small amplitudes.
Mainly in the field of electrical engineering  due to
the nature of electrical power plants that provide
nearly perfectly sinusoidal voltages with fixed frequency and amplitude  one more type of analysis is
of great importance:
 Quasi-stationary analysis applies sinusoidal excitations with known frequency, amplitude and
phase shift. In a circuit with isolated sub-circuits,
each sub circuit may be operated at different fre-

The Modelica Association

2
2.1

Complex Phasors
Representation of Sinusoidal Voltages and
Currents

Any sinusoidal oscillation can be expressed by computing the real part of a complex time-dependent
phasor according to Fig. 1:

229

(

a (t ) = A cos(t + ) = 2A Re e jt e j

(

A = A  e j  a (t ) = 2 Re A  e jt

)

)

(1)
(2)

Fig. 1 The real part of a rotating phasor equals a
sinusoidal oscillation; depicted phasor with  = 0;
left: complex phasor 2 Ae jt ;
right: time domain signal a (t )

Modelica 2008, March 3rd  4th , 2008

A. Haumer, C. Kral, J. V. Gragger, H. Kapeller

The magnitude A of the complex phasor A is the
root mean square (RMS) value of the cosine wave.
The phase shift  is the phase shift of the cosine
with respect to its maximum at t = 0 . Time dependence is considered by the phasor e jt and 2 is the
ratio between the amplitude and the RMS value of
the sinus waveform.
This background of complex phasors can also be
applied to sinusoidal voltages and currents using
complex voltage and current phasors:

(
)
2 Re(I  e )

v(t ) = V cos(t +  v ) = 2 Re V  e jt
i(t ) = I cos(t +  I ) =

jt

(3)
(4)

(5)

and the complex current phasor
I = I  e jI

(6)

are sufficient to describe quasi-stationary voltages
and currents.
The derivative of a complex phasor A with respect
to time leads to:

da (t )
= 2 Re A  je jt
(7)
dt
The time derivative of a sinusoidal waveform is thus
considered in the complex domain by multiplying
the original phasor with j . This relationship also
implies the result of the integration with respect to
the time domain. Since the constant of integration is
zero for quasi-stationary analysis, the complex representation of a time domain integration is determined
by the division of the original phasor by j .

(

2.2

)

Modeling a Linear Resistor

A linear resistor can be described by the algebraic
equation:
v = R i
(8)
Using complex phasors of voltage and current, we
can replace the algebraic equation by a complex algebraic equation:
V = R I

(9)

Modeling a Linear Conductor

A linear conductor can be described by the algebraic
equation:
i=Gv
(10)
Using complex phasors of voltage and current, we
can replace the algebraic equation by a complex algebraic equation:
I=GV
2.4

Assuming sinusoidal excitation of an electric circuit,
all voltages and currents are of sinusoidal waveform
with the same angular frequency  = 2f . Therefore
the complex voltage phasor
V = V  e j v

2.3

(11)

Modeling a Linear Inductor

A linear inductor can be described by the differential
equation:
di
(12)
dt
Exploiting the sinusoidal waveform of the current
(4), we can replace the differential equation by a
complex algebraic equation:
v=L

V = jL  I = X L  I

(13)

We find a complex version of the equation describing a resistor, using the complex reactance
X L = jL .
2.5

Modeling a Linear Capacitor

A linear capacitor can be described by the differential equation:
dv
(14)
dt
Exploiting the sinusoidal waveform of the voltage
(3), we can replace the differential equation by a
complex algebraic equation:
i=C

I = j C  V = Y C  V

(15)

We find a complex version of the equation describing a conductor, using the complex admittance
Y C = j C .
2.6

Kirchhoffs Laws

For complex voltages and currents, respectively,
Kirchhoffs Laws can be applied equivalently:

 Ii = 0

(16)

The sum of all complex current phasors flowing to a
node is zero.

 Vi = 0

(17)

The sum of all complex voltage phasors in a closed
loop is zero; this also implies that directly connected

The Modelica Association

230

Modelica 2008, March 3rd  4th , 2008

Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors

nodes have the same complex potential. Both laws
are inherently considered in Modelica connections.
2.7

Power

Multiplying a time dependent voltage (3) and the
corresponding current (4), we obtain the instantaneous electrical power:
p(t ) = v(t )  i(t )
(18)
Substituting (3) and (4) in the electric power equation we obtain:
p(t ) =
2V cos(t + V )  2I cos(t + I ) =

V  I  [cos(V  I ) + cos(2t + V + I )]

(19)

The instantaneous power oscillates with double the
frequency of voltage and current, respectively. The
average value of instantaneous power is dependent
on the phase shift between voltage and current; this
term is the active power:
P = V  I  cos( V   I ) = S  cos( V   I ) (20)
Apparent power S is defined as the product of the
RMS values of the voltage and the current:
S=VI
(21)
Reactive power is defined as quadratic complement:
Q = S  P = S  sin ( V   I )
2

2

(22)

Using complex phasors, we obtain:
S = V  I = P + jQ

(23)

In this equation, S is the complex apparent power;
the amplitude of this complex quantity is the apparent power (21).

3
3.1

Design of an AC Modelica Library
Implementation of Complex Arithmetics

Unfortunately complex numbers are not an intrinsic
data type in the Modelica language. As a workaround, a record Complex containing both the real
and the imaginary part of the complex number can
be defined:
record Complex
Real re "Real part";
Real im "Imaginary part";
end Complex;

In some cases, the polar representation of a complex
phasor, consisting of length and phase angle, is advantageous, however:
A = A Re + j  A Im = A  e j
The Modelica Association

(24)

record Polar
Real len "Length of the phasor";
Modelica.SIunits.Angle phi "Phase angle";
end Polar;

Of course we have to provide functions for complex
arithmetic + - * /, like
function '+' "Complex add"
input Complex c1;
input Complex c2;
output Complex c3 "= c1 + c2";
algorithm
c3 := Complex(c1.re + c2.re,
c1.im + c2.im);
end '+';

as well as complex functions like
 abs
length of the phasor
 arg
phase angle
 conj conjugate complex
 sqrt square root
 exp
natural exponentiation
 log
natural logarithm
 sin
sine
 cos
cosine
which can be implemented according to a mathematical textbook.
It is not very elegant to use these functions:
v = Complex.'*'(Complex(0, w*L), i);

Therefore an intrinsic implementation (or at least
operator overloading) would allow reading, type and
understanding code easier.
Additionally, we need conversion functions between
rectangular and polar representation:
function fromPolar
input Polar polar;
output Complex result;
algorithm
result.re :=polar.len*cos(polar.phi);
result.im :=polar.len*sin(polar.phi);
end fromPolar;
function toPolar
input Complex c;
output Polar polar;
algorithm
polar.len := Complex.'abs'(c);
polar.phi := Complex.arg(c);
end toPolar;

The tricky part of the conversion from rectangular to
polar representation is obtaining an angle that may
be smoothly differentiated to obtain the angular velocity of the corresponding phasor. With the presented implementation the wrapping of the phase
angle at 2 cannot be avoided. Instead, a continuous
growth of the phase angle for non-zero frequency is
desired.
A rather difficult exception of a smooth angle is the
following example: Imagine a phasor with constant

231

Modelica 2008, March 3rd  4th , 2008

A. Haumer, C. Kral, J. V. Gragger, H. Kapeller

angle, but length varying with time. The length
shrinks within a certain time to zero, growing again
in the opposite direction afterwards. This would lead
to a discontinuity by  when the phasors crosses the
origin.
Additionally, we have to define complex phasors
with physical units, like:

3.3

record ComplexVoltage = Complex (
redeclare Modelica.SIunits.Voltage
redeclare Modelica.SIunits.Voltage
record ComplexCurrent = Complex (
redeclare Modelica.SIunits.Current
redeclare Modelica.SIunits.Current

not only contains complex potential and complex
current, but also the record providing the local frequency respectively phase angle of the reference
frame as explained in 3.2.
Additionally, basic components as ground, resistor,
conductor, capacitor and inductor are defined. Furthermore, we need sensors and voltage sources as
well as current sources. Fig. 2 gives an overview of
the implemented components.

re,
im);
re,
im);

to take advantage of a tools type checking capabilities. Furthermore we have to define the polar representations, too:
record PolarVoltage = Polar (
redeclare Modelica.SIunits.Voltage len);
record PolarCurrent = Polar (
redeclare Modelica.SIunits.Current len);

3.2

Single Phase Components

The connector definition
connector Pin
Types.ComplexVoltage v;
flow Types.ComplexCurrent i;
Types.Reference ref;
end Pin;

Propagation of the Common Frequency

Since different sub-circuits of an electrical circuit
could have different frequencies  e.g. stator and
rotor of an asynchronous induction motor it would
be advantageous to provide the local frequency of a
component via the connector. Introducing an additional variable (reference angle, frequency or angular
velocity) in the connector leads to over-determined
connection equations. Fortunately, Modelica [4] provides methods to deal with this problem. This connector variable has to be defined as a type or record
with an additional function definition:
record Reference
Modelica.SIunits.Angle phi;
function equalityConstraint
input Reference ref1;
input Reference ref2;
output Real residue[0];
algorithm
residue := ...;
end equalityConstraint;
end Reference;

Additionally, the following functions are used to allow a tool to break algebraic loops:


Connect

defines a breakable branch


Connections.branch

defines a non-breakable branch


Connections.root

defines a root node in a virtual connection graph


Connections.potentialRoot

defines a potential root node in a virtual connection graph

The Modelica Association

232

Fig. 2 Structure of the AC library

Modelica 2008, March 3rd  4th , 2008

Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors

As an example, the implementation of the inductor
as well as the partial models that inductor extends
from are shown:



FromPolar takes a polar representation of a
complex phasor on the input and generates a
complex phasor as the output.

partial model TwoNode
Types.ComplexVoltage v =
Complex.'-'(p.v, n.v);
Types.ComplexCurrent i = p.i;
Modelica.SIunits.AngularVelocity w =
der(p.ref.phi);
AC.SinglePhase.Interfaces.PositivePin p;
AC.SinglePhase.Interfaces.NegativePin n;
equation
Connections.branch(p.ref, n.ref);
p.ref.phi = n.ref.phi;
end TwoNode;



FromPolar calculates the complex sum of an
array of complex input phasors.

4

defines the complex voltage drop along the
component as well as the angular velocity by differentiating the reference phase angle.
TwoNode

partial model OnePort
extends TwoNode;
equation
Complex.'+'(p.i, n.i) = Complex.'0'();
end OnePort;
OnePort additionally defines that the sum of currents
flowing into the component is zero.
model Inductor
extends Interfaces.OnePort;
parameter
Modelica.SIunits.Inductance L=1;
equation
v = Complex.'*'(Complex(0, w*L), i);
end Inductor;

Simulation Examples

For calculating quasi-stationary characteristic curves
of an electrical circuit varying a parameter the usage
of the AC library is advantageous. This will be demonstrated on four examples:
 Current of a series resonance circuit, varying the
supply frequency
 Voltage of a parallel resonance circuit, varying
the supply frequency
 Torque and current of an asynchronous induction machine, varying slip
 Terminal voltage of a synchronous induction
machine, varying load impedance (resistive and
inductive).
4.1

Series Resonance Circuit

As a first example, we model a series resonance circuit (Fig. 3).

Using these partial models Inductor is a simple implementation of (13).
3.4

Auxiliary Blocks

Additionally to the basic components, blocks with
complex inputs / outputs are needed. Therefore a
complex signal is defined, as well as a polar signal:
connector ComplexSignal = AC.Types.Complex;
connector PolarSignal = AC.Types.Polar;

These connectors are used to define ComplexInput,
ComplexOutput, PolarInput and PolarOutput. Instances of these output signal connectors are needed
for sensors, as well as input signal connectors for
variable sources.
Additionally some useful blocks are defined:


ToComplex generates a complex phasor from real
inputs, either real and imaginary part or amplitude and phase angle.



generates real outputs  real and
imaginary part as well as amplitude and phase
angle  either from a complex input or a polar input.



takes a complex input and generates a
polar representation of the phasor as the output.

FromComplex

ToPolar

The Modelica Association

Fig. 3 Model of a series resonance circuit

We apply sinusoidal voltage with constant amplitude
and phase to a series connection of a resistor, an inductor and a capacitor. Frequency varies according
to a ramp.
Analytically the resonant frequency of this simple
experiment can be determined:

res =

1
LC

(25)

1
1
H and C =
F we derive a reso2
2
nance frequency at f = 1 Hz. From the amplitude
(Fig. 4) as well as the phase shift (Fig. 5) of the current, the resonance frequency is evident.
With L =

233

Modelica 2008, March 3rd  4th , 2008

A. Haumer, C. Kral, J. V. Gragger, H. Kapeller

1
1
H and C =
F we derive a reso2
2
nance frequency at f = 1 Hz. From the amplitude
(Fig. 7) as well as the phase shift (Fig. 8) of the voltage, the resonance frequency is evident.

With L =

Fig. 4 Amplitude of current versus excitation frequency

Fig. 7 Amplitude of voltage versus excitation frequency

Fig. 5 Phase shift of current versus excitation frequency

4.2

Parallel Resonance Circuit

Furthermore, we investigate a parallel resonance circuit (Fig. 6).

Fig. 8 Phase shift of voltage versus excitation frequency

4.3

Asynchronous Induction Machine

Quasi-stationary operation of a three-phase asynchronous induction machine with squirrel cage
(AIMC) may be described by an equivalent circuit as
depicted in Fig. 9. This equivalent circuit represents
one phase of a symmetrical three phase asynchronous induction machine, however.
Fig. 6 Model of a parallel resonance circuit

We inject a sinusoidal current with constant amplitude and phase to a parallel connection of a resistor,
an inductor and a capacitor. Frequency varies according to a ramp. The resonant frequency of the
parallel resonant circuit is:
res =

The Modelica Association

1
LC

(26)

234

Fig. 9 Single phase equivalent circuit of an AIMC

Modelica 2008, March 3rd  4th , 2008

Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors

In this equivalent circuit Rs is the stator resistance,
Ls is the stator leakage inductance, and Lm is the
main field inductance. In the rotor circuit Lr' is the
rotor leakage inductance and Rr' is the rotor resistance. Both these rotor components refer to an
equivalent stator winding and are thus indicated by '.
An implementation of this equivalent circuit in Modelica is shown in Fig. 10.
For an induction machine slip

(27)
s =1
s
is the relative deviation of the mechanical angular
velocity  from the synchronous angular velocity:
s =

2f
p

Fig. 11 Stator current versus (1-slip)

(28)

Fig. 10 Model of an AIMC

In the presented example slip is modeled as a ramp
from slip 100% (i.e. stand-still) to slip 0% (i.e. noload). Dividing the rotor resistance by the slip is
equivalent to multiplying the rotor conductance by
slip. The slip dependent rotor conductance is thus
modeled by a variable conductance gr_s. Using the
conductance avoids division of zero slip at no-load:
R'
R ' r ,actual = r
(29)
s
The motor parameters used for this example are the
same as those of the dynamic model
Electrical.Machines.BasicMachines.
AsynchronousInductionMachines.
AIM_SquirrelCage.

Fig. 12 Airgap power versus (1-slip)

4.4

Synchronous Induction Machine

A synchronous induction machine feeding an isolated system is presented in this example. Two cases
are investigated: resistive load (Fig. 13) and inductive load (Fig. 14).
In both cases, constant excitation is assumed. Synchronous induced voltage is modeled by a voltage
source with constant complex voltage phasor. ld
represents the synchronous reactance and rs the resistance of one phase. Variable load is prescribed by
a ramp with logarithmic scale.

This leads to the quasi-stationary motor characteristics depicted in Fig. 11 and Fig. 12. The horizontal
axis of these plots shows the relative (per unit) speed
which is equal to (1slip).
Fig. 12 shows only 1/3 of the total air gap power of
the machine since only one phase is modeled. The
total airgap torque can thus be determined by:

T=

3  Pairgap
s

The Modelica Association

(30)

235

Fig. 13 Synchronous induction machine with R-load

Modelica 2008, March 3rd  4th , 2008

A. Haumer, C. Kral, J. V. Gragger, H. Kapeller

Fig. 14 Synchronous induction machine with L-load

Fig. 15 shows the characteristic voltage versus current from nearly no-load (high resistance and inductance, respectively) to nearly short circuit (low resistance and inductance, respectively).
The machine parameters used for this example are
the same as those of the dynamic model

chronous and synchronous induction machines for
quasi-stationary analysis. These machine models are
planned to be based on space phasors as described
in [6]; the transformation of space phasors with respect to different reference frames has to be implemented.
For applications focused on the energy consumption
of an electric drive over a longer period of time, the
fast electrical transients can be neglected. Using
complex quasi-stationary models would lead to faster
simulations, however.

References

Electrical.Machines.BasicMachines.
SynchronousInductionMachines.
SM_ElectricalExcited.

[1]
[2]
[3]
[4]

[5]

[6]

[7]
Fig. 15 Voltage versus current for
resistive load and inductive load

5

M. L. Boas, Mathematical Methods in the
Physical Sciences. J. Wiley & Sons 1966
T. D. Burton, Introduction to Dynamic Systems Analysis. McGraw Hill 1994
R. C. Dorf, The Electrical Engineering Handbook. VDE 1993
Modelica
Specification,
version
3.0.
http://www.modelica.org/documents/
ModelicaSpec30.pdf
P. Fritzson, Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1.
Piscataway, NJ: IEEE Press, 2004.
C. Kral, A. Haumer, Modelica libraries for dc
machines, three phase and polyphase machines. 4th International Modelica Conference
2005, Hamburg, Germany
O. Enge, C. Clau, P. Schneider,
P. Schwarz, M. Vetter, S. Schwunk, Quasistationary AC Analysis Using Phasor Description With Modelica. 5th International
Modelica Conference 2006, Vienna, Austria

Conclusions and Outlook

The design of a Modelica library for quasi-stationary
analysis of electrical single-phase circuits has been
presented. The application of complex algebraic
equations instead of dynamic differential equations
leads to high performance simulations.
With respect to the current Modelica version 3.0, the
implementation of complex numbers is possible but
not really satisfying. The authors would suggest the
introduction of complex numbers as an intrinsic data
type. This data type and complex arithmetics would
improve the Modelica language, however.
Based on the presented draft of an AC library, the
next steps will be extending the components for
multi-phase circuits as well as modeling of asynThe Modelica Association

236

Modelica 2008, March 3rd  4th , 2008

Session 3a
Language, Tools and Algorithms

The Modelica Association

237

Modelica 2008, March 3-4, 2008

The Modelica Association

238

Modelica 2008, March 3rd  4th , 2008

HyAuLib: Modelling Hybrid Automata in Modelica

HyAuLib: modelling Hybrid Automata in Modelica
Tiziano Pulecchi Francesco Casella
Politecnico di Milano, Dipartimento di Elettronica e Informazione
Piazza Leonardo da Vinci 32, 20133 Milano, Italy

Abstract

linear systems such as for instance diodes, switches,
valves, mechanical backlashes and dead strokes, can
A library of components for modelling hybrid au- be conveniently described via abstracted hybrid modtomata in a natural fashion has been implemented in els.
Modelica. This library exploits and extends the free The analysis and design of hybrid systems is in genModelica library StateGraph to the modelling and sim- eral more demanding than that of purely discrete or
ulation of deterministic hybrid systems described by purely continuous systems, because of the necessity to
the hybrid automaton formalism. In this contribution accurately deal with the interplay between the discrete
the librarys main features are described and its flexi- and continuous dynamics. The same consideration
bility highlighted by developing models for two classic holds true for their simulation, that presents specific
hybrid systems literature examples.
challenges requiring special care. Specifically, it is
Keywords: hybrid automata; simulation
of paramount importance to be able to determine with

1 Introduction
Hybrid systems (see [7]) are dynamical systems involving the interaction of both continuous state and
discrete state dynamics. Recall that a state variable
is called discrete if it can take a finite (or countable)
number of values and continuous if it takes values in
the Euclidean space Rn for some n  1. By their nature, discrete states can change value only through a
discrete jump; on the other hand, continuous states can
change values either through a jump, or by flowing in
time according to a given differential equations set.
Physical systems are by their own nature inherently
continuous. Nevertheless, because of the couplings
with very high frequency dynamics, or in presence of
mechanisms too complicated to be dealt with in simulation by a sound physical description, many physical systems can be conveniently represented under the
hybrid systems paradigm. This provides a convenient
framework for modelling systems in a wide range of
engineering applications, including for instance electrical circuitry, where continuous dynamic is affected
by switches opening and closing; chemical processes
control, where the continuous evolution of chemical
reactions is controlled by valves and pumps; or digital
control, where digital computers interact with a continuous time physical system. Of course, highly nonThe Modelica Association

great accuracy the time instant when discrete jumps
take place, and consistently deal with simultaneous
events occurrences, which represents one of the main
sources of modelling inconsistencies.
Nowadays, general purpose simulation packages such
as Matlab and Simulink can deal adequately with most
complications. Specialized packages have also been
developed that allow accurate simulation of hybrid
systems (see e.g. [2], [3], [1], [5]). The interested
reader is addressed to [4] for a thorough overview on
the subject.
In this paper a library of components for modelling
(autonomous) hybrid automata (HyAuLib), implemented in Modelica (see [9, 6]), has been designed.
Modelica is already capable of efficiently handle hybrid systems modelling and simulation via suitable
scripts (see [8]). Nevertheless, sometimes this operation can turn out to be very cumbersome and error
prone for the unexperienced user. This library, extending the free Modelica library StateGraph (see [10]),
overcomes these difficulties by providing an easy way
to the consistent modelling and simulation of hybrid
systems described by the hybrid automaton formalism.
The paper is organized as follows: in Sections 2 and 3
the hybrid automaton formalism and the implemented
Modelica HyAuLib will be respectively described. In
Section 4, the library capabilities shall be illustrated
on two classic hybrid systems textbook examples. Fi-

239

Modelica 2008, March 3rd  4th , 2008

T. Pulecchi, F. Casella

nally, in Section 5 concluding remarks and future de- as long as x  Inv(q0 ). If at some point x reaches
the guard G(q0 , q1 )  Rn of some edge (q0 , q1 )  E,
velopments will be presented.
then the discrete part of the state q may change to q1 .
If this happens, x is reset according to the reset map
2 Hybrid Automata
R(q0 , q1 , x). After a discrete transition has taken place,
A hybrid automaton is a dynamical system describ- continuous evolution resumes, until a new transition is
ing the evolution in time of a set of discrete and triggered, and so on.
continuous variables. In this paper we will focus on To define the time horizon over which the states
autonomous hybrid automata, i.e. hybrid automata of the hybrid system evolve, we need to introduce
which have no inputs nor outputs. More specifically, the concept of Hybrid Time Set by the following
the transitions between two modes of our automata definition (see e.g. [7]):
shall occur in accordance with a user-specified determinism. This topic will be thoroughly discussed in Definition 2.2 (Hybrid Time Set) A hybrid time set is
Section 3. The hybrid automaton will answer to the a sequence of contiguous intervals  = {I0 , I1 , . . . , In }
finite or infinite such that
following definition (see e.g.[7]):
Definition 2.1 (Hybrid Automaton) A hybrid automaton H is a collection H =
(Q, X, f , Init, D, E, G, R) where

 Ii = [i , i0 ] for all i < n;
 if N <  then either IN = [N , N0 ] or IN = [N , N0 );

 i  i0 = i+1 for all i,
 Q = {q1 , q2 , . . .} is the set of all admissible discrete states, or modes of H;
where i0 represents the time instant immediately preceding a discrete transition occurrence, whereas i+1
 X  Rn is the set of continuous states;
corresponds to the time instant just following the dis f (, ) : Q  X  Rn is a vector field, defining the crete transition. The adoption of this representation of
evolution in time of the continuous part of the time in hybrid automata allows the handling of situations where multiple transitions occur simultaneously.
state of H;
When the range of a generic interval I j shrinks to a
 Init  Q  X is the set of all admissible initial single value  , it means that the associated mode Q
j
k
states for H;
has been entered and exited in the very same instant.
 Inv() : Q  P(X) is a the invariant set or domain; If multiple transitions are enabled and do occur simultaneously, the automaton evolves to its new mode
 E  Q  Q is a set of edges, defining all transi- Qr passing through several intermediate modes, whose
tions from one mode of H to the next;
associated residing times are zero.
The triple ( , q, x) consisting of a hybrid time set and
 G : E  P(X) is the set of guard conditions;
two sequences of functions q = {qi } and x = {xi } is
 R(, ) : E  X  P(X) is a reset map,
named a hybrid trajectory, whereas an execution of H
is a hybrid trajectory ( , q, x) admissible by the hybrid
where P(X) denotes the power set (the set of all posautomaton H.
sible subsets of X), and the pair (q, x)  Q  X is the
Note in passing that the exploitation of the invariant
state of H, made up by its discrete and continuous conset definition, allowable within the hybrid automatributors.
ton formalism, could be used to efficiently simulate
Hybrid automata define possible evolutions for their
a broad variety of unconventional engineering applistate. Roughly speaking, starting from an initial value
cations, such as, for instance, the suitability of the
(q0 , x0 )  Init, the continuous state x flows according
designed safety procedures for continuous dynamical
to the differential equation
systems. This could be achieved simply by modelling

the safety critical conditions for the system via undex = f (q0 , x)
sirable regions for the continuous state (by defining the
x (0) = x0
automaton domain accordingly). As a consequence,
defined by the hybrid automaton vector field, while the
if the recovery procedures fail, the automaton will vidiscrete state q remains constant, i.e.,
olate the invariant set and the simulation will be terq(t) = q0
minated with a warning message specifying the safety
The Modelica Association

240

Modelica 2008, March 3rd  4th , 2008

HyAuLib: Modelling Hybrid Automata in Modelica

critical condition violated, leading to a procedure redesign. Many other useful controls of this kind, such
as for example Zeno behavior detection, can be easily
incorporated into the Modelica HyAuLib.
Another interesting field of application for the
HyAuLib could be in the framework of simulation of
systems undergoing failures. Lets focus on a simple
example, where a relief valve is used to control the
pipeline pressure in an hydraulic plant. During nominal operational regime, the valve remains closed while
pressure at the valve inlet is lower than the valve preset pressure. When the preset pressure is reached, the
valve is opened and the pressure at the inlet reduced.
Now, if the valve experiences a failure and got stuck in
the open position, and for some operational reason the
pressure in the pipeline crosses the valve preset pressure and keeps rising, either the valves backup (if any)
will be activated, or the system will suffer damage and
loose functionality. If no backup is activated, or it results ineffective, the pressure will utterly increase to
the point of exceeding a new threshold value (defining
when the system is no more operative), specified via
the invariant set. The simulation will be either terminated if the experienced failure is classified as safety
significant or safety critical (the system architecture
needs a redesign), or kept running with the system in
failure. Note that our simple example requires that the
transition between the operational modes of the pressure relief valve (open and close) is triggered either by
an opening (resp. closing) command or as a consequence of a failure experienced by the equipment and
associated to a probability of occurrence. Relevant
data both in terms of failure modes and failure rates
can be obtained from the equipments Failure Mode
Effect and Criticality Analysis document, and the necessary hybrid models easily implemented exploiting
the HyAuLib models, described in the following Section 3.

hybrid automata paradigm in a natural fashion. Although such models could of course be obtained by
writing explicitly the relevant Modelica code, this task
is likely to turn out to be burdensome and error prone
even for very simple models. The HyAuLib, by automatically managing all state transitions and the discrete/continuous domains interaction, seeks to minimize all possible sources of wrong modelling behavior. An expanded view of the HyAuLib tree is given in
Figure 1.

3 The Modelica HyAuLib

Figure 1: The Modelica HyAuLib librarys tree.

The Modelica HyAuLib addresses the problem of supThe Modelica HyAuLib encompasses two basic comporting the designers working with hybrid systems, by
ponents, the FiniteState and Transition models, which
providing them with an efficient and intuitive modare briefly summarized in the following:
elling and simulation tool for hybrid automata. The
 Component FiniteState: defines each finite state
library has been derived by extending the free Mod(or mode) for the generic automaton. Embedelica StateGraph library by Otter and Dressler (see
ded in this model are the definitions of the vec[10]), which is based on the JGraphChart method and
tor field and of the invariant set associated to the
provides components to model finite state machines.
present state of the hybrid automaton. CompoThe HyAuLib allows for the modelling of complex
nent FiniteState extends StateGraphs Step comhybrid systems that can be represented throughout the
The Modelica Association

241

Modelica 2008, March 3rd  4th , 2008

T. Pulecchi, F. Casella

ponent, which is used to define which state is
presently active. (See Figure 2, where the Modelica code used to generate the FiniteState component is shown.)
The FiniteState options selection mask is shown
in Figure 3. For every FiniteState component
instantiated in the hybrid automaton model, the
number of input and output connections needs
to be specified, jointly with the selection between StateGraphs InitialStep and Step components (for further information on StateGraph, see
[10]). Finally, notice that a given time continuous dynamics and invariant set must necessarily
be specified. These models can be elementarily defined by extending suitable interfaces provided within the HyAuLib library. Several of
such examples are provided in the librarys Example folder.

current time. Future development will comprise the
implementation of a probabilistic approach in the definition of the transition occurrence.
Notice that no care needs to be taken in the HyAuLib
with respect to the definition of an hybrid time set for
the automaton execution. Modelica is indeed capable
of dealing with this issue, requiring no further modelling endeavor.

 Component Transition: defines the generic transition between modes. The model, extending
StateGraphs Transition component, comprises
the definition of the guard and the reset conditions. Notice that all transitions are triggered according to a deterministic mechanism, i.e., at the
moment no provision is given within the library
in order to assign a probability to the transition.
Two possible reset conditions are available: the
standard option guarantees the continuity of the
continuous state variable throughout the transition, whereas the second option allows for the
definition of a specified reset. The Modelica code
for the Transition model is provided in Figure 4.
Also, Figure 5 shows the options selection mask
for the HyAuLib Transition component.

A bouncing ball is a very effective example of an
highly nonlinear dynamical system, which can be conveniently represented as a simple hybrid automaton
with a single discrete state, describing the ball being
above the ground. Here, all the system nonlinearities
are easily modelled by introducing a hybrid component in the model.
The system state is a two dimensional vector comprising the balls center of gravity height from ground and
its derivative, the vertical velocity. The state continuous time evolution is then described by

Both models take full advantage of the Modelica redeclare construct feature, which makes it possible to
create general classes which are defined only when the
model is instantiated. It is then possible, once suitable
models for the hybrid automatons dynamics, invariant
sets, guards and reset conditions have been defined, to
simply drag and drop in the automaton model the base
FiniteState and Transition models, select the relevant
features from the graphical user interface, and connect
them to reproduce the automaton scheme.
The HyAuLib supports multiple edges connection between different modes (the number of input and output connections being a parameter of the mode component). The transition mechanism adopted is deterministic. The transition is triggered as soon as the guard
condition is satisfied, or with a delay that can be specified as a function of the hybrid automaton state and
The Modelica Association

4 Case studies
In the following, two classic applications, which have
been extensively discussed in the hybrid systems control literature, are presented to illustrate the HyAuLib
capability when modelling hybrid automata.

4.1 Bouncing ball



x1 = x2
x2 = 9.81

where x1 , x2 are the vertical position and velocity respectively, and the associated invariant is given by the
condition x1  0 (ball in the air).
The only transition possible occurs from the state to itself when the ball hits the ground: the associated guard
condition is then
x1 = 0 and x2  0 .
A nonconservative description of the phenomenon
may be easily accounted for by acting upon the reset
condition. Proceeding like that, we could easily force
an energy loss due to the deformation of the system
simply by setting
x2 := c x2
with c non negative and less than unity.

242

Modelica 2008, March 3rd  4th , 2008

HyAuLib: Modelling Hybrid Automata in Modelica

Figure 2: Modelica code of the FiniteState component.

Figure 3: Users selection mask for the HyAuLib librarys FiniteState component.
The Modelica Association

243

Modelica 2008, March 3rd  4th , 2008

T. Pulecchi, F. Casella

Figure 4: Modelica code of the Transition component.

Figure 5: Users selection mask for the HyAuLib librarys Transition component.

The Modelica Association

244

Modelica 2008, March 3rd  4th , 2008

HyAuLib: Modelling Hybrid Automata in Modelica

Figure 6: Vertical position of the bouncing ball vs.
Figure 7: Vertical position of the bouncing ball vs.
time. HyAuLib model.
time. Modelica flat code.
Figure 6 shows the evolution in time of the ball position, given an initial height of 2 meters, a null initial
velocity and a damping coefficient c = 0.8.
Both a Simulink/Stateflow and a Modelica flat model
for the bouncing ball were realized, to serve as a reference for a discussion about the HyAuLib modelling
performance. Both models (provided that the zerocrossing block is used in Simulink) provide good accuracy as long as the balls energy is sufficiently large.
Anyway, the Zeno behavior typical of this example,
cause a severe impair of performance when the balls
vertical position x1 gets very small. Due to numerical errors, x1 will eventually become negative and,
since the equations used to describe the model are
still satisfied, the ball position will keep decreasing.
This behavior, depicted in Figure 7, corresponds to the
ball passing through the floor and keep falling, and is
of course not admissible. This problem is naturally
avoided if the HyAuLibs components are used, since
the specification of the hybrid automaton invariant set
clearly marks negative values for x1 as unfeasible.

where  = 0 if the heater is turned off and  = 1 if the
heater is on. The hybrid automaton will then comprise
two modes and two transitions, which can be defined
as follows:
1. Hybrid Automata modes:
a) heating on ( q = ON )
The continuous state evolves according to
T = 0.05 T + 1.5
whereas the invariant set is T  21.

b) heating off ( q = OFF )
The continuous state evolution is given by
T = 0.05 T

T = 0.05 T + 1.5  ,
The Modelica Association

(2)

whereas the invariant set is T  17.
2. Transitions:
a) from ON to OFF
The guard condition is T  21,
whereas the reset condition is T := 21.

4.2 Air conditioning system
Lets now consider the problem of designing a room
air conditioning system. We want to keep the room
temperature within a specified range by acting upon a
heating device. Assume that the desired temperature
is 19 degrees centigrade, and the thermostat policy is
to turn the heater on whenever the room temperature
drops below 17 C, and turn it off when is passes 21 C.
For simplicitys sake let the room temperature evolution in time be subjected to the simplified law

(1)

b) from OFF to ON
The guard condition is T  17,
whereas the reset condition is T := 17.
Notice how the evolution of the continuous and discrete states of the automaton are tightly coupled.
Whenever q = ON , the temperature rises according
to (1), whereas it decays according to (2) when q =
OFF . Likewise, the evolution in time of the discrete
state is constrained by the continuous state value: it
cannot jump from ON to OFF or viceversa unless the
guard condition is triggered.

245

Modelica 2008, March 3rd  4th , 2008

T. Pulecchi, F. Casella

Figure 8 shows the evolution in time of the room air
temperature and the periodic switching of the heater
from power on to power off and viceversa. The air conditioning system was initialized in power off, with a
room temperature of 14 C. Whenever the temperature
upper bound (21 C) is reached, the heater is powered
off, and the room starts cooling until the lower bound
for the admissible temperature (21 C) is hit. Then, the
heater is powered off and a new cycle begins.

Room temperature [C]

22
20
18

[2] M. Anderson. Object-Oriented Modeling and
Simulation of Hybrid Systems. Ph.D thesis, Lund
Institute of Technology, Lund, Sweden, December 1994.
[3] C. Brooks, A. Cataldo, E. A. Lee, J. Liu, X.
Liu, S. Neuendorffer, H. Zheng. HyVisual:
A Hybrid System Visual Modeler, Technical Memorandum, UCB/ERL M05/ 24,
http://ptolemy.eecs.berkeley.edu/ publications
/papers/05, University of California, Berkeley,
CA 94720, 2005.

16
14

0

5

10

15

20

25

30

35

40

45

50

0

5

10

15

20

25
Time [s]

30

35

40

45

50

[4] L. Carloni, M. D. Di Benedetto, R. Passerone,
A. Pinto, A. Sangiovanni-Vincentelli. Modeling
Techniques, Programming Languages and Design Toolsets for Hybrid Systems. Technical report, http://www.columbus.gr/documents/ public/WPHS, 2002.

1.5
Heater ON active

http://www.cis.upenn.edu, University of Pennsylvania, Philadelphia, PA.

1

0.5

0

Figure 8: Room temperature and Heater ON status vs.
time.

5 Concluding Remarks
In this paper the HyAuLib, a Modelica library for
modelling and simulation of autonomous hybrid automata, extending the free Modelica StateGraph library for Finite State Machines, has been presented,
and its main features illustrated throughout the simulation of two classic hybrid system textbook case studies. The HyAuLib allows, even to the most unexperienced user, to derive in a natural way models for
simulating complex hybrid systems. Future developments of the HyAuLib will comprise the inclusion of
a probabilistic approach with respect to the transition
occurrence and the exploration of the librarys capabilities and efficiency in modelling complex applications
in the system safety design area.

[5] A. Deshpande, A. Gollu, and L. Semenzato. The
SHIFT Programming Language for Dynamic
Networks of Hybrid Automata. IEEE Transactions on Automatic Control, 43 (4): 584-587,
April 1998.
[6] P. Fritzson, and P. Bunus, Modelica - a general object-oriented language for continuous and
discrete-event system modelling and simulation.
In Proceedings of the 35th IEEE Annual Simulation Symposium, San Diego, CA, 2002.
[7] J. Lygeros. Lecture Notes on Hybrid Systems.
Rio, Patras, Greece: Internal report, Department
of Electrical and Computer Engineering University of Patras, 2004.
[8] S. E. Mattsson, M. Otter, and H. Elmqvist. Modelica Hybrid Modeling and efficient simulation.
In IEEE Conference on Decision and Control,
Phoenix, AZ, 1999.
[9] Modelica Association, Modelica - a unified
object-oriented language for physical systems
modelling. Language specification. Technical report, http://www.modelica.org, 2002.

[10] M. Otter, K.E. Arzen, I. Dressler. StateGraph
- A Modelica Library for Hierarchical State
Machines. In Proceedings of the 4th Interna[1] R. Alur, R. Grosu, Y. Hur, V. Kumar, I.
tional Modelica Conference, Hamburg, GerLee. Modular Specification of Hybrid Sysmany, pp.569-578, 2005.
tems in Charon. Technical Memorandum,

References

The Modelica Association

246

Modelica 2008, March 3rd  4th , 2008

Application of Neural Networks to model Catamaran Type Powerboats

Application of neural networks to model catamaran type powerboats
Garron Fish Mike Dempsey
Claytex Services Ltd
Edmund House, Rugby Road, Leamington Spa, UK
garron.fish@claytex.com

Abstract
Powerboats in operation represent a system consisting of a number of complex components such as:
surface propellers, aerodynamics and hydrodynamics; which interact with each other and with the wind
and water surface conditions. By measuring the behaviour of the powerboat it is possible to create a
mathematical model using system identification
methods. A neural network model has been generated which can be used to predict how the powerboat
will perform under different driver inputs for the
purpose of optimizing performance.
Keywords: neural networks; system identification;
powerboats

1

surface propellers and environmental conditions
(such as the water surface and wind speed and direction).
The aim of generating a mathematical model of the
system was to be able to investigate the effect on the
boat performance of variations in driver input and
boat setup. A neural network system identification
method was selected as the most appropriate way to
model the system. Neural network techniques can be
very effective at identifying complex nonlinear systems when complete model information cannot be
obtained [2].
A Modelica library called ANN_SID has been developed to facilitate system identification using neural networks. The library contains different types of
neural network and several training methods and has
been applied to study the powerboat system.

Introduction

There are many different approaches to mathematical
modelling and the decision about the most appropriate method to use is based on what a priori knowledge is known about the system. Modelica is typically used for white box modelling, which is based
on the application of the universal laws and principles. This paper discusses the use of black box modelling techniques that are entirely based on the use of
measurement data to generate the mathematical
model [1].
In black box modelling, the inputs and outputs of an
unknown system are used to create a model that produces an output close to that of the actual system,
when supplied with the same inputs. Neural network
system identification is one method that can be used
to create black box models.
In the case of a powerboat, it is convenient to model
the system as a black box, as it is not feasible to
model the behaviour of the system as a white box
model. Figure 1 shows a class 1 powerboat under
race conditions. To create a white box model we
would need to create models of the aerodynamic and
hydrodynamic effects, and their interaction with the

The Modelica Association

Figure 1. View of a powerboat during operation.
Image courtesy of Victory Team

2
2.1

Neural networks
An artificial neural network

An artificial neural network is a network of functions
called neurons, which are connected by weighted
signals (see Figure 2). This architecture is loosely
based on a biological neural network. Neural networks can be used for a variety of tasks such as system identification and classification. The ANN_SID
library provides neural networks appropriate for system identification tasks.

247

Modelica 2008, March 3rd  4th , 2008

G. Fish, M. Dempsey

2.2
Input layer

Hidden layer

Output Layer
weight

function

1

1

bias
1

1

neurons
bias

Figure 2. Feedforward neural network
Figure 2 shows a simple diagram of a typical neural
network, commonly called a feedforward neural
network, which consists of an input layer, a hidden
layer and an output layer. In both the hidden and
output layers, the weighted sum of the inputs to the
layer and the bias, are applied to neuron functions.
The formulae that describe the feedforward neural
network in Figure 2 are shown below. Equation (1)
calculates the outputs of the hidden layer and equation (2) calculates the output of the neural network.

o j (t ) = O j ( u i (t )vij + 1  v n +1 j )

Types of neural networks implemented in
the ANN_SID library

The ANN_SID library provides pre-defined neural
network models for feedforward neural networks and
a form of dynamic recursive neural networks called
Neural Network Output Error. Within each type of
neural network there can be any number of inputs,
hidden neurons, neuron layers and output neurons.
In the dynamic recursive neural network, the output
of the neural network can be used as an input to the
neural network, as shown in Figure 3. This type of
recursive network is used for modelling dynamic
systems where the next output is affected by the previous output values and previous input values.

delay
delay

(1)

i

y k (t ) = Yk ( o j (t ) w jk + 1  wm +1k )

Figure 3. Dynamic recursive neural network

(2)

j

where:
oj is the output of the hidden layer
Oj is the hidden neuron function
ui is the input
vn+1j is the bias weight for the j neuron (there are n
inputs)
yk is the output of the neural network
Yk is the output neuron function
wm+1k is the bias weight for the k neuron (there are m
hidden neurons)
t is the current sample
Within the ANN_SID library the most common neuron functions such as linear, sigmoid and tanh are
available. The user can also easily add their own
neuron function by extending from the neuron function base class and implementing the required function.

2.3

Training of the neural network

The weights and biases in a neural network have to
be trained so that the output of the neural network
approximates the actual system well. The mean
square error between the actual output and predicted
output is the cost function determining the measure
of the closeness of the approximation of the neural
network to the actual system, as in equation (3).

MSE =

1
2N

N

 ( z (t )  y(t ))

2

(3)

t =1

where:
MSE is the mean square error
z is the target value (output from the actual system)
y is the output of the neural network
N is the total number of target values
The process of minimising the cost function of the
neural network is called training. In the ANN_SID
library both backpropagation and the Levenberg-

The Modelica Association

248

Modelica 2008, March 3rd  4th , 2008

Application of Neural Networks to model Catamaran Type Powerboats

Marquardt training methods are available. These
methods have been implemented in Modelica in both
continuous and discrete forms. The choice of method
to train a neural network is influenced by the size of
the neural network and the amount of data being
used to train the network.
The continuous training methods have the advantage
that the gradient, which is the rate of change of the
weights, is accurate everywhere, not only at the linearization points as with discrete methods. This can
result in the search method travelling along the bottom of valleys of the cost function and not oscillating
along valley walls.
The continuous method interacts with the variable
step solvers to determine the step-size. If the gradient
changes suddenly then the solver will reduce the step
size to deal with this efficiently. The disadvantage
of the continuous method is that it generates huge
numbers of equations due to the way that Dymola
expands the for loops used in the model. By using
Modelica functions and external C functions these
problems can be minimized through the reuse of
code sections.
Data storage and the manipulation of large matrices
in Dymola can also generate problems with large
neural networks if the continuous training methods
are used. The discrete methods have been implemented to overcome these issues.

Levenberg-Marquardt training methods can be used
to minimise the cost function.
Modelica provides semantics to define partial derivatives and Dymola is able to utilise these semantics to
generate the symbolic derivative of functions. Example 1 shows how the partial derivatives are defined in Modelica. This method was used to help
define a function to calculate the partial derivatives
of the neural network with respect to the weights.
[Example: The specific enthalphy can
be computed from a Gibbs-function as
follows:
function Gibbs
input Real p,T;
output Real g;
algorithm
...
end Gibbs;
function Gibbs_T=der(Gibbs, T);
function specificEnthalpy
input Real p,T;
output Real h;
algorithm
h:=Gibbs(p,T)-T*Gibbs_T(p,T);
end specificEnthalpy;

]
Example 1. An example of Modelica code for the generation of the partial derivative of a function. Quoted
from Modelica 3.0 Specification [4]

2.3.1 Backpropagation
It is possible to train a neural network by calculating
the gradient of the cost function with respect to the
weights, and to then adjust the weights in the appropriate direction to reduce the cost function. This
method is called backpropagation and can be slow to
converge to a solution. Appendix A has further information about how the gradient is calculated.

2.3.4 ANN_SID Implementation
An example of training a neural network using the
ANN_SID library is shown in Figure 4. The training
methods are implemented in the replaceable training
component and the user simply selects the required
method.

2.3.2 Levenberg-Marquardt
The Levenberg-Marquardt training method generally
requires fewer iterations than the backpropagation
method to train a neural network. However the LM
method is more complex and requires more computation and memory to perform each iteration.
The rules used to calculate the weights are described
in Appendix B.

Training
component

2.3.3 Recursive method
In this method the partial derivative of the neural
network with respect to the weights is required.
From this partial derivative the gradient and Hessian
matrices can be calculated. Once we have determined these matrices either the backpropagation or

The Modelica Association

Figure 4. ANN_SID training performed in a model

249

Modelica 2008, March 3rd  4th , 2008

G. Fish, M. Dempsey


2.4

Improving the neural network training

When training a neural network it is important to
have confidence that the neural network will approximate well with inputs that are not part of the
training data. This ability is known as generalisation
[5]. One way to investigate this is to divide the data
into two sets, one that is used to train the neural network (training data), and one that is used to test the
generalisation of the neural network (test data).
Generalisation is likely to be improved by reducing
the number of weights used in the neural network
[3]. The ANN_SID library supports both weight
decay and pruning methods to reduce the number of
weights and improve generalisation.
Two pruning methods are available in the library and
these are known as Optimal Brain Surgery and Optimal Brain Damage. These algorithms determine
which weights to remove from the neural network.
The remaining weights are then updated to reduce
the errors introduced by removing the weights (for
further details refer to [3]).
Weight decay is another approach to removing
weights from a neural network. In this method a
penalty proportional to the magnitude of the weights
is added to the cost function (see [3] for further details). All cost functions should contain a measure of
the closeness of the neural network outputs to the
desired output. Adding a weight penalty to the cost
function generates a trade off between reducing the
magnitude of the weights and reducing the closeness
measure. As a result of this the weights that have
little effect on improving the closeness measure will
now be reduced in magnitude.

3

Powerboat operation

The type of powerboat that has been modelled using
the ANN_SID library is a Victory Team class 1 offshore powerboat as shown in Figures 1 and 5. These
boats have a catamaran hull with two engines and a
central rudder. Each engine drives a height adjustable, steerable propeller. The boats are operated by
two crewmembers: a throttle man and a driver. Between them they have 5 controls, which are:
 A steering wheel that directly controls the
rudder angle. The steered angle for the propellers is also controlled by the steering
wheel angle.

The Modelica Association



trim
piston

The propeller heights are set using two
rocker switches. These control the trim pistons that move the propellers vertically.
Throttle position is set using the throttle levers for the left and right engine.

rudder

Figure 5. Rear view of a powerboat. Image courtesy of Victory Team
As the boat accelerates it begins to plane and travels
higher above the water, i.e. less of the hull is below
the water line. As the boat lifts out of the water, the
propellers are lowered (trimmed down) to control
their depth in the water.
The trim height (or propeller depth) also affects the
pitch angle at which the boat travels. In general, the
lower the depth of the propellers, the lower the pitch.
If the boat is travelling at a pitch angle that is too
high for the speed it is doing, it will flip over (a
blowover). If the pitch angle of the boat is too low
the result will be a larger surface area of the boat in
the water and thus an increase in drag.
When cornering, the catamaran powerboat rolls to
the inside of the corner (due to the asymmetrical hull
design). If the cornering is too severe for the current
speed, the boat will begin to roll to the outside of the
corner, and will roll over if the drivers do not take
correcting action. A typical cornering manoeuvre
requires the throttle man to reduce the throttle to
slow the boat to a controllable speed before the corner, and the driver to steer the boat along the course,
ensuring that the steering angle is not too steep for
the current speed.

250

Modelica 2008, March 3rd  4th , 2008

Application of Neural Networks to model Catamaran Type Powerboats

Figure 6. A Racecourse. The powerboats must
travel along a course defined by buoys. There are
three different types of laps. The start lap in red, the
short lap in black and the long lap in green. Supplied
courtesy of IOTA.
A race involves the boats travelling around a course
defined by buoys laid out in the water (see Figure 6).
The drivers try to select good trim height to maximize acceleration while maintaining stability. The
drivers also try to find good throttle, rudder and trim
positions for cornering that result in fast and stable
cornering. The neural network can investigate different possible driver inputs and predict their effects
on boat performance over a lap.

4
4.1

Powerboat model
Defining the neural network

To model the powerboat using neural network techniques, a significant amount of data is used to characterise the system. During races and testing sessions the boats are fitted with a data logger that records the data required to train the neural network.
The input data required is:
 The engine throttle positions
 The rudder angle
 The trim height of both propellers
The target output data required is:
 The engine speed of both engines
 The boat speed
 The yaw rate of the boat
Using this input and output data we can train a neural
network to represent the powerboat system and then

The Modelica Association

use the neural network to investigate the system performance with different inputs.
As the boat is an example of a dynamic system, the
dynamic recursive neural network was chosen. The
model has been generated from data recorded by
Victory Team from their racing boat number 77 during the 2007 Arendal race. During this race the boat
completed 12 laps of the course.
The measured data was filtered using Basel and
Chebyshev filters to reduce the amount of noise and
high frequency components in the data. The filtered
data was then re-sampled from 100Hz to 1.7Hz to
reduce the number of duplicate data points and to
decrease the amount of time required to train the
neural network. Finally the data was divided into
training and test data sets.
4.2

Training the neural network

Training a neural network for such a complex system
is done in a number of steps. When first training a
dynamic recursive neural network it is not known
how many past outputs and inputs will result in the
model giving a good representation of the powerboat
system. It is also not known how many neurons will
be required, or which neuron functions should be
used. These can only be determined by trying different configurations to find the best setup.
The first step in training this type of neural network
is to train it to only predict the next output value
from the previous data value. The weights from this
training are then used as the initial weights for the
recursive training. The recursive training algorithm
described in 2.4.3 was used with the LevenbergMarquardt method to train the neural network. To
improve the generalization, weight decay was used.
4.3

Correlation results

After training, the MSE for the neural network using
the training data set was 0.0035 and the MSE for the
test data set was 0.0064. This means that the neural
network has been trained successfully and is able to
accurately predict the performance of the powerboat,
as shown in Figure 7.
In Figure 7, the recorded driver inputs have been fed
in to the trained neural network and the outputs for
boat speed, engine speed and the yaw rate of the boat
are compared to the measured data. Overall the results show that there is very good correlation between the neural network and the real powerboat.
There are some small deviations which could be due
to a number of different factors, such as swell and

251

Modelica 2008, March 3rd  4th , 2008

G. Fish, M. Dempsey

wind conditions along the course, that are not accounted for in the neural network.

Figure 7. Comparison of simulated neural network
with recorded data for a single lap of the course.
4.4

Optimisation of the trim strategy

Section 3 describes how the propeller height (trim
height) affects the performance of the powerboat.
By using the neural network it is possible to determine what the optimum trimming strategy is for the
powerboat.
The model shown in Figure 8 uses the trained neural
network to simulate the powerboat accelerating from
an initial speed up to its maximum speed.

Figure 8. Acceleration model test. The throttle position is set to 100% and the boat is travelling in a
straight line.

neural network. Using the optimised trimming strategy the powerboat would take 1s less to travel along
a 2km straight than using the example trim strategy.

Figure 9. Comparison of a simulated trim strategy
with a real trim strategy. The simulated optimal results (Simulated Speed and Simulated Trim) assume
the boat is travelling perfectly straight. The Example
Trim strategy was taken from the race data and applied to the simulator.
The neural network used in the model can only be
expected to accurately model an operating region if
this region was sufficiently excited during the data
recording stage. In Figure 10 the histogram data
identifies what trim position data is available for the
operating region of the simulated result. The optimum trim strategy is limited by the availability of
data (see Figure 10). The upper bound on the trim
data is probably due to driver caution because of the
risk of a blowover in this operating region.

Figure 10. Histogram plot of recorded trim position
at the operating state. The optimised trim position is
plotted over the histogram as white circles

Figure 9 compares an example trimming strategy
extracted from the race data and the optimized trim
strategy that has been determined with the use of the

The Modelica Association

252

Modelica 2008, March 3rd  4th , 2008

Application of Neural Networks to model Catamaran Type Powerboats

5

date a feedforward neural network using the MSE as
the cost function.

Conclusions

A library called ANN_SID has been developed for
the development and training of neural networks for
system identification. This library was used to generate a black box model of a powerboat, and this
model was then used to determine an improved
trimming strategy that should deliver improvements
in boat performance.

Victory Team have kindly provided the photographs
used in this paper and the powerboat data used to
carry out this study.
IOTA have kindly provided the course map used in
Figure 9.

References

[2]

[3]

[4]

[5]

Estrada-Flores S., et-al. Development and validation of grey-box
models for refrigeration applications:
a review of key concepts. International Journal of Refrigeration, pages
931-946, July 2006.
Wen Yu, Nonlinear system identification using discrete-time recurrent
neural networks with stable learning
algorithms. Information Sciences,
pages 131-147, 2004.
M. Nrgaard, O. Ravn, N.K.Poulsen
and L.K.Hansen, Neural Networks
for Modelling and Control of Dynamic Systems
Modelica 3.0 Specifications
http://www.modelica.org/release_of_
modelica_3_0/view
Neural Network FAQ, part 3 of 7,
ftp://ftp.sas.com/pub/neural/FAQ3.ht
ml

APPENDIX A:
gorithm

Backpropagation al-

By calculating the gradient of the cost function (see
Section 2.3) it is possible to update the weights in a
way that will reduce the cost function. The example
below is how backpropagation would be used to up-

The Modelica Association

o j = O j ( u i vij + 1  v n +1 j )

(1)

i

y k = Yk ( o j w jk + 1  wm +1k )

(2)

j

The cost function is the mean square error (i.e.
MSE):

Acknowledgments

[1]

The following equations describe a neural network.

V =

1
2N

N

 ( z (t )  y(t ))

2

(3)

t =1

The calculation of the partial derivative of MSE with
respect to output weight wjk follows:

V

1
=
(
w jk w jk 2 N

N

 ( z (t )  y (t ))

2

)

t =1

y (t )
V
1 N
=
 k (t ) k

w jk
N t =1
w jk

(let  = z(t)-y(t) )

Substituting in (2):

V
1 N
=
  k (t )
w jk
N t =1

Y k ( o j (t ) w jk + 1  wm +1k )
j

w jk

y
V
1 N
=
 k (t ) k  o j (t )

w jk
N t =1
a k
(where ak= o j (t ) w jk + 1  wm+1k )
The calculation of the partial derivative of the cost
function with respect to hidden weight follows:

V

1
=
(
vij vij 2 N

N

 ( z (t )  y (t ))

2

)

t =1

V  1 N
y (t )
=
 (t )

vij
N t =1
vij
(note that  and y are vectors)
y (t )  (o j (t ) w jk + 1  wm +1 j )
V  1 N
=
(  k (t ) k )

vij
N t =1 k
a k (t )
v ij

o j (t )
y (t )
V  1 N
=
(  k (t ) k )wi
u i (t )

vij
N t =1 k
a k (t )
bij (t )
where: bij(t) = O j (

 u (t )v
i

ij

+ 1  v nj )

i

The discrete weight update method is:

253

Modelica 2008, March 3rd  4th , 2008

G. Fish, M. Dempsey

wjk = -

minimum of L is far from the current iterate, (i), a
poor search direction may be obtained. [3].

V
vij

By choosing  sufficiently small, the cost function
can be decreased at each iterate.
The continuous method uses the gradient calculated
above to update the existing weights continuously.

APPENDIX B: Levenberg-Marquardt
algorithm
In the backpropagation algorithm the search direction is calculated from the first order Talyor approximation of the cost function. The LevenbergMarquardt algorithm makes use of the second order
Talyor approximation of the cost function to update
the weights. The second order approximation of the
cost function follows:
^

V ( ) = V(*) + ( -*)V(*) +
( -*)V(*)( -* )

 (i +1) = arg min L(i ) ( )


subject to |(i+1) - (i)|  (i)

(5)
where:
(i) has a monotonic relationship with (i) [3]. Where
increasing (i) decreases (i) and visa versa.
The weights are updated using the following rule:
[R((i)) + (i)I] = -G()
where:
 = (i+1) - ( i)
The update rule for the  value follows:
1. If the L(i) value approximates MSE well, then
(i+1) = (i)/2 and thus increasing the search region.
2. If the L(i) value does not approximates MSE well,
then (i+1) = (i)*2 and thus decreasing the search
region.
3. Leave * if neither the 1 or 2 thresholds are true.

^

V ( ) = V(*) + ( -*)G + ( -* ) H( -* )

To get a more detailed explanation on the update rule
for * refer to [3].

where:
 represents all the weights in the neural network
* are the weights at which the Taylor approximation is made.
V is dV/d and equal to the gradient G
V is d2V/d2 and equal to the Hessian H
In the Levenberg-Marquardt method a further approximation is made; the Hessian is approximated by
the following equation:

R( ) =

1
N

N


t =1

dy (t ) dy (t )
d d

This is valid when the MSE is the cost function.
Let the approximation of the cost function be:
L()= V(*) + ( -*)G + ( -*) R( -*)

(4)

This cost function is minimised using an iterative
process; where the next weights are limited to a region around the current weights (see (5)). Limiting
the range of the search is often effective as If the

The Modelica Association

254

Modelica 2008, March 3rd  4th , 2008

ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata

ModeGraph A Modelica Library for Embedded Control Based on Mode-Automata
Martin Malmheden1, Hilding Elmqvist1, Sven Erik Mattsson1, Dan Henriksson1, and Martin Otter2
1
Dynasim AB (A Dassault Systmes Company), Ideon Science Park, SE-223 70 Lund, Sweden
2
German Aerospace Center (DLR), Institute of Robotics and Mechatronics, Oberpfaffenhofen,
82234 Weling, Germany
{Martin.Malmheden, Hilding.Elmqvist, SvenErik.Mattsson, Dan.Henriksson}@3ds.com ,
Martin.Otter@dlr.de

Abstract
The ModeGraph library is a new Modelica library
for modeling of hybrid and embedded control systems based on Mode-Automata semantics. Actions
can be associated with discrete states in a way that
makes sure that the single-assignment rule is fulfilled. Consequently, non-deterministic variable assignment is impossible, which is usual in nearly all
other state machine formalisms. Besides ModeAutomata, concepts from Sequential Function Charts
(SFC)/Grafcet, Statecharts, and Safe State Machines
(SSM) are utilized to provide a flexible modeling
environment for safe, hierarchical state machines
where Modelica is used as action language. ModeGraph shall replace the existing Modelica.StateGraph library. The implementation of
ModeGraph requires extensions to the Modelica language, in order to support the Mode-Automata semantics and to drastically reduce code overhead and
improve performance of modeled graphs.
Keywords: Statechart, Mode-Automata, Finite State
Machines, Hybrid Control, StateGraph, Modelica

1

Introduction

The StateGraph library [5] is a sublibrary in the
Modelica Standard Library 2.1 (from 2004) and later
versions, providing components to model hierarchical state machines using Modelica as an action language. The StateGraph library has several significant
drawbacks that are mainly due to the underlying implementation language Modelica 2, where some special features needed for hierarchical state machine
modeling and for Mode-Automata are missing.
A new Modelica library for modeling hierarchical
state machines is proposed in this paper. It is a more
Statechart [2] oriented approach compared to StateGraph, but avoids several deficiencies of the State-

The Modelica Association

chart formalism in order to arrive at safe state machines. The library is capable of handling extended
state machine properties, such as hierarchy (meta
states), orthogonality (parallel substates), synchronization, and preemption. All StateGraph functionality
is available, but with a new simplified implementation. The ModeGraph library ensures safe state machines, especially with respect to
1. upper limit on execution time of one cycle,
2. guaranteed deterministic variable assignment.
The library is based on extensions to the Modelica
language, e.g., ensuring mutual exclusivity between
states. Usage of the new Modelica 3.0 graphical annotations provides a more modern look and feel.
In the following sections the ModeGraph library will
be explained and excerpts of the implementation will
be presented. A ModeGraph is defined in Modelica
using Boolean equations. As a result, the exact semantics of ModeGraph is formally defined with the
Modelica semantics (equations are sorted and iteration takes place, if pre(x)  x). General concepts
taken from Finite State Machines (FSM), Statecharts
[2], Sequential Function Charts (SFC) [7], and Safe
State Machines (SSM) [1] will be used as references
and benchmarks to demonstrate the feasibility and
applicability of ModeGraph.

2

Steps and Transitions

An FSM describes a behavior by decomposing it into
a distinct finite set of states visualized by statetransition diagrams. States are usually illustrated by
rectangles with rounded corners. An FSM is often
used to model reactive systems, which means it reacts to certain stimuli, usually called inputs. A transition is depicted with an arrow between two states
and a transition condition written next to the arrow.
When the condition evaluates to true, the transition is
taken, and a change of state is performed. As an ex-

255

Modelica 2008, March 3rd  4th , 2008

M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter

ample, see Figure 1, where the system initially is in
state A. When input  occurs, the state will change
from A to B. The arrow originating in a small black
dot is used to mark the initial state of the system.

at each hierarchical level is allowed to be active at a
given time instant. This requires restrictions on the
outPort fire mechanisms, which will be explained in
detail below.
2.2

Figure 1: Simple state machine with two states
and two transitions.

Inheriting much of the semantics from StateGraph,
the basic components of ModeGraph are Steps and
Transitions that are both
similar to the corresponding StateGraph objects.
Figure 2 shows the
ModeGraph equivalent of
Figure 1. We will proceed
to describe the Steps and
Transitions in more detail.
2.1

Transitions are used to decide when a change of state
should be performed. A basic Transition will check
if its predecessor Step is available and evaluate if its
transition condition is true (visualised by the condition being colored green). If this is the case, it will
send a signal, fire, to its surrounding Steps. Hence,
the previous Step will turn inactive and the following
will turn active.
inPort.fire

= condition and
inPort.available;
outPort.fire = inPort.fire;

The signal flow between Steps and Transitions is
viewed in Figure 3.

Steps

There are two types of
Steps: a regular Step and
a StepWithSignal. The
state of a regular Step is
represented by a Boolean,
active. In the case of
the StepWithSignal, active is instead a BooleanOutput that can be
Figure 2: A ModeGraph
graphically connected to
comprised of two Steps and
other components, typitwo Transitions.
cally to logical blocks:

Figure 3: Signal flow between Steps
and Transitions.

2.3

s1.newActive = (pre(s1.newActive)
and not t1.fire)
or t2.fire or entry.fire;
t2.fire = condition and
pre(s2.newActive);
s2.newActive = (pre(s2.newActive)
and not t2.fire)
or t1.fire;
t1.fire = condition and
pre(s1.newActive);

For a Step with one inport and one outport available is defined as:
available = active;

The function anyTrue iterates through its argument
array of connectors and returns true if any of them is
true. The state of the Step in the next iteration is
called newActive, hence active is set to
pre(newActive). A Step is said to be available to
the successor Transition when active is true.
Several transitions can lead to and from a Step, respectively. This is implemented with two vectors of
connectors, called inPort and outPort. The Step
component is said to be a mode, hence only one Step

Delayed Transitions to Break Loops

Consider the sequence of Steps and Transitions with
true conditions in Figure 4. A graph like this is said
to be unstable. At a given time instant, the active
Step is undefined, because all Transitions will evaluate to true at all times. The code below represents the
evaluation of the chain in Figure 4.

newActive =(anyTrue(inPort.fire) or
pre(newActive)) and not
anyTrue(outPort.fire);
active
= pre(newActive);

The Modelica Association

Transitions

Examining this code, it is clear that there is no defined active Step at a given time instant, since it
would immediately fire and activate the next Step.
Loops like this illustrate the need for a Transition
that requires the preceding Step to be available and
its condition to be true for a certain period of time
before it fires. This is shown by t2 in Figure 5. This
type of Transition is called delayed Transition and
requires additional equations to decide how long a
transition is delayed until it can fire.

256

Modelica 2008, March 3rd  4th , 2008

ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata

upper limit on the evaluation time of a ModeGraph
at any time instant. Both properties are important for
safe embedded control systems.
As mentioned above, Steps can have multiple input
and output transitions, and only one Step is allowed
to be simultaneously active at every level. This requires priorities among the output transitions. The
most intuitive way is to use the index of the port array as priority. A lower index represents higher priority.
The available flag needs to take priority into account
and a port is available if the Step is active and if no
port with higher priority fires:
for i in 1:size(outPort,1) loop
outPort[i].available =
if i == 1 then
active
else
active and not
outPort[i-1].fire;
end for;

Figure 4: An infinite loop of Figure 5: A loop broken by
true transitions.
a delayed Transition t2.

In the present ModeGraph prototype, a parameter
waitTime > 0 defines the duration for which the
fire conditions need to be true before the transition
can fire. The release version will alternatively allow
definition of the delay by the number of sample periods (with a default of one period), if the ModeGraph
is used in a sampled data system. A delayed Transition is currently defined as:
enableFire = condition and
inPort.available;
when enableFire then
t_start = time;
end when;
fire = enableFire and
time >= t_start + waitTime;
inPort.fire = fire;
outPort.fire = fire;

The concept of delayed transitions is a generalization
of the SFC semantics, where every transition from
bottom to top is delayed by one cycle. Introducing delayed transitions explicitly allows drawing
state machines arbitrarily without the restriction to
always draw it from top to bottom which is not
practical for Statechart-type state machines. Delayed
transitions are, e.g., also present in SSM [1], where
transitions are by default delayed by one cycle. In
SSM immediate transitions (denoted with the #
symbol) are immediate and equivalent to the normal Transitions in ModeGraph.
ModeGraph has the essential requirement, that every
loop must have at least one delayed transition. In the
next section it is described how a violation is detected during translation. This gives both a guarantee
that infinite looping is not possible, and it gives an

The Modelica Association

2.4

Graphs with Infinite Loops

Assume that a user creates a graph containing a loop
where the conditions of all Transitions are true, as in
Figure 4. With the current Step and Transition definitions, the graph will translate, but the solver will
not be able to converge towards a single active Step.
This kind of undefined behavior is obviously dangerous and is not allowed. To identify cases like this
during translation, the signal flow can be slightly
changed by introducing a Boolean, loopTest. The
new signal flow between Steps and Transitions is
depicted in Figure 6.

Figure 6: New signal flow with added loop checking.

The idea is to let Steps and undelayed Transitions
just pass the signal on, while a delayed Transition
and all entry points will set loopTest to true. If
only Steps and undelayed Transitions are present in a
loop, the translator will recognize an algebraic loop
of Boolean equations, and will print an error message because Boolean algebraic loops cannot be
solved. If a delayed Transition is included, the algebraic loop will be broken, and the graph will safely
translate. The code for the loop testing is simple:

257

Modelica 2008, March 3rd  4th , 2008

M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter

In a Step:

Figure 8 compared to Figure 7, despite the exact
same behavior of states A, B, and C.

for i in 1:size(outPort,1) loop
outPort[i].loopTest =
anyTrue(inPort.loopTest);
end for;

In a Transition:
outPort.loopTest = inPort.loopTest;

In a delayed Transition
outPort.loopTest = true;

This brute force method has the slight drawback
that no better loop breaking check can be provided.
In principal, it might be possible to have only undelayed transitions and if the transition conditions are
restricted, it might be possible to prove that infinite
looping is not possible.

3

Encapsulation and Aggregation

The FSM formalism is adequate as long as the modeled behavior remains reasonably simple. When the
number of states and transitions increases, the complexity of the FSM grows exponentially. This is fatal
to readability and strongly confines the viability of
the graph. Thus, when a state machine grows in
complexity, a strong formalism should support object-orientation and proper encapsulation of isolated
parts of the behavior to ensure well-defined interfaces.
Some remedies for the mentioned problems were
introduced by David Harel in Statecharts [2], where
several new properties were presented to extend
FSM. Being able to cluster states into a superstate
makes it possible to identify similarities between a
number of states and draw advantages from common
properties among them. Clustering of states enables
reuse of larger parts of a behavior than just a single
state. The superstate has a default entry point, which
is connected to the initial state with the same notation as the initial state arrow. In Figure 7, B and C
share the common property of transition  leading to
state A.

Figure 8: Two states clustered together in a superstate.

Refinement of a state involves identification of a
number of child states with unique properties within
a particular state. In Figure 8, states B and C can be
said to be a refinement of state D. Hence, state D is
said to be the superstate of state B and C. Being in
one of the substates implicitly means also being in
the superstate. The superstate D in Figure 8 is said to
be the XOR-decomposition of its substates.
3.1

ModeGraph allows aggregation of states into superstates. A Composite component inherits from
ModeGraph.Composite and has inPort and outPort
connectors defined, like a regular Step, but also suspend ports and resume ports - like in StateGraph.
Figure 9 shows a ModeGraph corresponding to the
chart in Figure 8.

Figure 7: Three states of which two share common properties.

Thus, B and C can be clustered together into state D
in Figure 8. Note the improved visual appearance in
The Modelica Association

ModeGraph Composite

258

Figure 9: ModeGraph containing two Steps clustered
inside a Composite. State D is a Modelica mode block
where the diagram layer is visible in the icon. Compare
with Figure 8.

Modelica 2008, March 3rd  4th , 2008

ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata

The initial Step, B, of the Composite is connected to
the entry port, depicted with a black dot. Similarly,
there is an optional exit port, illustrated with two
circles at the bottom of the Composite. This notation
is inspired by the semantics of SSM, but is slightly
modified to provide a more consistent look. In SSM,
a specific 'final step' indicates when the superstate
may be exited through the outPort, and is depicted
with two circles. To prevent misuse, there is an exit
port in the Composite and Parallel ModeGraph components that the 'final step' should be connected to.
When this step is active, the outPort of the Composite becomes available.
The difference between entry/exit and the existing
StateGraph approach extends beyond the mere
graphical deviation. The entry model contains a state
connected to the black connector dot that is initially
true. Having an entry state, no specific InitialStep
component is required. This prevents the user from
making mistakes by, for example, placing two InitialStep components in a graph. The code below defining the entry point ensures that the state remains
true for one iteration, when the Composite turns active, and then switches to false.
Entry entry(fire(start = false,
fixed = true));
protected
Boolean active(start = true);
fixed = true));
equation
active = pre(active) and not
pre(entry.fire);
entry.fire = pre(active);

4

Preemption and Exception

Aggregation of states introduces new possibilities.
Being an own entity, it is possible to have a transition drawn directly from the superstate. This will
result in a preemption, and the superstate is left regardless of which of the substates is active, see, e.g.,
transition  in Figure 8. Of course, normal exit is
possible by having a transition originating in an inner
state and targeting an outer. Notice how state D in
Figure 10 is only left through transition  if state C is
active.

Figure 10: Superstate D can only be left when in
substate C.

4.1

ModeGraph Exit and Preemption

To exit a Composite, the final step is connected to
the mentioned exit port. When the final step is active, exit.exit.available = true, and a transition connected to the Composite outport becomes
enabled. The ModeGraph realization of Figure 10 is
shown in Figure 11.

When the Step connected to the exit port is active,
the Transition connected to the outPort of the Composite may fire (if its condition is fulfilled). This
calls for a definition of how the state of a Composite
is evaluated:
available = exit.exit.available and
allSubBlocksFinished and active;
newActive = (active and not
anyTrue(outPort.fire) and not
anyTrue(suspend.fire)) or
anyTrue(inPort.fire) or
anyTrue(resume.fire);
active = pre(newActive);

In the code above, the state of the Composite, active is set to pre(newActive) to avoid an algebraic loop involving mode conditions that will be
introduced later in this paper.
An important feature of ModeGraph is conditional
execution. This applies for the Composite component, whose associated code is only executed when
the composite is active. This will be further explained in Section 6.
The Modelica Association

Figure 11: Composite D can only be left if Step C is active, compare with Figure 10.

A ModeGraph Composite has an array of suspend
connectors. Recalling the active condition of the
Composite, it is clear that after a suspend port fires,

259

Modelica 2008, March 3rd  4th , 2008

M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter

the Composite is no longer active. This behavior is
used to preempt a Composite without necessarily
having reached the final Step, i.e., the one connected
to the exit port. The condition of suspend.available needs to equal the state of the
Composite, since it should be preempted only when
it is active. The same kind of prioritization as for
Steps is performed here:
for i in 1:nSuspend loop
suspend[i].available =
if i == 1 then
active
else
active and not
suspend[i-1].fire;
end for;

The suspend port can be compared to the Statechart
equivalence of drawing a transition directly from the
superstate to an outer state, compare for example
transition  in Figure 8 and its equivalent in Figure 9.
The deactivation of the Composite does not, explicitly, influence the internal states of the Composite.
The state of the subblocks will be kept, but all internal interaction will be frozen.
4.2

Figure 12: Superstate D is entered through an H-entry.

To handle history of several nested superstates, the
H-entry can be extended to be applied all the way to
the lowest level. This is in Statecharts called an H*entry. Assume that state C in Figure 13 is active, and
transition  is taken (leaving superstate F). If later
transition  is taken, state C will be active, since  is
connected to an H*-entry.

History and CLH

The concept of preemption introduces an additional
way of entering a superstate. Normally, entry is performed through the default entry point, as mentioned
above. This behavior can be compared to a subroutine that has only one entry point. There is an obvious advantage of offering additional ways of entering an aggregation, similarly to the ways a co-routine
may be entered. Hence, re-entering a superstate, it is
also reasonable to be able to enter the most recently
visited substate.
Memory of the internal state of a superstate is called
entry by history in Statecharts, and depicted with
an encircled H to which transitions can be connected.
The H-entry will make the previously visited state
before preemption at the current level active. If the
superstate is entered for the first time, the default
entry arrow is used. Assume for example that state C
is active and transition  is taken in Figure 12. If
subsequently transition  is taken, state C (and of
course also state D) will once again be entered.

The Modelica Association

Figure 13: Superstate D is entered through an
H*-entry.

Having the possibility to utilize history functionality,
an obvious requirement is to also clear this memory
and enter an aggregation as normal. We will introduce the concept of actions and activities before this
property is defined.
4.3

Actions and Activities

A transition action in FSM can be performed when a
transition fires, which is denoted at the transition
condition after a '/' character. An action is assumed
to be performed instantaneously in ideally zero time.
Statecharts also defines activities that, opposed to
actions, are performed in non-zero time, and are used
to carry out tasks of some sort. For each activity ,
the following two actions are defined: start() and
stop() which are true when an activity starts and
stops, respectively. Also, a new condition is defined:
active(), which is true when  is active.
In SFC, actions are associated with a state instead of
being executed upon a transition being fired. Actions
in SFC are not instantaneous as in Statecharts and
may also be conditional.

260

Modelica 2008, March 3rd  4th , 2008

ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata

4.4

CLH

With the definition above, a special action called
clear-history(state), clh(state), can now be defined.
When clh is performed, the history at the level of the
state is reset. Just as with the H-entry, it is possible
to perform a clear-history down to the deepest level.
This action is consequently called clh(state*). Consider the graph in Figure 14 and assume that state C
is active when transition  is taken and clh(F) is performed.

junction, like the one in Figure 12, is directly implementable in ModeGraph by always entering through
the resume port, like in Figure 16.

Figure 16: ModeGraph Composite being entered only
through the resume port, compare with Figure 12.

Figure 14: The history of superstate F is reset when transition  is taken.

If transition  is subsequently taken, the choice
stands between state D or E, and since clh(F) has
been performed at this level, the default arrow, and
consequently, state E will be active. Note that if now
transition  is taken, state C will be active, since no
clh occurred at this level.

Note that when a Composite is suspended, all states
all the way down the hierarchy keep their current
state, which actually corresponds to the H*-entry.
Figure 17 is the ModeGraph implementation of
Figure 13. Clear History is performed in ModeGraph
upon normal entry through the inPort of a Composite.

Figure 15: The history of superstate F and all descending
substates are reset when transition  is taken.

In Figure 15 clh(F*) is performed instead. If now
transition  is taken, state E would be entered. If
transition  is taken, it would result in state B being
active, since all superstates are entered through their
respective default arrows on all descending levels
due to the earlier performed recursive clh.
4.5

ModeGraph History and CLH

The ModeGraph equivalence of the History junction
is the resume port. When the resume port fires, the
Composite is simply activated. This means that a
superstate that is always entered through a history

The Modelica Association

261

Figure 17: Two nested ModeGraph Composites that are
both entered through their resume ports, compare with
Figure 13.

Modelica 2008, March 3rd  4th , 2008

M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter

5

Parallelism

Parallelism and synchronization are important properties of a state machine to prevent exponential
blow-up of the number of states as complexity
grows. Assume, for example, two subsystems having
x and y states, respectively. When executing in parallel, the number of states would obviously be x + y.
However, realizing the system without the parallel
states would require xy states.
Orthogonality provides the possibility to have several superstates executing in parallel. Assume state D
being the orthogonal product of states B and C, D = B
 C, then D is said to be the AND-decomposition of B
and C, see Figure 18.

into a new given number of subpaths that are later
joined to a single connection. Hence, synchronization is implicitly demanded of parallel branches.
However, it is sometimes useful to have subsystems
working independently of each other that never synchronize, as is the case for states B and C in Figure
18. Those two systems will run concurrently until
they are preempted by transition . Hence, no synchronization will ever occur in this case.
Implementing this in StateGraph will result in a
rather messy graph with an unconnected Parallel join
component, see Figure 19. This use of unsynchronized subsystems is common in Statecharts, and a
more flexible way of implementing orthogonality is
thus desirable.

Figure 18: Superstate D is the orthogonal product
of B and C.

In practice, it is common to graphically omit the surrounding orthogonal product state, and in this case
instead connect transitions directly to the B  C state.
Another important aspect of subsystems running in
parallel is synchronization. An orthogonal product of
states should provide the possibility of only being
left if a particular set of states is active. In Statecharts, this is performed by using guards on a preemptive transition originating in the orthogonal
product state. This can successfully be used to let
sequences synchronize before continuing further
execution.
Being a sequence-control-oriented formalism,
SFC/Grafcet implements parallelism somewhat differently compared to the illustrated example. In SFC,
a transition can be split up in parallel paths. Consequently, several paths can be joined by an ANDjunction. This sequential approach suits its sequence
control purposes very well, and supports synchronization in a natural way.
5.1

Figure 19: A StateGraph containing two
unsynchronized subsystems.

In ModeGraph, a more Statechart-oriented design is
introduced without compromising existing possibilities of synchronization. A Parallel component inherits from ModeGraph.Parallel and is placed within a
Composite to enable preemption. Figure 20 shows a
ModeGraph implementation of Figure 18.

ModeGraph Parallelism

The existing StateGraph Parallel component follows
the Grafcet/SFC tradition by dividing one connection

The Modelica Association

262

Figure 20: A ModeGraph Composite that contains two
independent Parallel subsystems.

Modelica 2008, March 3rd  4th , 2008

ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata

As can be seen, ModeGraph incorporates an approach to orthogonality that is very similar to Statecharts. Note, that one or more Parallels are placed in
a Composite to provide the possibility of preemption
and synchronization of the Parallel children. As
shown in the code below, the active flag of a Parallel
component is always true. The reason for this is that
its activeness should always be decided by the parent
Composite. Alternatively, if the Parallel is the root of
the graph, it should indeed always be active.

tive/Parallel components are instantiated at the same
level as their branches. This makes it possible for a
user to freely connect a branch outside the component without properly synchronizing it, see Figure 22
for an example. Analysis to identify such cases
forces unnecessary code overhead.

output Boolean active
"= true if parallel step is
active, otherwise the
parallel step is not active";
equation
active = true;

One important feature of the ModeGraph Parallel
component is that synchronization is still available.
Each Parallel block also contains a Boolean variable,
finished, which is true when the Step connected to
the exit port is active.
Assume the scenario in Figure 18 with the modification that transition  can be taken only if Step F and
Step H are simultaneously active. This would result
in a ModeGraph implementation shown in Figure 21.

Figure 22: Example of unsafe StateGraph.

In ModeGraph, this kind of misuse is not possible.
Since the user is forced to inherit from ModeGraph.Parallel and build the parallel branches within
a model, i.e., on a different level, there is no way of
connecting to outer Steps or Transitions, since the
icon layer is closed.

6

Modelica Mode

To implement Mode-Automata in Modelica, a
mechanism for enabling/disabling a block is needed.
There must be a way to conditionally evaluate code
within a Composite and enable/disable its children.
The Modelica mode comprises five variables that
define the behavior of the inheriting block. The variables define under what conditions equations within
the block and its children will be evaluated and when
to reset states and outputs. The proposed built-in
base class mode is defined as:
Figure 21: A ModeGraph Composite with two parallel
subsystems that must synchronize to allow the Composite
to exit. Note that the exit ports of the Parallel components
are now connected.

To utilize exit connectors of the Parallel component,
it is required to set the parameter withExit to true.
If withExit is false, finished will be set to true.
This becomes useful when synchronizing Parallel
states with exits when there are additional Parallel
states without exits present in the same Composite.
The new approach of parallelism supports safe
graphs in a natural way. As stated in [5] the Parallel
and Alternative components in StateGraph are vulnerable to misuse. The problem is that the Alterna-

The Modelica Association

263

partial block mode
input Boolean finished = false
"The execution of the mode
block is finished";
protected
Boolean enable = true
"Enable/disable block and all
children";
Boolean enableSubBlocks = true
"Enable/disable children";
Boolean resetStates = false
"Reset all continuous and
discrete states of this block
and all its children";

Modelica 2008, March 3rd  4th , 2008

M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter

Boolean resetOutputs = false
"When a block is disabled, set
all its outputs to their start
values";
end mode;

6.1

The translator will assert that only one block inheriting from mode at every level is enabled at the same
time instant. This will make it possible to ensure
consistency of the single assignment rule in the
Mode-Automata context.
Naturally, the ModeGraph Step component extends
mode, and only one of Steps A and B in Figure 2 can
thus be enabled at a given time instant. A proposed
Modelica extension would make it possible to assign
a variable y as:
Step A equation
y = expr1;
end equation;
Step B equation
y = expr2;
end equation;

Just like the Step, the Composite component inherits
from the mode base class. It is by purpose that a
Composite and a Step on the same level are mutually
exclusive. All components inside the Composite will
in turn be gathered and evaluated in the same manner.
The modifiers of the mode block need to be configured according to the desired behavior of the Composite. When the inPort fires, resetStates is set to
re-initialise all the states of the Composite and its
children to behave exactly like if it was indeed the
first time it was entered. The attribute enableSubBlocks will be true when the Composite is active,
enabling children as long as the Composite stays active. When the block is not enabled, all outputs of the
Composite and all children should be reset, hence
resetOutputs is set to true. The mode modifier is
shown below.
partial block Composite
extends mode(
enableSubBlocks = active,
enable = true,
resetStates = inport_fire,
resetOutputs = true,
finished = allSubBlocksFinished);

The same restriction as in a when-clause applies, i.e.,
there must be a variable reference on the left hand
side of the equal sign (here: y). This code will be
transformed by the translator and will result in the
following single equation:
y = if A.enable or
A.enableSubBlocks then
expr1
elseif B.enable or
B.enableSubBlocks then
expr2
else pre(y);

The proposed built-in operator allSubBlocksFinished expands to a check if all children of the
mode have their finished variable set to true. Hence,
if allSubBlocksFinished is true, the Composite
may be left through the outPort, since its finished
flag becomes true.

The expressions expr1 and expr2 are thus defined
within A and B, respectively, and the equation above
is generated by the translator to ensure that the single
assignment rule is not violated.
As a consequence this means that in the generated
code every variable is only defined at one place. For
example, it will not be possible to assign the same
variable in two parallel branches of a Composite step
with two Parallel modes. If this is attempted, an error
occurs, since the number of equations and unknowns
is not the same. Nearly all other formalisms lack
such a property and therefore it is possible to assign
to the same variable several times and then nonintuitive rules are used to determine which assignment takes priority. Stated differently, ModeGraph
guarantees deterministic variable assignment,
whereas most other state machine formalisms have
non-deterministic variable assignment.

The Modelica Association

Composite Mode

6.2

Parallel Mode

The final discussion relates to the Parallel Component. Since we think in terms of an orthogonal product, AB, several Parallel components will indeed be
simultaneously active. To avoid violation of the
Mode-Automata semantics, the Parallel component
is not itself a mode, but contains sets of modes. Since
the sub-components are not instantiated at the same
level as the Parallel components this does not conflict with the Mode-Automata theory.
Since the Parallel component is not a mode, it is not
conditional. There is, however, no need for this,
since Parallels are placed inside Composites, and
thus inherit the conditional behavior of the parent
Composite. Note that a Parallel can be placed at the
top level. In fact, this is the intended way to define a
top level ModeGraph, since the top component of a
graph should always be active.

264

Modelica 2008, March 3rd  4th , 2008

ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata

7

Application Example 
Harels wristwatch

When David Harel introduced Statecharts in [2], he
identified and mapped the behavior of a Citizen
Quartz Multi-Alarm III wristwatch using the new
semantics. This complex, yet comprehensible graph
has been realized in ModeGraph as a case study. Selected parts of the ModeGraph implementation of
Harels wristwatch [2] will be used to illustrate the
functionality of the mode concept. The main interface of the ModeGraph implementation is shown in
Figure 23. It is comprised of a main display, buttons
for interaction, and indicator lamps to show the
status of the alarms.

Figure 25: ModeGraph realization of Update.

Declaration of the Step components should according to the proposed mode declaration look like:
Step second equation
inc_time_second = 1;
end equation;
Step minute equation
inc_time_second = 60;
end equation;
Figure 23: ModeGraph Wristwatch main window.

More information about this implementation of
Harels wristwatch can be found in [3].
An example where the mode semantics becomes
very convenient can be found in the time update
mechanism of Harels wristwatch. In update mode,
different time quantities can be traversed by pressing
a button, c. When another button, d, is subsequently
pressed, the quantity defined by the active state is
incremented, see Figure 24.

Figure 24: Update mechanism of wristwatch.

The ModeGraph realization of Update is shown in
Figure 25.

The Modelica Association

Step day equation
inc_time_day = 1;
end equation;
Hence, inc_time_second would, e.g., be automatically gathered into a single if-statement like:
inc_time_second =
if second.enable
or second.enableSubBlocks then
1
elseif minute.enable
or minute.enableSubBlocks then
60
...
else pre(inc_time_second);
...

Harels wristwatch contains a state, chime-status,
shown in Figure 26. This state controls the chime
function that is an alarm that sounds every whole
hour that may be either enabled or disabled. Additionally, when enabled, it can be either quiet (the
default) or beeping every time the clock reaches a
whole hour. Notice that when chime-status is
active, it can be left regardless of which of the internal states is active. The ModeGraph realization of
chime-status is shown in Figure 27. Recall that
every time a ModeGraph Composite turns inactive,

265

Modelica 2008, March 3rd  4th , 2008

M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter

Figure 28: Stopwatch.

Figure 26: Chime  Status.

interactions between all child states are frozen and
no code within the block is evaluated. Hence, if the
Composite is activated anew, the last active subblocks will once again be active. When entering state
enabled, sub-state quiet should be activated by
default. In the ModeGraph realization, the step representing state quiet is connected to the entry point.
Hence, entering enabled through the inport, resetStates becomes true, and the Step connected to
the entry point will be active.

When the states display and run are entered, the
stopwatch starts running (state on) and displays
regular time (state reg). Pressing button b, the user
can turn the stopwatch on/off. Pressing button d has
different meanings depending on the current active
state of run. If the stopwatch is running, pressing
button d switches between display modes regular
and lap. If instead the stopwatch is in state off,
button d is used to exit to state zero, thus resetting
the time of the stopwatch. The ModeGraph realization of the stopwatch is shown in Figure 29.

Figure 29: ModeGraph realization of Stopwatch.

Figure 27: ModeGraph realization of Chime-Status.

The state stopwatch in Harels wristwatch is a
good example of the need of flexible parallel states
that support easy synchronization. The Stopwatch
can either display zeros or the running/frozen time,
depending on the context of the parallel states display and run, see Figure 28.
The Modelica Association

An additional Composite displayrun is introduced
to encapsulate the two parallel states display and
run, see Figure 30. The transition condition d(in on)
in Figure 28 becomes true when button d is pressed
and state on is active. It is realized in ModeGraph by
the state on (in Parallel run) sending its state out on
the bus, which is read by the transition
reg_d_in_on located in the Parallel display. This
is a good example of how inter-mode

266

Modelica 2008, March 3rd  4th , 2008

ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata

or Statechart-oriented. Graphically, ModeGraph provides a modern look and feel with components based
on Modelica 3.0 graphical annotations. Furthermore,
the Mode-Automata semantics offers a convenient
way of managing complex conditional structures for
the user. Large-scale systems will successfully draw
advantage of the fact that only relevant parts of the
code (i.e., the code of the current active modes) are
evaluated. The conditional structure also prevents the
user from unintentionally abusing the available components in dangerous ways without having extensive
code overhead.

9

This work was in parts supported by the
ITEA2 EUROSYSLIB project
(http://www.itea2.org/public/project_leaflets/EURO
SYSLIB_profile_oct-07.pdf).

Figure 30: Contents of the ModeGraph Composite
displayrun.

communication can be performed with expandable
connectors, often called buses. This is an important
difference in ModeGraph compared to other types of
state machines. Since ModeGraph is implemented in
Modelica and modes are basic blocks, the variables
in a mode block are local variables. In other formalisms, variables are usually available as global entities
on all levels. For embedded systems the ModeGraph
approach is safer, since variables of composites are
encapsulated.
Also note, in Figure 30, how Steps off and reg are
connected to the exit points of their respective Parallel parent. When both these Steps are active, Parallels run and display both declare themselves findisished,
which
enables
transition
playrun_d_in_off in Figure 29 to fire, since its
allSubBlocksFinished attribute will return true.
What has just been discussed is the core functionality
of the ModeGraph library. The possibility of simply
ignoring equations within a disabled mode, that also
are guaranteed to be mutually exclusive with respect
to other modes on the same level, reduces code and
introduces powerful properties allowing equations to
be associated with modes.

8

References

Conclusions

In this paper the ModeGraph library has been introduced. The motivation for ModeGraph originates in
the inadequacy of StateGraph in terms of implementing Statechart-oriented state machines. ModeGraph
offers improved flexibility of graphical modelling of
state machines, regardless if they are SFC/Grafcet-

The Modelica Association

Acknowledgement

267

[1] Andr, C. (2003): Semantics of S.S.M (Safe State
Machine). I3S Laboratory  UMR 6070 University
of Nice-Sophia Antipolis / CNRS.
http://www.i3s.unice.fr/~map/WEBSPORTS/Docu
ments/2003a2005/SSMsemantics.pdf
[2] Harel, D. (1987): Statecharts: A Visual Formalism for Complex Systems. Science of Computer
Programming 8, 231-274. Department of Applied
Mathematics, The Weizmann Institute of Science,
Rehovot, Israel.
http://www.inf.ed.ac.uk/teaching/courses/seoc1/20
05_2006/resources/statecharts.pdf
[3] Malmheden, M. (2007): ModeGraph  A ModeAutomata-Based Modelica Library for Embedded Control. Masters thesis, Department of
Automatic Control, Lund University,Sweden.
http://www.control.lth.se/database/publications/arti
cle.pike?artkey=5808
[4] Maraninchi, F. and Rmond, Y. (2002): ModeAutomata: a New Domain-Specific Construct
for the Development of Safe Critical Systems.
http://wwwverimag.imag.fr/~maraninx/SCP2002.html
[5] Otter, M., rzn, K.-E., Dressler, I. (2005): StateGraph - A Modelica Library for Hierarchical
State Machines. Proceedings of the 4th International Modelica Conference. TU-HamburgHarburg, Germany.
http://www.modelica.org/events/Conference2005/o
nline_proceedings/Session7/Session7b2.pdf
[6] AFCET. (1997): Normalisation de la representation du cahier des charges dun automatisme logique. J. Automatique et Informatique Industrielle.
[7] IEC Standard 61131-1 http://www.iec.ch/

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

268

Modelica 2008, March 3rd  4th , 2008

A new Approach for Modeling and Verification of Discrete Control Components within a Modelica
Environment

A new Approach for Modeling and Verification of Discrete Control
Components within a Modelica Environment1
Ulrich Donath
Jrgen Haufe
Fraunhofer-Institute for Integrated Circuits, Design Automation Division
Zeunerstrae 38, 01069 Dresden, Germany
ulrich.donath@eas.iis.fraunhofer.de juergen.haufe@eas.iss.fraunhofer.de
Torsten Blochwitz
Thomas Neidhold
ITI GmbH
Webergasse 1, 01067 Dresden, Germany
torsten.blochwitz@iti.de thomas.neidhold@iti.de

Controller as
UML Statechart Model

Modelica Code Generation
lR_Commands

Physical System Model

The Modelica Association

sensor

Vt=0.04

v3

Vt=0.04
sPlus1
Vt=0.04
sMinus1

v4

v1

+

screw

Vt=0.04

Introduction

The modelling of discrete and hybrid control algorithms [1] is not a novel application area for Modelica. In the last years, Modelica libraries for Petri
Nets [2] [4], Statecharts [3] or StateGraph [5] were
introduced. Furthermore, the extension of Modelica
with a new statechart section is discussed in [6].
In this paper, we present a new approach for modeling and verification of discrete control components
within a Modelica environment. In contrast to the
solutions mentioned above, we create the control
component models of the physical system outside
Modelica. The other modules of the physical system

v2

VDC=12

s

Logic

sPlus2

1

lR_Controller

sMinus2

The paper presents the use of a subset of UML Statecharts to model discrete control components together
with the physical model within a Modelica simulation environment. In addition, we show how statecharts can also be used to describe assertions charts
for checking the compliance of user defined model
properties and model behaviour during simulation.
As the main difference to other approaches, neither
Modelica language enhancements nor special libraries are necessary. The statechart model is automatically mapped onto standard Modelica constructs and
can be simulated with any common Modelica standard simulator. Controlled by the user, the Modelica
model can be automatically instrumented by additional Modelica code to examine the state coverage
and transition coverage during simulation.
Keywords: state machine; statechart; control system,
assertions, state coverage, transition coverage

are modeled as usual in the Modelica environment.
In a second step, Modelica standard code is generated for the control components automatically. The
insertion of the generated code into the Modelica
physical model completes the system model (Fig. 1).

-

Abstract

ballScrewDrive

mass

GND
J=0.001

DC_Motor

Fig. 1: Using UML Statecharts in SimulationX [9]
As modeling language for the control components
we use a subset of UML Statecharts [7]. We derived
the subset from an analysis of typical control algorithms in the domains mechanical and automotive
engineering.
Besides control components, UML Statecharts
proves to be suitable for robust modeling of physical

269

Modelica 2008, March 3rd  4th , 2008

U. Donath, J. Haufe, T. Blochwitz, T. Neidhold

effects or technical sub-systems with discrete states
(friction, hysteresis, valves, switches, etc.).
For our approach we see following advantages:
 UML Statecharts are well established for modeling of control algorithms, especially for reactive
systems.
 The statechart creation outside Modelica allows
the use of off-the-shelf UML development tools.
 The approach provides not only an interface to
Modelica. The approach is also open to interface
specialized verification tools esp. formal verification tools.
 In the sense of model based design, the approach
is expandable for generation of production code
for different targets such as PLCs or embedded
controllers.
 The generated Modelica code can be simulated
with any common Modelica simulator.
For UML Statechart entry, an additional Graphical
User Interface (GUI) containing a UML Statechart
editor is necessary which comes usually with the
UML development tool. The UML tool should meet
following requirements:
 The GUI as well as the UML tool code generator
needs the ability to be customized.
 The UML tool should support the interaction
between GUI and generated code to establish a
comfortable visualization and animation.
In section 5 we present an UML Statechart editor
which is completely integrated into the GUI of SimulationX [9].
The paper is organized as follows. Section 2 gives an
overview on the supported UML Statechart subset.
In section 3 some techniques are introduced which
allow an efficient verification of the statechart models. Section 4 presents a prototypic implementation
of our approach. An outlook on future work is given
in section 5.

2

UML Statechart Subset

In this section we present the subset of UML Statecharts which is implemented in our prototype (see
section 4). The subset contains the minimum of
UML Statechart constructs to model a control component in a comfortable way:
 States: Simple States, Non-Concurrent Composite States, Pseudo States.
 Transitions: Signal Triggers, Change Triggers,
Time Triggers, Guards.
The Modelica Association

 Activities: Modelica text.
The UML Statechart subset as well as the resulting
Modelica code is illustrated with a linear drive as an
example.
2.1

Example

The linear drive (Fig. 2) is controlled by the Controller module. Inputs for the Controller are the operator
commands Run and Halt as well as the position x of
the linear drive. As output, the controller delivers the
DC motor supply voltage U=-10V for left run,
U=+10V for right run and U=0V for stop.
The specification of the controller is such as follows:
 Start after Run is given and drive to left
 Run 10 times between left and right end position
 Pause 3 seconds, afterwards continue
 Stop immediately after command Halt was given
 Restart with the action which was suspended after
Halt, when Run is given again.
The physical system model of the linear drive example depicted in Fig. 2 is a simplification of the more
complex model shown in Fig. 1.

Fig. 2: Over-all structure of the linear drive
2.2

States

The control program (Fig. 3) is divided into the
states Stop and Go. Stop is a simple state, whereas
Go is a composite state with the nested simple states
GoLeft, GoRight, and Pause. In consideration of hierarchy, the graph with the states Stop and Go is the
top-level graph, implicit denoted as Main. The subjacent graph comprises the sub-states of Go.
For Modelica representation of state activities and
state transitions, a state variable is declared for each
hierarchy level. Their type declarations contain the
enumerations of the state names. Each composite
state is added with the enumeration InActive to indicate the inactivity of the composite state.

270

Modelica 2008, March 3rd  4th , 2008

A new Approach for Modeling and Verification of Discrete Control Components within a Modelica
Environment

2.2.1 Simple States
In our subset, simple states may optionally have entry-activities, exit-activities, and activities which are
initiated by internal transitions. These activities are
simple Modelica algorithms. Modelica when-clauses
are not allowed here.

into multiple outgoing transitions. A shallow history
stores the most recent active sub-state of a composite
state after leaving it. When the composite state is
newly entered via shallow history this sub-state becomes active again.
2.3

Transitions

Following kinds of transitions may be used: simple
transitions (connecting two states), self-transitions
(the same state acts as both the source and the destination), compound transitions (connecting many
states via junction pseudo states), group transitions
(originating from composite states), and internal
transitions of simple states. A trigger, a guard, and a
transition-activity may label a transition.
The triggering of a group transition implies the exiting of all the sub-states of the composite state and
executing their exit-activities starting with the innermost states. An internal transition executes without exiting or re-entering the state in which it is defined.
In our approach, each transition is triggered with a
single trigger as described below.

Fig. 3: Statechart model of the control program
2.2.2 Composite States
In comparison to simple states, composite states are
extended each with a composition compartment. In
our approach, this compartment comprises only one
region of sub-states  this means, concurrency of
activities can not occur within one statechart instance. Concurrency is only possible between multiple statechart instances.
In the generated Modelica code, all entry-activities
of the nested sub-states are gathered in a
when-clause separately (see 2.4 Entry-activities of
Go). All other activities are included in an if-clause
which describes the transitions of the composite
state.

2.3.1 Signal Trigger
Generally, a signal trigger represents the receipt of
an asynchronous signal instance [7]. In our interpretation, a signal is either a record typed message with
e.g. one integer and real component or a boolean
typed variable, typically a controller input command.
Every new signal is notified by toggling a flag which
is an additional component of the message. In case of
a boolean variable, Run and Halt in the example, the
variable itself is toggled.
Signals are produced either by modules of the physical system or inside the statechart instance.
Signal type definition:
type SignalT = record SIGNAL
Boolean flag;
Integer int_val;
Real
real_val;
end SIGNAL;

Signal assignment in physical system module:
2.2.3 Pseudo States
We support following pseudo states: initial state,
junction, and shallow history. An initial state indicates the default starting point of processing the
statechart or a composite state. A junction merges
multiple incoming transitions into a single outgoing
transition, or conversely, split an incoming transition

The Modelica Association

SignalT Run;
when ( time >= 1 ) then
Run.flag := not Run.flag;
Run.int_val := 100;
end when;

A toggled signal is detected by the Modelica changefunction, for instance change (Run.flag).

271

Modelica 2008, March 3rd  4th , 2008

U. Donath, J. Haufe, T. Blochwitz, T. Neidhold

In addition to UML, signals can be also defined in a
Signal Definition Table (Fig. 4). In the table, signal
events are derived from the achievements of predefined thresholds of physical system quantities or of
internal statechart variables.

Fig. 4: Example of the Signal Definition Table
2.3.2 Change Trigger
A change trigger specifies an event that occurs when
a boolean-valued expression becomes true as a result
of a change in value of one or more attributes [7]. In
UML the life time of the change event is a semantic
variation point. Related to control tasks, in our approach the change event remains true as long as the
evaluation of the change expression results in true. In
our linear drive example, change triggers are
x < LimitLeft, x > LimitRight, and count > N_Max.
The Modelica representation of this behavior is
given by an if-clause in the transition block (see 2.4
Transitions of Go).

transition does not fire and the event is lost. In the
linear drive example, the guards [dir==DirT.Left],
[dir==DirT.Right] determine the target sub-states of
Go after the Run command is given.
2.3.5 Firing Priorities
It is possible that more than one transition could be
concurrently fired to change the state, e.g., they have
the same trigger event and their guard expressions
results in true. Then, in UML, an implicit priority
rule is applied based on the relative position of the
source state in the state hierarchy [7]. In addition, we
allow the user to assign the transition priorities explicitly. A transition priority is denoted by a number
1, 2, 3 where 1 symbolizes the highest priority.
These priorities are depicted near the start points of
the transition arrow lines. Chosen by the user, the
priorities of group transitions are either higher or
lower than priorities of inner transitions of composite
states.
The resulting priority number determines the position of the transition in the check for firing. In the
linear drive example, Halt shall have the highest priority to stop the machine, especially in case of an
emergency.
2.4

Over-all Modelica Code Structure

2.3.3 Time Trigger
A time trigger specifies a time event, which models
the expiration of a specific deadline [7]. We restrict
the deadline to a relative expression. The expression
is relative to the time of entry into the source state of
the transition triggered by the event, e.g. after
(t_Pause). The time event is generated only if the
state machine is still in that state when the deadline
expires.
In Modelica this behavior is reflected in following
steps: Firstly, if the source state entry is detected in a
when-clause, a time variable is set to the time limit
(see 2.4 Entry-activities of Go). Secondly, a whenclause checks if the simulation time exceeds the time
limit. If true, a timeout signal is toggled. This whenclause belongs to the event generation block of the
module (see 2.4 Event generations). Thirdly, if the
source state will inactive due to another transition,
the time variable is reset.

The Modelica representation of a statechart consists
of following sections:
 Declaration of state variables, input/output signals, internal signals, system variables, auxiliary
variables, parameters.
 Initialization of state variables and auxiliary
variables, execution of initial transition activities
(when-clause).
 Event generation block: generation of signal
events according to signal event definition table,
generation of timeout events (when-clauses).
 Entry-activity block: detection of state entries,
execution of entry-activities, assignment of time
limits to time variables, generation of completion
events of composite states (when-clauses).
 Transition block: event detection, assignment of
next state, execution of exit-activities and transition-activities, reset of time variables (ifclauses).

2.3.4 Guards
A guard is a Boolean expression written in terms of
parameters of the triggering event or attributes of the
context object [7]. It is evaluated only once whenever its associated event fires. If it is false, then the

For the linear drive example the Modelica code is
given below. To shorten, the declaration section is
omitted.

The Modelica Association

272

Modelica 2008, March 3rd  4th , 2008

A new Approach for Modeling and Verification of Discrete Control Components within a Modelica
Environment
Module Controller

Transitions of Go:
if (pre(goState)==GoStateT.GoLeft) then
if (change(Halt)) then
goState:=GoStateT.InActive;
ontoMainState:=MainStateT.Stop;
elseif (x<LimitLeft) then
goState:=GoStateT.GoRight;
end if;
elseif(pre(goState)==GoStateT.GoRight)then
if (change(Halt)) then
goState:=GoStateT.InActive;
ontoMainState:=MainStateT.Stop;
elseif (count>N_Max) then
goState:=GoStateT.Pause;
elseif (x>LimitRight) then
goState:=GoStateT.GoLeft;
end if;
elseif (pre(goState)==GoStateT.Pause)then
if (change(Halt)) then
t_PauseFinished:=time;
goState:=GoStateT.InActive;
ontoMainState:=MainStateT.Stop;
elseif (change(timeout) then
goState:=GoStateT.GoRight;
end if;
end if;

Initialization:
when initial()then
mainState:=MainStateT.Stop;
ontoMainState:=MainStateT.Stop;
goState:=GoStateT.InActive;
entryGoState:=GoStateT.InActive;
LimitLeft:=-0.4; LimitRight:=0.4;
t_Pause:=3;
t_PauseFinished:=0;
count:=0; N_Max:=10;
dir:=DirT.Left;
timeout:=false;
completeGo:=false;
end when;

Event generations:
when (time>=t_PauseFinished) then
timeout:=not timeout;
end when;

Entry-activities of Main:
when (mainState==MainStateT.Stop) then
U:=0; count:=0;
elsewhen (mainState==MainStateT.Go) then
goState:=entryGoState;
end when;

Entry-activities of Go:
when (goState==GoStateT.GoLeft) then
U:=-10; count:=count+1;
dir:=DirT.Left;
elsewhen (goState==GoStateT.GoRight) then
U:=10; count:=count+1;
dir:=DirT.Right;
elsewhen (goState==GoStateT.Pause) then
U:=0; count:=0;
t_PauseFinished:=time+t_Pause;
elsewhen (goState==GoStateT.InActive) then
completeGo:=not completeGo;
end when;

Transitions of Main:
if (pre(mainState)==MainStateT.Stop) then
if (change(Run)) then
if (dir==DirT.Left) then
mainState:= MainStateT.Go;
entryGoState:=GoStateT.GoLeft;
elseif (dir==DirT.Right) then
mainState:= MainStateT.Go;
entryGoState:=GoStateT.GoRight;
end if;
end if;
elseif(pre(mainState)==MainStateT.Go)then
if (change(completeGo)) then
mainState:=ontoMainState;
end if;
end if;

The Modelica Association

end Controller;

3

Verification

The main tool for the verification of the Modelica
model is the simulator. In this section we describe
techniques to increase the efficiency of the simulation based verification: Design Rule Check, State
Coverage Analysis and Transition Coverage Analysis, and Assertion Charts.
3.1

Design Rule Check

During graphical entry and compilation of statecharts
the following design rules are currently checked:
 Only one initial state is allowed on each hierarchy level.
 An initial state has exactly one outgoing transition. Trigger and guards are not allowed.
 Pseudo states must not connected by transitions.
 A split junction has only one incoming transition. Only this transition has a trigger.
 A merge junction has only one outgoing transition. Only this transition has a trigger.
 Self-transitions are not allowed for composite
states.
 Each state, except initial state, has at least one
incoming transition.
273

Modelica 2008, March 3rd  4th , 2008

U. Donath, J. Haufe, T. Blochwitz, T. Neidhold



3.2

Isolated sub-graphs are not allowed.
A warning is given when some outgoing transitions of one state have the same priority number.
State and Transition Coverage

The analysis of both state activations and transition
activations are measures for the achieved functional
coverage during the simulation run.
To measure the activation of states and transitions,
additional Modelica code is automatically inserted
into generated Modelica code (described in section
2.4) by the Modelica code generator (see section
4.2). The additional code basically consists of a set
of counters. A unique counter is associated with any
entry-activity block and any transition block. The
counters are implemented as integer vectors. Every
state or transition activation leads to an increment of
the associated counter component.
For comfortable use, the actual achieved counting
results may continuously back-annotated into the
UML Statechart schematic.

In our case, the charts are composed like ordinary
statecharts and run simultaneously to them. We deliver a set of typical Assertion Charts concerning
dedicated event sequences and time limits. The predefined Assertion Charts are parameterized.

4

Implementation Prototype

The section introduces the first implementation of
our approach into the SimulationX Modelica environment [8][9]. The implementation consists of the
components Statechart Editor, Modelica Code Generator, Run Time Visualization (simulation driven
statechart animation, association of the State Coverage and Transition Coverage Analysis results). All
additional functionality can be controlled by the user
within the SimulationX GUI. For easy use, a set of
typical control domain Assertion Charts comes with
the implementation.
4.1

Statechart Editor

Our Assertion Chart approach is derived from [10].
Assertion Charts aim for watching the behavior of
the system in respect of specified properties. With
the help of Assertion Charts, we describe both nontemporal and temporal system properties which have
to be examined.
For the linear drive, e.g., an assertion may be: If the
DC motor supply voltage U alters to U > 0, then
drive position x will exceed its limit within T seconds, otherwise a fault will be reported (Fig. 5).

The Statechart Editor (Fig. 6) is seamlessly integrated into the SimulationX framework. The Statechart Editor has the following features:
 Schematic entry of the statecharts,
 Definition of statechart activities as Modelica
code,
 Definition of triggers,
 Definition of local types, variables and parameters,
 Definition of the interface to the physical system.

Fig. 5: Assertion Chart example of the linear drive

Fig. 6: Statechart Editor window

3.3

Assertion Charts

The Modelica Association

274

Modelica 2008, March 3rd  4th , 2008

A new Approach for Modeling and Verification of Discrete Control Components within a Modelica
Environment

Pressing the compile button starts the Modelica Code
Generator. The structure of code is outlined in section 2.4.
4.2

Modelica Code Generator

The Modelica Code Generator generates standard
Modelica code from the UML Statechart model. The
code is user-driven instrumented with additional
code to perform the State Coverage Analysis and
Transition Coverage Analysis and to associate Assertion Charts with selected signals. In addition, the
Modelica Code Generator accomplishes the Design
Rule Check. Besides Modelica code the generator
architecture is open to generate code for various targets such as formal verification tools or production
code for PLCs or embedded controllers.
4.3

Fig. 8: Wave-forms of the linear drive example

Runtime Visualization

SimulationX supports the visualization of statecharts
at runtime by a specialized view. During simulation
the active state and the latest transition are highlighted if a time step or time interval is completed
(Fig. 7). Controlled by the user, state and transition
coverage are also displayed. The actual state and
transition counter readings are annotated on the
states and on the end points of transitions, respectively.

Fig. 7: Back-annotation of active states
For checking the functionality of whole system, the
common view of internal controller variables and
variables of the equipment are essential. Therefore
all variables of the statechart, inclusive the state
variables, may be accessed by the user.
In case of the linear drive example the causality of
the system behavior (Fig. 8) is reflected by the signals Run and Halt of the operator, the variables
goState and count of the controller, its output U, and
the position x of the drive. The correlations between
these quantities may be checked by assertion charts
during the simulation.
The Modelica Association

5

Conclusions

We have applied our methodology to control systems
in the area of automotive, robotics and manufacturing systems engineering. The approach introduced in
the paper proves to be very comfortable for modeling
of control components and physical system within
the SimulationX environment. Especially the integrated verification support decreases modeling and
simulation cycles and leads to robust control components with high test coverage in relative short time.
Our next steps are the successive extension of the
approach to a Modelica model based design environment for control algorithms.
Next steps are:
 Enhancements in code generation
Right now, we generate Modelica code to validate
the control component behavior within the physical system. For the implementation of the control
component models, target code has to be derived
from the models according to the target hardware
platform, e.g. for PLC systems or embedded systems.
 Enhancements in formal verification
In the recent years, considerable progress has
been achieved in the field of formal verification
tools for model checking especially for digital integrated circuit verification. Therefore, we are encouraged to interface our modeling approach to
selected model checker tools by transformation of
our statechart models to the model checker input
description.

275

Modelica 2008, March 3rd  4th , 2008

U. Donath, J. Haufe, T. Blochwitz, T. Neidhold

References
[1]

Donath, U.; Haufe, J.; Schwarz, P.: MehrEbenen-Simulation automatisierungstechnischer Prozesse und Steuerungen (in German).
4. Fachtagung Entwurf komplexer Automatisierungssysteme, Braunschweig, pp. 543553, June 7-9, 1995
[2] Mosterman, P.J., Otter, M., Elmqvist, H.:
Modeling Petri Nets as Local Constraint
Equations for Hybrid Systems Using Modelica. Summer Computer Simulation Conference '98, Reno, Nevada, USA, pp. 314-319,
July 19-22, 1998
[3] Ferreira, J.A., de Oliveira, J.E.: Modeling
Hybrid Systems Using Statecharts and
Modelica. 7th IEEE International Conference
on Emerging Technologies and Factory
Automation, Barcelona, Spain, 18-21 Oct.,
1999.
[4] Fabricius, St.: Extensions to the Petri Net Library in Modelica. http://www.modelica.org,
2001
[5] Otter, M.; rzn, K.-E.; Dressler, I.:
StateGraph - A Modelica Library for Hierarchical State Machines. Proc. 4th Int. Modelica
Conf., Hamburg, Germany, March 7-8, 2005,
pp. 569-578.
[6] Nytsch-Geusen, Ch: The use of the UML
within the modeling process of Modelicamodels. Proc. ECOOP, Berlin, Germany,
July 30, 2007.
[7] UML Superstructure Specification, v2.0.
http://www.omg.org
[8] Neidhold, Th. et al: Modeling of State Machines in SimulationX. 10th ITI Simulation
Workshop, Dresden, Germany, September
20-21, 2007.
[9] http://www.simulationx.com
[10] Drusinsky, D: Modeling and Verification Using UML Statecharts. Elsevier Inc., Oxford,
2006
1

The project was founded by the European Regional Development
Fund (ERDF) and by the Free State of Saxony in the framework of
technology promotion.

The Modelica Association

276

Modelica 2008, March 3rd  4th , 2008

Session 3b
Thermodynamic Systems & Applications

The Modelica Association

277

Modelica 2008, March 3-4, 2008

The Modelica Association

278

Modelica 2008, March 3rd  4th , 2008

Model-Based Online Applications in the ABB Dynamic Optimization Framework

Model-based online applications in the
ABB Dynamic Optimization framework
Rudiger Franke
ABB Power Technology Systems
Mannheim, Germany

B.S. Babji
ABB Corporate Research
Bangalore, India

Marc Antoine
ABB Power Technology Systems
Baden, Switzerland

Alf Isaksson
ABB Corporate Research
Vasteras, Sweden

Keywords: technical calculations, model-based sim- nology. Aspect Objects relate plant data and funculation, model tuning, online optimization, model- tions  the aspects, to specific plant assets  the obbased control, 800xA, Modelica, HQP
jects. Aspect objects represent real objects, such as
process units, devices and controllers. Aspects are informational items, such as I/O definitions, engineering
Abstract
drawings, process graphics, reports and trends that are
assigned to the objects in the system.
ABB Dynamic Optimization is an extension for the
Aspect Objects are organized in hierarchical structures
control system 800xA. Exploiting the Aspect Objects
that represent different views of the plant, such as
technology of 800xA, Dynamic Optimization allows
Functional Structure and Location Structure. One obthe seamless integration of model based applications,
ject may be placed multiple times in different strucsuch as model-based process control. Running offline
tures. The idea of placing the same object in multiple
and online using one and the same software environstructures is based on the IEC standard 1346 [7, 2].
ment, Dynamic Optimization provides an attractive
framework to apply offline results online, in order to
2.2 Dynamic Optimization architecture
optimize the efficiency of an industrial process.

1

Introduction

Industrial plants search for powerful diagnostic and
optimization tools to monitor and predict plant performance, issue early warnings for equipment diagnosis,
sensor validation and preventive maintenance. New
modeling technologies and increasing computational
power make the online application of computer simulations more and more attractive.
This paper shows how the Modelica technology is exploited in the Industrial IT Extended Automation System 800xA using the Dynamic Optimization framework.

2

Dynamic Optimization framework

2.1 Industrial IT System 800xA
The architectural framework for the Industrial IT System 800xA is built upon ABBs Aspect Object techThe Modelica Association

Figure 1 gives an overview about the software architecture. Many existing software interfaces and components that are intended for process control are reused by Dynamic Optimization for model-based applications. These are in particular the connectivity to
a process and the treatment of trend&history data using OPC DA and OPC HDA technology, respectively.
Furthermore, these are operator graphics, alarms and
events, as well as a common configuration database.
Dynamic Optimization adds new software components for the management of model knowledge and for
running model-based activities. Model variables are
treated like process signals by allocating OPC properties in a simulation server.
The models are being built and tested with a modeling
application such as Dymola or MathModelica. Afterwards executable model code is exported to Dynamic
Optimization. The numerical solver HQP is employed
at runtime. HQP combines a large-scale nonlinear
optimization solver with ODE and DAE solvers, see
e.g. [5].

279

Modelica 2008, March 3rd  4th , 2008

R. Franke, B.S. Babij, M. Antoine, A. Isaksson

Figure 1: Software architecture of the Dynamic Optimization framework.
Excel serves as intermediate data layer between the
modeling application and the control system. This allows to make small changes, e.g. to change parameter
values, at runtime. Moreover advanced model based
activities, including optimization objectives and constraints not covered by Modelica, can be specified in
Excel. Furthermore, an activity can be archived in
an Excel file, including the parameterization of the
model, solver settings, used process data, and results.
The use of standard interfaces and independent applications for modeling and numerical solution does not
only provide for seamless integration re-using existing tools, but it also gives more flexibility regarding
the framework itself. This way for instance research
studies can be done in a platform more appropriate for
research. As the same tools are used, the platform can
easily be changed to deploy research results later on.
Take the industrial case study [9] for example. The research on model predictive control of batch processes
has been done using Matlab and Simulink as platform,
together with the HQP numerical solver and OPC process interfaces [9]. Using Dynamic Optimization, the
research results can be deployed in the control system
800xA by running the same model code and using the
same solver.
The Modelica Association

2.3

Introductory example

Consider one wants to perform a simple calculation
online, like the determination of the efficiency of a preheater in a power plant. According to water-tube boilers standards [4], the efficiency of a heat exchanger is
defined as
T22  T21
(1)
=
T11  T21
with T11 and T21 the inlet temperatures at primary and
secondary side, respectively, and T22 the outlet temperature at the secondary side.
The heat exchanged in a preheater mostly results from
the condensation of the fluid at the primary side. This
is why the inlet temperature T11 is not used directly
from a measurement. It is replaced by the saturation
temperature Tsat (p11 ) for a measured pressure p11 at
the primary side. This gives a more reliable value for
the preheater efficency.
The calculation can be set up graphically in a Modelica tool, see Figure 2. The block heatExchangerEfficiency contains the general calculation given in (1).
The saturation temperature Tsat (p11 ) is calculated for
a measured p11 using a function available in the standard Modelica.Media library.
In order to run the calculation in the control system
800xA, first appropriate Aspect Objects have to set

280

Modelica 2008, March 3rd  4th , 2008

Model-Based Online Applications in the ABB Dynamic Optimization Framework

Figure 2: Graphical implementation of a preheater efficiency calculation in Dymola.

Figure 3: PreheaterEfficiencyMeter in 800xA Plant Explorer Workplace.
The Modelica Association

281

Modelica 2008, March 3rd  4th , 2008

R. Franke, B.S. Babij, M. Antoine, A. Isaksson

up. They can be created from the modeling application Dymola by invoking the menu command Create aspect object PreheaterEfficiencyMeter in 800xA.
The menu command is included as annotation in the
model, being accessible from Dymola and calling the
according system command provided by Dynamic Optimization. The hierarchical structure of Aspect Objects in 800xA corresponds to the package structure in
Modelica, see Figures 2 and 3.
The model can be deployed with the menu command
Deploy model PreheaterEfficiencyMeter to 800xA.
The deployment process consists of multiple steps that
have been automated. First the model is translated and
an executable dynamic link library is created. Three
aspects are configured in 800xA for the Aspect Object
PreheaterEfficiencyMeter, see Figure 3 and the relation to the software architecture shown in Figure 1:
1. The Modelica Model aspect declares the interface
of the model through inputs, outputs, parameters
and states. Moreover the model aspect contains
attributes like value, unit and description for each
model variable. The empty columns Refd Object, Refd Aspect, Refd Property can be
used to link model variables to signals in the control system.
2. The Control Connection aspect declares OPC
properties for the model variables, which are
served by the Simulation Server.

online determination of thermal stress and the implementation of lifetime counters for critical components
of a power plant. Further applications cover the online
determination of the plant efficiency.
Such technical calculations are normally set up to run
automatically on a specified sample time interval. The
results of the calculations are added as new signals to
the control system.

3.2

Model-based simulation

Modelica is designed to allow convenient, componentoriented modeling of complex physical systems.
Available model libraries significantly simplify the
object-oriented modeling process. Such models can
run online to analyze and optimize the modeled process. Further applications of model-based simulation
include the training of plant operators and the validation of automatic controllers.
Take soot blowing, a cleaning mechanism for steam
boilers, as example. Due to constant fouling, the heat
transfer coefficient in superheaters and the steam pressure decrease during the operation of a recovery boiler.
Soot blowing is applied to clean the boiler.
The modeling and simulation study [8] describes the
dynamic modeling of a recovery boiler of a paper mill
in Modelica, in order to simulate the effects of fouling
and soot blowing on drum pressure and heat transfer
coefficients.

3. The Dynamic Calculation aspect links the model 3.3 Estimation and optimization
to the solver and defines solver settings like samPrior to an online application, a model normally needs
pling rate for the calculation.
to be tuned. Unknown model parameters, such as heat
Besides the aspects, also the Simulation Server for transfer coefficients, need to be estimated based on
OPC properties introduced by the model and the Dy- process data resulting from experiments. This can be
namic Optimization Service running HQP solver in- done using a Dynamic Estimation aspect. The experstances are updated during deployment.
iment data is directly available in 800xA through history Log Configuration aspects. The estimation setup
can be archived together with the used process data,
3 Model-based applications
solver settings and estimation results in an Excel file.
The use of Modelica gives access to a broad range of Moreover estimation can be configured to run online,
possible applications using a common modeling tech- in order to analyze the process or to validate measurements. Future development may involve addition
nology.
of model validation against separate data sets as well
as adding grey-box calibration methods similar to the
3.1 Technical calculations
ones described in [1].
Many calculations that are of interest for industrial Having a well tuned model, it can be used to optiapplications have been standardized. The water-tube mize the modeled process, such as the optimization of
boilers standards are an example [4]. The standardized steady-state setpoints or of transient control trajectoformulae and algorithms can be implemented in Mod- ries. The Dynamic Optimization aspect allows to setup
elica and evaluated online. This provides e.g. for the and solve optimization problems for a given model.
The Modelica Association

282

Modelica 2008, March 3rd  4th , 2008

Model-Based Online Applications in the ABB Dynamic Optimization Framework

Figure 4: Operator display for boiler startup optimization.
The solver HQP covers initial-value simulation problems for hybrid DAEs resulting from the translation
of a Modelica model. Mathematical optimization and
estimation problems, however, can currently only be
solved for a simplified hybrid DAE, containing no
state events. A formulation and solution of mixedinteger nonlinear optimization problems, as required
for instance for planning&scheduling of production
processes, may be subject of future development.

3.4

3.5

Model-based control

Applying Model Predictive Control (MPC) technology, a model can be used to predict the optimal operation of the process. The calculated predictions get applied in closed control loop. An example application,
that has been installed successfully in several power
plants, is the startup optimization of large steam boilers [6, 5]. Appropriate process models can be built
based on the Modelica.Media and Modelica.Fluid libraries [3].
Figure 4 shows an operator display used for boiler
startup optimization. Elements known from a regular
The Modelica Association

operator graphics, such as temperature measurements
and operator controls, are seamlessly integrated with
new elements resulting from the model based BoilerMax application, such as thermal stress values, stress
limits and predicted startup time. Furthermore, the results of the predictive startup optimization are accessible in a regular trend display showing the optimization
results as future process data.

Runtime scheduling and supervision

Individual model based activities can be performed
for a specified sample time or triggered by changing
process data on-line. However, more advanced runtime scheduling might be required for complex activities. For instance, one might want to synchronize
multiple activities, supervise solver times and implement specific error recovery strategies. Such advanced
runtime scheduling can be formulated in Modelica as
state graph [10]. In the Dynamic Optimization framework, a runtime scheduler is running as additional activity, triggering and supervising other activities, such
as state estimation and predictive optimization.

283

Modelica 2008, March 3rd  4th , 2008

R. Franke, B.S. Babij, M. Antoine, A. Isaksson

R
Figure 5: Overview about the ABB solution OPTIMAX
.

4

Optimizing energy efficiency in the 4.2 Minimize maintenance cost
power industry
Maintenance expenses are second only to fuel costs as

variable costs. The key to optimizing assets is often
having information that is accurate, timely and actionable. Clearly, the ability to act on reliable information
is as essential as having access to the information in
the first place.
Work preparation and planned condition-based maintenance are increasingly important for reduction of
R
downtime. The benefit of OPTIMAX
Maintenance
Management Solutions is to achieve and maintain a
high level of availability, quality and safety of the
4.1 Maximize operational performance & ef- plant. This applies to current plant operation but is
particularly valid for inspection, overhaul and service
ficiency
activities. For industrial users this leads to a higher
R

OPTIMAX operations solutions can handle utilities Return On Asset (ROA) which is a key driver of sharewith complex generation portfolios which are seeking holder value.
to minimize energy generation costs, be it electrical or
a combination of electrical and other forms of energy. 4.3 Reduce emissions & waste
In addition, deciding whether or not it makes sense
to buy or sell power or fuel, start or stop a unit, save The measurement and reduction of hazardous emislifetime, or postpone a preventive maintenance outage sions is increasing in importance and regulatory standards are getting stricter every day. Emission of greencan be easily answered.

The primary key to energy efficiency in the power industry is reducing the cost of fuel and consumables.
Industrial plants are huge energy consumers; therefore
small percentage savings can have a significant impact
on their bottom line. Figure 5 gives an overview about
R
the ABB solution OPTIMAX
, which uses Dynamic
Optimization as one tool, besides others.

The Modelica Association

284

Modelica 2008, March 3rd  4th , 2008

Model-Based Online Applications in the ABB Dynamic Optimization Framework

house gases now has measurable economic value and
operators have a real incentive to lower these emisR
environmental solutions resions. The OPTIMAX
duce emissions by monitoring flame quality, measuring coal flow and carbon in ash content, and providing Advanced Process Control (APC) which optimizes combustion, shortens boiler startup times and
improves efficiency.

4.4

References

Extend the Asset Life Cycle

From an economic perspective, plant managers seek
to balance their investment in new assets against perR
solutions
formance, risk and downtime. OPTIMAX
for lifecycle optimization of assets are able to schedule the most economical operation of different generating units and trade-off income from sales against
lifecycle costs. In addition, this approach is also capable of taking emission costs into account, i.e. more
stringent CO2 requirements may make plants that are
still mechanically functional uneconomic to run. The
advantage of these decision support tools is the ability to include plant ageing models to find the optimal operational strategy between maintenance outages, especially when operating under environmental
constraints.

5

Conclusions

[1] T. Bohlin. Practical Grey-box Process Identification  Theory and Applications. Springer, 2006.
[2] L.G. Bratthall, R. van der Geest, H. Hoffmann,
E. Jellum, Z. Korendo, R. Martinez, M. Orkisz, C. Zeidler, and J. S Andersson. Integrating
hundreds of products through one architecture 
the Industrial IT architecture. In International
Converence on Software Engineering. Orlando,
Florida, USA, 2002.
[3] H. Elmqvist, H. Tummescheit, and M. Otter. Modeling of thermo-fluid systems  Modelica.Media and Modelica.Fluid. In Proceedings of the 3rd International Modelica Conference. Modelica Association, Linkoping, Sweden,
November 2003.
[4] European committee for standardization. Watertube boilers standards. EN 12952, 2001.
[5] R. Franke and L. Vogelbacher. Nonlinear model
predictive control for cost optimal startup of
steam power plants. at  Automatisierungstechnik, 54(12):630637, 2006.
[6] R. Franke and B. Weidmann. Steaming ahead
with optimizing power plant boiler startup.
Power Engineering International  PEi, 15(6),
2007.

The Dynamic Optimization framework allows run[7] International Electrotechnical Commission. Inning model-based applications in the Industrial IT
dustrial systems, installations and equipment and
Extended Automation System 800xA. The Modelica
industrial products  structuring principles and
technology and the Aspect Object technology of Sysreference designations. IEC Standard 61346,
tem 800xA are integrated seamlessly. Dynamic Opti1996.
mization provides software components that establish
links between industrial control and the world of phys- [8] Tarun Prakash Mathur and B.S. Babji. Object
oriented approach to dynamic modeling of recovical modeling and simulation.
ery boiler in Modelica. In Proceedings of Intl.
Simple model based simulations can be deployed diConf. on Modeling and Simulation. Coimbatore,
rectly from a graphical modeling application, such as
India, August 2007.
Dymola or MathModelica. Excel is used as intermediate data layer. This allows the treatment of advanced
[9] Z.K. Nagy, B. Mahn, R. Franke, and F. Allgower.
solver settings, such as optimization constraints, and
Nonlinear model predictive control of batch proof process data used for offline applications, such as
cesses: an industrial case study. In 16th IFAC
experiment data used for parameter estimation.
World Congress. Prague, Czech Republic, July
A broad range of model-based applications is becom2005.
ing possible. Examples are the simulation of recovery
boilers in pulp mills [8], model predictive control of [10] M. Otter, J. Arzen, and A. Schneider. Statebatch processes [9], and cost optimal startup of power
Graph  a Modelica library for hierarchical state
plants [5].
machines. In Proceedings of the 4th International Modelica Conference. Modelica AssociaThe optimization of energy efficiency is a particular
tion, Hamburg-Harburg, Germany, March 2005.
application area of high interest.
The Modelica Association

285

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

286

Modelica 2008, March 3rd  4th , 2008

Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model

Using Modelica/Matlab for parameter estimation in a
bioethanol fermentation model
Juan I. Videla Bernt Lie
Telemark University College
Department of Electrical Engineering, Information Technology, and Cybernetics
Porsgrunn, 3901 Norway

Abstract
Bioethanol production from fermentation of a substrate using biomass as catalyst is considered.
Four alternative reaction rate models with dierent levels of details are derived and implemented
in Modelica. The problem of parameter estimation of models using state/parameter estimation
techniques in a Modelica-Dymola/Matlab setup is
discussed. Practical aspects concerning the dierent implementations of nonlinear estimators are
analyzed (EKF, UKF, and EnKF). The use of
Modelica-Dymola for on-line applications such
as state estimation poses the additional problem
of the e ciency of the code; this will also be discussed. The four reaction rate models are tted
using ctitious experimental data generated from
one of the models to illustrate the parameter estimation procedure.
Keywords: bioethanol fermentation, parameter estimation, nonlinear estimators

1

Introduction

Alcoholic fermentation is an important biochemical process which has been known for some
5000 years. Ethyl alcohol, or more commonly
ethanol, has chemical formulae C2 H5 OH, and
nds uses as (i) alcoholic beverage (beer, wine,
spirits), (ii) solvent, (iii) raw material in chemical
synthesis, and (iv) fuel.
With the current focus on CO2 release and global
warming, there is a considerable interest in producing fuel from biomass. Production of ethanol
from fermentation typically involves a two step
process: (a) the main process where substrate
(glucose) is converted to ethanol and non-fossil
CO2 in an enzymatic process, and (b) the aeroThe Modelica Association

bic yeast growth through the consumption of substrate and oxygen.
In continuous reactors, yeast is contiuously
washed out, leading to a less e cient use of the
yeast. The use of immobilized yeast increases
the e ciency of the process, as less substrate is
wasted for yeast production. In fermentation,
salts are involved as co-enzymes. The resulting
ions aect the oxygen uptake in the reaction mixture.
The produced (bio-) ethanol can be used as fuel
after some additional processing lter yeast, remove water by distillation, etc. Alternatively, the
ethanol can be converted to methane by microorganism.
The e cient production of ethanol in a fermentation reactor requires quantitative analysis of how
raw materials are converted to products. Static
models are often used for design purposes for continuous reactors, while dynamic models are required for batch reactors (e.g. beer production)
and for control analysis and design in continuous
reactors. A simple numeric dynamic model for
the continuous fermentation of glucose using the
yeast saccharomyces cerevisae is given in [1]. The
model is somewhat simplied in that the dynamics of the overall reactor volume is neglected, the
role of the salts as co-enzymes is neglected, and
somewhat simple kinetic reaction rates are used.
A more systematic development of reaction rates
for the continuous ethanol fermentation process is
presented in [2]. In [1], the eect of ions on the
oxygen uptake in the reactor mixture is included,
but the eect of glucose is neglected; expressions
for the eect of ions and sugars are given in [3].
Most of the parameters of the model of [1] are
given in their publication; however there is one
or two typos, and the eect of salt ions on the

287

Modelica 2008, March 3rd  4th , 2008

J. I. Videla, B. Lie

oxygen uptake is as if the salinity of the reaction tal data. We then generate ctitious experimental
mixture was similar to that of sea water (due to data from the model of Agachi et al., and we illustrate the parameter estimation procedure by tsome mole-to-gram conversion problem).
ting the new models to the generated experimental
It is of interest to study the parameter estimadata.
tion problem of the fermentation model for the
dierent rates of reaction models with the purposes of control and identication. Online pa- 2 Fermentation model
rameter identication can be achieved using recursive state/parameter estimators. For linear 2.1 Description
systems with normally distributed process and
measurement noise, the optimal recursive estima- The nutrients in biochemical reactions are known
tor is the Kalman lter. Estimation for non- as substrates. The substrate for the ethanol prolinear systems is considerably more di cult and duction process is thus glucose. For the yeast
admits a wider variety of suboptimal solutions. growth process, the substrates are glucose and
The extended Kalman lter (EKF), unscented oxygen. In the sequel we will use symbol S do deKalman lter (UKF), and the ensemble Kalman note glucose. Since oxygen has a relatively simple
lter (EnKF) are implemented using Modelica- chemical formulae, we will not introduce a particDymosim and Matlab. The fermentation with the ular notation for oxygen. Furthermore, we will use
dierent reaction rates is implemented in Model- symbol P for the main product, which is ethanol,
ica and compiled into Dymosim. The parameters and symbol X for the yeast.
are directly estimated using the parameter state- The original reaction kinetics given by [1] can be
augmented approach and the discrete version of seen in oTable 3 with the superscript o for every
specie rj :
the estimators are implemented in Matlab.
The fermentation reactor for the production of
The paper is organized as follows. In the next ethanol is sketched in Fig. 1. Glucose (substrate
section, an overview of the fermentation process S, sugar) in a water solution is continuously fed
and its implementation is given. Dierent kinetic to the well stirred reactor; the volumetric feed
reaction rates for the fermentation process are pre- ow is V_ i [volume/time] : The reactor contains
sented in accordance with biochemical engineering yeast (microorganisms X), which reacts with subprinciples. We give a brief introduction of the im- strate to produce ethanol (product P). We conplementation of the proposed models in Modelica. sider this reaction 1, with kinetic reaction rate
In section 3, we discuss the problem of parame- r1 [mass/(volume time)] 1 .
ter estimation of models using recursive nonlinear
E1
state/parameter estimation techniques in a Mod(1)
S!P
elica/Matlab setup. The traditional use of the
Extended Kalman Filter poses some questions re- Simultaneously, in a second reaction (2), the migarding the computation of the Jacobians of the croorganism breed under the consumption of oxysystem. In more modern techniques such as the gen to produce more yeast; the kinetic reaction
Unscented Kalman Filter, and Monte Carlo tech- rate is r2 [mass/(volume time)].
niques such as the Ensemble Kalman Filter, the
E2
(2)
computation of Jacobians is avoided. Also, these
S + O2 ! X
more modern techniques handle nonlinearities in a
The relationships between the rates of generation
better way than the Extended Kalman Filter. In
r [mass/(volume time)] with j 2 fP; X; S; O2 g
particular when these estimation techniques are j
can be seen in Table 3. All reaction rates have
used for parameter estimation, some of the ldimension mass/(volume time). It follows that
ter constants need to be carefully tuned, and we
r = rP is the mass of ethanol produced per voldiscuss this problem. Also, the use of Modelica 1
ume and time, etc. Factor YSP has the meaning
for on-line application such as state estimation
of mass of ethanol (product) produced per mass of
poses some particular problems with regards to
glucose (substrate) consumed. Similar interpretathe e ciency of Modelica implementations; this
tions are valid for YSX and YOX .
will be discussed. Finally, we assume that the
1
model of [1] has been tted well to experimenThe CO2 specie is not considered in the expression.
The Modelica Association

288

Modelica 2008, March 3rd  4th , 2008

Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model

V% i , _, _ S,i , T i

V% J , _ J , T J,i

Tab. 1: Fermentation model.
Reactor total mass and species balances:
d
_i m
_o
dt m = m
d
m
=
m
_
m
_ j;o + m
_ kj;g with j 2 fP; X; S; O2 g
j;i
dt j
Reactor rates of generation:
m
_ j;g = rjk V with j 2 fP; X; S; O2 g
Reactor outputs:
p
m
_o=k V
m
_ j;o = V_ o j with j 2 fP; X; S; O2 g
Reactor inputs:
m
_ i = V_ i
m
_ P;i 0
m
_ X;i 0
m
_ S;i = ;i V_ i

V% J , _ J , T J

Q%
V, h, _, _ P , _ X, _ S , _ CO 2 , T

V% o , _, _ P , _ X , _ S , _ CO 2 , T

A

S

m
_ O2 = m
_ O2 ;a
Oxygen interface transport:
m
_ O2 ;a = k`a O2
O2 V
P
P
n In
m Sm )
O2 = O2 ;0 (T ) exp (
with n 2 fNa+ ; Cl ; Ca+2 ; CO3 2 ; Mg+2 ; H+ ; OH g
In = 12 Hj zj2 cj
P
m Sm = SS = KS cS
2
3
O2 ;0 (T ) = 0 + 1 T + 2 T + 3 T
Reactor energy balance:
c^p V dT = c^p V_ i (Ti T ) + Hr;2 V rj
Q_ heatex

Fig. 1: Sketch of fermentation reactor.

Both in the inlet stream and in the reaction
medium, water is dominant such that the density
of the mixture can be assumed to be constant.
For oxygen, there is an input ow m
_ O2 ;a in that
oxygen is transported from air to dissolved oxygen
in the reaction medium,
m
_ O2 ;a = k`a

O2

O2

V;

(3)

where k`a [1/time] depends on the temperature,
V is the volume of the reaction medium, O2 is
the mass based concentration [mass/volume], and
O2 is the equilibrium concentration of oxygen in
water. O2 depends on salts in the mixture. It
is assumed that there is no O2 in the feed water
stream. In both reactions 1 and 2, CO2 is released
as a byproduct; here we do not model the carbon
dioxide production.
The total mass, species balances, and energy balance for the reactor and the water jacket models
are presented in Table 1. The fermentation boundary conditions dened as inputs and outputs are
dened in this table. The fermentation model parameters of the original model developed in [1] are
shown in Table 2.
2.1.1

Fermentation reaction and rates

The elementary reaction rate r1e for the ethanol
production is developed considering the substrateenzyme interactions, the resulting rate is given by
the Michaelis-Menten kinetics. Additionally, the
presence of ethanol inhibits the ethanol producThe Modelica Association

d

O2

Water jacket mass balance:
m
_ J;i + m
_ J;o = 0
Water jacket energy balance:
J
^p;J VJ dT
^p;J V_ J (TJ;i TJ ) + Q_ heatex
Jc
dt = J c
Water jacket-reactor heat transfer:
Qheatex = Ux Ax (T TJ )

tion rate (inactive enzymes), this eect is also included in this reaction rate. The combined eect
is shown in Table 3.
A common simplied model for the eect of competition for active sites yields the simplied rate
r1s ; where a specie that competes for an active
site and participate in the reaction has the form
S =(KS;1 + S ), while a specie that competes for an
active site and does not participate in the reaction
has the form 1=(1 + kP;1 P ):
Another possible model for ethanol production with ethanol inhibition is to notice that
1= 1 + kP;1 P : This exponenexp kP;1 P
tial term can be explained by assuming inhibition
by ethanol may be caused by intracellular mechanisms.
A similar analysis can be done for the reaction
rate for the yeast production for the dierent ap-

289

Modelica 2008, March 3rd  4th , 2008

J. I. Videla, B. Lie

Tab. 2: Parameters for the fermentation reactor with Tab. 3: Parameters for the fermentation reactor with
original reaction rates.
original reaction rates.
Reactor/Water jacket parameters:
Reaction rates 1:
o
S
~ r;O = 518 kJ= molO
= 1080 g= l
H
r
kP;1 P
1 = 1 X KS;1 + S exp
2
2
e
VJ = 50 l
r1 = 1 X K + 1+kS
J = 1000 g= l
S;1 (
P;1 P )+ S
c^p = 4:18 J=( g C)
Ux Ax = 3:6 E5 J= ( h C)
1
s
S
r
=
1
1
X KS;1 + S 1+kP;1 P
c^p;J = 4:18 J=( g C)
(kla )0 = 38 h 1
r1i = 1 X KS;1S+ exp kP;1 P
S
Rate of generation parameters:
Reaction rates 2:
1
KS;2 = 1:03 g= l
1 = 1:79 h
r2o = 2 X KS;2S+ exp kP;2 P
1
S
=
0:5
h
K
=
8:86
mg=
l
O
2
O2
r2e = 2 X K K + 1+k S O2 +K
A1 = 9:5 E8 h 1
kP;1 = 0:070 l= g
S;2 O2 (
P;2 P )
O2 S + S O2
O2
1
s
1
S
r2 = 2 X KS;2 + KO +
A2 = 2:55 E33 h
kP;2 = 0:139 l= g
S
O2 1+kP;2 P
2
Ea1 =R = 6:6185 E3 K YSX = 0:607 gX = gS
r2i = 2 X KS;2S+ KO O+2
exp kP;2 P
S
O2
2
Ea2 =R = 26:474 E3 K YSP = 0:435 gP = gS
Rates of reactions for P; X; S; O2
KS;1 = 1:68 g= l
YOX = 0:970 gX = gO2
k
rP
= rk1
, k = fo; e; s; ig
Oxygen interface transport parameters:
k
rX = rk2
, k = fo; e; s; ig
zNa+ = +1
HMg+2 = 0:314 l= mol
1
1
k
k
k
rS = YSP r1 YSX r2
, k = fo; e; s; ig
zCl = 1
HCa+2 = 0:303 l= mol
1
k
k
rO2 = YOX r2
, k = fe; s; ig
zCa+2 = +2
KS = 0:119 l= mol
O2
1
o
rO
=
YOX O2 X KO2 + O2
2
MNaCl = 58:44 g
zCO 2 = 2
3

zMg+2 = +2
zH+ = +1
zOH = 1
HNa+ = 0:55 l= mol
HCl = 0:84 l= mol
HOH = 0:94 l= mol
HCO 2 = 0:48 l= mol
3

HH+ =

0:77 l= mol

MMgCl2 = 95:21 g= mol
MCaCO3 = 100:09 g= mol
MO2 = 32 g= mol
MS = 180:15 g= mol
0 = 14:16 mg= l
0:394 mg=( l C)
1=
2
2 = 7:71 E 3 mg=( l C )
3=

6:4 E 5 mg=( l C3 )

proximations.
The original rates are closely related to the developed rates where product inhibition is explained
via intracellular transport. The original model
neglects the oxygen dependence of the intracellular model and neglects the substrate dependence
and the product inhibition. Clearly, when the kinetic rates change their functional form, the parameter/temperature functions change. The dierent rate reaction rates are shown in Table 3.

2.2

Implementation

In Modelica it is important to implement a good
structure to enable easy modication of the models. The core model of the fermentation reactor is
the basic volume model, there is where the total
mass, species mass balances, and energy balance
are dened. This model exchanges heat with the
water jacket model through an MSL heat port. It
The Modelica Association

also has a chemical port (i.e. intensive variables:
temperature and mass concentration vector; and
extensive variables: mass ow rates vector and
heat ow rate) that connects with the rate of generation replaceable model and the oxygen transport model, and two thermouid ports (i.e. intensive variables: pressure, specic enthalpy, and
mass fraction vector; and extensive variables: enthalpy ow rate vector, mass ow rate vector, and
total mass ow rate) to connect the basic volume
with the incoming mass ow rate in and the outcoming mass ow rate out of the model. The basic volume is then connected to the water jacket
model, to the oxygen transport model, to the rate
of generation replaceable model as shown in Fig.
2.
The four dierent reaction kinetic rates (i.e. original, elementary, simplied, and intracellular ) are
implemented using a replaceable component. A
common set of parameters and equations are dened in a partial model called rate of generation.
Specics of every reaction rate model are dened
separately in each model that inherits the rate of
generation partial model. The heat of reaction is
also dened in these models. The water jacket
model uses two MSL ow ports.

290

Modelica 2008, March 3rd  4th , 2008

Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model

Tab. 4: EKF algorithm.
O2 transport
interface model

Initialization:
x
^0j0 N (x0 ; P0 )
P0j0 = P0
for k = 1; 2; : : :
Propagation step:
( a priori covariance estimate)

replaceable
rate of
generation
models

Mass and
energy balance
control volume

Fk

Water Jacket
model

Fig. 2: Dymola diagram layout of the fermentation reactor component.

3
3.1

@fk
@xk

=

1
1

x
^k

Lk
1jk

1

=

1

@fk
@wk

Pkjk 1 = Fk 1 Pk 1jk 1 FkT 1 + Lk
( a priori state-output estimate)
x
^kjk 1 = fk 1 (^
xk 1jk 1 ; uk 1 ; 0)
y^kjk 1 = hk (^
xkjk 1 ; 0)
Measurement update:
(Kalman gain calculation)
Hk =

@hk
@uk

x
^kjk

Mk =
1

@hk
@vk

x
^kjk

1
1

x
^k

1 Qk

1jk

T
1 Lk

Description

The ethanol fermentation reactor model can be
written in the general discrete nonlinear state
space form:

"

xk
k

#

=

"

fk

1

(x)
1 ; u k 1 ; wk 1
( )
k 1 + Ts wk 1

xk

yk = hk (xk ; vk )

1 (xk 1 ; uk 1 ; wk 1 )

1

1

1

Kk = Pkjk 1 HkT (Hk Pkjk 1 HkT + Mk Rk MkT )
( a posteriori state-covariance estimate)
x
^kjk = x
^kjk 1 + Kk (yk y^kjk 1 )
Pkjk = (I Kk Hk )Pkjk 1

Nonlinear estimators

xk = fk

1

1

#

(5)
(6)
(x)

(4) where Ts is the sampling time step, w(x) 2 Rnw
k 1
is the process noise vector that aects the original
( )
where fk 1 : Rnx +nu +nw ! Rnx is the discrete states; and w( ) 2 Rnw is the process noise veck
1
state function, xk 2 Rnx is the discrete state vec- tor that aects the added parameter states. The
tor, uk 1 2 Rnu is the discrete input, wk 1 2 Rnw noise vector sequences fwk 1 g and fvk g are asis the discrete process noise vector, hk : Rnx +nv ! sumed Gaussian, white, zero-mean, uncorrelated,
Rnx is the discrete output function, vk 2 Rnv is the and have the known covariance matrices Qk 2
( )
discrete measurement noise vector, yk 2 Rny is the R(nx +n ) (n(x)
w +nw ) and R 2 Rny nv
k
output vector, and k is the time index. The noise
vector sequences fwk 1 g and fvk g are assumed
(x)
( )
Gaussian, white, zero-mean, uncorrelated, and
wk
N (0; blkdg(Qk ; Qk ))
n
n
x
w
have the known covariance matrices Qk 2 R
vk
N (0; Rk )
and Rk 2 Rny nv .
During the propagation step, the augmented
states corresponding to parameters k are consid3.2 Augmented states
ered equal to the previous time step k 1 with
( )
The augmented state space approach can be di- some additive process noise wk 1 . If it is assumed
rectly used to simultaneously solve the state and that the parameters do not change at all, then
( )
the parameter estimation problem (e.g. see [4]). there is no process noise vector wk 1 , but for the
An augmented state space representation is for- more general case of time-varying parameters (e.g.
( )
mulated by adding the vector of parameters to be fouling, etc.), the value of Qk will be given by
estimated k 2 Rn 1 as new states:
the admissible range of variation of k : During
yk = hk (xk ; vk )

The Modelica Association

291

Modelica 2008, March 3rd  4th , 2008

J. I. Videla, B. Lie

the measurement update step the parameter values are corrected.
For notational simplicity in the estimators algorithms that follow, the augmented state vector is
referred to as xk , the state augmented function (5)
is referred to as fk 1 , and the augmented process
noise vector is referred to as wk 1 .

step. This is the optimal way of predicting a state
probability density function (pdf) p (xk ) for any
system in state space representation with process
and measurement noise2 .
Tab. 6: EnKF algorithm.
Initialization:
(initial ensemble)
for i = 1; 2; : : : ; N
xi0j0 N (x0 ; P0 )

Tab. 5: UKF algorithm.
Initialization:
L = nx + nw + nv ; = 2 (L + ) L
p
= 2 L + ; 0m = =( + L)
0
2
+ )
c = =( + L) + (1
for i = 1; 2; : : : ; 2L
i
1
; ic = im
m = (2( + L))
x
^0j0 N (x0 ; P0 )
P0j0 = P0
for k = 1; 2; : : :
Propagation step:
(sigma points propagation)
P~k 1jk 1 = blkdiag(Pk 1jk 1 ; Qk ; Rk )
xk 1jk 1 )T ; 01 nW ; 01 nv ]T
x
~0k 1jk 1 = [(^
for i = 1; 2; : : : ; L
x
~ik 1jk 1 = x
~0k 1jk
x
~i+L
k 1jk
(x)i
x
~kjk 1
i
y~kjk
1

=x
~0k

1

+ chol(P~k
chol(P~k

i
ykjk

Measurement update:
(Kalman gain calculation)
e~iy;kjk 1 = (~
y i 1 y^kjk 1 )
P2L kjk
Py = i=0 ic (~
ei
eiy;kjk 1 )T
1 )(~
P2L i y;kjk
Pxy = i=0 c (~
eix;kjk 1 )(~
eiy;kjk 1 )T

Kk = Pxy Py 1
( a posteriori state-covariance estimate)
x
^kjk = x
^kjk 1 + Kk (yk y^kjk 1 )
Pkjk = Pkjk 1 Kk Py KkT

= hk (xikjk

i
1 ; vk 1 )

(covariance calculation)
eix;kjk 1 = (xikjk 1 x
^kjk 1 )
1 PN
i
Pkjk 1 = (N 1)
i=1 (ex;kjk

i
T
1 )(ex;kjk 1 )

Measurement update:
(Kalman gain calculation)
i
eiy;kjk 1 = (ykjk
y^kjk 1 )
1
P
N
1
Py = (N 1)
(eiy;kjk 1 )(eiy;kjk 1 )T
Pi=0
N
1
i
i
T
Pxy = (N 1)
i=0 (ex;kjk 1 )(ey;kjk 1 )

+ L)

Kk = Pxy Py 1
(state-out-covariance update)
xikjk = xikjk 1 + Kk ((yk + vki )
PN
x
^kjk = (N ) 1 i=1 xikjk

( a priori state-output estimate)
P2L
(x)i
x
^kjk 1 = i=0 im x
~kjk 1
P2L
i
y^kjk 1 = i=0 im y~kjk
1

( a priori state covariance estimate)
(x)i
e~ix;kjk 1 = (~
xkjk 1 x
^kjk 1 )
P2L
i i
Pkjk 1 = i=0 c (~
ex;kjk 1 )(~
eix;kjk 1 )T

1

i
1 ; u k 1 ; wk 1 )

(estimated state-output propagation)
PN
x
^kjk 1 = (N ) 1 i=1 xikjk 1
PN i
y^kjk 1 = (N ) 1 i=1 ykjk
1

1jk 1 ; i)

1jk 1 ; i
1jk 1
(x)i
(w)i
= fk 1 (~
xk 1jk 1 ; uk 1 ; x
~k 1jk 1 )
(x)i
(v)i
= hk (~
xkjk 1 ; x
~k 1jk 1 )
1

for k = 1; 2; : : :
Propagation step:
(ensemble propagation)
for i = 1; 2; : : : ; N
xikjk 1 = fk 1 (xik 1jk

Pkjk = Pkjk

1

i
ykjk

1)

Kk Py KkT

Assuming that the initial state pdf p (x0 ), the
process noise pdf p (wk 1 ) ; and the measurement
noise pdf p (vk ) are known, a recursive solution of
the estimation problem can be found using rst
the Chapman-Kolmogorov equation to calculate
the a priori pdf for the state xk based on the previous measurement yk 1 (propagation step)
p(xk jyk

R

1 )=

p(xk jxk

1 )p(xk 1 jyk 1 )dxk 1

(7)

where p (xk jxk 1 ) can be calculated from the state
function fk 1 and the pdf of the process noise wk .
3.3 Nonlinear Recursive Estimators
Secondly, the Bayes rule to update the pdf of
the state xk with the new measurement yk (meaThe nonlinear estimation problem can be formusurement update) is
lated as a recursive Bayesian estimation problem
2
with a propagation and a measurement update
Markov process of order one.
The Modelica Association

292

Modelica 2008, March 3rd  4th , 2008

Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model

p (xk jyk ) = R

p (yk jxk ) p (xk jyk 1 )
p (yk jxk ) p (xk jyk 1 ) dxk

(8)

where p (yk jxk ) is available from our knowledge
of the output function hk and the pdf of vk , and
p (xk jyk 1 ) is known from (7). Although the initial
state pdf p (x0 ), the process noise pdf p (wk 1 ) ;
and the measurement noise pdf p (vk ) are needed
to solve the recursive Bayesian estimation, no specic statistical distribution is required.
The recursive relations (7) and (8) used to calculate the a posteriori pdf p (xk jyk ) are a conceptual solution and only for very specic cases
can these be solved analytically. In general, approximations are required for practical problems.
Three main groups of suboptimal techniques with
signicant performance and computational cost
dierences are used to approximate the recursive
Bayesian estimation problem: the classical nonlinear extension of the Kalman lter (EKF), the
Unscented Kalman lter (UKF), and the Ensemble Kalman lter (EnKF) approaches.

3.4

dsu.mat
dsu.txt

Extended Kalman Filter (EKF)

The discrete EKF is probably the most used sequential nonlinear estimator nowadays. It was
originally developed as a nonlinear extension by
Schmidt [5] of the seminal work of Kalman [6].
Based on the Kalman lter, it assumes that the
statistical distribution of the state vector remains
Gaussian after every time step3 so it is only necessary to propagate and update the mean and covariance of the state random variable xk . The
main concept is that the estimated state (i.e. estimated mean of xk ) is su ciently close to the
true state (i.e. true mean of xk ) so the nonlinear
state/output model equations can be linearized
by a truncated rst-order Taylor series expansion
around the previously estimated state.
The discrete algorithm is given in table 4. In
general, this algorithm works for many practical
problems, but no general convergence or stability
conditions can be established4 and its nal performance will depend on the specic case study.
For highly nonlinear models with unknown initial
conditions, the EKF assumptions may prove to
be poor and the lter may fail or have a poor per-

-Stand-alone
program that
-s simulate
-l linearize
-t inival. calc.

dslog.txt
- Statistics of
the simulation.
- Debug info

dslin.mat

-Experiment description:
-start time
-stop time
dsin.txt
-inival. (opt.)
-parameters,etc

- Optional file
to define
trajectories of
input signals

dymosim -i generates a
default dsin.txt file

dymosim.exe

dsres.mat
dsres.txt
- Results of the
simulation
- Binary or text
formats

dsfinal.txt
- Final state
(same structure
as dsin.txt)

dymosim -l
- linearize model
at initial values
-Jacobians

Fig. 3: Dymosim and related input and output les.

formance. The main tuning parameters are the
estimator covariance matrices Qk and Rk :

3.5

Unscented Kalman Filter (UKF)

The unscented Kalman lter was originally developed by Julier and Uhlman [8, 9, 10, 11].
In the unscented Kalman lters, instead of approximating the nonlinear state/output functions,
it is the probability distribution that is approximated. Basically, a set of points, called sigma
points, are generated to match the state mean and
state covariance of the probability distribution of
the previously estimated state, then they are propagated through the nonlinear function. The projected points are used to approximate the rst two
moments (i.e. the a priori estimated state and
state covariance) that are necessary during the
measurement update step. This lter normally
outperforms the previously presented EKF. Its
more general form has a higher computational cost
but it does not require the calculation of any Jacobian matrices (i.e. derivatives). The algorithm
is given in table 5.
The tuning parameters of the UKF are also the
estimator process and measurement noise covariance matrices, and the scalar parameters f ; ; g:
determines the spread of the sigma points
around the previous estimate, and the
value
depends on the type of distribution assumed (for
more details about their values see [11]).

3.6

Ensemble Kalman Filter (EnKF)

3

this assumption is in general not true for nonlinear systems.
4
except for some special cases [7].

The Modelica Association

The EnKF uses an ensemble (i.e. particle set) during the propagation step, but the classical Kalman

293

Modelica 2008, March 3rd  4th , 2008

J. I. Videla, B. Lie

measurement update equations (instead of using
the resampling with replacement approach of the
particle lters) during the measurement update
step. The covariances matrices Pxy and Py obtained from the propagation of the ensemble elements through the nonlinear state-space are used
to calculate the Kalman gain Kk : The a posteriori ensemble is calculated from the Kalman gain
matrix and an articially generated measurement
particle set that is normally distributed with mean
equal to the current measurement yk and covariance equal to Rk . The a posteriori ensemble is
used to calculate the a posteriori state and covariance estimate, and it is used for the next lter
iteration of the algorithm. For details about the
algorithm, see table 6. The EnKF was originally
developed in [12] to overcome the curse of dimensionality in large scale problems (i.e. weather data
assimilation). It is suggested in the literature [13]
that ensembles (i.e. particle sets) of 50 to 100
are often adequate for systems with thousands of
states, but no conclusive work has been done on
this.

model fermentation
...
input Real u_u1; // define model inputs
input Real u_w1; // define noise inputs
input Real u_p1; // define param. inputs
...
parameter Real p_u1;
parameter Real p_w1;
parameter Real p_p1;
parameter Real p_i1;
equation
fluidBCv.u[1]=u_u1+p_u1;
reactor.basicVol.w[1]=u_w1+p_w1;
reactor.RG.p_mu1=u_p1+p_p1;
reactor.i_rho[1]=p_i1;
end fermentation;

Additionaly, the discrete EKF estimator requires the calculation of the discrete Jacobians
Fk 1 ; Lk 1 ; Hk ; Mk . This can be done calculating a linearized model around the previous state
estimate dened by the operating point op =
[xTk 1 ; uTk 1 ; 0; Tk 1 ]T with the following Matlab
code:
eval( ['! dymosim ', '-l ','dsin.txt'] );

Besides the estimator process and measurement
noise covariance matrices, the other tuning para- In the le dsin.txt (see Fig. 3) the operating
meter for this lter is the number of ensemble el- point is dened using parameters and the initial
state for every iteration. The calculated linearized
ements.
model is written in the le dslin.matand then it
can be loaded into Matlab using the Dymola addon function tloadlin which loads the matrices
A,B,C,D and the string vectors uname, yname, and
xname. These matrices correspond to

3.7

Implementation

A
B

@f (x;u;w)
@x

=

op

@f (x;u;w)
@u

=

;

@f (x;u;w)
;
@w

Within the Modelica model the input vector uk ,
the process noise input vector wk , and the parameter input vector k must be dened. This can
be done in the following way at the top level of
the model:
The Modelica Association

294

Lk
Hk
Mk

=

1

=
=
=

0np

@fk
@wk

nx

1np

op

;

@f (x;u;w)
@

op
The fermentation model is written in Modelica
@h(x;u)
C
=
@x
and compiled in Dymola into a stand-alone exop
@h(x;u)
ecutable le called Dymosim. The dierent esD =
@u
op
timators are implemented in Matlab from where
The parameter augmented state space discrete jaDymosim is sequentially called during the propcobians are approximated from the A; B; C; D maagation step to project the state vector (i.e. intrices
"
#
tegrate over the sampling time) in the estimator
A
B(: ;nu +nw +1:end)
e
A
=
algorithms. The parameter state vector k is di0np nx
0n p n p
rectly propagated within the Matlab code so the
@fk 1
Fk 1 = @xk 1
exp (Ae t)
original model does not need to be modied to
op
"
#
B(:;nu +1:end) 0nx np
include the parameter dynamic equations.
e

B

op

np

1
1

[I t +
C 0ny
D

op
1 e
2! A

t2 +

1 e2
3! A

t3 + : : :]B e

nx

Modelica 2008, March 3rd  4th , 2008

Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model

x0

V_ ;

=

P ; X ; S ; O2 ; T; TJ

0
500
1000
Mass concentration of ethanol

P (k)[g=l]

14
12
10

T0

8

=
=
=

diag ([1000; 15; 2; 100; 5; 35; 30]) 1 E 7
diag ([1; 1; 1; 1; 1; 1; 1; 1]) 1 E 7
diag ([15; 2; 100; 5; 35; 30]) 2 E 3

S (k)[g=l]

200

400

600

800

0

20
0

500
Reactor Temperature

5.5

32
30
28
26
0

5

4
3.5
0

500
Jacket Temperature

1000

500
time [h]

1000

32

34

A
subset
of
8
parameters
=
is
[ 1 ; KS;1 ; KS;2 ; kP;1 ; kP;2 ; YSP ; YSX ; YOX ]T
estimated for every estimator (i.e., the EKF,
the UKF, and the EnKF) using every reaction
rate model (i.e., the original, the elementary,
the simple, and the intracellular reaction kinetic
models). The initial parameter values for every
reaction rate model are adjusted to ensure that
all simulation results give the same steady state
values at initial time t = 0. The estimators
inputs are equal to the system model inputs
u = [V_ J;i ; S;i ]T , and the measured outputs are
y = [ P ; X ; S ; O2 ; T; TJ ]T (see Fig.4). The estimators are simulated for 1000 h with a sampling
time of 1 h.
The estimators initial state vectors are drawn
from a normal distribution with mean and covariance equal to

500
1000
Mass concentration of oxygen

4.5

3

1000

500
1000
Mass concentration of yeast

1

0.5
0

1000

40

60
40
20

1.5

Mass concentration of glucose

60

0

(x)
( )
Qk ; Qk

blkdiag

0

80

[1000; 12:9; 0:9; 28:6; 3:9; 30:4; 26:9]

=

100
80

16

T(k)[ C]

(x)

Qk
( )
Qk
Rk

40
20

The system model process and measurement noise
vector sequences fwk 1 g and fvk g are Gaussian,
white, zero-mean, uncorrelated, and have constant
covariance matrices
Qk

S;i (k)[g=l]

V_J;i (k)[l]

60

T

=

mass concentration of glucose in V_i
120

Water jacket volume ow rate in

Due to the lack of experimental measurements,
simulated data sets from the model with the original kinetic reaction rates are generated. The system model is simulated for 1000 h and data samples are collected every 1 h. Because the transient
response is relevant to parameter identication,
step-like input sequences with high frequency content are used (see Fig.4). The initial state vector
for the fermentation
model is
h
i

X (k)[g=l]

Results

TJ (k)[ C]

4

f1 E 3; 0; 0g, and the EnKF is evaluated
for an ensemble of N = 100 elements. The estimators process and measurement noise sequences
are Gaussian, white, zero-mean, uncorrelated,
and have constant covariance matrices equal to
the system model.

O2 (k)[mg=l]

where nu is the input vector dimension, nw is the
process noise vector dimension, and so on. For
notation simplicity, the matrices in the previous
equations use Matlab notation.

500
time [h]

1000

30
28
26
24
22
0

Fig. 4: Process inputs (V_ J;i ; S;i ), and measured outputs ( P ; X ; S ; O2 ; T; TJ ) with measurement noise
(grey line) and without it (black line).

Every dierent reaction rate is evaluated for
every estimator using 50 Monte Carlo simulations. As a general notation, consider an ensemble {xij (k)g where i indicates the realization, j the
state/parameter, and k the time index. The ensemble average (over the realizations) is denoted
hxij (k)i:
P

xi (k)

j
hxij (k)i , nisimul
where nsimul is the number of realizations.
For every estimator with the dierent reaction
rates two performance values (averaged over the
T
(x)
( )
x
^0j0
N ([xT0 ; 0 ]T ; blkdiag P0 ; P0 )
number of Monte Carlo simulations) are calcux0
= [990; 13:9; 0:8; 27:6; 4:9; 27:4; 24:9]T
lated for each estimated parameter j: the averaged
T
=
[1:49;
1:48;
1:23;
7:3;
1:19;
5:07;
4:55;
9:3]
estimated parameter for every time index k that
0
(x)
is used to evaluate the parameter estimation bias
P0
= diag( 0:125 x0j0 :^2)
i
( )
P0
= diag( 0:125 0j0 :^2)
wrt. the true parameter value h^j (k)i, and the
The UKF parameters are f ; ; g
= averaged absolute estimated parameter error de-

The Modelica Association

295

Modelica 2008, March 3rd  4th , 2008

J. I. Videla, B. Lie

i
i
ned as hjei j (k) ji , hj^j -h^j (k)iji for every time
index k. This second performance value is used to
evaluate the convergence and consistency of every
estimator.

The Monte Carlo averaged performance of the estimators using the original reaction rate model is
shown in Fig. 5. The averaged estimated parameters h^j (k)i converge to the true parameters for
all the parameters except for the slightly biased
Y^SP estimate and the more biased Y^SX estimate.
In Fig. 5 column (b), the averaged estimated parameter errors for the parameters fk^P;2 ; Y^SP ; Y^O2 g
converge at a faster rate than for the other esti^ S;1 ; K
^ S;2 ; k^P;1 ; Y^SX g: The
mated parameters f^ 1 ; K
EKF and the UKF have comparable averaged estimated parameters, while the EnKF has slightly
biased averaged estimated parameters. The best
performance wrt. the averaged absolute estimated
parameter error hjei j (k) ji is achieved for the EKF
followed by the UKF and the EnKF.
The Monte Carlo averaged performance of the estimators using the elementary reaction rate model
is shown in Fig. 6. It can be seen that the averaged estimated parameters no longer converge
to the true parameters of the original rate model
used in the system model simulations. It is to
be expected that some of the parameters will be
time-varying to compensate for the dierent kinetic rates (between the system and the estimator
kinetic rate models) and, in this way, keep a good
state estimation performance besides their dierences. For this case, the averaged estimated parameters h^j (k)i are considered as an unbiased estimate of the true (possibly time-varying) parameters. The averaged estimated parameters h^j (k)i
take dierent shapes over time depending on the
specic estimator evaluated. In Fig. 6 column (b),
the averaged absolute estimated parameter errors
hjei j (k) ji for the parameters fk^P;1 ; k^P;2 ; Y^SX ; Y^SP g
and the EKF diverge while the UKF achieves the
best performance followed by the EnKF. It is then
reasonable to consider that the averaged estimated
parameters h^j (k)i that correspond to the UKF
are the best estimate of the true parameters j (k)
for this estimator reaction rate model.
The Monte Carlo averaged performance of the estimators using the simplied reaction rate model
is shown in Fig. 7. As for the elementary case, the
averaged estimated parameters h^j (k)i are considered as an unbiased estimate of the true (possibly time-varying) parameters. The averaged esThe Modelica Association

timated parameters h^j (k)i have similar values
for the EKF and the UKF and slightly dierent
for the EnKF. In Fig. 7 column (b), the lowest averaged absolute estimated parameter errors
hjei j (k) ji are achieved for the EKF, closely followed by the UKF performance. For all the estimators the averaged absolute estimated parameter
errors decrease over time.
The Monte Carlo averaged performance of the
estimators using the intracellular reaction rate
model is shown in Fig. 8. As for the elementary
and simplied cases, the averaged estimated parameters h^j (k)i are considered as an unbiased estimate of the true (possibly time-varying) parameters. The averaged estimated parameters h^j (k)i
have similar values for the EKF and the UKF and
slightly dierent for the EnKF. In Fig. 8 column
(b), the averaged absolute estimated parameter
errors hjei j (k) ji decrease over time for all the parameters and estimators, except for the estimated
parameter Y^SX with the EnKF.
In Table 7 the dierent reaction rate models are
evaluated for each lter using the normalized
mean RMSE dened as
s
RMSE (x)

Pnx

=

j

Pnsimul
i

2
Pnt
x
^j (k) xtrue (k)
j
k
nt
xtrue
min xtrue
j
j

2

max(

)

(

)

(

)

Tab. 7: Normalized mean RMSE for the estimated
state x and parameter vectors .The best results for
every case is indicated by parentheses.
RMSE (:)
EKF
UKF
EnKF
Original
x
9.11E-2
9.13E-2
(8.44E-2)
Elementary

5

x

Simplied

x

Intracellular

x

(1.22)
2.09E-1
5.57E-1
8.36E-2
(3.21E-1)
8.94E-2
(3.98E-1)

1.74
1.00E-1
(2.73E-1)
(8.05E-2)
3.56E-1
1.05E-1
5.69E-1

1.95
(9.35E-2)
7.54E-1
8.77E-2
3.28E-1
(8.60E-2)
4.71E-1

Conclusions

The recursive parameter estimation problem is analyzed for an ethanol fermentation process with
dierent reaction rate models. The model is implemented in Modelica and three nonlinear estimators are evaluated using the compiled Modelica
model (Dymosim) with Matlab. Implementation
details (e.g. how to calculate Jacobians, dened
noise inputs, etc.) are presented.
Some relevant model parameters are estimated using the EKF, the UKF, and the EnKF from sim-

296

Modelica 2008, March 3rd  4th , 2008

1

0

500

0.12

0

500

1000

0.48
0.46
0.44
0.42

0

500
time [h]

< jeiKS; 1 (k)j >

< j^
ei1 (k)j >

0

1000

0

500

500

0
1000

0.7

0

500

0

1000

0 -4
x 10

500

0

9

0

500

0.02

1000

1.5

0.04

9.5

0.02

0

(a)

500
time [h]

0
1000

500

1000

0 -4
x 10

500

1000

500
time [h]

1000

0.04

0.06

10

0

0.06

0.01

1000

1000

0.08

0.005

0.5

500

0.005

0.015

0.6

10.5

1000

0

0

0.01

0.1

0.065
0.06

0

1000

0.2

0.07

< Y^OX (k) > [gX =gO2 ]

0.1

500

0.075

1000

0.14

0

0.1

< jeiYSX (k)j >

1.2

1.4

0.1

< jeiYOX (k))j >

1.4

1.6

< jeikP; 1 (k)j >

1000

0.2

< jeiKS; 2 (k)j >

500

< ^kP;1 (k) > [l=g]

^ S;2(k) > [g=l]
<K
< ^kP;2 (k) > [l=g]

0

0.2

< jeikP; 2 (k)j >

1.6

1.8

< jeiYSP (k))j >

1.8

1.4

< Y^S P (k) > [gP =gS ]

^ S;1(k) > [g=l]
<K

2

< Y^S X (k) > [gX =gS ]

<
^1 (k) > [h1 ]

Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model

1

0.5

0

500
time [h]

0

1000

0

(b)

Fig. 5: Original kinetic rate model parameter estimation results, averaged over 50 Monte Carlo simulations for
the EKF (black solid line), the UKF (black dash line), and the EnKF (black dotted line): (a) mean parameter
estimates h ^j (k)i for every time index k and true parameters j (grey solid line); (b) mean absolute estimated
i
parameter error, hjei ji = hj^
h^j (k)iji for every time index k.

2
0
-2

0

500

1000

0.5

0

-0.5

0

500

1000

0.5
0.45
0.4
0.35
0

500
time [h]

1000

(a)

< jeiKS; 1 (k)j >

< j^
ei1 (k)j >

0

500

0

500

0

1000

0

500

0

1000

500

0

500

0

1000

4

0.06
0.04

4

0

500
time [h]

1000

500

1000

0
-4
x 10

500

1000

500
time [h]

1000

2

0.02

2

0

0.2

0

1000

1000

0.4

0.02

0
-3
x 10

500

0.05

0.04

0.5

0

0.1

0.06

1

0

0

1000

1.5

6

500

0.5

0.1

0

0

1

0.2

0

0

1000

< jeikP; 1 (k)j >

<^
kP;1 (k) > [l=g]

4

-1

< jeiYSX (k)j >

1000

0.2

0.5

0

< jeiYOX (k))j >

500

1

< jeiKS; 2 (k)j >

0

0.4

1

< jeikP; 2 (k)j >

2

2

< jeiYSP (k))j >

3

< Y^S X (k) > [gX =gS ]

^ S;2(k) > [g=l]
<K
<^
kP;2 (k) > [l=g]

^ S;1(k) > [g=l]
<K

4

1

< Y^S P (k) > [gP =gS ]

j

< Y^OX (k) > [gX =gO2 ]

<
^1 (k) > [h1 ]

j

0

0

500
time [h]

0

1000
(b)

0

Fig. 6: Elementary kinetic rate model parameter estimation results, averaged over 50 Monte Carlo simulations
for the EKF (black solid line), the UKF (black dash line), and the EnKF (black dotted line): (a) mean parameter
i
estimates h ^j (k)i for every time index k; (b) mean absolute estimated parameter error, hjei j ji = hj^j h^j (k)iji
for every time index k.

The Modelica Association

297

Modelica 2008, March 3rd  4th , 2008

0
-1

0

500

0.14
0.12
0.1

0

500

1000

0.5

0.45

0.4

0

500
time [h]

1000

< jeiKS; 1 (k)j >

< jei 1 (k)j >
500

0

1000

0

500

0

500

4

1000

500

0

1000

0

500

0.02

1000

1.5

0.04
0.02

0.9

0

(a)

500
time [h]

0

1000

500

1000

0 -4
x 10

500

1000

500
time [h]

1000

0.04

0.06

1

0

0.06

0.005

0 -3
x 10

1000

0.08

0.01

0.6

500

6

0.015

0.8

1.1

0
0 -3
x 10
10

1000

8

0

1000

1

0.4

500

0.1

0.05

0

0

0.2

0.1

1000

0.16

0

< jeikP; 1 (k)j >

1

0.5

0.1

< jeiYSX (k)j >

2

0.1

1

< jeiYOX (k))j >

1000

1.5

< jeiKS; 2 (k)j >

500

< ^kP;1 (k) > [l=g]

^ S;2(k) > [g=l]
<K
< ^kP;2 (k) > [l=g]

0

0.2

< jeikP; 2 (k)j >

1

0.2

2

< jeiYSP (k))j >

2

0

< Y^S P (k) > [gP =gS ]

^ S;1(k) > [g=l]
<K

3

< Y^OX (k) > [gX =gO2 ] < Y^S X (k) > [gX =gS]

<
^1 (k) > [h1 ]

J. I. Videla, B. Lie

1

0.5

0

500
time [h]

0

1000

0

(b)

1000

0.2

0.15

0

500

1000

0.5

0.45

0.4

0

500
time [h]

< Y^OX (k) > [gX =gO2 ]

0.1

< jeiKS; 1 (k)j >

< j^
ei1 (k)j >

0

500

0

1000

0.2

0

500

0.2

0.15

0

500

1

10.5

0
x 10-4

500

(a)

0

1000

0

1000

1000

1000

0 -4
x 10

500

1000

500
time [h]

1000

0.04

0

500

0.02

1000

1

0.5

0.02

500
time [h]

500

0.06

0.04

0

0

0.08

0.06

9.5
9

500

0.005

10

1000

0

0.01

0.6

1000

0.005

0.015

0.8

0.4

0

1000

500

0.01

0.1

0.1
0.05

0
0

1000
< jeikP; 1 (k)j >

1

0.1

< jeiYSX (k)j >

500

0.1

1.5

< jeiYOX (k))j >

0

0.2

< jeiKS; 2 (k)j >

1

0.5

2

1000

1.5

0.2

< jeikP; 2 (k)j >

500

< ^kP;1 (k) > [l=g]

^ S;2(k) > [g=l]
<K
<^
kP;2 (k) > [l=g]

0

2.5

< jeiYSP (k))j >

2

1

< Y^S P (k) > [gP =gS ]

^ S;1(k) > [g=l]
<K

3

< Y^S X (k) > [gX =gS ]

<
^1 (k) > [h1 ]

Fig. 7: Simplied kinetic rate model parameter estimation results, averaged over 50 Monte Carlo simulations for
the EKF (black solid line), the UKF (black dash line), and the EnKF (black dotted line): (a) mean parameter
i
estimates h ^j (k)i for every time index k; (b) mean absolute estimated parameter error, hjei j ji = hj^j h^j (k)iji
for every time index k.

0

0

500
time [h]

0

1000
(b)

0

Fig. 8: Intracellular kinetic rate model parameter estimation results, averaged over 50 Monte Carlo simulations
for the EKF (black solid line), the UKF (black dash line), and the EnKF (black dotted line): (a) mean parameter
i
estimates h ^j (k)i for every time index k; (b) mean absolute estimated parameter error, hjei j ji = hj^j h^j (k)iji
for every time index k.

The Modelica Association

298

Modelica 2008, March 3rd  4th , 2008

Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model

ulated data sets over 50 Monte Carlo simulations. [3] P. M. Doran, Bioprocess Engineering Principles.
San Diego: Academic Press, 1995.
Four dierent reaction rate models are used by the
estimators while the simulated data sets are gen- [4] J. L. Crassidis and J. L. Junkins, Optimal estimaerated assuming that the original reaction rate
tion of dynamic systems, ser. CRC applied mathematics and nonlinear science series. Chapman
parameters have been estimated experimentally.
& Hall, 2000.
When using the original reaction rate model in
the estimator, the best parameter estimation is [5] S. F. Schmidt, Application of State-Space Methods
achieved by the EKF with slightly poorer perforto Navigation Problems, c.t. leondes ed. Academic Press, New York, San Francisco, London,
mances for the UKF and the EnKF. The lower
1966, vol. 3, pp. 293340.
performance of the UKF can be explained by the
lack of tunig of its parameters. For the estimator [6] R. E. Kalman, A new approach to linear lterusing the elementary reaction rate model, the best
ing and prediction problems,Transactions of the
ASMEJournal of Basic Engineering, vol. 82, no.
parameter estimation corresponds to the UKF,
Series D, pp. 3545, 1960.
while the EnKF has a poorer performance and the
EKF diverges for some of the parameters. For the [7] D. Simon, Optimal State Estimation  Kalman,
estimator with the simplied reaction rate model
H1 , and Nonlinear Approaches. Hoboken, New
Jersey: John Wiley & Sons, Inc., 2006.
similar performances are achieved for the 3 estimators; the UKF slightly outperforms the other [8] S. J. Julier, J. K. Uhlmann, and H. F. Durranttwo. For the estimator with the intracellular reWhyte, A new approach for ltering nonlinear
systems, in Proceedings of the 1995 American
action rate model, the best parameter estimation
Control Conference, Seattle, WA, 1995, pp. 1628
performance corresponds to the EKF.
1632.
The EnKF has a poor parameter estimation performance for most of the cases but when consid- [9] S. Julier and J. Uhlmann, A general method for
approximating nonlinear transformations of probering the mean RMSE of the estimated states it
ability distributions, tech. rep., RRG, Dept. of
outperforms the other estimators for three of the
Engineering Science, University of Oxford, Nov
four cases (see Table 7).
1996, Tech. Rep., 1996.
The computational cost of the estimators increases
considerably from the EKF to the EnKF because [10]   , A new extension of the Kalman lter to nonlinear systems, in Int. Symp.
of the number of projections required for every
Aerospace/Defense Sensing, Simul. and Controls,
estimator iteration. The fermentation model is
Orlando, FL, 1997.
run from a Dymosim executable le and this slows
down the computational performance of the esti- [11] S. J. Julier and J. K. Uhlmann, Unscented ltering and nonlinear estimation (invited paper),
mators (i.e. the computational time required for
in Proceedings of the IEEE, vol. 92(3). IEEE
every estimator interation) mainly because DyInstitute of Electrical and Electronics, 2004, pp.
mosim uses a slow le input/output interface. De401422.
spite this practical disadvantage, nonlinear esti[12] G. Evensen, The ensemble kalman lter: Themators can be evaluated with complex Modelica
oretical formulation and practical implementamodels in a simple way. Our future work will focus
tion, Ocean Dynamics, vol. 53, pp. 343367,
on the parameter identiability of the complete
2003.
model.

References
[1] P. S. Agachi, Z. K. Cristea, and A. Imre-Lucaci,
Model Based Control. Case Studies in Process
Engineering.
Weinheim: Wiley-VCH Verlag
GmbH&Co., 2006.

[13] S. Gillijns, O. B. Mendoza, J. Chandrasekar, B. L.
R. D. Moor, D. S. Bernstein, and A. Ridley,
What is the ensemble kalman lter and how well
does it work? in Proceedings of the 2006 American Control Conference, Minneapolis, Minnesota,
USA, June 2006.

[2] B. Lie and J. I. Videla, Continuous bioethanol
production by fermentation, in Green Energy
with energy management and IT, Stockholm,
2008.

The Modelica Association

299

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

300

Modelica 2008, March 3rd  4th , 2008

Model-Based Optimizing Control and Estimation using Modelica Models

Model-Based Optimizing Control and Estimation
using Modelica Models
Lars Imsland

Pal Kittilsen Tor Steinar Schei
Cybernetica AS
7038 Trondheim, Norway

{lars.imsland,pal.kittilsen,tor.s.schei}@cybernetica.no

Abstract
This paper reports on experiences from case studies in
using Modelica/Dymola models interfaced to control
and optimization software, as process models in real
time process control applications. Possible applications of the integrated models are in state- and parameter estimation and nonlinear model predictive control.
It was found that this approach is clearly possible, providing many advantages over modeling in low-level
programming languages. However, some effort is required in making the Modelica models accessible to
NMPC software.
Keywords: Nonlinear Model Predictive Control, Online optimization, process control, offshore oil and gas
production

1

Introduction

Model Predictive Control (MPC) has become the advanced control strategy in the process industries [11].
MPC refers to control strategies which optimize future
performance as predicted by a process model, and implement the first part of the calculated control inputs.
The optimization/implementation is repeated at regular intervals to achieve robustness through feedback.
Although linear MPC (based on linear, typically empirical, process models) is prevalent, it is seen that in
many cases, MPC based on nonlinear process models
(NMPC), with models derived from first principles and
process knowledge, is advantageous or even necessary
to achieve better control performance over varying operating conditions (due, for example, to varying product specifications or large process disturbances). In
addition to the use of nonlinear process models, another important aspect with NMPC based on models
from first principles, is that nonlinear state estimation
is an essential part of the control system.
NMPC has received considerable attention in
academia, especially in terms of optimization methods
The Modelica Association

[1] and requirements for stability of the resulting
closed loop [7]. However, when it comes to industrial application, use of NMPC clearly has an
unfulfilled potential, although some applications
are being reported, especially in polymerization
processes [8, 11].
One important reason for the limited practical use of
NMPC, is the substantial time and effort required for
developing, validating and maintaining nonlinear process models that are valid over a wide operating range.
Importantly, but sometimes overlooked, these models
should at the same time be suitable for optimization,
in terms of issues such as complexity and smoothness.
An important step towards less costly model development is the use of advanced modeling environments,
which promotes model structure, model reuse and
model maintenance through equation-oriented modeling languages, object orientation and hierarchical
composition of sub-models.
Literature reveals some effort towards using advanced
process modeling environments in a practical dynamical optimization setting, e.g. [9], where gPROMS are
connected to a software environment for dynamic optimization. However, the impression remains that this
is very much a developing area.
The use of such models is not limited to NMPC
in real-time process control settings. One can envision many types of real-time model-based applications using such models, ranging from data reconciliation, estimation (states, parameters, disturbances, softsensing) for monitoring and control, to advisory operator support systems and finally to NMPC. One can
argue that a complete NMPC installation involves the
other applications mentioned, such that if Modelica
models can be used for NMPC, the other applications
follows naturally.
The aim of this paper is to discuss requirements, challenges, opportunities, and experiences from using an
advanced modeling environment, in particular Dymola/Modelica, for developing models that are used
in model-based process control applications.

301

Modelica 2008, March 3rd  4th , 2008

L. Imsland, P. Kittilsen, T. Steinar Schei

Model component
NMPC
Interface

model mpc.c

Estimation
Interface

model est.c

Simulation
Interface

model sim.c

Definition of states,
parameters, etc.
Solving ODE/DAE.

Interface code for
initialization, outputs,
and derivatives.

Autogenerated code
from Dymola.

XXX
Interface

model xxx.c

Model specific

General

Model specific

model.c

dymint.c

dsmodel.c

Figure 1: Illustration of model component software structure
The paper is structured as follows: First, we give some
remarks on how we have integrated Modelica models
(developed using the Dymola tool) into the NMPC tool
C YBERNETICA C ENIT (for state estimation and optimization). Next, we give some comments on modeling and model types, and give a brief overview over
the modeling used in the case examples. In Section 4
we discuss using the Modelica models for state estimation, and give briefly some results obtained using
real process data. In Section 5 we discuss optimization
in Nonlinear Model Predictive Control, and illustrates
with results from a simulation study.

2

Interfacing Modelica/Dymola models with NMPC estimation and optimization software

In this section, we discuss the integration of Modelica
models with C YBERNETICA C ENIT, a software package for NMPC developed by Cybernetica.
The C YBERNETICA C ENIT kernel consists of three
components: The NMPC optimization component, the
state estimation component, and the model component. The components communicate (with each other
and externally) using prespecified interfaces. The two
first components are general, while the model component of course is specific for each project. Other
C YBERNETICA C ENIT modules, for example for offline parameter estimation/optimization for fitting the
model to data, also exist and make use of the kernel,
but are not considered part of the kernel.
The model component includes discretization (simulation of the model between sample intervals), such that
the model is discrete time as seen from the state estimation and NMPC module.
Traditionally, the model component has been coded in
C. This has served the purposes well, but for a number
of reasons it is desirable to have a more user-friendly
The Modelica Association

way of implementing models, using a high-level modeling language. The overall goal is to reduce the cost
of modeling, which is a significant cost factor in a
NMPC implementation project. Reasons for the cost
reduction include
 Promote reuse of models, also through building
of model libraries.
 Better overview of models, ease of implementation and modifications.
 Easier exploitation of modeling effort in other
contexts.
 Possibly easier integration of external models
(external libraries, customer models, thermodynamics, etc.).
After an investigation of the available alternatives,
evaluated against a range of criteria including the issues in the list above, it was found that Modelica was
an excellent possible choice for an alternative modeling language. Moreover, the software tool Dymola
provided a good Modelica modeling environment, and
the opportunity to integrate the models in other software, through the Dymola C-code export option.
With the C-code export, the Modelica model is available in a C-file, dsmodel.c, along with interface functions. Figure 1 illustrates how this C-file can be integrated to form a model component ready to use with
C YBERNETICA C ENIT.
A distinct advantage of the C-code export offered
by Dymola, is that it allows compilation of the total
control system including model on any target system
equipped with an ANSI C compiler. This is in contrast to systems which base the interface on software
component interfaces such as CORBA, and requires (a
version of) the modeling environment to run simultaneously.
On the other hand, it might be conceived as a disadvantage that the interface is Dymola specific, and not
based on any standard.
Presently, the developed interface only allows obtain-

302

Modelica 2008, March 3rd  4th , 2008

Model-Based Optimizing Control and Estimation using Modelica Models

ing sensitivity information by finite differences, but
with the availability of analytical Jacobian from Dymola models, a natural next step, subject for current
development, is to include integration of sensitivities
in the model component. This can be an advantage
both for simulation of the model (see next section), but
perhaps more importantly, also for solving the NMPC
optimization problem (see Section 5).

3

Modeling and simulation

As mentioned in the previous section, the models developed in Modelica/Dymola must be
solved/simulated in the model component.
In
this section we first give some general remarks on
modeling and simulation for NMPC, and thereafter
we briefly present the modeling that is done for the
case examples in Section 4 and 5.

3.1

Simulating the model

Using equation-based modeling environments such as
those based on Modelica, one generally ends up with
differential-algebraic equation systems (DAEs). In
Dymola, there are implemented algorithms for reformulation (symbolic transformation) of the DAE system such that it from the outside looks like an ODE
system,
x(t) = f (t, x(t), u(t), p),
(1)
y(t) = g(t, x(t), u(t), p),
but where the evaluation of the right hand side in general requires the solution of some nonlinear equation
systems. The reformulation ensures that these equation systems are as small, and hence as efficiently
solved, as possible. However, the solution is based
on iterative, local methods, such that it can in general
take many iterations to find an acceptable solution, and
worse, one is not always guaranteed to find a solution
at all. (Although for well-behaved models, one normally finds a solution in few iterations.)
Another issue is that the right hand side might be discontinuous in its arguments. If this is the case, the
solvers used to solve the (apparent) ODE above, must
be able to handle discontinuities. Moreover, the system will often be stiff, calling for implicit methods
with variable step lengths.
Apart from any possible discontinuities, the above
issues (DAEs, stiffness, variable step lengths) do
not in principle imply any problems using Modelica/Dymola models with an NMPC tool like C YBER NETICA C ENIT.
Nevertheless, efficiency and robustness issues may
change the picture. Simulation in a NMPC system
The Modelica Association

involves frequent resetting of system parameters (initial states, inputs and estimated parameters), which for
DAEs in general requires online re-solving of the nonlinear equation set. For the ODEs exported by Dymola, it leads to frequent re-solving of the hidden
nonlinear equation sets.
If we can ensure that the model is a real ODE (without nonlinear equation sets), this is avoided, resulting
in increased speed and robustness.
There are no direct help in Dymola to avoid the nonlinear equation sets leading to a DAE system, but the
reporting when translating models helps to identify
where these nonlinear equations are.
Additionally, ensuring that the model is continuous,
means that we can use more efficient solvers that do
not have to handle discontinuities.
These issues require more effort during the modeling,
and also imply that one often cannot apply other (library, customer) models directly. Nevertheless, the issues are important: In our experience, it is a key aspect
of a successful implementation of a NMPC system to
find the correct balance between computational complexity of the model/simulation and required model
accuracy. Required model accuracy is not easily defined in general, but relates to the specific control objectives of the particular process. In this respect, more
complex models are not necessarily more accurate.
When building models from physics, one typically
ends up with stiff equation systems, which require implicit solvers with variable step sizes to be solved efficiently. If one chooses to exploit analytical Jacobians
in connection with optimization (see also Section 5),
this can in principle also be used in the implicit solvers
to speed up computation.

3.2 Control-relevant modeling of an offshore
oil and gas processing plant
In the North Sea (and on other continental shelfs), oil
and gas are produced by drilling wells into the ocean
bed. From the wells, a stream of typically oil, gas
and water arrive at a surface production facility which
main task is to separate the components and make oil
and gas ready for export, either through pipelines or by
ship. A schematic picture of such an offshore oil and
gas processing plant placed on an offshore platform is
given in Figure 2. In this case, we have to some extent disregarded water, to concentrate on the oil and
gas streams.
In Figure 2, we see that oil and gas enter from two different main sources (each main source is represented
by one oil and one gas source) into three separators
(the grey ovals). The separators are large tanks which
split oil, water and gas. The produced oil is leaving in

303

Modelica 2008, March 3rd  4th , 2008

L. Imsland, P. Kittilsen, T. Steinar Schei

the lower right corner of the figure, while the gas enters a compression train from the second and third separator. The compressor train, consisting of five compressors (five stages) compresses the natural gas for
re-injection or to export through a pipeline (upper right
corner). At the top, there is an additional gas import
(from another production platform) with an additional
gas compressor. Some of the gas is taken out (top left)
as fuel for on board generators.
As can be seen, this is a fairly complex system in
terms of numbers of components, however, many of
the components are of the same type (mainly separators, compressors, valves, PID controllers, in addition
to minor components such as sources, sink, splitter,
sensors, etc.), which simplifies overall modeling.
A brief description of some unit models is given below:
 Separators: Separators are large tanks which due
to their construction, and the different densities
of the components, separate water, oil and gas
into different process streams. The dynamics of
the separator model is based on a mass balance
and flash calculations to calculate the split of oil
and gas. Based on the separator geometry (and
thermodynamics), water and oil levels and gas
pressure can be calculated from the component
masses.
 Compressors: The centrifugal compressor models are static models based on compressor maps
(specified by the compressor vendor) of polytropic head vs. volumetric rate, parameterized in
compressor speed. The compressor maps are
interpolated to yield continuous relations. The
compressors are strongly nonlinear, that is, the
gain from compressor speed (input) to pressure
and volumetric rate are strongly dependent on operating point.
 Valves: There are different valve models for liquid and gas flow, both based on basic valve equations. Critical and sub-critical flow are handled.
The valve characteristics can be chosen to be either linear or equal percentage via a drop-down
menu.
For real-time efficiency reasons, we have made an effort to ensure that we end up with an ODE model.
The main manifestation of this, is that we cannot have
more than one unit that determines flow between each
volume in the model. Therefore, we have introduced
semi-physical nodes (the grey round units in Figure 2), and tuned the volumes of these to retain good
transient response (for example, by tuning them to be
faster than the sample frequency, the exact value is not
important in terms of simulation accuracy vs. measureThe Modelica Association

ments).
Thermodynamics are important in order to calculate
phase transitions between oil and gas. It is also essential to be able to describe the gas properties over a
large span in pressure. Furthermore, the model should
have real time capabilities, favoring simple/explicit relations.
For phase equilibrium calculations, correlations of
k-values (as function of temperature, pressure and
molecular weight) were used together with a simplified representation of the many chemical species found
in the real process. Gas density was described by a
second-order virial equation, where the model coefficients were fitted to an SRK-equation for the relevant gas composition evaluated for the temperature
and pressure range of current interest.
The thermodynamic models have been implemented in
the style of the Modelica.Media library in the Modelica Standard Library.

4 State estimation
4.1 State estimation background
Nonlinear state-, disturbance- and parameter estimation are essential for NMPC implementations, but are
also important in other settings than purely controlrelated, such as monitoring and surveillance, and static
optimization/RTOs.
Estimation based on Kalman filter algorithms has become tremendously widespread over the last almost 50
years. Other types of estimation algorithms also exist, but are much less used. For nonlinear state estimation, Extended Kalman Filtering (EKF) algorithms
should be used. Traditionally, these are based on analytical linearizations, but over the last years, it is seen
that using divided differences (or similarly, Unscented
Kalman Filtering (UKF) approaches) in many cases
provides better performance than linearization-based
EKF.
Importantly, the perturbation schemes used in connection with covariance update by divided differenceapproaches (including UKFs) obtain information beyond linearization. Thus, for these cases, availability
of analytical Jacobians from the model is not necessarily an advantage (unless it speeds up simulation). On
the other hand, for estimation schemes based on linearizations (e.g. traditional EKF), or estimation based
on numerical optimization (e.g. Moving Horizon Estimation (MHE)-approaches, taking inequality constraints into consideration), analytical Jacobians can
be exploited.
C YBERNETICA C ENIT has implemented EKFs based

304

Modelica 2008, March 3rd  4th , 2008

Model-Based Optimizing Control and Estimation using Modelica Models

G

G

G

G
G

G

1

L

0

0

0

V

_

0

A

2

_

L

m

m
m

Figure 2: Overview of an offshore oil and gas processing plant, as implemented in Dymola.
on divided differences (both DD1 [13] and DD2 [10], sential basis for taking the correct corrective actions
in the notation of [10]), in addition to MHE [12]. For in case of abnormal incidents, and also essential as a
starting point for optimization of process operation.
further information and discussion, see also [14].
The resulting ODE model of the system was fairly

4.2

Example: State estimation of offshore stiff, with modes ranging from around 0.1 seconds to
hours, while the sampling time of the process was 1
processing plant

The state and parameter estimation capabilities of C YBERNETICA C ENIT (extended Kalman filtering based
on finite differences in this case) was used to estimate
states and model parameters in a Modelica model of
the offshore oil and gas processing plant illustrated in
Figure 2. The Modelica model was integrated as a C YBERNETICA C ENIT model component as explained in
Section 2. Logged data from real operation was used
in the test.
The process is fairly well instrumented (a subset of the
instrumentation is included in the Modelica model, see
Figure 2), but there is no overall reconciliation of the
individual measurements nor any overall measurement
of key figures. From the individual measurements,
most often in engineering units, it is hard to get an
overview of the state of the process. With a complete
process overview by the help of the model, it is possible to identify the current process state, being an esThe Modelica Association

minute. Therefore, it was absolutely necessary to use
an (implicit) ODE solver with varying step lengths. In
this case, the CVODE ODE solver1 was used, with Jacobians found by finite differences. For this model,
with 38 states and 35 estimated parameters, the state
estimation ran more than 10 times faster than real time.
The state and parameter estimation was successfully
tuned and tested on data from several days of operation. An excerpt is shown in Figure 3, where the model
initially is simulated open loop, and the state estimation is turned on after 60 minutes. The figure demonstrates, for a single compressor stage, how the compressor parameters converge such that the estimated
variables match the measured ones.

1 From the SUNDIALS package, see http://www.llnl.
gov/CASC/sundials/.

305

Modelica 2008, March 3rd  4th , 2008

L. Imsland, P. Kittilsen, T. Steinar Schei

Suction pressure

Delivery pressure

5.2

17.8

barg

barg

17.7
5.15

17.6
17.5

5.1

0

50
4

150

17.4

200

0

Volumetric flow rate

x 10

50

100

150

200

Delivery temperature
127
126
C

1.75

3

m /h

1.8

100

1.7
1.65

125

0

50

100

150

124

200

0

Compressor parameter 1

50

100

150

200

Compressor parameter 2

1

0.77
0.765

0.995

0.76
0.755

0.99

0

50

100

150

0.75

200

0

50

100

150

200

Figure 3: State and parameter estimation of one of the compressor stages. Red lines are real process data, and
blue lines are estimated results.

5
5.1

Nonlinear Model Predictive Control
NMPC background

The NMPC optimization problem is a dynamic optimization problem, usually discretized to have a finite
number of optimization variables (manipulated variables), that must be solved at regular (sampling) instants. The first part of the optimal solution  the first
sample interval, is implemented to the process, before
the dynamic optimization problem is resolved before
the next sample instant. The optimization problem is
using updated process information from a state estimation algorithm.
The optimization problem to be solved at time t, with
available state estimate x(t), may look something like
this, after a piecewise constant parameterization of future manipulated variables (u) over an horizon L:

eral obtained by simulation of an ODE (1) over the
sample intervals. The functions hx and hu represent
constraints on states (or controlled variables) and manipulated variables.
In most cases, the (discretized) dynamic optimization
problem is solved using numerical algorithms based
on sequential quadratic programming (SQP). A SQP
method is an iterative method which at each iteration
makes a quadratic approximation to the objective function and a linear approximation to the constraints, and
solves a QP to find the search direction. Then a linesearch is performed along this search direction to find
the next iterate. General SQP solvers may be applied
to NMPC optimization, but it is in general very advantageous to use tailor-made SQP algorithms for NMPC
applications.

Although a very crucial step in SQP algorithms tailored for NMPC optimization is the linesearch, the
main approaches found in the literature are usually
L1
categorized by the way they specify the QP for findmin  F(xk+1 , uk ) subject to
ing the search direction. Arguably, the most common
u0 ,u1 ,...,uL1
k=0
method is the sequential approach [5], which at each

xk+1  f (xk , uk ) = 0, k = 0, . . . , L  1,

iteration simulate the model using the current value of


x
=
x(t),
the optimization variables (u0 , u1 , . . . , uL1 ) to obtain
0
(2)
the
gradient of the objective function (and possibly the

hx (xk )
 0, k = 1, . . . , L,



Hessian), thus effectively removing the model equalhu (uk )
 0, k = 0, . . . , L  1.
ity constraints and the states x1 , x2 , . . . , xL as optimizaThe discrete-time system xk+1 = f (xk , uk ) is in gen- tion variables. Thereafter a reduced space QP probThe Modelica Association

306

Modelica 2008, March 3rd  4th , 2008

Model-Based Optimizing Control and Estimation using Modelica Models

lem is solved to find the search direction. Conversely,
in the simultaneous [4, 2] approach, the model is implemented as explicit equality constraints, meaning
that the optimization variables are both u0 , u1 , . . . , uL1
and x1 , x2 , . . . , xL . The third approach, multiple shooting [3, 6], can be viewed as a combination of the two
other approaches, where, loosely speaking, the control
horizon is divided into some sub-horizons which are
solved in a sequential fashion, and equality constraints
link the sub-horizons.
There is no general consensus as to which of the above
methods is best  probably, it is problem dependent.
Note that the two latter approaches allow closer cooperation between the ODE/DAE solvers and SQP optimization than is revealed by the formulation (2).
A sequential approach to dynamic optimization is implemented in C YBERNETICA C ENIT. A central issue is how to obtain the necessary sensitivity information for solving the NMPC optimization problem.
The two main routes are either by finite differences
directly on the objective function, or by integrating
ODE/DAE sensitivities along with the model, and calculate NMPC sensitivities based on this. For the latter
case, one can exploit the possibility of using analytical
Jacobians in Dymola.
Calculating the gradient by finite differences means
that many (depending on number of optimization variables) simulations over the control horizon has to be
done, which can be time-consuming. Calculating the
gradient based on sensitivity integration has the potential to be significantly more efficient, at least for some
problems.
A possible problem with forming the NMPC objective function gradient (and possibly Hessian) based on
ODE/DAE sensitivities, is that the resulting gradient
(and Hessian) is not necessarily a very good approximation to the NMPC objective function to be solved
numerically. Consider the following argument: By
using finite differences directly on the NMPC objective function (which includes solving the ODE/DAE),
we obtain a direct approximation to the gradient of the
numerical NMPC objective function, which is what
we are minimizing numerically. However, by computing the gradient based on ODE/DAE sensitivities,
discretization errors will make the computed gradient
different from the gradient of the numerical objective
function.
Such errors may be important since one for computational complexity reasons is likely to push the accuracy limits for the ODE/DAE solvers.
The Modelica Association

5.2 Simulation example: NMPC of offshore
processing plant
The case used in this section is similar to the one used
in the previous section, but is based on (another) production platform. In this case, the focus is on the
separation, and the gas compression is not modeled.
The process has five different streams of oil and gas,
that are to be separated in four separators (a separator
train). In contrast to Section 4, the water phase is now
explicitly modeled in the separators. The model was
tuned to fit data from the real process, but all results
shown in this paper are based on simulations.
The process is controlled by level controllers for water
and oil, and gas pressure controllers for each separator. This is a standard solution, which works well in
many/normal cases. However, in some cases, disturbances in the inlet flows from the inlet pipelines/wells
can cause problems for the control of the separators.
The levels in the separators will vary, which may cause
bad separation and may be detrimental for equipment
downstream the separators, due to uneven flow out of
the separator train. The purpose for this study is to see
if NMPC with state and disturbance estimation, using
the level controller setpoints as manipulated variables
(MVs), can exploit the buffer capacity in the separators to smooth out the outlet flows of water and oil.
The oil is in this particular case entering a distillation
column, and the water is entering a glycol regenerator,
for regeneration of glycol that is added in the process.
Smoother inflow to these units may allow more regular/increased production of the overall process.
There are six manipulated variables: The setpoints for
water and oil level controllers in the separators (two of
the separators does not separate water, and hence does
not have a water level controller). The controlled variables (CVs) are pressures, levels and valve openings
for all separators, and rate of change of glycol concentration in one separator.
The resulting model, with 29 states, was not particularly stiff. Therefore, a simple forward Euler ODE
solver was used. The NMPC system, including state
and disturbance estimation based on finite differences,
and NMPC optimization with gradients found by finite differences, ran considerably faster than real time,
using a sample interval of 6 s.
Some simulation results with a disturbance, a timelimited increased flow in one of the inflowing
pipelines, are shown in Figures 46. Figure 4 shows
how the NMPC reduces the level controller setpoints
in the inlet separator (resulting in increased outflow
valve openings, see Figure 6), to let the increased inlet flow (detected by the state and disturbance estimation) be smoothed out over all the separators. Figure 5

307

Modelica 2008, March 3rd  4th , 2008

L. Imsland, P. Kittilsen, T. Steinar Schei

demonstrates how the NMPC achieves smoother outflow from the last separator, and that the glycol fraction in the water varies less.

MVs inlet separator
100
75
%

50

CVs inlet separator
100

25

Level oil
90

0

Level water

0

20

40

0

20

40

80

%

50

20

0

20

40

60
minutes

80

100

120

Figure 4: Oil and water levels in the inlet separator,
with MPC (solid) and without MPC (dashed).

Glycol fraction in water from last separator
70
65
60
55

0

20

0

20

40

60
80
minutes
Condensate flow rate from last separator

100

120

100

120

100

90
%
80

40

60
minutes

80

Figure 5: Glycol concentration in glycol/water mixture (top) and oil flow rate (bottom) from the last
stage separator, with MPC (solid) and without MPC
(dashed).

6

Experiences with using Modelica
and Dymola for real time process
control applications

In this section, we summarize some of our experiences
with using Modelica and Dymola for process control
applications.
The Modelica Association

60
minutes

100

120

Figure 6: Level controller setpoints (MVs, top) and
level and valve openings (CVs, bottom) in inlet separator. Red line is oil, blue line is water, magenta is oil
valve opening, cyan is water valve opening.

10

70

80

50

0

30

50

120

25

40

%

100

75

60

0

80

100

70

%

60
minutes
CVs inlet separator

6.1 Modelica modeling in Dymola
When it comes to modeling, Modelica and Dymola has
much to offer over implementing the models in C. Due
to the object orientation and the graphical interface it
is easy to work on details and at the same time have
an overview over the whole model. Using a tool such
as Dymola, tasks like manipulation, testing and simulation of the model are convenient.
In this paper, we have used two cases from offshore oil
and gas production. We saw some advantages in terms
of reuse between these projects, but as we probably
will work more in this area, we expect to see further
advances at later stages. Using an object-oriented environment like Modelica, makes it easier to develop
unit models with more general interfaces, such that
they are easier reused. For some of the simple model
units, we could use units from the Modelica Standard Library, although in most cases, some modifications were done. By drawing inspiration from Modelica.Media, we had a convenient structure for implementating the thermodynamics.
As with other equation-based modeling systems, debugging models during model development is a challenge in Dymola, and tools to help model debugging
would be a benefit. However, by testing unit models
thoroughly before aggregating them, many problems
can be avoided.
When we have models with nonlinear equations systems (DAEs), we had in some cases problems with
initialization of the equation systems, and identifying
which variables that were part of the equation system.
Of course, when making sure the model was an ODE,
these problems were avoided.

308

Modelica 2008, March 3rd  4th , 2008

Model-Based Optimizing Control and Estimation using Modelica Models

6.2

Integration of Modelica/Dymola models
in NMPC software

Using the C-code export option of Dymola, it was
fairly straightforward to integrate the Modelica models as C YBERNETICA C ENIT model components as
described in Section 2. However, some modifications
must be done to the Modelica model before it is exported, and some information, not directly available
from the exported C-code interface functions, must
currently be hand-coded into the model component.
These issues are discussed below.
A significant part of the effort in constructing the
model component based on the structure illustrated in
Figure 1, is to generate and keep up to date the referencing/indexing variables in the file model.c. This
information is necessary in the NMPC user interface,
for instance for tuning of the EKF and the NMPC controller. This is presently coded by hand, but in theory, it should be possible to auto-generate at least large
parts of this file based on the model information in the
file dsmodel.c. Another possibility might be if Dymola added interface functions/functionality for this.
A NMPC system must exchange the following information dynamically with the model (in addition to
states and state derivatives):
 Model inputs: The NMPC must (at least) be able
to set the manipulated variables (MVs), the measured disturbances (DVs) and the parameters that
are estimated by the EKF.
 Model outputs: Measured variables (for state estimation), and controlled variables (for NMPC).
We have (naturally) chosen to have the MVs and DVs
as Modelica inputs. For estimated parameters, there is
a choice involving some trade-offs:
 The estimated parameters could be part of the
Modelica inputs. The advantages with this is that
it is simple to manage in the model component,
and that it is possible to calculate analytical Jacobians with respect to these parameters (for use
for instance in state estimation using MHE, or in
offline parameter estimation). The drawback is
that the Modelica unit models must be modified
to have these parameters as inputs, which makes
it cumbersome to use the same model both for
simulation and testing in Dymola, and as model
for generating the model component.
 We can access the estimated parameters the same
way as all other parameters2 . This makes bookkeeping of the parameters in the model component (model.c) more involved, and we cannot ex-

ploit analytical Jacobians with respect to these
parameters. On the other hand, this choice simplifies model maintenance, since we do not have
to make new models for estimating parameters.
Presently, our implementation is based on the first
choice, which in practice means we must maintain
two Modelica models with identical behavior  one
for simulation, and one for integration in the model
component. This situation is not ideal. One possibility
which might rectify the situation, is if Modelica had a
variable type that is both parameter and input, and a
kind of a master switch that switches the interpretation.
In some cases, it would be an advantage to be able
to debug the model code. Due to the structure of the
auto-generated code, this is hard.

6.3 Running Modelica/Dymola models in
NMPC software
There are some further interesting findings from the
case study in Section 5.2. We had this model implemented as a model component in C before we implemented it in Modelica. By using profiling tools,
we found that running NMPC with the model component based on the Modelica model, used less than 20%
additional time compared to using the pure C model
component, where most of the difference must be attributed to Modelica overhead since the models were
practically mathematically identical.
However, to get the Modelica-based model to run this
fast, we had to implement the Modelica functions used
in the Modelica-model in C. Not surprisingly, there is
considerable overhead in the implementation of Modelica functions, especially related to indexing of arrays. The possibility to implement Modelica functions
in C is supported by the Modelica specification, and
implemented in Dymola, and is a considerable practical advantage for real time applications.

7 Conclusions

It is possible to use Modelica/Dymola for modeling
for NMPC purposes, with many of the advantages
promised by such advanced modeling environments
fulfilled. Such environments are helpful in developing
complex process models, towards reuse of unit models, and we see potential for increased model value (by
extending the application area of the model) and easier
customer participation in model development.
2 Note that the estimated parameters will be constant in all sim- However, using Modelica/Dymola models for NMPC
ulations made, for instance over one sample interval in the EKF, has some hurdles. Some effort is required to make
or over the control horizon in the NMPC.
a Modelica simulation model ready to be used with

The Modelica Association

309

Modelica 2008, March 3rd  4th , 2008

L. Imsland, P. Kittilsen, T. Steinar Schei

NMPC software. In our experience, two main issues [8] B. A. Foss and T. S. Schei. Putting nonlinear model
predictive control into use. In Assessment and Fuare a) making Modelica model parameters accessible
ture Directions Nonlinear Model Predictive Control,
to the NMPC through Modelica inputs and outputs,
LNCIS 358, pages 407417. Springer Verlag, 2007.
and b) specifying the structure of state-, input-, outputand parameter vectors (e.g. for NMPC and state esti- [9] Y. D. Lang and L. T. Biegler. A software environment
for simultaneous dynamic optimization. Computers &
mation tuning).
Chemical Engineering, 31(8):931942, 2007.
Finally, we emphasize that process models for NMPC
should be developed with the specific task in mind, [10] N. K. Poulsen M. Nrgaard and O. Ravn. New developments in state estimation for nonlinear systems.
in terms of issues such as complexity, accuracy and
Automatica, 36(11):16271638, 2000.
smoothness. In some cases, this means that the model
should be an ODE, while models from component- [11] S. J. Qin and T. A. Badgwell. A survey of industrial
based modeling languages such as Modelica naturally
model predictive control technology. Control Engineering Practice, 11:733764, 2003.
translates into DAEs. It will in general require some
effort and compromises for Modelica models to trans- [12] C. V. Rao and J. B. Rawlings. Constrained process
late into ODEs.
monitoring: Moving-horizon approach. AIChE J.,
48(1):97109, 2002.
[13] T. S. Schei. A finite-difference method for linearization in nonlinear estimation algorithms. Automatica,
33(11):20532058, 1997.

Acknowledgments

We gratefully acknowledge StatoilHydro Research
[14] T. S. Schei. On-line estimation for process control and
Centre in Porsgrunn, Norway for providing the cases
optimization applications. In Proc. 8th International
and process data used in this paper.
IFAC Symposium on Dynamics and Control of Process
Systems (DYCOPS-07), Cancun, Mexico, 2007.

References
[1] L. Biegler. Efficient solution of dynamic optimization
and NMPC problems. In F. Allgower and A. Zheng,
editors, Nonlinear Predictive Control, pages 219245.
Birkhauser, Basel, 2000.

[15] T. S. Schei, P. Singstad, and Aa. J. Thunem. Transient
simulations of gas-oil-water separation plants. MIC
Model. Identif. Control, 12(1):2746, 1991.

[2] L. T. Biegler, A. M. Cervantes, and A. Wachter. Advances in simultaneous strategies for dynamic process
optimization. Chem. Eng. Sci., 57:575593, 2002.
[3] H. G. Bock, M. Diehl, D. B. Leineweber, and J. P.
Schloder. A direct multiple shooting method for realtime optimization of nonlinear DAE processes. In
F. Allgower and A. Zheng, editors, Nonlinear Predictive Control, volume 26 of Progress in Systems Theory, pages 246267, Basel, 2000. Birkhauser.
[4] A. M. Cervantes and L. T. Biegler. Large-scale dae
optimization using simultaneous nonlinear programming formulations. AIChE J., 44:1038, 1998.
[5] N. M. C. de Oliveira and L. T. Biegler. An extension of
newton-type algorithms for nonlinear process control.
Automatica, 31:281286, 1995.
[6] M. Diehl, H. G. Bock, and J. P. Schloder. A real-time
iteration scheme for nonlinear optimization in optimal
feedback control. SIAM J. Contr. Optim., 43(5):1714
1736, 2005.
[7] R. Findeisen, L. Imsland, F. Allgower, and B. A. Foss.
State and output feedback nonlinear model predictive
control: An overview. European J. of Control, 9(23):190206, 2003.

The Modelica Association

310

Modelica 2008, March 3rd  4th , 2008

Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System Models

Overdetermined Steady-State Initialization Problems
in Object-Oriented Fluid System Models
Francesco Casella, Filippo Donida
Dipartimento di Elettronica e Informazione
Politecnico di Milano
Piazza Leonardo da Vinci, 32 - 20133 Milano ITALY
e-mail: casella@elet.polimi.it

Bernhard Bachmann
Fachbereich Mathematik und Technik
Fachhochschuele Bielefeld
Am Stadtholz 24  33609 Bielefeld GERMANY

Peter Aronsson
MathCore Engineering AB,
Teknikringen 1B, SE-583 30 Linkping, SWEDEN

Abstract
The formulation of steady-state initialization
problems for fluid systems is a non-trivial task. If
steady-state equations are specified at the
component level, the corresponding system of initial
equations at the system level might be overdetermined, if index reduction eliminates some states. On
the other hand, steady-state equations are not sufficient to uniquely identify one equilibrium state in
the case of closed systems, so additional equations
are required. The paper shows how these problems
might be solved in an elegant way by formulating
overdetermined initialization problems, which have
more equations than unknowns and a unique
solution, then solving them using a least-squares
minimization algorithm. The concept is tested on a
representative test case using the OpenModelica
compiler.

1

Introduction

The Modelica language is finding more and more
applications in the field of thermo-fluid system
modeling, due to the many advantages of the declarative, object-oriented approach. In this context, it is
very often the case that steady-state initialization is
required.

The Modelica Association

Specifying a well-posed steady state initialization
problem in an object-oriented language is a nontrivial task for some fundamental reasons. From an
end-user point of view, the ideal situation is to select
a steady-state initialization option on the system
components, without worrying too much about the
actual internal implementation. This means that each
component model should contain an initial equation
section, with conditionally activated initial equations
that express the steady state condition for that
model. In this way, initial equations are specified
locally within each model. Unfortunately, a wellposed initialization problem can only be formalized
at the aggregate system level, i. e., on the system of
DAEs describing the complete system. On one hand,
index reduction can lead to a reduced number of
states, if ideal pipes with zero pressure loss are used
or ideal controllers are employed, so that some of
the locally specified initial conditions are redundant.
On the other hand, some model structures (e. g.,
closed systems) may be such that the locally
specified steady-state conditions are not sufficient to
completely determine the initial state.
The actual type and number of independent initial
equations required to uniquely determine a
consistent steady-state initialization thus depends in
a non-trivial way on the connection topology of the
system. It is therefore impossible for the library
designer to write local steady-state initial equations

311

Modelica 2008, March 3rd  4th , 2008

F. Casella, F. Donida, B. Bachmann, P. Aronsson

which are always good, because that depends on
how the specific model will be connected to other
ones. Furthermore, it is exceedingly hard for the end
user to determine the exact structure of the required
initial equations, because this would require a deep
knowledge of the inner mathematical details of the
single models, and of the mathematical properties
arising from the interconnection of the models. The
former requirement is against the principle of encapsulation: one should not necessarily be aware of the
implementation details of an object in order to use it;
the latter can be even more difficult for large
systems.
The aim of this paper is to demonstrate how an
elegant and user-friendly solution to this problem
can be obtained by formulating overdetermined
initialization problems, with particular reference to
fluid systems. No extension to the Modelica
language is needed. Three representative examples
will be presented, then solved using the Open
Modelica compiler and the methods presented in [1].

2

A Simple Circuit Model

The approach proposed in this paper will be demonstrated on a small case study: the simplified model
of a heating circuit. The system includes an accumulator to pressurize the circuit, a pump, a heater (pipe
with prescribed heat flow), a valve and a radiator
(pipe with convective heat transfer to a fixed temperature sink), connected in a closed loop configuration
(Fig. 1).

The original model was built using components from
the Modelica_Fluid library [2]. In order to overcome
the current limitations of the OpenModelica
compiler, the SimpleFluid library has been
developed. The aim of this small library is to capture
the essential mathematical structure of fluid system
models, while avoiding advanced language features,
such as the semiLinear operator and the replaceable
packages of the Modelica.Media library, currently
not supported by the compiler. These simpler models
are more than adequate to demonstrate the proposed
approach; the library will be updated with more
complex models and test cases as the OpenModelica
compiler is improved.
2.1

Connectors

The fluid connectors of the library are similar to the
connectors of the ThermoPower library [3]-[4]:
connector FlangeA "Type-A connector"
Types.Pressure p "Pressure";
flow SI.MassFlowRate w "Mass flowrate";
output Types.SpecificEnthalpy hAB
"Specific enthalpy of fluid flowing A->B";
input Types.SpecificEnthalpy hBA
"Specific enthalpy of fluid flowing B->A";
end FlangeA;
connector FlangeB "Type-B connector"
Types.Pressure p "Pressure";
flow SI.MassFlowRate w "Mass flowrate";
input Types.SpecificEnthalpy hAB
"Specific enthalpy of fluid flowing A->B";
output Types.SpecificEnthalpy hBA
"Specific enthalpy of fluid flowing B->A";
end FlangeB;

Locally re-defined types are used in order to set
reasonable non-zero default start values for the
thermodynamic properties. The reader is referred to
[3] for details about the connector design.
Thermal transfer is described by standard Modelica.Thermal.HeatTransfer connectors and components.
2.2

Figure 1. Flow diagram of the test case
The Modelica Association

Medium models

Medium properties are computed by a replaceable
medium model, similar to the BaseProperties model
of the Modelica.Media standard library. The base
model contains the pressure p, temperature T,
density , specific enthalpy h, and specific energy u
of the fluid, as well as the partial derivatives with
respect to pressure and enthalpy which are needed
for the mass and energy balance equations.
The test cases described in this paper use a model of
a compressible liquid with constant specific heat at

312

Modelica 2008, March 3rd  4th , 2008

Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System Models

constant pressure, constant compressibility and
constant thermal expansion coefficient.
2.5
2.3

Pump

Currently, a trivial pump model is employed, with
prescribed flow rate: this could represent a pump
equipped with an ideal mass flow rate controller.
The prescribed flow rate is given by an input signal
connector. The enthalpy increase due to the specific
work added to the fluid is not taken into account, as
it is negligible compared to the heat tranfer in the
heater and radiator models.
2.4

Mass and energy storage are represented by the
classical lumped-parameter mass and energy balance
equations. Pressure and temperature are used as
states.
M = V
(6)

U =M u
dM
=V
dt

dM
=w1w2 ,
dt

(2)

dp
=w1w2 ,
dt

dM
=0 ;
dt

(4)

given the choice of states, the initial equation in the
model is written as:

dp
=0 .
dt
The Modelica Association

(5)

dp
d

dT
T dt

dT
p dt

(8)
(9)
(10)

The mass and energy balance equations

dM
=w1w2
dt
dU
=w1 h 1w2 h 2Q
dt

(11)
(12)

are thus written using the results of equations (8)(10). Here, M and U are the mass and energy of the
fluid contained in the model, V is the volume, cp is
the specific heat at constant pressure, h1 and h2 are
the specific enthalpies of the fluid entering and
exiting the volume, and Q is the heat flow entering
the volume.
The steady-state equations for this component are:

dM
=0
dt
dU
=0 .
dt

(3)

w1 and w2 being the inlet and outlet mass flow rates.
Since the flow rate of fluid going into and out of the
accumulator is usually much smaller than the flow
rate in the circuit, trivial energy balance equations
are assumed, where the specific enthalpy of the fluid
going out of the T junction is always equal to the
enthalpy of the incoming fluid.
The steady-state equation for this component, which
contains a dynamic mass balance, should be

[    ]
d
dp

 

is written as

C

(7)

dh
dh dp
dT
=
c p
dt
dp T dt
dt
dU
dh dM
dp
=M

hV
dt
dt
dt
dt

Accumulator

Accumulators are usually employed to pressurize
liquid-filled circuit and accommodate the expansion
and contraction of the fluid due to the thermal
expansion effect. Typical accumulators are built
using a tank partially filled with air, so that the
amount of water contained depends on the air
pressure. The model includes the three-way T
junction to the circuit, so that it has two fluid
connectors.
A simple linear model has been used to compute the
amount of liquid contained in the accumulator:
M =Cp ;
(1)
where C is the hydraulic capacitance; since the
pressure has been selected as a state, the mass
balance equation of the model

Lumped volume

(13)
(14)

Given the choice of states, these equations can be
more conveniently reformulated as

dp
=0
dt
dT
=0 .
dt
2.6

(15)
(16)

Pressure loss model

In order to avoid trouble with hard nonlinearities at
this stage, a simple linear pressure loss has been
assumed:
(17)
w=K  p ,

313

Modelica 2008, March 3rd  4th , 2008

F. Casella, F. Donida, B. Bachmann, P. Aronsson

where p is the pressure drop across the component,
w is the mass flow rate through it, and K is a
constant flow coefficient. Future version of the
model wil consider a density-dependent, quadratic
pressure loss.
The energy balance is an isentalpic transformation
between the inlet and the outlet.

Each pipe is described by a simple symmetric
lumped-parameter model, with one volume
describing mass and energy storage, and two
adjacent pressure loss models describing the
momentum balance.

where Mj are the masses of the fluid in the components with storage, i.e., the accumulator and the two
pipe volumes. If one now sums the initial equations
(4) and (13) for the accumulator and volume components, the same equation is obtained. This means
that the simulation equations and the steady-state
equations for a closed system will always be linearly
dependent. The corresponding initialization problem
is therefore singular, and has an infinite number of
solutions, corresponding to different amounts of
liquid in the circuit or, equivalently, to different
levels of pressure in the circuit.
It is important to note that no single component has
singular initialization equations: the singularity only
arises at the system level. It is therefore convenient
to leave all the steady-state equations in the single
components, and add one more initial equation at the
system level, e. g. by specifying the pressure at one
point of the circuit or, alternatively, by specifying
the total mass of liquid in the circuit. This leads to
an overdetermined system of initial conditions,
which has one more equation than unknowns, but
now has one unique solution.

2.9

3.2

2.7

Valve

The valve model is similar to the pressure loss,
except that the flow coefficient can be modulated by
varying the valve opening input signal u from 0 to 1.
w=K u  p .
(18)
2.8

Pipe

Choice of physical parameters

The nominal operating point of the circuit assumes a
flow rate of 1 kg/s, a thermal power of 84 kW, and a
convective heat transfer to the environment such that
the temperature of the radiator is 10 K above the
ambient value of 300 K, while the heater temperature is 330 K. The pressure loss in the valve is 1
bar, as well as the pressure loss in the pipes, which
is equally divided between the two half-pressure-loss
models. The hydraulic capacitance of the accumulator is 3 kg/bar.

3
3.1

Initialization problems
Steady-state initialization of a closed circuit

The components of the circuit model have 5
potential state variables: the pressure and temperature of the two volumes, and the pressure of the
accumulator.
Since the circuit is closed, the total mass of the fluid
in the circuit must be constant, because there is no
mass flow rate entering or leaving the system.
Therefore, the system equations, by their very
nature, imply that

j

dM j
=0
dt

The Modelica Association

(19)

Steady-state initialization with
pressure-loss flow components

zero-

Suppose that the pressure loss due to friction in the
radiator is small, compared to other pressure losses
in the circuit. In order to avoid highly nonlinear stiff
equations, and to reduce the number of states in the
system, a possible modelling option is to neglect the
pressure loss entirely, i. e. use the equation:
 p=0
(20)
in place of equation (17) for the two pressure loss
models of the radiator. This might be an interesting
option for control-oriented models, where a reduced
number of states is often sought.
As a consequence, the pressure within the radiator
volume and the pressure within the accumulator are
bound to be equal, so that the resulting system has
index 2. The index reduction algorithm gets rid of
one of the two pressure states, so that there now is
one more redundant initial equation, compared to the
previous case, even though the overdetermined
system of equation still has one unique solution.
As in the previous case, this situation does not
depend on equations which are local to a single submodel, but rather depends on the system-level
structure of the overall model, due to the way the
sub-model are connected. It is therefore very convenient if the user doesn't have to change the local
initialization option for any sub-model, and still get

314

Modelica 2008, March 3rd  4th , 2008

Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System Models

the unique steady-state solution for the initialization
problem.
3.3

Steady-state initialization with idealized
controllers (inverse simulation)

So far, open-loop simulation problems have been
considered, in which the three inputs corresponding
to the three actuators (pump speed, valve opening,
burner power) are prescribed functions of time. One
could then study a closed-loop control problem, in
which, e. g., the burner power is used to control the
radiator temperature to a given set point, using a PI
controller. In this case, one more steady-state
equation would be needed for the controller state,
but this would not cause any further imbalance
between the initial states and the initial equations.
However, it would be necessary to tune the parameters of the PI controller in order to obtain a stable
and satisfactory performance.
In some cases, one could be interested in evaluating
the transient of the control variable (the burner
power) corresponding to some external disturbance,
assuming a very tight control, without worrying
about the actual tuning of the controller itself. This
kind of study is carried out easily in an a-causal
context, by just removing the equation which assigns
the prescribed value to the control variable, and
adding an equation which prescribes the value of the
controlled variable to be equal to the set point. This
kind of approach is also know as inverse simulation
problem (see, e.g., [5]). The prescribed set-point
must be smooth enough in order for the inverse
simulation problem to have a well-defined solution,
but this is outside the scope of the initialization
problem.
In the specific case considered in this paper, one
could prescribe the value of the radiator temperature,
in order to obtain the corresponding value of the
heater power input. This can be done both with the
system described in Sect. 3.1, as well as with the
system described in Sect. 3.2. In both cases, since
the radiator temperature is one of the system states,
the connection of the plant model to the idealized
controller will enforce an algebraic constraint on a
differentiated variable; index reduction will have to
be applied in order to get an index-1 DAE, and thus
one more state will be eliminated. Once again, since
this is a system-level issue, it would be nice not to be
obliged to change the initialization options inside
any specific sub-model of the plant, but rather keep
the resulting overdetermined initial equation system,
which still has one unique solution.

The Modelica Association

4

Numerical results

The three test cases described in Sect. 3 have been
set up in the SimpleFluid library, described in Sect.
2. The problems have then been solved using the
OpenModelica Compiler (OMC) version 1.4.3 [6].
The current solution algorithm is summarized here:
 The Modelica code is flattened, obtaining
the declarations of all variables, parameters
and constants, as well as the full set of
equations and initial equations.
 Index reduction is applied, in order to
obtained a reduced-order, index-1 system.
 The initialization problem f(z) = 0 is built,
by adding the initial equations to the set of
index-1 DAEs of the system; z is the vector
including the algebraic variables, the state
variables, and the state derivatives, while f is
the vector of the residual functions. Note
that, in general, dim(f)  dim(z).
 The initialization problem is then solved by
minimizing the norm of the residual vector
2
F  z = j f j  z , by using the Sequential
Quadratic Programming optimization code
described in [7]; the start values of all
variables are used as an initial guess for the
iterative algorithm. If the initialization
problem has one solution, the minimum is
unique and characterized by a zero residual.
OMC successfully solves all the three initialization
problems described in Sect. 3, finding the corresponding initial steady state, provided that:
 all the thermodynamic variables (pressures,
temperature, densities) are given a
meaningful, non-zero start value  this is
accomplished by extending the standard SI
unit types with suitable default start
attributes within SimpleFluid;
 the pressure and temperature states of the
volumes and of the accumulator are given a
start value close enough to the steady-state
value.
Unfortunately, convergence of the initialization
problem seems to be rather sensitive to the start
values of the temperatures in the volumes: a start
value of 300 K instead of 330 K for the heater
volume is enough to make the algorithm fail.

315

Modelica 2008, March 3rd  4th , 2008

F. Casella, F. Donida, B. Bachmann, P. Aronsson

5

Improvements and future work

Several improvement actions are proposed in this
section, which will be tested in future versions of
OMC.
First of all, the size of the optimization problem
corresponding to the initialization problem can be
roughly halved by just removing alias variables from
the flattened model. Although this sounds like a
trivial operation, care must be exercised in order to
avoid getting rid of user-defined start values, which
might have been applied to only one of the variables
in the alias set. For this purpose, it might be useful
to define a suitable priority indicator for start value
modifiers, and select the alias variable with the
highest priority start value in the set.
In order to further reduce the size of the optimization
task, BLT partitioning of the initialization equation
set could be performed, in order to split the original
problem into smaller problems, to be solved sequentially. As the incidence matrix has more rows than
columns, one has more degrees of freedom in
selecting the row/column permutation than it is
possible in the standard square problem. This is an
open topic for further research. Tearing methods
could also be very beneficial in this context.
Better scaling must be ensured to improve the
robustness of the minimization algorithm. Currently,
the state and algebraic variables z of the initialization problem, and the equation residuals f(z) are
directly used in the optimization problem. Some
equations and some variables thus have a predominating influence on the optimization problem, due to
bad scaling. For example, in the test case discussed
in this paper, the mass flow rates have an order of
magnitude of 1, while the pressures are around 106;
the mass balance equations have residuals (i.e., flow
rates) of the order of 1, while the energy balance
equations might easily give residuals (i.e. powers) of
the order of 105. This might explain the failure of the
initialization algorithm even for small changes in the
start values of the temperatures, since they mainly
affect the energy balances, which have a larger
influence on the residual norm than the mass
balances.
To improve this situation, the algebraic and state
variables might be normalized with their nominal
values; the state derivatives might be normalized
with the nominal values of the corresponding states,
assuming a typical time scale of 1 second. On the
equation side, residuals could be normalized with
scale factors obtained by a Monte Carlo approach:
these could be estimated by computing the residuals

The Modelica Association

with random small variations of the corresponding
values around their start values.
Convergence of the minimization algorithm might be
improved by introducing penalty functions which are
added to the objective function when the unknown
variables gets out of their min-max interval. In fact,
confidence intervals for the initial value are usually
known, which are much narrower than min-max
values during simulation  new minStart and
maxStart attributes for Real types could be defined
in Modelica, in order to specify the range during
initialization.
Finally, homotopy methods might be considered in
order to improve the robustness of the convergence
for not too accurate choices of the start values.
In order to be able to evaluate the impact of all these
actions, it is important to be able to monitor the
progress of the iterative minimization algorithm,
step by step. Improved diagnostic features (e.g.,
logging of iteration variable values) should then be
implemented in OMC, which could also be useful
for the diagnostics of the nonlinear solvers during
simulation.
As the robustness of the initialization algorithm and
the diagnostic capabilities are improved, it will be
possible to increase the complexity of the test cases,
first by introducing density-dependent, quadratic
pressure losses in flow models, and then by trying
more complex systems with larger numbers of
equations and states.

6

Conclusions

Steady-state initialization problems for fluid systems
are often naturally specified in terms of overdetermined systems of initial equations, having more
equations than unknowns, but possessing just one
unique solution. These problems can be solved using
minimization algorithms. The paper motivates the
need of such problems with reference to a simple
test case, and presents results obtained with the
OpenModelica compiler. Suggestions to improve the
robustness of the OpenModelica solver are also
given. The Modelica source code of all the test cases
is available from the authors; contributions to
improve the algorithms within the OpenModelica
Compiler are welcome.

316

Modelica 2008, March 3rd  4th , 2008

Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System Models

7
[1]

[4]

References
Bachmann B., Aronsson P., Fritzson P.. Robust
Initialization of Differential-Algebraic Equations,
Proceedings of the 5rd Modelica Conference,
Vienna, Austria, 4-5 Sep 2006, pp. 607-614.
http://www.modelica.org/events/modelica2006/
Proceedings/sessions/Session6a2.pdf

[2]

Casella F, Otter M., Proelss K., Richter C.,
Tummescheit H., The Modelica Fluid and Media
library for modeling of incompressible and
compressible
thermo-fluid
pipe
networks,
Proceedings of the 5rd Modelica Conference,
Vienna, Austria, 4-5 Sep 2006, pp. 631-640.

h08_Leva.pdf

[5]

F. Casella, A. Leva, Modelling of thermohydraulic power generation processes using ModelicaModular Modelling in an Object Oriented
Database, Mathematical and Computer Modelling
of Dynamical Systems, Modelling of Systems, v. 12,
n. 1, pp 19-33, 2006.

The Modelica Association

M. Thmmel, G. Looye, M. Kurze, M. Otter, J.
Bals, Nonlinear Inverse Models for Control,
Proc. 5th International Modelica Conference,
Hamburg, Germany, Mar 2005, pp. 267-279.
http://www.modelica.org/events/Conference2005/
online_proceedings/Session3/Session3c3.pdf

[6]

http://www.modelica.org/events/modelica2006/
Proceedings/sessions/Session6b1.pdf

[3]

F. Casella, A. Leva, Modelica open library for
power plant simulation: design and experimental
validation, Proceedings 3rd International Modelica
Conference, Linkping, Sweden, Nov 2003, pp. 4150. http://www.modelica.org/Conference2003/papers/

Peter Fritzson, et al. The Open Source Modelica
Project, Proc. 2nd International Modelica
Conference, 18-19 March, 2002. Munich, Germany
See also:
http://www.ida.liu.se/labs/pelab/modelica/
OpenModelica.html

[7]

317

M. J. D. Powell, The NEWUOA software for
unconstrained optimization without derivatives,
Proc. 40th Workshop on Large Scale Nonlinear
Optimization, Erice, Italy, 2004, paper DAMTP
2004/NA05.

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

318

Modelica 2008, March 3rd  4th , 2008

Session 3c
Automotive Applications

The Modelica Association

319

Modelica 2008, March 3-4, 2008

The Modelica Association

320

Modelica 2008, March 3rd  4th , 2008

Modelling of Conventional Vehicle in Modelica

Modeling of Conventional Vehicle in Modelica
Wei Chen, Gang Qin, Lingyang Li, Yunqing Zhang, Liping Chen
CAD Center, Huazhong University of Science and Technology, China
chenw@hustcad.com

Abstract
Modelica is a modern language used to model
physical systems. The language is object-oriented,
non-causal1 and the models are mathematically
described by differential algebraic equations. The
characteristic of modelica language make it very
suited to define model libraries with reusable
components, model complex applications involving
parts from several application domains, and many
more useful facilities.
InteDrive library was created for simulating
automotive driving performance, fuel consumption
and emissions. The library is yet under developed by
Huazhong University of Science and Technology in
modelica language. The aim of the library is to
provide the user with an easy to use and highly
replaceable set of vehicle component models, and
predict the vehicle performance, especially fuel
consumption for a given cycle.
The main components of this library and their
applications are introduced in this paper. The
simulation was carried out by MWorks, which is a
general modeling and simulation platform developed
by Huazhong University of Science and Technology.
The simulation results were compared with
ADVISOR. The easy and fast modeling process
shows that modelica is very useful for the modeling
and simulation of vehicles.
Keywords: InteDrive library; Simulation; Modelica;
MWorks

1

Introduction

Automotive manufacturers have been striving for
decades to produce vehicles which satisfy customers
requirements at minimum cost. Many of their
concerns are on fuel economy, road performance and
driveability. Improving fuel economy is both a
political concern of alleviating dependency on
foreign fuel and a customer preference of reducing
vehicle operating cost. Consumers also expect
vehicles to provide satisfactory performance with
desirable driving comfort. So it is very necessary to

The Modelica Association

predict the vehicle performance when the vehicle is
design.
There have been a lot of program tools to predict
vehicle performance, for example, cruise by AVL,
ADVISOR, PSAT, etc. However, these tools are
block-oriented and demand a huge amount of manual
rewriting to get the equations into explicit form.
Hence, these tools are less extensible, and hard to
reuse. It brings too much inconvenience to the user.
Modelica is an object-oriented language for
modeling of large and heterogeneous physical
systems. The language is object-oriented,
non-causal1 and the models are mathematically
described by differential algebraic equations. These
characteristics make it fast in modeling and easy to
reuse modeling knowledge[1]. Modelica has been
used to model various kinds of systems and proved
to have superiority over traditional tools in modeling
efficiency, especially over Matlab/Simulink.
InteDrive library was developed in modelica
language to predict automotive driving performance,
especially for fuel consumption. The aim of the
library is to provide the user with an easy to use and
highly replaceable set of vehicle component models.
MWorks is under developed by Huazhong
University of Science and Technology. It is a general
modeling and simulation platform for complex
engineering systems which supports visual modeling,
automatically translating and solving, as well as
convenient postprocessing. The current version is
based on Modelica 2.1 and implements almost all the
syntax and semantics of Modelica.
A vehicle model was built with InteDrive library,
and the simulation was carried out with MWorks.
The simulation results are compared with ADVISOR,
and show the correctness of the model.

2

Components

The InteDrive library contains some components
of a conventional vehicle, such as engine, clutch,
gearbox, etc. The modeling process have referred the
paper[2-4]. The present structure of InteDrive can be
viewed in Fig.1.

321

Modelica 2008, March 3rd  4th , 2008

W. Chen, G. Qin, L. Li, Y. Zhang, L. Chen

2.4

Brakes

This is described by braking data and dimensions.
By the implementation of a specific braking factor it
is possible to model disc brakes as well as different
forms of drum brakes. In this paper, a brake model in
modelica standard library was adopted.
2.5

This package contains the gears in a vehicle, such
as gear box, differential, final drive, etc.
The engine torque is turned into a power take-off
torque by considering the transmission, the mass
moments of inertia, the moment of loss. The
modeling of gear box can be referred to the
paper[3-5].

Fig.1 The structure of the InteDrive

The components of the InteDrive library are
described as below.
2.1

Vehicles

The vehicle is one of the main objects in a model.
This component contains general data of the vehicle,
such as nominal dimensions and weights. The library
presents only dynamic models for the longitudinal
motion of the vehicle. So a sliding mass may
represent as vehicle body. The model will be
developed in the future for considering the load
transfer to the rear or front axle when the vehicle is
accelerating or braking.
2.2

DriveCycles

The drive cycle is the vehicle speed trace versus
time. It is very useful for the evaluation of fuel
economy and emissions. When the simulation was
carried out, the vehicle speed must follow the speed
profile to calculate the fuel consumption and
emissions. This package includes tables for several
driving cycles. At present, it contains the NEDC,
UDDS, NYCC, HWFET and some standard driving
cycles. Any other cycle can be added easily if
desired.
Interpolation to the cycle table was used to get the
vehicle speed when the simulation was carried out.
2.3

Clutches

The clutch contains the model of a friction clutch
as used in cars with manual gear boxes. It is
controlled by the driver via the clutch pedal position.
In this paper, we adopt the clutch model in modelica
standard library, and made some modification for
simplification. The maximum normal force was
changed to maximum transferable torque. So the
parameters of the clutch may be acquired more
easily.

The Modelica Association

Gears

2.6

Engines

The component engine contains a model for a
combustion engine. The engine was modeled by a
structure of characteristic curves and maps. As the
characteristic curves for the full load, the fuel
consumption and others can be freely defined by the
user. It is possible to define a gasoline engine as well
as a diesel engine. Interpolation to the fuel map was
used to get the fuel consumption. The emission can
be calculated also if the emission map was defined.
2.7

Wheels

The wheels and tires link the vehicle to the road.
In this paper, a block called IdealGearR2T in
modelica standard library was used to model the
wheel. It converts the rotational motion to
translational motion. A force acted on the wheel to
model the rolling resistance.
2.8

Controls

The vehicle is controlled to make the vehicle
speed follow the driving cycle profiles. The controls
include throttle control, brake control, gearbox
control, clutch control and so on.
The throttle and the brake are controlled by PI
controllers. The input to the PI controller was the
error of vehicle speed acquired by simulation and the
speed requested by the driving cycle. If the vehicle
speed exceeds the reference speed, the driver
controls the brake to let the vehicle slow down. If the
vehicle speed is lower than the reference speed, the
driver controls the throttle to let the vehicle
accelerate. The PI parameters were tuned to control
the vehicle properly.
The gearbox controller shifts the gears according
to the vehicle speed. It is necessary to define the upand downshifting velocities always only for one gear
less than are available in the gear box (i.e. for a five
step gear box, only for four gears the up- and

322

Modelica 2008, March 3rd  4th , 2008

Modelling of Conventional Vehicle in Modelica

is under constant developing by Huazhong
University of Science and Technology. The current
version is based on Modelica 2.1 and implements
almost all the syntax and semantics of Modelica.
MWorks has features as follows:
a. With
modern
integrated
development
environment styles, it provides friendly user
interfaces such as syntax high-lighting, code
assist etc.;
b. Based on object-oriented compiler framework, it
perfectly supports almost all the syntax and
semantics of Modelica;
Using self-adapting solving strategies, it can
1
2
3
4
5
agilely solve differential equations, algebraic
equations and discrete equations.
MWorks Studio is a visual modeling environment
which supports drag-drop modeling based on
Modelica Standard Library. It is also an integrated
Vehicle speed (m/s)
development environment integrating with translator,
Fig. 2 Shift strategy by vehicle speed
optimizer, solver and postprocessor.
As a developing tool, this studio provides many
The clutch control determines whether the clutch modern IDE styles to promote the users
should be fully engaged, fully disengaged in this conveniences just as Eclipse or Microsoft Visual
paper. The state of the clutch depends on the Studio does, such as real-time syntax highlighting,
requirements of the drivetrain.
content assist, code formatting, outlining etc.
If the gear is changing, for an upshift or downshift,
The snapshot of MWorks Studio is shown as
the clutch is disengaged. If no (positive) torque is Figure 3.
required of the engine and or the speed required of
the engine is less than its idle speed then the clutch is
disengaged. Otherwise, the clutch is engaged.
downshifting velocities have to be defined). As can
be seen in figure 2, the upshifting velocity of the 2nd
gear means that at this velocity the gear box control
is upshifting from the 2nd into the 3rd gear. The
downshifting velocity for the 2nd gear means that at
this velocity the gear box control is downshifting
from the 3rd into the 2nd gear.

2.9

AirDrags

This component models the air resistance force act
on the vehicle. Usually, the aero dynamic resistance
force is approximated by simplifying the vehicle to
be a prismatic body with a frontal area Af . The
force caused by stagnation pressure is multiplied by
aerodynamic drag coefficient cd that models the
actual flow conditions.
1
Fa =  a Af cd v 2
2
Here, v is the vehicle speed and  a is the
density of the air. The parameter cd must be
estimated using CFD programs or experiment in
wind tunnels.

3

MWorks

MWorks is a general modeling and simulation
platform for complex engineering systems which
supports visual modeling, automatically translating
and solving, as well as convenient postprocessing. It
The Modelica Association

Library
Viewer
Property
Table
Model
Viewer

Edit
Area
Message
Area
Fig. 3 Snapshot of MWorks Studio

The library viewer illustrates all predefined
system libraries, all loaded user libraries and other
top models in the memory. The model viewer shows
all components of the current model. The edit area is
visual modeling, text modeling, icon-editing or
information area, and the status is chosen by tag. The
property table displays all properties of selected
element in the model, and the properties can be
edited here. The message area displays all messages

323

Modelica 2008, March 3rd  4th , 2008

W. Chen, G. Qin, L. Li, Y. Zhang, L. Chen

in the checking, translating, or simulating, including
status and error messages. The error can
automatically be located by double clicking error
message.
The auxiliary functions of real-time syntax
highlighting, content assist, code formatting and
outlining are provided in the text modeling status.
The solver of MWorks includes two primary
modules: collection of algorithms and console of
solving strategies. Solver provides different basic
algorithm alternatives for users to select appropriate
one. Now, a series of algorithms for different kinds
of equations have been collected in the solver, such
as SUNDIALS.
More details about MWorks can be referred to
paper [6].

4

The other parameters can be referred to
ADVISOR2002, with the vehicle config file called
CONVENTIONAL_default_in. The simulation
works was carried out with MWorks.
The vehicle is driven with the UDDS driving
cycle and the actual vehicle speed is given in figure 5.
The total distance of the UDDS was 11.991 km. The
difference between desired speed from the UDDS
driving cycle and the actual speed is shown in figure
6. It seems the vehicle has been controlled as desired.
The signal from the gear box can be seen in figure 7.
The fuel information was shown in figure 8. The fuel
use was 0.69 liter at the end of the cycle. So if the
vehicle drives a distance with 100 kilometers, the
fuel consumption was 100/11.991*0.69=5.75 liter.
The result of ADVISOR is 5.9 liter. It shows the
correctness of our models.

Simulation

A complete conventional vehicle was built by drag
components from InteDrive library. The vehicle model
can be seen in figure 4. The vehicle was modeled by a
forward-facing approach include the driver model,
which controls the throttle, brake, clutch, gearbox to
make the vehicle speed follow a given driving cycle.
Fig. 5 Actual speed for the reference car during the UDDS
driving cycle. X-axis shows time [s], y-axis vehicle
velocity [m/s].

Fig. 4 Vehicle model

The key parameters for the vehicle simulation are
listed in Table 1.
Table 1 Key parameters of the vehicle
Components
Engine
Final Drive
Transmission
Vehicle Mass
Wheel Radius
Rolling
Resistance
Wheelbase
Frontal Area
Coefficient of
Air Drag

Key Parameters
Maximum power: 41kW@5700rpm
Maximum torque: 81Nm@3477r/min
3.77
3.5676/2.008/1.3289/1.0/0.7525
1000Kg
0.282m
0.09

Fig.6 Difference between UDDS speed and actual vehicle
speed during the simulation. X-axis shows time [s] and
y-axis shows velocity [m/s].

2.6m
2m2
0.335

The Modelica Association

324

Modelica 2008, March 3rd  4th , 2008

Modelling of Conventional Vehicle in Modelica

Acknowledgement
This work was supported by the National Natural
Science Foundation of China (Grant No. 60574053),
the National High-Tech Development 863 Program
of China (Grant No. 2006AA110105).
References
[1] Modelica Association. http://www.modelica.org.
[2] Fritzson, P., et al. The Open Source Modelica Project.
Proceedings of the 2nd International Modelica
Conference, 18-19 March, 2002. Munich, Germany.
[3] P. Nobrant. Driveline Modelling using MathModelica.
Master's thesis. Linkopings universitet, Linkoping,
Sweden, 2001.
[4] Johanna Wallen. Modelling of Components for
Conventional Car and Hybrid Electric Vehicle in
Modelica. Master's thesis. Linkopings university,
Linkoping, Sweden, 2004.
[5] Otto Montell. Advanced concepts in Modelica and
their implementation in VehProLib. Master's thesis.
Linkopings university, Linkoping, Sweden, 2004.
[6] FAN-LI Zhou, LI-PING Chen, etc. MWorks: a
Modern IDE for Modeling and Simulation of
Multidomain Physical Systems Based on Modelica.
Proceedings of the 5th International Modelica
Conference, 2006.

Fig.7 Gear number during the simulation. X-axis shows
time [s] and y-axis shows gear number.

Fig.8 Fuel consumption during the simulation. X-axis
shows time [s] and y-axis shows fuel [L].

5

Conclusions

In this paper, a library for modeling of simulation
automotive fuel consumption is introduced. It uses
the
interfaces
from
the
Modelica
and
ModelicaAddtions packages to be compatible with
other libraries. The easy and fast modeling process
shows the superiority of modelica language in
modeling.
InteDrive provides various vehicle component
models to simplify for the user to build the vehicle
model according to their needs. The modular
structure of the model design allows to take
advantage of the Modelica language.

6

Future work

The library is under constant development. The
models in the library will be modified with more
detailed description. Much more models such as
viscous-clutch, torque converter, CVT, and so on will
be developed. Much more components with
electrical modules will be developed, and the library
is aimed to model conventional vehicles and electric
vehicle.

The Modelica Association

325

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

326

Modelica 2008, March 3rd  4th , 2008

Vehicle Model for Limit Handling: Implementation and Validation

Vehicle Model for Limit Handling:
Implementation and Validation
Johan Andreasson
Modelon AB
Ideon Science Park
SE223 70 Lund, Sweden
E-mail: johan.andreasson@modelon.se
Mats Jonasson
Department of Vehicle Dynamics and Active Safety
Volvo Car Corporation
SE405 31 Gteborg, Sweden
E-mail: mjonass2@volvocars.com

Abstract
This paper describes how a vehicle model from the
VehicleDynamics Library is configured, parameterised
and validated for predicting limit handling manoeuvres. Particular attention is paid to the selection of subsystem models with suitable levels of detail, as well as
the selection of measurements performed and measuring equipment. A strong principle running throughout
the presented work is component-based design where
parameterisation is performed on subsystem levels, no
tuning on the final vehicle models is done. As a final
test, the vehicle model is exposed to a sinusoidal steering input. It turns out that the model is able to reproduce the vehicles behaviour for the driving scenario
selected up to the limit of adhesion.
Keywords: Vehicle Dynamics, Component-Based
Modelling, Limit Handling, Validation

1

cal vehicle [1]. Moreover, the development of vehicle
control is facilitated if the vehicle plant pose an adequate response.
Driving conditions such as strong side motion of a vehicle are often considered to be unsafe, since the driver
risks losing control of the vehicle. Such potentially
dangerous situations need to be identified, and accordingly, there is a great deal of interest in reproducing
this class of scenarios. However, the combination of
fast transients and high accelerations triggers strong
non-linear vehicle characteristics, which in turn make
great demands on the model used. One example of
this manoeuvre is the single lane change [2]. An example of such a limit-handling manoeuvre is given in
Figure 1.

Introduction

Safety plays a prominent part in the development
of vehicles. A large portion of the development is
devoted to vehicle stability and the control task to
maintain stability even under severe driving situations.
Here, multi-body modelling becomes a powerful tool
to preserve competitiveness and keep the development
time within the given timescale. One reason for this
strength is the ability to offer an improved understanding of the vehicle and also to support the ranking of
its design variables without any access to the physiThe Modelica Association

Figure 1: Simulation of the vehicle model undertaking
a severe lane change maneuver. The arrows visualize
the forces generated in the tyre contact patch.
A fundamental requirement when considering simulation as an alternative to real-life testing is validity. A
model must not just be valid in the sense that it captures the results of already tested scenarios and pa-

327

Modelica 2008, March 3rd  4th , 2008

J. Andreasson, M. Jonasson

wheel travel

compliance

Figure 3: Animation view of the left front suspension
linkage with the 7 DOF indicated.

Figure 2: Diagram view of the chassis model layout
with body, suspensions and wheels. The component
above the body keeps track of the vehicle motion and
handles initialisation.
rameterisations. It must especially be able to predict
the effects of new scenarios, parameters and configurations, and therefore, the aim of this work is to show
that by having valid subsystem and component models, the resulting vehicle model shall also be valid.
This paper will demonstrate how a vehicle model
from the VehicleDynamics Library (VDL) [3] is put
together from parameterised subsystems and verified
against limit handling measurements. Special attention is given to choice and configuration of vehicle
model, and parameterisation of subsystems, especially
suspension characteristics.

2

Vehicle Model Configuration

The test vehicle is equipped with front McPherson
and rear multi-link suspensions. The chassis model
is implemented as a multi-body model in VDL with a
rigid body onto which the suspensions and wheels are
mounted as illustrated in Figure 2.
For the suspensions, there are two main approaches
to modelling the kinematics and compliance characteristics, respectively. The kinematics can either be
specified by the hard point locations of the links or as
tabular characteristics depending on wheel travel (and
steering for the front suspension). Compliance is either given by the individual characteristics of the elastic elements or as a lumped characteristics of the whole
suspension. The required tabular characteristics and
lumped elasticities can be generated from kinematics
and compliance (K&C) analysis.
The Modelica Association

In this application, suspension is modelled as ideal
kinematic multi-body linkages with one degree-offreedom (DOF) for wheel travel. The compliances
that are caused by bushings and material deflection is
lumped in one element between the wheel carrier and
the hub. This approach is similar to what has been used
in e.g. [4] and is illustrated in Figure 3.
The compliance adds 6 DOF for each suspension linkage, with wheel travel totally 7 DOF. Together with
the front steering compliance there is a total of 7x4+1
DOF with 2 states each for position and velocity, i.e.
58 states for the suspensions.
The wheel models use the Pajeka02 tyre force model
in VDL, implemented according to [5]. This representation was chosen because it is considered to be state
of the art and because there were available tyre data in
this format. The tyre force model has two states for
lateral and longitudinal relaxation lengths (first order
dynamics). Together with the wheels spin DOF, there
are therefore 4 states per wheel and additionally, there
are 6 degrees of freedom (12 states) for the vehicles
body motion, giving in total 58+4x4+12=86 states for
the chassis model.

3

Suspension parameterisation and
verification

As already mentioned, the model used contains both
component parameters and lumped characteristics.
Most parameters are taken from construction data such
as geometries, masses and inertias, but some are calculated from measurements on isolated subsystems.
Here, this is illustrated for the suspension compliance
characteristics.
The kinematics and the compliance of the front and
rear suspension have been measured in a dedicated rig
where the car body is fixed and a post is mounted on

328

Modelica 2008, March 3rd  4th , 2008

wheel travel

wheel travel

Vehicle Model for Limit Handling: Implementation and Validation

msr, left
msr, right
simulation, left

wheel travel

Figure 4: Virtual version of the test rig used for kinematics and compliance analysis. The chassis body is
kept fixed and one actuator at each hub applies forces
while the motion is registered using cameras. The
spheres indicate centre of gravity and payloads.

lateral

wheel travel

longitudinal

camber

toe

Figure 5: Suspension characteristics showing left and
each wheel hub (Figure 4). Using this post, forces right side measurements (blue,green) and simulation
and torques can be applied to replicate different driv- (red). Longitudinal, lateral, camber and toe motions
ing scenarios. In this case, forces have been applied on the plots x-axes and wheel travel on the y-axes.
in the lateral (ey ), longitudinal (ex ), and vertical (ez )
directions, both at the wheels centre (C) and at the es- so that a new column could be calculated from  0 / f 0 .
z
timated tyre-road contact point (W ). For every load This column is used as a replacement in C and the origcase, the rotations ( p) and translations (r) of the hub inal column is used to define the spring rates. Correare measured.
spondingly, the linear compliance of the steering sysFor a force applied anywhere other than at the hub, tem is also extracted from these measurements.
there is both a resulting torque (t) and a force ( f) at With C calculated for each suspension linkage, the
the hub so by comparing two equal forces applied at wheel travel tests performed in the K&C rig are cardifferent locations, the torque dependency can be cal- ried out virtually with VDL to verify the behaviour of
culated, and thus
the suspension models. Figure 5 shows a comparison
   
between the K&C measurement and the corresponding
f
r

.
(1) simulation for different wheel travel from.
t
p
Since it is a well-known fact that hydraulic dampers
| {z } | {z }
F

may deviate from the specification, all four dampers
were disassembled and measured in a damper rig.
Assuming that the dependency is linear, equation 1
The non-linear force-velocity characteristics retrieved
can be rewritten as  = CF where C is a 6x6 complifrom the damper measurements were used for pur1
ance matrix and C the corresponding stiffness mapose of modelling. This was carried out by linearising
trix, which is required for the compliance element.
the characteristics piecewise for the compression and
As described in Section 2, there are 7 degrees of freeexpansion phases respectively. One complicating asdom for each suspension, 6 from lumped compliance
pect is the ability of the rear dampers to adapt to load
element and 1 from wheel travel. Unfortunately, from
changes. In brief, this can be explained as a preload
a numerical point of view, it is hard to separate these
in parallel with the damper that adapts slowly to the
dependencies since springs in a car are a factor >100
vehicles load and the driving conditions.
more compliant than the contribution from the compliance element. However, since the deflection in
the compliance element is small in comparison with 4 Validation of the vehicle model
the total wheel travel, it is assumed that the accuracy
requirement of the z-deflection from the compliance As already mentioned, limit handling involves both
component is low. By keeping the vertical position fast transients and highly non-linear characteristics. To
of the measured hub fixed while forcing the opposite create a validation in such circumstances, it is sufwheel hub to move, a force ( fz0 ) is implied through the ficient to measure the state-trajectory of the vehicle
stabiliser linkage. This affected the measured hub ( 0 ) body. However, even if the response from the simThe Modelica Association

329

Modelica 2008, March 3rd  4th , 2008

J. Andreasson, M. Jonasson

ulations coincides with the measured trajectory, little
information can be retrieved about the correctness of
the subsystem models used.
In order to identify and improve the modelling and
parameterisation of these subsystems, it is advisable
to extend the handling measurements to include even
more mechanical phenomena. Obviously, since the
tyre forces contribute substantially to the vehicle motion, added to which they are well-known to be hard
to model, they become an important source to be monitored. In addition, at limit handling the vehicle executes large roll or/and pitch motions, and as a consequence, the suspension deflections become large. For
large deflections, there is a significant alteration in
toe and camber as illustrated in Figure 5, which in
turn influences the tyre forces. Moreover, the compliance characteristics changes during the deflection. The
most obvious situation is the entrance of the bump stop
for large suspension compressions. For these particular reasons, the supervision of the deflection of all four
corners becomes a viable option.

4.1 Instrumentation selection
Keeping the information discussed above in mind,
the vehicle was equipped with a gyro-platform, four
torque measuring wheels and sensors for deflection of
all four corners. The gyro-platform measures the rotations (roll, pitch and yaw speeds) and accelerations (in
x, y and z axes) of the car body. As illustrated in Figure 6d, the gyro-platform was mounted between the
front seats. The standard wheels were replaced by the
torque measuring wheels, which are able to measure
tyre forces and wheel torques in and around x, y and z
axes. This is possible due to strain gauges positioned
at the rim. The suspension deflection instrumentation
comprises levelling sensors, which measure the distance between the wheel hubs and car body.
In addition, signals from Controller Area Network
(CAN) were logged in order to monitor wheel speeds
and the states of the engine, brakes, gears and Haldex
differential. All signals (approximately 90) were collected and sampled at 50 ms in a computer. Finally,
a steering robot was mounted to support for steering
input at a high level of accuracy and repeatability. Figure 6 illustrates the measurement setup of the vehicle.
One important issue was to judge and assign a span
for the accuracy of these measurements. Another challenge related to the large amount of redundant data retrieved from the vehicle instrumentation. One example
of this redundant data relates to vehicle speed, which
can be taken from wheel speed sensors (from CAN)
The Modelica Association

and also via the gyro-platform. To select the best data,
information from sensors was compared, and later on,
consolidated or arbitrated. In addition to this, the vehicles corner weight and ride height were measured
manually.

4.2

Driving scenarios

The driving scenarios were selected with two purposes
in mind; reference and validation. To meet the first
requirement, tests were carried out under conditions
that allowed the measuring equipment to be tested as
independently of the vehicle where possible. Typical
examples are to expose the vehicle to constant conditions such as gradients in different directions.
Tests to measure the vehicle behaviour during steadystate manoeuvres were performed with both purposes
in mind, and included, braking and acceleration to verify longitudinal load transfer and the resulting pitch of
the body. Also steady-state cornering was executed
by driving with a constant radius of 45 metres, while
gradually increasing the vehicle speed up to the maximum achievable lateral acceleration. Thus body roll
and tyre normal load distribution could be validated.
The handling manoeuvres used solely for validation,
were selected to cover as much of the dynamics of the
vehicle as possible up to its limits. This group of tests
were conducted to force the vehicle into transient motions:
 Step steer using the steering robot
 Single lane change, sinusoidal steering input
from the steering robot
 J-turn and simultaneous relief of the gas pedal
(oversteer situation)
 Double lane change with a driver
Finally, the test procedure above was repeated under
conditions where roll and yaw stability control were
deactivated, in the test data presented in this report.

4.3

Validation results

Validations was finally achived on the most extreme
manoeuvres which is illustrated here by a single lane
change test with all active safety systems turned off.
The vehicle response, both measured and simulated,
is shown in Figure 7. The amplitude and the vehicle
speed are set to reach the limit of available grip to trigger most non-linear characteristics. From the slight
bouncing in the roll angle it can be seen that the bump

330

Modelica 2008, March 3rd  4th , 2008

Vehicle Model for Limit Handling: Implementation and Validation

Figure 6: The tested vehicle equipped with a) wheel travel sensors, b) steering robot, c) measuring wheels and
d) gyro platform
stops in the suspensions are activated which also gives
the same effect on lateral acceleration. It can also bee
seen that the side slip angles follow each other closely
throughout just over half of the manoeuvre when they
start to diverge. During the first half, the two simulations (red and green) are practically the same for all vehicle states while later on, the red and green are closer.
At the time when the severe single-sine tests were carried out, the proving ground was slightly moist, as appose to the rest of the testing period when the ground
was dry. A qualified guess is that  was slightly lower
when these manoeuvres were performed, which is also
supported by the fact that the simulation with  gives a
behaviour closer to that measured. Another interesting
aspect is the fundamentally different results for  = 1
and  = 0.95. While the first simulation shows a vehicle that slowly recovers low side slip, the latter one
continues to spin out and never recovers. During this
type of severe maneuvers, even very slight changes to
the surrounding conditions can have a great impact on
handling behaviour.
Another effect that is of particular importance during
manoeuvres where a bump stop is involved is the ride
height. The sudden change in load transfer can give
completely different results, as illustrated in Figure 8,
showing the effect of a change in ride height. The
red curve shows the lateral acceleration for the setup
with the measured ride height and is the same as the
red curve in Figure 7. The green curve shows the
same setup, but with the default ride height taken from
construction parameters. The default ride height was
higher in the front and lower at the rear, compared to
the measured ride height. As a result, the default settings gives a later bump stop activation and thereby
slower turn-in and more roll motion.
The influence on the suspension elasticity on the vehiThe Modelica Association

Lateral acceleration
default ride height
measured ride height

delay

Figure 8: Lateral acceleration for two different ride
height settings, the phase delay is 0.18s.
cle characteristics is well-known and provides an important means to tune a vehicles characteristics. This
effect is also seen in many of the manoeuvres investigated. However, for the limit manoeuvre presented
in in Figure 7, changes in compliance have less effect
on the results. As an example, a change of the rear
compliance by a factor of 10 only gives very slight
changes to the trajectory. This is expected to be due to
the high amplitude which makes the front tyres reach
their saturation limit almost immediately, thereby the
load transfer has a significantly higher effect on the
generated lateral force compared to changes in wheel
angles [6].

5

Conclusions

This paper has presented a methodology for validation
of a vehicle model, which is to be used in a broad range
of driving scenarios. A suitable approach for the selection of wheel suspension parameters has been pre-

331

Modelica 2008, March 3rd  4th , 2008

J. Andreasson, M. Jonasson

Lateral acceleration

Yaw rate

Side - slip angle

Roll angle

measurements
simulation, =1.0
simulation, =0.95

Figure 7: Response of open loop sine excitation (single lane change) at 80 km/h, measurements (blue) and
simulations with  = 1 (green) and  = 0.95 (red). Lateral acceleration (upper left), yaw rate (upper right),
side slip angle (lower left) and roll angle (lower right).
sented. In addition, the wheel suspension models have Jacobson at Volvo Car Corporation and Professor Anbeen validated through measurement in a chassis rig. nika Stensson Trigell at KTH Vehicle Dynamics for
A strong principle throughout the presented work is their immense support.
component-based design where parameterisations are
done on sub-system levels and no tuning on the final
References
vehicle models is performed.
The final validation involves reproduction of a real [1] M. Blundell, D. Harty, The Multibody Sysdriving scenario, which has been represented here by
tems Approach to Vehicle Dynamics, Elsevier
measurement of the state-space trajectory. The results
Butterworth-Heinemann, 2004.
indicate that it is feasible to design a valid vehicle
model, at least up to limit handling, from valid sub- [2] Technical Committee ISO/TC 22, Road vehicles
- Transient open-loop response test method with
systems without involving additional tuning. Finally,
one sinusoidal input, ISO/TR 8725, 1988.
it is demonstrated that a minor error in the estimation
of unknown environmental factors, such as road fric[3] J. Andreasson, M. Gvert, The VehicleDytion, risk to jeopardise the correspondence.
namics Library - Overview and Applications.
From these findings, it is evident that the methodology
In: Proceedings of the 5th Modelica Conferpresented is a viable tool for use in the vehicle develence, Vienna, Austria, Modelica Association, 4-5
opments. In addition, it has a great potential to support
September 2006.
for the development of safer vehicles and facilitate the
[4] K. Salani and G. Heydinger, Parameter Deterdevelopment of preventative safety functions.
mination and Vehicle Dynamics Modeling for
the National Advanced Driving Simulator of the
2006 BMW 330i, SAE paper 2007-01-0818.
Acknowledgments
This work was financed in part by the Swedish National Energy Agency. The authors are grateful to Mr
Per Hesslund and Mr Mikael Riikonen at Volvo Car
Corporation for assisting us with the vehicle measurements. In addition, we would like to thank Dr Bengt
The Modelica Association

332

[5] Pacejka, H.B. Tyre and Vehicle Dynamics,
Butterworth-Heinemann, 2002.
[6] J. Andreasson, On Generic Vehicle Motion Modelling and Control, Ph.D. thesis, ISBN 91-7178527-2, 2006.
Modelica 2008, March 3rd  4th , 2008

Modelling of a Double Clutch Transmission with an Appropriate Controller for the Simulation of Shifting
Processes

Modelling of a Double Clutch Transmission with an
Appropriate Controller for the Simulation of Shifting Processes
Henrik Isernhagen Clemens Ghmann
Technische Universitt Berlin
Chair of Electronic Measurement and Diagnostic Technology
Sekr. EN 13, Einsteinufer 17, 10587 Berlin
{henrik.isernhagen, clemens.guehmann}@tu-berlin.de

Abstract
In this paper the modelling of a double clutch transmission with an appropriate controller is presented.
An accordant library for modelling different levels of
detail and the use of defined state signals are introduced. Furthermore, the control of the transmission
with the simulation of shifting cycles is discussed.
By varying the driver models it is possible to drive
miscellaneous drive and shifting cycles. We present
simulation results of a drive cycle with an examination of the interaction between the transmission control and the engine control. Finally, the application of
the model and the simulation data are shown in view
to the parameterisation of an automated measurement
data analysis system.
Keywords: double clutch transmission, power train,
control, shifting processes, state signals, simulation

1

Introduction

Nowadays, more and more new cars are assembled
with double clutch transmission because of efficiency,
drive comfort, and uninterrupted power shifts. A double clutch transmission contains two parallel transmission shafts with two parallel clutches. The clutches
can be either dry clutches or laminar multi-disc (wet)
clutches. The different gears are mounted alternately
on the two transmission shafts. The first shaft contains the odd gears, and the second shaft contains the
even gears. Depending on the number of gears the reverse gear is mounted either on the first shaft or on
the second shaft. There are uninterrupted power shifts
possible by reason of the two different clutches with
the accordant shafts. The first clutch opens and the
second clutch closes simultaneously during the shift
process resulting in an uninterrupted power transmission. The correct control of the two clutches is very
The Modelica Association

import in view to the different shifting processes. At
this point it is necessary to distinguish between upshifts and downshifts as well as pulling power and
pushing power of the power train. Control and calibration errors can result in bad shifting, e. g., in form
of revolution speed droppings, break outs, or oscillations. These errors should be detected by an automated
measurement data analysis system [1]. The software
is used for the evaluation of power train measurement
data in the vehicle development. The parameterisation
of this analysis system requires measurement data of
good and bad shifting processes. Accordingly, the aim
of the modelling and the simulation are to get data of
shifting processes of different quality.
In this paper we present the modelling, control, and
simulation of double clutch transmissions. First, a basic library and the use of state signals are introduced
in Section 2. In Section 3 we discuss the need for
models with different levels of detail. Section 4 shows
the control structure of the double clutch transmission
in view to different shifting processes, and Section 5
describes the simulation of drive and shifting cycles.
Finally, we discuss in Section 6 simulation results of
particular shifting cycles, and we present an outlook
to the parameterisation of an automated measurement
data analysis system [1] using the simulation results.

2

Library for modelling
clutch transmissions

double

For the modelling of double clutch transmissions we
developed a library with basic components. On the one
hand there are auxiliaries, interfaces, and basic blocks,
which are reused in further blocks and models. These
blocks are often used and they normally have a simple
structure. On the other hand the library contains different components of the double clutch transmission.

333

Modelica 2008, March 3rd  4th , 2008

H. Isernhagen, C. Guhmann

Figure 2: State signals relevant blocks

Figure 1: Library base structure
Here, it has to be differentiated between physical components of the transmission and components for control. A couple of models exist with different levels of
detail or with a different implementation, e. g., gearbox with or without losses, or different controls for
shifting. Furthermore, the library contains additional
components for modelling, control, and simulation of
the power train with a double clutch transmission. An
example is the engine control in connection with the
transmission control. Here, the engine torque has to be
influenced by the transmission control in some parts of
the shifting process for a smooth shifting.
The library is derived from the VehicleInterfaces library [2] and the PowerTrain library [3]. Consequently, the suitable interfaces and bus structures are
used, so that new transmission models can be connected with the models of these libraries. Furthermore,
we defined additional interfaces to get the advantage of
replaceable models and blocks. Doing this, it is possible to define some basic models and structures and it
is easy to build models with different levels of detail.
The overall structure of the library is arranged according to the different components like controllers, engines, transmissions, auxiliaries, interfaces, etc. The
library base structure is shown in Figure 1. Besides,
the VehicleInterfaces library, the PowerTrain library,
and the Modelica Standard Library [4] are used.

2.1 Introduction of state signals
State graphs [5] are used at important places for the
control of the double clutch transmission, because the
control process of the double clutch transmission depends often on more than one state. The active states
of the particular state graphs have to be available
through the control from different points. According to this, it is necessary to get an access to the active states. Here, we introduced so called state signals
which are accessible in our case by the TransmissionControlBus in the ControlBus of the VehicleInterfaces.
A state signal is defined by an Integer and the particuThe Modelica Association

Figure 3: Generating a state signal in a state graph
lar states are represented by the present Modelica implementation of the Enumerations. Inside a state graph
the particular states are combined to one state signal,
which represents always the active state by the associated Integer value of the Enumeration. Additionally,
we created new blocks to access these state signals so
that the state signal can be compared with a desired
state and a specific control can be activated.
The different blocks for using state signals are shown
in Figure 2. The blocks in the first row and the block
SetState are used to generate the desired state signal. Figure 3 shows an example for generating a
state signal in a state graph. The input size of the
BooleanMultiplex depends here on the number of
states in the state graph. The block SetState determines the active state and assigns the accordant Enumeration value to the state signal. The code is shown
in Listing 1.
There are two types of blocks to access the state signals. First, a real signal can pass or is set to zero by
the blocks Activate and ActivateOr. These blocks
work like a switch. Listing 2 shows the code example
for the block Activate. Second, the blocks IsActive
and IsActiveOr generate a Boolean signal according
to the signal state. All four blocks are parameterised
by the chosen Enumeration value. They compare the
actual state signal and the Enumeration value and set
the output signal accordingly. The or-variants use a
logical or comparison to different Enumeration val-

334

Modelica 2008, March 3rd  4th , 2008

Modelling of a Double Clutch Transmission with an Appropriate Controller for the Simulation of Shifting
Processes

Listing 1: Code example for SetState
model S e t S t a t e
extends
Modelica . Blocks . I n t e r f a c e s . IntegerSO ;
parameter Types . DCTTypes . Temp
states [:]={1 ,2};
Modelica . Blocks . I n t e r f a c e s . BooleanInput
u[ size ( states , 1)];
protected
I n t e g e r sz = s i z e ( s t a t e s , 1 ) ;
algorithm
f o r i i n 0 : sz 1 l o o p
i f u [ szi ] t h e n
y : = s t a t e s [ szi ] ;
end i f ;
end f o r ;
end S e t S t a t e ;

Figure 4: Basic double clutch transmission model
Listing 2: Code example for Activate

synchronisers of the particular gears are also modelled
as clutches. Here, the transmission control has to ensure the correct gear synchronisations. Only one gear
per shaft is allowed to be synchronised. The TransmissionControlBus contains the control signals for the
two parallel clutches and for the particular synchronisers. All measured signals like revolution speeds and
torques are added to the TransmissionBus. In a real
vehicle torques are not measured, because of the difficult measurement of a dynamic torque. Normally, the
torque is calculated by characteristic curves.
The replaceable elements can be modelled with different levels of detail. A clutch can be either a dry or a
ues, respectively.
laminar clutch. Many components can be chosen as
Furthermore, an advantage is the possibility to plot the ideal or with losses. Furthermore, it is possible to use
state signals like other simulation variables. Thus, the different numbers of spring and damper elements and
change of the states of each state graph can be ob- different spring and damping constants.
served after the simulation. A possible disadvantage
is the increase of variables and equations.
block A c t i v a t e
extends
M o d e l i c a . B l o c k s . I n t e r f a c e s . SO ;
parameter VehicleDCT . Types . DCTTypes . Temp
s t a t e ( s t a r t =1);
Modelica . Blocks . I n t e r f a c e s . RealInput u ;
Modelica . Blocks . I n t e r f a c e s . I n t e g e r I n p u t
statesignal ;
equation
y = i f ( s t a t e s i g n a l == s t a t e )
then u e l s e 0 ;
end A c t i v a t e ;

4

3

Different models of a double clutch
transmission

The aim of the simulation process is to get data of shift
processes of different quality. According to this, it is
necessary to build models with different levels of detail. A basic model of a double clutch transmission
is shown in Figure 4. It represents the base for further models by containing replaceable elements in the
front and back layers using the interfaces and elements
of the described library.
Figure 4 shows the two shafts with the two clutches.
The first shaft contains the odd gears and the reverse
gear, and the second shaft contains the even gears. The
The Modelica Association

Control of the transmission

The modelling of the control is just as important as
the physical modelling of the double clutch transmission. The outputs of the transmission control are the
control signals for the two clutches and for the synchronisers of the particular gears. Additionally, the
transmission control calculates internal control signals
like the actual driving state, the current gear, or the
requested gear. The main focus is the control of the
different shifting processes. At this point, the correct
control is very important in view to smooth shiftings,
because both clutches are engaged. Control errors can
result in oscillations, jerks, or even in a damage of the
transmission.
Figure 5 shows the structure of the transmission con-

335

Modelica 2008, March 3rd  4th , 2008

H. Isernhagen, C. Guhmann

Figure 5: Transmission control model
trol. All control components extend the Controllers
interface and use ControlBus sub buses of the VehicleInterfaces. The models GearCurrent and GearRequested determine the current and the requested
gear using state graphs and assigning the states to state
signals. Additionally, DriveMode appoints the actual
driving state, e. g., creep, drive, upshift, etc., and assigns a corresponding state signal, too. The block
GearShift identifies the type of the shifting using
the drive mode and the power transmission direction
of the power train. ActiveShaft determines the active transmission shaft and the active clutch, respectively. This information is very important in view to
the control of the clutches, because the clutch control
values are calculated independent of the clutch number. There is only one differentiation between the active and the inactive clutch, or during a shifting process between the engaging and the disengaging clutch.
Doing this, each control value is calculated only once
using an individual control block.
Currently, the clutch control distinguishes between
creep, driveaway, drive, and shift. For all these drive
modes exists a replaceable control. The controls calculate independent values for the active clutch. In
consideration of the drive mode and the active shaft
the block ClutchXControl assigns the control signal
for the particular clutch. As shown in Figure 6, the
clutch control signal is calculated using Activate and
ActivateOr blocks with the state signals. Doing this,
the independent control values of the different drive
modes are merged to one control signal for the particular clutch. Finally, the transmission control contains
the model Synchronisation, which controls the synchronisers of the particular gears. The control has to
safeguard that only one gear per transmission shaft is
synchronised.
The aim of the modelling and the simulation of a douThe Modelica Association

Figure 6: Clutch control model merging the particular
clutch control values
ble clutch transmission are to get data of shifting processes of different quality. According to this, the focus of this work is on the control of the shifting process. The shifting process is controlled by the model
ControlShift. There exist four different shifting
types in consideration of downshift and upshift as well
as pulling and pushing power of the power train. Additionally, these types are separated in two phases. The
shifting types are: pull upshift, push downshift, pull
downshift, and push upshift.
The structure of the model ControlShift is shown in
Figure 7. For each shifting type and each phase exists a
replaceable control using the same interface. The three
output signals are clutch_shift_old, clutch_shift_new,
and engineEngagement. The input is an activation signal in form of a Boolean signal. If the activation signal
equals false, then the outputs have to be set to zero.
Only one shifting process can be activated, because
all blocks work in parallel. All types and phases are
replaceable elements to simulate shifting processes of
different quality.
The two frequently used shifting types are pull upshift
and push downshift. They are similar in their control
behaviour. In the first phase the torque is transmitted
from the old clutch to the new clutch, so both clutches
are engaged. Then in the second phase of the shifting
process the engine speed is passed to the speed of the
new shaft. The engine speed decreases while upshifting and increases while downshifting. Two possibilities exist for the adjustment of the engine speed. On
the one hand it can be managed by an increase of the
clutch capacity. Then the drive end impacts the engine
torque and the engine speed decreases or increases, respectively. The clutch capacity is a function of the

336

Modelica 2008, March 3rd  4th , 2008

Modelling of a Double Clutch Transmission with an Appropriate Controller for the Simulation of Shifting
Processes

Figure 8: Vehicle model with replaceable elements
driver.
Figure 7: Shift control model with replaceable shift
modes and phases
clutch engagement and describes the clutchs maximum possible transmission torque. The real transmitted torque of the clutch is a function of the clutch capacity and the input torque. Therefore, the clutch is either in slipping or locked mode. On the other hand it is
possible to do an engine engagement. This means that
the engine torque increases or decreases and to that effect the engine speed will be changed. In this work
we use an engine based on an engine map. According to this, an engine engagement changes the internal
throttle position as input of the engine map.
The other two shifting types are pull downshift and
push upshift. Here, the order of the two phases
changes. At first there is the adjustment of the engine speed to the second transmission shaft speed. Finally, the torque is transmitted from the first to the second clutch. The downshift with pulling power occurs
in consequence of a kick down. Then, it is possible
that both clutches are engaged during the speed adjustment, because of the demand of high power transmission. An upshift with pushing power occurs normally
if the vehicle rolls downhill with increasing speed and
the engine speed exceeds the upshift threshold.
Now, it is possible to simulate shifting processes of
different quality. A good shifting results in an uninterrupted power transmission. In this case the driver does
not sense a changing of the acceleration. Then the sum
of both clutch torques equals the engine torque less the
dynamic torques at any time. A bad shifting in consequence of control errors can result in revolution speed
droppings, break outs, or oscillations. This leads to a
changing of the acceleration and will be sensed by the
The Modelica Association

5

Simulation of shifting cycles

With the described models and controls, simulations
of different shifting cycles are executed. By varying
the driver models it is possible to drive miscellaneous
drive and shifting cycles, e. g., in form of a table with
acceleration and brake pedal positions, or following a
velocity profile in form of predefined drive cycles. An
example for a drive cycle is the New European Driving
Cycle NEDC [6].
The vehicle simulation structure is shown in Figure 8.
The components are replaceable or have internal replaceable elements. Furthermore, it is possible to use
existing models, e. g., of the PowerTrain library. Both
the redeclaration of physical components and the shift
control can be changed. Thus, the simulations generate data of different quality due to the choice of the
grade of the control.

6

Results and application

Based on the presented vehicle simulation structure
we can now simulate drive and shifting cycles. As
an example, the simulation results of a drive cycle are
shown in Figure 9. The drive cycle contains the following sections: engine start, creep, driveaway, upshifts, drive, downshifts, and stoppage. The upshifts
are realised with an engine engagement and the downshifts are realised with an increase of the clutch capacity for the adjustment of the engine speed.
At the top the Figure 9 shows the speeds of the engine and of the two transmission shafts. In the next
part the capacity of the two clutches and the engine
torque can be seen. The up- and downshifts can be
easily recognised by the crossing of the clutch capacities and the change of the engine speed between the

337

Modelica 2008, March 3rd  4th , 2008

H. Isernhagen, C. Guhmann

Figure 9: Simulation results of a simple drive cycle
transmission shaft speeds. During the downshifts the
clutch capacity increases for the adjustment of the engine speed as described in Section 4. The third part
shows the engine engagement at the upshifts. At the
upshift the engine torque is decreased during the engine speed adjustment to the new transmission shaft
speed. The engine control decreases the throttle position on demand of the transmission control to decrease
the engine torque. The acceleration pedal, the brake
pedal, and the decreased throttle position can be seen
in the fourth plot of Figure 9. The throttle position
increases at the start and at the end of the simulation,
because of the engagement of the engine speed governor. The bottom of Figure 9 shows the transmission
state according to the described sections. Furthermore,
the current and the requested gear can be seen. These
three signals are state signals and the Integer value represents a particular state.
In the past, we developed in cooperation with the IAV
GmbH an automated measurement data analysis system [1]. The evaluation process of the software can be
parameterised efficiently by XML templates. The system supports the common automotive measurement
file formats and it can handle huge data traces with a
sequential data processing. Moreover, there exist several intelligent signal processing modules for the data
evaluation.
For complex analyses the system parametrisation is
The Modelica Association

difficult, because the measurement data is often unlabelled . The data contains measurements of several shifting processes, but there is normally no information about good or bad examples. Now, we
have the possibility to simulate shifting processes of
different quality. With the simulation results of this
work we can parameterise the automated measurement
data analysis system for the evaluation of shifting processes. The aim of the measurement data analysis is
the detection and assessment of bad shifting in the vehicle development.

7

Conclusion and outlook

In this paper, we presented the modelling, control, and
simulation of a double clutch transmission. The focus is the simulation of data of different quality particularly with regard to shifting processes. According to this, we developed model and control structures with replaceable elements. It is possible to use
the same vehicle model for the simulation of good and
bad shiftings. On the one hand the level of detail can
be changed. On the other hand it is possible to redeclare elements of the transmission control to change
the control behaviour.
We presented a library with basic transmission components and introduced state signals to access sys-

338

Modelica 2008, March 3rd  4th , 2008

Modelling of a Double Clutch Transmission with an Appropriate Controller for the Simulation of Shifting
Processes

March 2005. The Modelica Association and the
tem states from different points of the control process.
Hamburg University of Technology.
Furthermore, we described the developed transmission
control and discussed the different shifting types in
detail. The vehicle model can be used to simulate [6] Emission Test Cycles. Summary of worldwide engine and vehicle test cycles. http://www.dieselnet.
a power train with a double clutch transmission. Ficom/standards/cycles/.
nally, the simulation results of a simple drive cycle
were shown.
With the presented models we get the background for
future works. We developed a base model of a double
clutch transmission and a base control structure with
a working control for the four basic shifting types. At
the moment there exist basic controls for each phase
of the shifting. The next step will be the variation
of the control to get data of different quality. Additionally, we will simulate drive cycles using double
clutch transmission models of different levels of detail.
With these results we will parameterise the automated
measurement data analysis system for the evaluation
of shifting processes of double clutch transmissions in
real vehicle measurement data.

References
[1] Henrik Isernhagen, Helmut Neemann, Steffen
Khn, and Clemens Ghmann. Intelligent signal processing in an automated measurement data
analysis system. In Proceedings of the IEEE Symposium on Computational Intelligence in Image
and Signal Processing (CIISP 2007), pages 83 
87, Honolulu, USA, April 2007.
[2] Mike Dempsey, Magnus Gfvert, Peter Harman,
Christian Kral, Martin Otter, and Peter Treffinger.
Coordinated automotive libraries for vehicle system modelling. In Proceedings of the 5th International Modelica Conference, pages 3341, Vienna, September 2006. The Modelica Association
and arsenal research.
[3] Jakub Tobolr, Martin Otter, and Tilman Bnte.
Modelling of Vehicle Powertrains with the Modelica PowerTrain Library. In Systemanalyse in
der Kfz-Antriebstechnik IV, volume 79 of Haus
der Technik Fachbuch, pages 204216, Augsburg,
February 2007.
[4] Modelica. http://www.modelica.org.
[5] M. Otter, K.-E. rzn, and I. Dressler. StateGraph
- A Modelica Library for Hierarchical State Machines. In Proceedings of the 4th International
Modelica Conference, pages 569578, Hamburg,
The Modelica Association

339

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

340

Modelica 2008, March 3rd  4th , 2008

TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs

TestWeaver
A Tool for Simulation-based Test of Mechatronic Designs
Andreas Junghanns, Jakob Mauss, Mugur Tatar
QTronic GmbH, Alt-Moabit 91d, D-10559 Berlin
{andreas.junghanns, jakob.mauss, mugur.tatar}@qtronic.de

Abstract
The tight interaction among an ever increasing
amount of software functions and hardware
subsystems (mechanics, hydraulics, electronics, etc.)
leads to a new kind of complexity that is difficult to
manage during mechatronic design. System tests
have to consider huge amounts of relevant test cases.
Validation with limited resources (time and costs) is
a challenge for the development teams. We present a
new instrument that should help engineers in dealing
with the complexity of test and validation.
TestWeaver is based on a novel approach that aims
at maximizing test coverage with minimal work load
for the test engineer for specifying test cases. The
method integrates simulation (MiL/SiL) with automatic test generation and evaluation, and has found
successful applications in the automotive industry.
We illustrate the approach using a 6-speed automatic
transmission for passenger cars. We present also the
way TestWeaver and Modelica simulators can work
together.
Keywords: test automation, mechatronic systems

1

Introduction

When developing complex mechatronic systems,
like a hybrid drive train or an automatic transmission
for a vehicle, contributions from different
engineering disciplines, design teams, departments,
and organizations have to be integrated, resulting in
a complex design process. Consequently, during
development, design flaws and coding errors are
unavoidable. For an OEM, it is then crucial that all
those bugs and weak points are found and eliminated
in time, i.e. before the system is produced and delivered to customers. Failing to do so may result in expensive recalls, high warranty costs, and customer
dissatisfaction. OEMs have long realized this and
spend up to 40% of their development budgets for
test related activities. Software offers great flexibility
to implement new functions, but also many hidden
opportunities to introduce bugs that are hard to
The Modelica Association

discover. Moreover, the complex behaviour that
results from the interaction of software and physical
systems cannot be formally and completely analysed
and validated. Most often, it can only be evaluated in
a limited amount of points with physical or virtual
experiments. The development teams are often faced
with a dilemma: on the one side, the system test
should cover a huge space of relevant test cases, on
the other, there is only a very limited amount of
available resources (time and costs) for this purpose.
This paper presents a novel test method that has the
potential to dramatically increase the coverage of
testing without increasing the work load for test engineers. We achieve this by generating and executing
thousands of tests automatically, including an initial,
automated assessment of test results. The test generation can be focused on certain state spaces using constraints and coverage goals.
This paper is structured as follows: In section 2, we
take a bird's-eye view on testing mechatronic systems. In section 3, we survey the main test methods
used in the automotive industry today. Section 4
presents the proposed test method. Section 5 illustrates the proposed method using a 6-speed automatic transmission for passenger cars. Section 6 discusses our approach to automated test evaluation. We
conclude the paper with a summary of the benefits of
our test method, and discuss its applicability to other
engineering domains.

2

The challenge of testing

When testing a mechatronic system, it is usually not
sufficient to test the system under laboratory conditions for a couple of idealized use cases. Instead, to
increase the chance to discover all hidden bugs and
design flaws, the system should be tested in as many
different relevant conditions as possible. Consider as
an example an assembly such as an automatic transmission used in a passenger car.

341

Modelica 2008, March 3rd  4th , 2008

A. Junghanns, J. Mauss, M. Tatar

In this case, the space of working conditions extends
at least along the following dimensions:
 weather: for example, temperatures range
from - 40C to 40C, with significant impact
on oil properties of hydraulic subsystems
 street: different road profiles, uphill, down
hill, curves, different friction laws for roadwheel contact
 driver: variations of attitude and behavior of
the human driver, including unforeseen
(strange) ways of driving the car
 spontaneous component faults: during operation, components of the assembly may spontaneously fail at any time; the control software of the assembly must detect and react
appropriately to these situations, in order to
guarantee passenger safety and to avoid
more serious damage
 production tolerances: mechanical, electrical
and other physical properties of the involved
components vary within certain ranges
depending on the manufacturing process
 aging: parameter values drift for certain
components during the life time of the
assembly
 interaction with other assemblies: a transmission communicates with other assemblies
(engine, brake system) through a network
that implements distributed functions; for
example, during gear shifts, the transmission
might ask the engine to reduce the torque in
order to protect the switching components.
These dimensions span a huge space of possible operational conditions for an assembly. The possibilities along each dimension multiply to form a huge
cross-product. The ultimate goal of testing is to verify that the system performs adequately at every single point of that space. It would be great to have
techniques to mathematically prove certain properties of the system (such as the absence of unwanted
behavior), which would enable a test engineer to
cover infinitely many cases within a single work
step. However, such proof techniques (e.g. model
checking, cf. [1]) are by far too limited to deal with
the complexity of the system level test considered
here.
In practice, the goal of covering the entire state space
is approximated by considering a finite number of
test cases of that space.

The Modelica Association

3

A critical view on some test methods in use

Testing at different functional integration levels (e.g.
component, module, system, vehicle) and in different
setups (e.g. MiL, SiL, HiL, physical prototypes) is
nowadays an important, integral part of the development process. The earlier problems are discovered
and eliminated, the better. Very often, however:
(a) relevant tests can only be formulated, or
have to be repeated, at higher levels of functional integration (e.g. at system level) - consider, for instance, the system reaction in
case of component faults
(b) system-level tests are only performed in a
HiL or physical prototype setup1.
Let us briefly review some of the limitations of the
HiL- / physical prototype based testing:
 time, costs, safety: physical prototypes and
HiL setups are quite expensive and busy resources; testing takes place late in the development cycle; not too many tests can be conducted; the reaction to certain component
faults cannot be tested with physical prototypes due to safety hazards
 lack of agility: it usually takes a long time
between the change of a software function
and the test of its effects
 limited precision or visibility: due to realtime requirements the physical system models used in HiL setups are often extremely
simplified and therefore extremely imprecise; debugging and inspection of hidden
system properties is difficult if not impossible for these setups.
Note, the above limitations are not present in MiL /
SiL setups. While the importance of the HiL tests
and of the tests based on physical prototypes should
not be underestimated, our argument here is that they
must be complemented by a more significant role of
MiL and SiL tests at system level. See also [4], [5].
Irrespective of the setup used, the main limitation of
common system-level test practices is the limited test
coverage that can be achieved with reasonable effort.
For example, test automation in a MiL / HiL setup is
typically based on hand-coded test scripts for stimu1 There are several reasons why this is very often the
case. An important one stems from the complexity of
the mechatronic development processes: several disciplines, several teams, several tools, several suppliers 
together with lacking standards and practices for exchanging and integrating executable functional models.

342

Modelica 2008, March 3rd  4th , 2008

TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs

lating the partially simulated assembly with a sequence of test inputs, including code for validating
the measured response. Coding and debugging such
test scripts is a labor intensive task. Given typical
time frames and man power available for testing,
only few (say a few dozen) cases from the huge
space of possible use cases can be effectively addressed by such a script-based approach. For testing
using a test rig or by driving a car on the road, this
figure is even worse. For example, it is practically
impossible to systematically explore the assembly's
response in the case of single component faults in a
setup that involves dozens of physical (not simulated) components.
When testing for the presence (or absence) of a certain system property, script-based tests verify such a
condition only during a few, specifically designed
scenarios and not throughout all tests.
In practice this means that many scenarios are never
explored during system test and that for those scenarios explored, usually only a few of the relevant
system properties are tested. Consequently, bugs and
design flaws may survive all tests. These are risks
the method presented here can help to reduce, adding
additional robustness to the design process.

4

Exploring system behavior with
TestWeaver

TestWeaver is a tool supporting the systematic test
of complex systems in an autonomous, exploratory
manner. Although the method could, in principle, be
applied to HiL setups as well, it is primarily geared
towards supporting the MiL and SiL setups. The
overall design objectives of TestWeaver were to:
(a) dramatically increase the test coverage, with
respect to system behavior, while
(b) keeping the workload for the test engineer
low.
To achieve this, we wanted to remove the necessity
of exclusively relying on hand-coded test scripts,
since we had identified script production as the main
hindrance on the way towards broad test coverage.
4.1

The chess principle

The key idea was: Testing a system under test (SUT)
is like playing chess against the SUT and trying to
drive it into a state where it violates its specification.
If the tester has found a sequence of moves that
drives the SUT in such an unwanted state, he has

The Modelica Association

won a game, and the sequence of moves represents a
failed test.
There are more analogies: To decide for a next best
move, chess computers just explore recursively all
legal moves possible in the current state and test
whether these lead to a goal state. This search process generates a huge tree of alternative (branching)
games. In TestWeaver, the automated search for
bugs and design flaws is organized quite similarly.
Our method assumes that the SUT is available as an
executable simulation (MiL) or as a co-simulation of
several modules (SiL). As usually done, the SUT is
augmented with a few components that communicate
with the test driver. These communication components, called instruments, implicitly carry the rules
of the game that TestWeaver is playing with the
instrumented SUT. Namely, they carry information
about: the control actions that are legal in a certain
situation, the interesting qualitative states reached by
the SUT, and, eventually, the violation of certain
system requirements. Each instrument specifies a
(relevant) dimension of the SUT state space. The
value domain along each dimension has to be split
into a finite set of partitions. Each SUT, or SUTmodule, has to be configured individually by placing
and parameterizing the instruments inside the SUT.
The game is played in this multi-dimensional partitioned system space.

Figure 1: The chess principle
4.2

Instruments

An instrument is basically a small piece of code
added to the un-instrumented version of the SUT using the native language of the executable, e.g. Modelica, Matlab/Simulink, or C. The instruments communicate with TestWeaver during test execution,
which enables TestWeaver to drive the test, to keep
track of reached states, and to decide during test execution whether an undesired state (failure) has been
reached. TestWeaver supports basically two kinds of
instruments, action choosers and state reporters, that
can come in several flavors:

343

Modelica 2008, March 3rd  4th , 2008

A. Junghanns, J. Mauss, M. Tatar

1. state reporter: this instrument monitors a discrete
or a continuous variable (e.g. a double) of the SUT,
and maps its value onto a small set of partitions or
discrete values (e.g. low, medium, high). During test,
this instrument reports each partition change of the
monitored variable to TestWeaver. This is used by
TestWeaver to keep track of reached states and to
maximize the coverage of the partitioned / discrete
state space.
2. alarm reporter: this is actually a state change reporter. In addition the partitions are associated with
severity levels, such as nominal, warning,
alarm, and error. The reachability of a bad
state corresponds to a failure of the test currently executed. Note: these failure conditions are verified
throughout all the tests run by TestWeaver.
3. action chooser: this instrument is associated with
an input variable of the SUT. In an automotive application, an input variable may represent the acceleration pedal or the brake pedal of a car. Depending on
the details of the instrumentation, this instrument
asks TestWeaver either periodically or when a trigger condition becomes true to choose a discrete input
value for its input variable from the partitioned value
domain of the variable.
4. fault chooser: this is a special case of action
chooser. The value domain is partitioned into nominal and fault partitions and can can be used to represent alternative fault modes of a component of the
SUT. For example, a shift valve model may have behavior modes such as: ok, stuckClosed, and
stuckOpen. Instruments like these are used by
TestWeaver to inject (activate) a component fault occurring spontaneously during test execution.

instrument a SUT in their favorite modeling language, i.e. using the native implementation language
of the SUT, or of the SUT-module that they are
working on.
In addition to the explicit instruments, TestWeaver
monitors the process of executing the SUT and
records problems, such as divisions by zero, memory
access violations, or timeouts in the communication.
4.3

Experiments, scenarios and reports

In TestWeaver, an experiment is the process of
exploring and documenting the states reached by the
SUT during a certain period of time, possibly taking
into consideration additional search constraints and
coverage goals. An experiment usually runs
completely autonomously for a long time, typically
several hours, and without requiring any user
interaction.
When running an experiment, TestWeaver generates
many differing scenarios, by generating differing
sequences of answers for the action choosers. A
scenario is the trace (or protocol) of a simulation run
of the given SUT in the partitioned state space.
TestWeaver combines several strategies in order to
maximize the coverage of the reached system states
and to increase the probability of finding failures.
The results are stored in a scenario data base of the
experiment, i.e. a tree of scenarios (actually a
directed graph), as shown in Fig. 3.

Figure 3: Scenarios generated by an experiment

Figure 2: Instruments connect SUT to TestWeaver
Engineers like to work with their favorite modeling
environment. Therefore we have implemented versions of the above instruments for alternative modeling environments, including Matlab/Simulink, Modelica, and C. The idea is to allow the test engineers to
The Modelica Association

The user can investigate the states reached in an
experiment using a high level query language similar
to SQL. Results are displayed in reports. A report is
basically a table that displays selected properties of
the scenarios stored in the scenario data base. The
user specifies the structure and layout of a table by
templates, while the content of a table depends on
the content of the scenario data base  see Fig. 9.
There are two kinds of reports: overview reports, that

344

Modelica 2008, March 3rd  4th , 2008

TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs

document state reachability, and scenario reports,
that document details of individual scenarios.
A user may specify, start, and stop an experiment,
reset the experiment's data base and investigate the
reports generated by the experiment, the last even
while the experiment is running. Individual scenarios
can be replayed: i.e. the SUT is restarted and is fed
with the same sequence of inputs as the one recorded
in order to allow detailed debugging of a problem,
e.g. by plotting signals and other means.
4.4

The experiment focus

The dimensions and the partitions of the state space
are configured by the instruments of the SUT. Apart
of these there are also other means that can constrain
the exploration, either as part of the instrumented
SUT, or as explicitely defined in the specification of
the experiment focus in TestWeaver. The focus of an
experiment specifies which region of the state space
should be investigated when running the experiment.
During an experiment, TestWeaver tries to drive the
SUT into those states that are in the experiment's
focus. The experiment focus is currently specified
using two means:




constraints: the constraints limit the size of
the considered state space of an experiment.
They can limit, for instance, the duration of a
scenario, or the allowed combinations of
inputs and states. A high level constraint
language is provided for this purpose. In an
automotive application, a user could, for
example, exlude all scenarios where brake
pedal and acceleration pedal are engaged
simultaneously. For a fault analysis, a
constraint could be used to exclude certain
fault modes from investigation, or to limit
the number of faults inserted in a scenario:
typical values are 0, 1 and 2. Higher
numbers are reasonable when investigating
fault-tolerant systems, e.g. systems with
complex fault detection and reconfiguration
mechanisms
coverage: the user can tell TestWeaver to
use some of the reports of the experiment as
defining the coverage goals of the
experiment. A report used in this way is
called coverage report.

Experiments with different SUT versions and with
different focus specifications can be created, run and
compared with each other.

The Modelica Association

4.5

Analyzing and debugging problems

The alarm and error states of the SUT are reported in
the overview reports. For each problem one or more
scenarios that reach that state can be recalled from
the scenario database. The scenarios can be once
again replayed and additional investigation means
can be connected. Depending on the SUT simulation
environment these can be, for instance: plotting additional signals, connecting additional visualization
means such as animation, setting breakpoints, and
even connecting to step-by-step evaluation with
source code debuggers  for instance for SUT modules developed in C.
4.6

The Modelica instrumentation library

In this section we briefly present the Modelica instrumentation library of TestWeaver, cf. Fig. 4.

Figure 4: The Modelica Instruments library
The package Instruments contains ready to use
components for instrumenting Modelica models.
Each instrument is a Modelica component that
communicates with TestWeaver through an outer
WeaverConnection. Instruments extend the partial
base class Instruments.Interfaces.Instrument, which
is a model with the following parameters:
 variable: the name of the SUT variable defined by the instrument
 comment: a description of the instrument
 unit: of the classified real value, e.g.
"km/h", "kg", or "%"
 intervals: an array of number pairs defining
the numeric partitions of the real value, e.g.
[0,100; 100,150; 150,1e10]

345



labels: an array with the partition names, e.g.
{"ok", "hot", "damaged"}



weaverConnection: outer reference.
Modelica 2008, March 3rd  4th , 2008

A. Junghanns, J. Mauss, M. Tatar

Furthermore, the Instruments package provides the
following instruments as Modelica components:
 Reporter: an instrument that adds a severity
rating to each interval and reports the value
of a SUT variable when triggered; whether
the reported value represents an alarm or a
nominal state depends on the associated
severity
 Chooser: an instrument that adds an
occurence rating to each interval and allows
TestWeaver to control a variable of the SUT,
when triggered; whether the control value
represents a fault to be injected or a nominal
value depends on the corresponding
occurence rating
 Parameter: a Chooser whose control
variable is a model parameter to be
initialized by TestWeaver at simulation start;
this is used to model parameter deviations,
for instance, due to aging, or due to
production tolerances.
Fig. 5 shows how to use a Reporter in a model.

Figure 5: Reporting a temperature
The reporter is connected to the output of a heat
model, and to a boolean trigger signal. Whenever the
trigger signal becomes true, the reporter classifies
the temperature w.r.t the partition margins and reports the result through the WeaverConnection to
TestWeaver.

Likewise, Fig. 6 shows two Choosers called
chooseBrakePedal, chooseAccelPedal.
Both accept a default value at the left side, output the
signal chosen by TestWeaver and accept a boolean
trigger signal as input, which defines the time points
when new values can be changed by TestWeaver.

5

Example: automatic transmission

As an application example for TestWeaver, consider
the development of the control software for an automatic transmission. An instrumented Modelica model of an entire car, including the transmission and a
WeaverConnection is shown in Fig. 7.

Figure 7: An instrumented car model
The control software is developed using a SiL development environment. The executable SUT is hence
co-simulating two modules: the compiled control
software, and the compiled Modelica model of the
car. Since the Modelica model has been instrumented, the SUT also contains functions to communicate
with TestWeaver. When TestWeaver starts the SUT
to perform a system test, all contained instruments
register themselves at TestWeaver with all their declared static properties (intervals, labels, severities
etc.). TestWeaver then displays a list of these instruments, see tree in Fig. 9. Selecting an instrument in
the tree displays all its properties. Fig. 8. shows how
TestWeaver displays the heat reporter of Fig. 5.

Figure 6: Controlling two pedals in a car
Figure 8: Reporter (Fig. 5) displayed by TestWeaver
The Modelica Association

346

Modelica 2008, March 3rd  4th , 2008

TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs

The tree shown in Fig. 9 also contains an item for
each report of the experiment. Selecting such a report displays the report as table. Fig. 9. shows a report that shows which gear shifts have already been
reached during the experiment, and whether critical
temperatures at the clutches A and B have been reported. For each state, up to two scenarios are referenced in the right most column. Clicking on such a
reference displays that scenario as a sequence of discrete states. It is possible to reproduce the entire scenario with an identical simulation such that the test
engineer can access all its details. For example, runtime exceptions of the control software (such as division by zero) can be reproduced this way and inspected using the usual software debugging tools.

Figure 9: TestWeaver displaying a coverage report

6

The instrumentation process and
quality watchers

If an executable SUT exists it is relatively easy to
add the instrumentation for the action choosers and
the pure state reporters  those reporters that do not
attempt to classify the states as good or bad. A
good understanding of the system functionality is required, in order to select the relevant system features
and the relevant qualitative partitions. This activity
in not completely new for the test engineers: the
commonly used Classification Tree Method for

The Modelica Association

specifying tests relies exactly on this kind of system
analysis [2].
For the automatic test evaluation TestWeaver uses
alarm reporters. The alarm reporters monitor correctness or quality conditions of the SUT. Some of these
conditions are easy to define, others might require
quite sophisticated watchers. Let us begin with the
easier cases:
(a) often physical components have well known
functional or safety ranges of operation that
should not be exceeded; examples: maximal
power dissipated by a component, maximal
temperature, maximal pressure in a container, maximal allowed rotational speed of an
engine or gear, etc.
(b) similar local correctness conditions exist
for software functions; in the software industry such assertions are widely used today for
detecting, diagnosing and classifying programming errors during test; examples here:
maximum number of allowed objects in a
buffer, access indices within array bounds,
assumed domains for input parameters, assertions about function pre-conditions, postconditions and other invariants that can be
easily declared and monitored  see also [3].
The above quality conditions can be locally implemented, e.g. in a component type library. In such a
case, each component instantiation will also instantiate the check of the quality condition and the instrumentation required.
In addition, the run time exceptions of the SUT process (e.g. divisions by zero, memory access violations, etc.) and the communication timeouts (possibly produced by infinite loops, non-converging numerical solvers, etc.) are anyway monitored and reported by TestWeaver.
An important class of quality conditions can be relatively easily defined when the SUT includes a controller and a model of the controlled system. Often
controllers have in some form (at least a simplified)
inverse model of the controlled system. This makes
it easier to formulate system invariants or quality
conditions. For instance: when not shifting, the controller gear should match the gear from the transmission model; if no fault is set in the hardware model,
the on-board diagnosis should not detect any fault; if
a fault code is generated, then the fault should coincide with a fault set in the hardware model. In general, the assumptions made by the control system about
the state of the controlled system should match
(within certain acceptable delays and tolerances) the
state of the model.

347

Modelica 2008, March 3rd  4th , 2008

A. Junghanns, J. Mauss, M. Tatar

The more we migrate from checking correctness to
checking quality, the more complex and subtle the
watchers can become. For TestWeaver arbitrarily
complex quality watchers can be implemented with
Modelica, Matlab/Simulink or C. In principle, any
conventional test case can be turned into a quality
watcher, although it might be sometimes difficult to
generalize the specific conditions checked in a test
case. The effort will be rewarded because:
(a) the quality condition will be checked not
only for one input sequence, but for many
differing scenarios, and
(b) a more general formulated condition is likely
to survive unchanged, or with only small
changes, when new SUT versions are produced later on, during development.
The tuning of some complex quality watchers can be
quite laborious. In practice, there will always be cases when false alarms are generated. Therefore, after
each experiment, also a detailed manual analysis and
diagnosis of the problems found is prescribed by our
test method.

7

Summary and conclusions

The increasing pressure to shorten and cheapen development for more and more complex products requires new test strategies. Today we see early module tests and late system-level tests, like HiL and
test-rigs, as state of the art. The importance of early
system-level testing increases with the increasing
complexity of module interaction because bugs on
system-level are more likely, more costly to fix and
harder to find. Testing before physical prototypes exist, for both controllers and hardware, is one necessary step towards early system-level testing.
As long as the behavior of a system can be described
easily using stimuli-response sets, script-based testing is a feasible strategy. With increasing system
complexity, this method fails to provide the necessary coverage at reasonable cost. On the other side,
our test method allows to:
(a) systematically investigate large state spaces
with low specification costs: only the rules
of the game have to be specified, not the
individual scenarios
(b) discover new problems that do not show up
when using only the predefined test scenarios prescribed by traditional test methods;
TestWeaver can generate thousands of new,
qualitatively differing tests, depending on
the time allocated to an experiment

The Modelica Association

(c) increase the confidence that no hidden design flaws exist.
In chapter 5, we have sketched the application of
TestWeaver to a SiL-based system test of an automatic transmission. We have several years of experience with this kind of applications. However, the application of TestWeaver to other domains seems
promising as well, especially for those cases where a
complex interaction between the software and the
physical world exists. For instance:
 driver assistance systems: in car systems
such as ABS, ESP, etc. we meet a complex
interaction among the control software, the
vehicle dynamics and the human driver; this
leads to myriads of relevant scenarios that
should be investigated during design
 plant control systems: in plants for chemical
processes, power plants etc. we meet the interaction of the control software, plant
physics and the actions of the operators;
again, the same kind of complexity that calls
for a systematic investigation during design.
TestWeaver runs on Windows platforms. It is a powerful, yet easy to use tool: users can use their native
specification or modeling environment and don't
have to learn yet another test-specification language.

Acknowledgments
Special thanks to Volker May who initiated the research that finally led to TestWeaver.

References

348

[1] Berard et. al.: Systems and Software Verification: Model-Checking Techniques and Tools,
Springer Verlag, 2001.
[2] Grochtmann, M., Grimm, K.: Classification
Trees for Partition Testing. Software Testing,
Verification & Reliability, Volume 3, No 2,
pp. 63-82, 1993.
[3] Meyer, Bertrand: Applying "Design by Contract", in Computer (IEEE), 25, 10, October,
pages 40-51, 1992.
[4] Rebeschie, S., Liebezeit, Th., Bazarsuren, U.,
Ghmann, C.: Automatisierter Closed-LoopTestprozess fr Steuergertefunktionen.
ATZ elektronik, 1/2007 (in German).
[5] Thomke, Stefan: Experimentation Matters: Unlocking the Potential of New Technologies,
Harvard Business School Press, 2003.

Modelica 2008, March 3rd  4th , 2008

Session 3d
Electric Systems & Applications

The Modelica Association

349

Modelica 2008, March 3-4, 2008

The Modelica Association

350

Modelica 2008, March 3rd  4th , 2008

Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the ExtendedMachines
Library

Simulation of Electrical Rotor Asymmetries in Squirrel Cage
Induction Machines with the ExtendedMachines Library
Christian Kral Anton Haumer
Arsenal Research
Giefinggasse 2, 1210 Vienna, Austria
christian.kral@arsenal.ac.at

Abstract
In this paper a physical model of a squirrel cage induction machine with rotor topology model is presented.
The parameters of the induction machine are discussed
and the issue of rotor fault detection is addressed. For
a machine with one broken rotor bar a Modelica simulation model is compared with measurement results.
Keywords: Electric machines, squirrel cage, rotor
asymmetries

1

Introduction

The squirrel cage of an induction machine consists of
Nr bars and two end rings, connecting the bars on both
ends, as depicted in Fig. 1. The fins located on the end
rings are required to force the circulation of the air in
Figure 1: Rotor cage of an induction machine
the inner region of the machine.
In the manufacturing process it is intended to fabricate
a fully symmetrical squirrel cage. Due to manufacturing problems or certain operating conditions, electrical In the Modelica Standard Library (MSL) the induction
rotor asymmetries can occur. The causes for such rotor machines are based on the assumption, that the number of phases is limited to three and that stator and
electrical asymmetries are:
rotor windings are fully symmetrical. Electrical rotor
 shrink holes and voids in the aluminum of the asymmetries can therefore not be modeled using the
MSL. For modeling electrical rotor asymmetries of the
bars or end rings,
squirrel cage induction machines the full topology of
 improper junctions of the bars and end rings,
the rotor cage has to be taken into account. Appro heavy duty start-ups that the machine is not de- priate models are provided by the ExtendedMachines
Library [1].
signed for,
 thermal overloading of the machine,

2 Stator Winding Model

 high temperature gradients, causing cracks.
Electric rotor asymmetry can be classified as rotor bar
or a rotor end ring segment fault. These cases can be
modeled by a ohmic resistance increase of either a rotor bar or an end ring segment.
The Modelica Association

For the investigated fault cases it can be assumed that
the stator winding is fully symmetrical. Additionally,
it will be assumed, that number of stator phases is limited to three. In this case the stator voltage equation

351

Modelica 2008, March 3rd  4th , 2008

C. Kral, A. Haumer

A

can be written as

Lea[i1]

dIs[i]
Vs[i] = Rs Is[i] + Ls
dt

Rea[i]

Ib[i]
Rb[i]

dIs[ j] Nr dLsr[i, j] Ir[ j]
+  Lsm[i, j]
+
. (1)
dt
dt
j=1
j=1
3

Ai

Lb[i]

Lea[i]

Rea[i+1]
Ib[i+1]

Ir[i]

DE

Rb[i+1]

r[i]

Lb[i+1]

In this equation Vs[i] and Is[i] and Ir[i] are the stator
NDE
voltage and current and the rotor current, respectively.
L
R
L
R
eb[i1]
eb[i]
eb[i]
eb[i+1]
Due to the symmetry of the stator winding the stator
Ieb
resistance Rs and the stator stray inductance Ls are
symmetrical, too. The matrix of the main field inductances of the stator winding,
Figure 3: Topology of the rotor cage (DE = drive end,


NDE = non drive end)
(i

j)2
Lsm[i, j] = L0 w2s 2s cos
,
(2)
3
and the matrix of the mutual coupling inductances between the stator and rotor,


(i  1)2 ( j  1)2

 m ,
Lsr[i, j] = L0 ws r cos
3
Nr
(3)
are fully symmetrical, since it is assumed that the coupling over the magnetic main field is not influenced by
the rotor asymmetries. In this equation, L0 indicates
the base inductance of a coil without chording, i.e., the
coil width is equal to the pole pitch. The parameters
ws and s are the number of series connected turns and
the winding factor of the stator winding. The product ws s is the effective number of turns. The winding
factor of the rotor winding
 
p
r = sin
(4)
Nr
is a pure geometric factor, which is derived in [2]. In
this equation, however, it is assumed that no skewing
occurs [3]. The rotor angle m represents the relative
movement of the rotor with respect to the stator.
The effective number of turns, ws s , may be determined from a winding topology, which is indicated
by the begin and end location and the number of
turns of the stator winding coils  as depicted in
Fig. 2. Alternatively, a symmetric stator winding can
be parametrized by entering the effective number of
turns.

turns equal to one. Using the winding factor of a rotor mesh (4), the matrix of the main rotor field can be
expressed as


(i  j)2
Lrr[i, j] = L0 2r cos
.
(5)
Nr
The rotor voltage equation can be derived from the
topology of the squirrel which is depicted in Fig. 3.
Considering constant leakage inductances Lb[i] and
Lea[i] and Leb[i] of the bars and the end rings on both
sides (index a = drive end side, DE; index b = non
drive end, NDE), the rotor voltage equations yields:
0 = (Rea[i] + Reb[i] + Rb[i] + Rb[i+1] )Ir[i]
Rb[i] Ir[i1]  Rb[i+1] Ir[i] + Reb[i] Ieb
dIr[i]
+(Lea[i] + Leb[i] + Lb[i] + Lb[i+1] )
dt
d
 (Lb[i] Ir[i1] + Lb[i+1] Ir[i]  Leb[i] Ieb )
dt
3 dL
dIr[ j]
sr[ j,i] Is[ j]
+  Lrr[i, j]
(6)
+
dt
dt
j=1
Additional parameters of this equation are the bar resistances Rb[i] and the resistances of the end ring segments Rea[i] and Reb[i] . The topology of the rotor cage
(Fig. 4) leads to Nr + 1 linearly independent meshes.
Therefore, the mesh current Ieb is introduced and the
additional voltage equation
Nr

0 =  Reb[i] (Ir[i] + Ieb ) +

3

i=1

Rotor Winding Model

d Nr
 Leb[i] (Ir[i] + Ieb) (7)
dt i=1

has to be taken into account.
The squirrel cage rotor with Nr rotor bars can be seen It should be noted that the main field inductances
as a winding topology with an effective number of Lss[i, j] and Lrr[i, j] of a squirrel cage induction machine
The Modelica Association

352

Modelica 2008, March 3rd  4th , 2008

Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the ExtendedMachines
Library

Figure 2: Stator winding parameters of a squirrel cage induction machine
are constant and the mutual inductances (3) are dependent on the rotor angle m .
In the ExtendedMachines library, the rotor cage can
be parametrized in two different ways. First, the resistances and leakage inductances of the rotor bars
and the end ring segments of both sides can be
parametrized (Fig. 4). This is how a squirrel cage is
internally modeled. Second, a symmetric rotor cage
can be indicated by the rotor resistance Rr and the rotor leakage inductance Lr , equivalently transformed
to the stator side. The same parameters are used for
the Machines package of the MSL. The relationship
between the symmetric rotor bar and end ring resistance and the rotor resistance with respect to the stator
side is determined by
Rr = 2

(Fig. 5),
ratioCageR =
ratioCageL =

Rb,sym
,
Re,sym
Lb,sym
.
Le,sym

(10)
(11)

This way, the symmetric cage resistance and leakage inductance parameters can be determined from Rr ,
Lr , ratioCageR and ratioCageL.

4 Torque
The electromagnetic (inner) torque of the machine is
computed by

2p
3ws 2 s 2
{Re,sym + Rb,sym [1  cos(
)]}. (8)
Nr r 2
Nr

3

Nr

dLsr[i, j]
Is[i] Ir[ j] .
i=1 j=1 dm

Tel =  

(12)

A similar equation can be obtained for the rotor leak- In the presented investigation neither friction nor venage inductance with respect to the stator side,
tilation losses nor stray load losses are taken into account.
2
2
3ws s
2p
Lr = 2
{Le,sym + Lb,sym [1  cos(
)]}.
2
Nr r
Nr
(9) 5 Theoretical Background of Rotor
Additionally,
the ratios of the resistances
Faults
(ratioCageR)
and
leakage
inductances
(ratioCageR), each with respect to the rotor The distorted rotor bar currents have an impact on the
bars over the end ring segments, can be specified fundamental wave of the rotor magneto motive force
The Modelica Association

353

Modelica 2008, March 3rd  4th , 2008

C. Kral, A. Haumer

Figure 4: Parameters of the resistances and the leakage inductances of the rotor bars and end ring segments

Figure 5: Parameters of the squirrel cage

The Modelica Association

354

Modelica 2008, March 3rd  4th , 2008

Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the ExtendedMachines
Library

Figure 6: 18.5 kW four pole induction machine
(MMF). The fundamental rotor MMF can be considered to be composed of a forward and backward traveling wave. The backward traveling wave is caused
by the electrical rotor asymmetry and induces a stator
voltage harmonic component at the frequency
Figure 7: For broken one rotor bar a hole is drilled into
fl = (1  2s) fs
(13) the aluminum part of the squirrel cage rotor
for infinite inertia drives. In this equation fs is the stator supply frequency and
fs  pn
s=
fs

(14)

is slip, expressed in terms of rotor speed n and the
number of pole pairs p. Due to the impedance of the
machine (and the supply) the stator voltage harmonic
gives rise to a stator current harmonic with the same
frequency. To this stator current harmonic component
literature refers as lower side band harmonic. A finite
inertia of the drives gives rise to additional upper side
band harmonics at the frequency
fu = (1 + 2s) fs ,

(15)

the upper side band harmonic [4]. Between no load
and rated operating conditions slip varies between zero
and some per cent.
Electrical rotor asymmetries give also rise to a distortion of the magnetic field of the air gap [5] and the
stray flux [6]. Additional effects are caused by the interaction of the current side band harmonics with the
fundamental wave of the voltage, which gives rise to
double slip frequency oscillations
ft = 2s fs

6 Investigated Machine
Simulation and measurement results refer to a
18.5 kW, four pole induction machine with 40 rotor
bars (Fig. 6). In this paper simulation and measurement results are obtained for nominal load torque,
nominal line-to-line voltage (400 V) and nominal frequency (50 Hz). The investigations refer to a squirrel
cage with one fully broken rotor bar. For the experiment, the faulty bar was broken by drilling a hole into
the aluminum part as shown in Fig. 7.
For the investigated machine ratioCageR = 9 was
estimated from the geometry, and in the same way,
without getting into details, it was assumed that
ratioCageL = 9, too. With these parameters the
rotor bar and end ring segment parameters Rb,sym ,
Lb,sym , Re,sym and Le,sym are computed according to
(8)(11) for a given rotor resistance Rr and a leakage
inductance Lr . In the Modelica simulation the broken
bar was considered by setting the faulty bar resistance
with index 1

(16)

Rb[1] = 100Rb,sym .
(17)
of the electrical power and torque [7], [8]. The magnitudes of these fault specific oscillations are much
smaller the average values of the electrical power and This resistance increase causes the current through this
torque, respectively.
bar to sufficiently vanish.
The Modelica Association

355

Modelica 2008, March 3rd  4th , 2008

3

4
rotor bar currents [kA]

rotor bar peak current Ib[i] [kA]

C. Kral, A. Haumer

2

1

0

Ib[40]
Ib[1]

2

Ib[2]
Ib[3]

0

2

1

10

20

30

4

40

0

0.5

index i of rotor bar

1

2

1.5

2.5

tims [s]

Figure 8: Peak values of the rotor bar currents; broken Figure 9: Rotor bar currents; broken rotor bar with
index 1; simulation results
rotor bar with index 1; simulation results
8

Simulation Results

rotor peak current Ir[i] [kA]

7

An electrical rotor asymmetry gives rise to a distortion
of the current distribution of the rotor bars and end
ring segments. The rotor bar currents can be computed
from the rotor currents according to Fig. 3,
Ib[i] = Ir[i]  Ir[i1] .

(18)

For nominal load and steady state operating conditions
the peak values of the the sinusoidal currents of the rotor bars are depicted in Fig. 8. A time domain plot of
some these currents (index 40, 1, 2 and 3) are shown in
Fig. 9. The current of the broken rotor bar (index 1) is
almost zero. Additionally, an interesting phenomenon
can be observed. The currents of the directly adjacent
rotor bars (e.g. index 40 and 2) are significantly larger
than the currents of the remaining rotor bars. Due to
this effect and the associated heat losses, the thermal
stress of the directly adjacent rotor bars increases. This
may also cause a damage of the adjacent bars which
gives rise to an avalanche-like increase of the extend
of the damage. Nevertheless, electrical rotor asymmetries spread relatively slow compared to other machine
faults. A significant rise of the fault extend may thus
happen within weeks, months or even years.
Due to the distortion of the current distribution in the
rotor bars, the end ring current distribution changes,
too. The rotor end ring currents of the A- and B-side
can be defined by
Iea[i] = Ir[i] ,

(19)

Ieb[i] = Ir[i] + Ieb .

(20)

6
4
2
0

1

10

20

30

40

index i of rotor end ring segment
Figure 10: Peak values of the currents of the end ring
segments; broken rotor bar with index 1; simulation
results
B-side are equal. The peak values of the currents of
the rotor end ring segments are depicted in Fig. 10.
The lower and upper side band harmonics of the current arise a few Hertz differing from the fundamental
wave according to (13) and (15). For the investigated
machine 50 Hz machine the Fourier spectrum of a stator current (phase 1) is depicted in Fig. 11. The lower
and upper side band harmonics clearly arise at 48.6 Hz
and 51.4 Hz. The magnitudes of these side band components are, however, much smaller than the magnitude of the fundamental. Therefore, electrical rotor
asymmetries can usually not be determined from the
time domain waveforms.

8 Measurement Results

Without any asymmetry of either of the end rings, The measured Fourier spectrum of on stator phase curIeb = 0 applies and therefore the currents of the A- and rent is depicted in Fig. 12. Comparing this plot with
The Modelica Association

356

Modelica 2008, March 3rd  4th , 2008

Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the ExtendedMachines
Library

stator current Is[1] [A]

102

9 Rotor Fault Detection Methods

100

102
40

45

50

55

60

frequency [Hz]
Figure 11: Fourier spectrum of the stator current Is[1] ;
simulation results

stator current Is[1] [A]

102

100

102
40

45

50

55

60

frequency [Hz]
Figure 12: Fourier spectrum of the stator current Is[1] ;
measurement results

the simulation results of Fig. 11 reveals, that the frequencies of the side band harmonics are the same, but
the magnitudes show small deviations. The different
magnitude of the side band harmonics is mainly related with the inertia of the drive which is not perfectly
tuned such way that the magnitudes match. Additionally, due to the deviation of the modeled rotor bar and
end ring resistance ratio from the real machine cage,
some deviations in the simulation results may arise.
With respect to the comparison of measurement and
simulation results it should also be noted that in a real
motor interbar currents can arise [9], which are not
modeled in the ExtendedMachines library. These interbar currents lead to a current flow through the rotor teeth, first, in general, and, second, adjacent to the
broken bar. Therefore, interbar currents may have an
impact on the magnitudes of the side band currents.
The Modelica Association

Only severe rotor asymmetries can be detected
through significant fluctuations of the amperemeters
or wattmeters connected in the feeders of the machine. Upcoming electric rotor asymmetries require
some more sophisticated detection methods. The most
usual rotor fault detection methods are solely based
on the measurement of one stator current. This class
of methods is called current signature analysis (CSA)
methods [10], [11], [12]. The measured current is then
processed by either a fast Fourier transform [13] or a
wavelet transform [14], [15] or some other signal processing techniques.
A second class of methods is based on power signature
analysis (PSA), evaluating either total or phase power
[7]. Additionally to CSA or PSA techniques, neural
networks [16], [17] or Fuzzy based methods [18] may
be applied.
A third class uses model based techniques for detecting a rotor fault. One model based technique is the
Vienna Monitoring Method (VMM) which was introduced in 1997 [19]. This method evaluates two mathematical machine models and calculates torque for each
model. In case of a fully symmetrical machine both
models calculate the same torque and torque difference is zero. An electrical rotor asymmetry gives rise
to side band currents and double slip frequency torque
oscillations. These torque oscillations are differently
sensed by the two mathematical models due to the different model structure. This leads to different magnitudes and phase shifts of the double slip frequency
torque oscillation derived by the two models. Therefore, torque difference shows a double slip frequency
oscillation which indicates an electrical rotor fault.
The torque difference, divided by the average load
torque, serves as quantity to determine the fault indicator through a certain data clustering technique. The
fault indicator is basically the magnitude of the double slip frequency oscillation of the torque difference,
divided by the average load torque. The particular advantage of the VMM is that it provides a reliable fault
indicator independent of load torque, speed, supply
and inertia of the drive [20], [21], [22].
The VMM has been applied to both the simulation and
measurement results. For the simulation results the determined fault indicator is 0.0093 and the VMM applied to the measured data leads to a fault indicator of
0.0105. This is a deviation of about 11%. Considering
no parameter tuning of the simulation model this is a
satisfactory result.

357

Modelica 2008, March 3rd  4th , 2008

C. Kral, A. Haumer

10

Conclusions

For squirrel cage induction machines the background
of electrical rotor asymmetries is discussed. A rotor
topology models for handling cage asymmetries is introduced and the implementation in the ExtendedMachines library is presented.
A 18.5 kW induction machine with one broken rotor bar out of 40 bars is investigated. The simulated and measured stator current Fourier spectrum are
compared and shown good coherence. Additionally,
the simulation and measurement data are applied to
a model based rotor fault detection method  the Vienna Monitoring Method. The comparison of the two
fault indicators determined by the Vienna Monitoring
Method reveals a deviation of about 11%. Considering
that no parameter tuning of the simulation model has
been performed, this is a satisfactory matching result.

References

ing faults in induction machines using an external flux sensor, Issue: 5 Industry Applications,
IEEE Transactions on , Volume: 39, pp. 1272
1279, 2003.
[7] Z. Liu, X. Yin, Z. Zhang, D. Chen, and W. Chen,
Online rotor mixed fault diagnosis way based
on spectrum analysis of instantaneous power in
squirrel cage induction motors, IEEE Transactions on Energy Conversion, vol. 19, pp. 485
490, Sept. 2004.
[8] S. Legowski, A. S. Ula, and A. Trzynadlowski,
Instantaneous power as a medium for the signature analysis of induction motors, IEEE Transactions on Industry Applications, vol. 32, no. 4,
pp. 904909, 1996.
[9] R. Walliser, The influence of interbar currents
on the detection of broken rotor bars, ICEM,
pp. 12461250, 1992.

[1] C. Kral, A. Haumer, and F. Pirker, A modelica [10] M. Benbouzid, A review of induction motors
library for the simulation of electrical assymesignature analysis as a medium for fault detries in multiphase machines - the extended matection, Annual Conference of the IEEE Inchines library, IEEE International Symposium
dustrial Electronics Society, IECON, pp. 1950
on Diagnostics for Electric Machines, Power
1955, 1998.
Electronics and Drives, The 6th, SDEMPED
[11] A. Bellini, F. Filippetti, G. Franceschini, C. Tas2007, Cracow, Poland, 2007.
soni, R. Passaglia, M. Saottini, G. Tontini,
[2] C. Kral, Modellbildung und BetriebsverhalM. Giovannini, and A. Rossi, On-field expeten einer Asynchronmaschine mit defektem Rorience with online diagnosis of large induction
torstab im Luferkfig einschlielich Detektion
motors cage failures using mcsa, IEEE Transdurch die Vienna Monitoring Method. PhD theactions on. Industry Applications, vol. 38, no. 4,
sis, Technische Universitt Wien, 1999.
pp. 10451053, 2002.
[3] G. Mller, Elektrische Maschinen - Theorie [12] G. Didier, E. Ternisien, O. Caspary, and
rotierender elektrischer Maschinen.
Berlin:
H. Razik, Fault detection of broken rotor bars in
VEB Verlag Technik, 2 ed., 1967.
induction motor using a global fault index, IEEE
Transactions on Industry Applications, vol. 42,
[4] F. Filippetti, G. Franceschini, C. Tassoni, and
pp. 7988, Jan.-Feb. 2006.
P. Vas, Impact of speed riple on rotor fault diagnosis of induction machines, Proceedings of
[13] I. M. Culbert and W. Rhodes, Using current sigthe International Conference on Electrical Manature analysis technology to reliably detect cage
chines, ICEM, pp. 452457, 1996.
winding defects in squirrel-cage induction motors, IEEE Transactions on Industry Applica[5] M.
Schagginger,
Diplomarbeittions, vol. 43, pp. 422428, March-april 2007.
Luftspaltfelduntersuchungen an umrichtergespeisten Asynchronmaschinen im Hinblick auf
elektrische Unsymmetrien im Rotorkfig. Wien: [14] H. Douglas, P. Pillay, and A. Ziarani, Broken
rotor bar detection in induction machines with
TU, 1997.
transient operating speeds, IEEE Transactions
on Energy Conversion, vol. 20, pp. 135141, Mar
[6] H. Henao, C. Demian, and G.-A. Capolino,
2005.
A frequency-domain detection of stator windThe Modelica Association

358

Modelica 2008, March 3rd  4th , 2008

Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the ExtendedMachines
Library

[15] J. Antonino-Daviu, M. Riera-Guasp, J. Folch,
and M. Palomares, Validation of a new method
for the diagnosis of rotor bar failures via
wavelet transform in industrial induction machines, IEEE Transactions on Industry Applications, vol. 42, pp. 990996, July-August 2006.
[16] B. Ayhan, M.-Y. Chow, and M.-H. Song, Multiple discriminant analysis and neural-networkbased monolith and partition fault-detection
schemes for broken rotor bar in induction motors, IEEE Transactions on Industrial Electronics, vol. 53, pp. 12981308, June 2006.
[17] W. W. Tan and H. Huo, A generic neurofuzzy
model-based approach for detecting faults in induction motors, IEEE Transactions on Industrial Electronics, vol. 52, pp. 14201427, Oct.
2005.
[18] E. Ritchie, X. Deng, and T. Jokinen, Diagnosis
of rotor faults in squirrel cage induction motors
using a fuzzy logic approach, Proceedings of
the International Conference on Electrical Machines, ICEM, pp. 348352, 1994.
[19] R. Wieser, C. Kral, F. Pirker, and M. Schagginger, On-line rotor cage monitoring of inverter
fed induction machines, experimental results,
Conference Proceedings of the First International IEEE Symposium on Diagnostics of Electrical Machines, Power Electronics and Drives,
SDEMPED, pp. 1522, 1997.
[20] C. Kral, F. Pirker, and G. Pascoli, Influence of
load torque on rotor asymmetry effects in squirrel cage induction machines including detection
by means of the Vienna Monitoring Method,
Conference Proceedings EPE, 2001.
[21] C. Kral, H. Kapeller, J. Gragger, F. Pirker, and
G. Pascoli, Detection of mechanical imbalances
during transient torque operating conditions, 5th
IEEE International Symposium on Diagnostics
for Electric Machines, Power Electronics and
Drives, SDEMPED, 2005.
[22] C. Kral, F. Pirker, and G. Pascoli, The impact of
inertia on rotor faults effects - theoretical aspects
of the Vienna Monitoring Method, IEEE International Symposium on Diagnostics for Electric
Machines, Power Electronics and Drives, The
6th, SDEMPED 2007, Cracow, Poland, 2007.

The Modelica Association

359

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

360

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Large Chipper Drive

Modeling and Simulation of a Large Chipper Drive
Hansjrg Kapeller

Anton Haumer Christian Kral Gert Pascoli
arsenal research
Giefinggasse 2, 1210 Vienna, Austria
hansjoerg.kapeller@arsenal.ac.at

Abstract

1.1

This paper presents a simulation model for a large
chipper drive used in a paper mill. If the chipper
drive is a slip ring induction motor, several advantages arise from using a rheostat in the rotor circuit.
This paper will investigate the impact of a rotor circuit rheostat with respect to starting behavior and
heavy duty load impulses. Furthermore an alternative
chipper drive with a speed controlled squirrel cage
induction machine will be presented. Both drives are
modeled in Modelica. Simulation results are compared and discussed.
Keywords: Chipper drive; slip ring induction motor;
squirrel cage induction machine; speed control; load
impulses; simulation model

1

Introduction

Both, starting the chipper drive and heavy duty operating, cause large currents if no measures are taken.
For a motor not being supplied by an inverter, high
starting currents arise from the low locked rotor impedance of the induction motor [1]. It is therefore
often useful to use a slip ring motor instead of squirrel cage motor. With a slip ring motor an additional
rheostat in the rotor circuit can be used to increase
the impedance. This gives rise to reduced starting
currents and improves the torque speed characteristic
with the effect, that reactions of the load impulses on
the motor currents and voltage sags are diminished,
too.
The significant disadvantages of a slip ring motor
with additional resistances in the rotor circuit is the
deterioration of efficiency due to additional losses in
the external rotor resistances and the high abrasion of
the brushes, which gives rise to an increased deposit
of brush dust in the motor. This brush dust subsequently increases the risk of isolation breakdown and
causes higher costs of maintenance.
1.2

Low Voltage Inverter Supplied Squirrel
Cage Motor with Speed Control

An alternative approach which gives rise to reduced
starting and load peak currents is a speed controlled
inverter drive with squirrel cage motor (Fig. 1).
power
supply
reference
speed
+

speed
control
speed
controller

reference
current
+

current
controller
current
controller

power
controller

squirrel
cage motor

load

I

The Modelica Association

Slip Ring Motor with Additional Resistances

I

Chipper drives are used in paper mills for crushing
trunks and making wood chips. The nominal power
of a motor used for such applications ranges from
several 100 kW up to 2 MW and even more. A chipper drive is usually not operated continuously, because load impulse-arise only if a trunk is shredded.
After that, the motor is not loaded until the next
trunk is processed. The heavy duty load impulses
(double the nominal torque) give rise to large motor
currents which cause large voltage drops across the
mains impedance. To the regulations of the standards, and the actual configuration and structure of
the voltage supply, certain voltage drops (flicker effects) may not be exceeded during impulse load or
starting operation. Under some circumstances, the
chipper drive even has to start with some remaining
parts of a trunk loaded which is a heavy duty condition for the motor.
In the following, two possible chipper drive applications are presented. First, a slip ring motor with
rheostat in the rotor circuit and, second, a speed controlled squirrel cage motor is investigated.

Franz Pirker

current feedback

speed feedback

current
sensor

position
transducer

d/dt

rotor
position

Figure 1: General diagram of a speed controlled drive

361

Modelica 2008, March 3rd  4th , 2008

H. Kapeller, A. Haumer, C. Kral, G. Pascoli, F. Pirker

The basic topology of a speed controlled drive consists of the electric machine, the power converter, the
power supply, cascaded current and speed controller,
the mechanical load, the current sensor and the position transducer respectively [2]. The speed controller
controls the reference stator current of the machine
according to the deviation of the actual speed from
the reference speed. The current controller has a
build in limitation of the current to avoid overloading
the machine. This leads to efficiency savings over a
wide operating range and indicates an advantage
compared to the realization with a slip ring motor.
The higher investment costs due to the additional
equipment  the entire speed control implementation
with all necessary sensors  are disadvantageous,
however.
1.3

Chipper drive with squirrel cage motor
Frequency
50 Hz
Number of pole pairs
2
RMS stator voltage, line-to-line
690 V
RMS stator current
1404.5 A
Warm stator resistance per phase
1.702E-3 
Stray stator inductance per phase
Main inductance per phase
Stray rotor inductance per phase
Warm rotor resistance per phase
Motor rated power
Motor rated rpm
Motor inertia
Load inertia
Gear unit

Technical Data
Grid

Frequency
RMS voltage, line-to-line
Short-circuit apparent power
Short-circuit power factor
Transformer's nominal apparent power
Transformer's short-circuit p.u. voltage
Transformer's copper losses

2

Chipper drive with slip ring motor
Frequency
50 Hz
Number of pole pairs
2
RMS stator voltage, line-to-line
6000 V
RMS stator current
161.1 A
RMS rotor voltage, line-to-line
1500 V
RMS rotor current
595.3 A
Warm stator resistance per phase
129.0E-3 

Motor rated power
Motor rated rpm
Motor inertia
Load inertia
Gear unit

6.845E-3 H
273.8E-3 H
0.4631E-3 H
8.729E-3 
1.5 MW
1490.8 min-1
120 kg.m2
20000 kg.m2
1500:300 min-1

Table 2: Data of the investigated chipper drive with slip
ring motor

The Modelica Association

1.135E-3 
1.5 MW
1493.9 min-1
80 kg.m2
20000 kg.m2
1500:300 min-1

Table 3: Data of the investigated chipper drive with low
voltage inverter supplied squirrel cage motor

50 Hz
6000 V
50 MVA
0.05
1.8 MVA
0.06
17.5 kW

Table 1: Grid data

Stray stator inductance per phase
Main inductance per phase
Stray rotor inductance per phase
Warm rotor resistance per phase

0.10835E-3 H
4.063E-3 H
0.10835E-3 H

Simulation Models

For performing the Modelica simulations [3] the
simulation tool Dymola is used. The behavior of the
chipper drive  except for the inverter and control 
can be modeled using the comprehensive Modelica
Standard Library (MSL).
The free MSL provides a collection of standard components and component interfaces for many engineering domains. In the current version of the MSL
all components for modeling the proposed chipper
drive are offered. For the proposed simulation models mainly the MultiPhase, the Machines (includes,
e.g., direct current, asynchronous induction and permanent magnet synchronous induction machines)
and the Rotational packages of the MSL are used.
Since the drive controllers are not modeled in the
MSL, controlled drives cannot be simulated with
components of the MSL, only. Based on the Machines library [4] the SmartElectricDrives (SED)
library [5] facilitates simulations of any electric drive
application using different control structures and
strategies.
The SED library contains models for the components
used in a state-of-the-art electric drive. Sources (batteries and a PEM fuel cell), converters (ideal and
power balanced), loads, process controllers, sensors,
etc. are provided in this library. In the SED library,
two classes of drives simulations are provided. The
first class models quasi stationary drives, the second
class uses the transient models of the MSL. For fast

362

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Large Chipper Drive

simulations regarding energy consumption or the
efficiency of a drive, the models of the QuasiStationaryDrives can be used. They have been modeled
with the aim to neglect all electrical transients in the
machines. Mechanical transients due to the rotor inertia are considered, however. A great benefit of the
QuasyStationaryDrives is the remarkable shorter
simulation time and the reduced number of input
parameters due to simpler controller configuration
and the neglect of switching effects. For the analysis
of current spikes due to converter switching the
TransientDrives have to be used. By choosing this
lower level of abstraction the user pays the price of
more computing time due to a high number of
switching events caused by the inverter.
Besides all elementary components that give the user
the freedom of building up an entire controlled machine, ready to use models of drives are provided.
These models can be used to conveniently and
quickly arrange simulations [5]. The ready to use
models contain converters, measurement devices and
a field oriented control (FOC).
2.1

Slip Ring Motor with Additional Resistances

If the motor is not loaded, the resistance Rc does not
have a significant influence on the motor current and
speed. If the motor is loaded with a constant load
torque the stationary speed depends on the actual
resistance Rc according to
Rr Rr + Rc
,
(2)
=
s
sc
where s denotes the slip for the case without external
rotor circuit resistance, and sc is the slip for the case
with the external rotor circuit resistance Rc [6].
The total rotor circuit resistance leads to a scaled
torque-slip characteristic. Therefore, load impulses
can be covered partially by the stored energy of all
rotating masses. The stationary torque speed characteristic of an induction motor is shown in Fig. 3, the
stator current versus speed is shown in Fig. 4. For a
short circuited slip ring rotor ( Rr = Rr ) the torque
speed characteristic shows a very low starting torque
and a starting current of approximately 5 times the
nominal current. For Rr = 21Rr the stationary characteristics show a significant improvement. In this
case the locked rotor torque is close to the breakdown torque and the locked rotor current is less than
4.5 times the nominal current.

A slip ring motor with an additional rheostat and an
external constant resistance in the rotor circuit can be
used to increase the impedance (Fig. 2). This gives
rise to reduced starting currents and improves the
torque speed characteristic (Fig. 3).

Figure 2: Three phase rheostat of a slip ring induction
motor

R r

The total rotor circuit resistance
consists of the
actual rotor (winding) resistance Rr and the external
resistance, which in turn consists of the variable resistance of the rheostat Rv and an external constant
resistance Rc:

Rr = Rr + R + Rc .

Figure 3: Stationary torque versus speed of a slip ring motor with external rotor resistance

(1)

During the start-up, the resistance of the rheostat Rv
is reduced along a linear ramp. The duration of the
ramp has to be chosen according to the actual inertia
and starting conditions of the entire chipper drive.
After reaching nominal speed, the variable resistance, Rv, is short circuited.
The Modelica Association

363

Modelica 2008, March 3rd  4th , 2008

H. Kapeller, A. Haumer, C. Kral, G. Pascoli, F. Pirker

Figure 4: Stationary current versus speed characteristic of
a slip ring motor with external rotor resistance

motor (AIM) is star connected, the stator terminals
are connected with the mains impedances, incorporating the instruments for voltage, current and power
measurement. The rotor circuit of the slip ring rotor
is also star connected. The slip ring terminals are
series connected to a constant resistor (Rc) and a
variable resistor (Rv). In the simulation model depicted in Fig. 5 the variable resistor is controlled by a
ramp during the start-up of the motor. The signal
inputs of the variable resistor, however, can be controlled by any other strategy as well. The mechanical
shaft of the induction motor is connected with a
torque and speed sensor. The power is transmitted
through a gear (idealGear) to the load torque
(loadTorque) model. The signal input of the load
torque model is supplied by a time table (loadTable) modeling impulse loads.
2.2

Low Voltage Inverter Supplied Squirrel
Cage Motor with Speed Control

In Fig. 6 a speed controlled chipper drive with a
squirrel cage induction motor is presented. This drive
uses components of the SED library. The voltage
supply and measurement is the same as in the previous model, except that a transformer is used to provide 690 V to the low voltage drive.

Figure 5: Chipper drive with slip ring motor

Figure 5 depicts the Modelica model of the chipper
drive realized with a slip ring motor. The
6 kV / 50 Hz voltage supply is modeled by three sinusoidal supply voltages (sineVoltage) which
are star (starG) connected. The overall mains impedance including all transmission lines and transformers, is modeled by a series connection of a three
phase resistor (resistorG) and a three phase inductor (inductorG). For having the root mean
square (RMS) values of the voltages and currents in
the simulation results available, an RMS voltmeter
and amperemeter are connected into the circuit. In
addition to these instruments, a power sensor is used
to measure the characteristic power terms of the circuit. The stator winding of the slip ring induction

The Modelica Association

Figure 6: Modelica model of a speed controlled chipper
drive with a squirrel cage motor

The transformed supply voltage (transformer) is
rectified (diodeBridge) and provides the intermediate circuit voltage for the inverter. The idealized
rectifier does not take into consideration the typical

364

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Large Chipper Drive

non-sinusoidal waveform of a diode bridge. Therefore the supply current is rather comparable to that of
an IGBT rectifier. The squirrel cage induction motor
is supplied by a DC/AC-inverter which is implemented in the field oriented controlled QuasyStationaryDrive model (AIMfoc). The mechanical load
model of the slip ring motor and the inverter drive
are the same, however.
The components of the cascade control system anticipated in Fig. 1 can be parameterized separately
[7]. Starting from the innermost to the outermost
closed loop, various parameterization methods can
be applied to achieve the desired dynamic behavior
[8].

Figure 7: Full transient Modelica model of a speed controlled chipper drive with a squirrel cage motor

In Fig. 7 the full transient Modelica model of a speed
controlled chipper drive with a squirrel cage induction motor is presented. This drive uses components
of the SED library, again. The voltage supply and
measurement is the same as in the quasi stationary
model, but using an ideal switching diode rectifier.
Additionally, the machine inverter is modeled in detail, not being integrated in the drive model. The detailed model of the ideal switching inverter leads to
high number of events during simulation, and gives
rise to significantly longer simulation time.
The dominant mechanical time constants are significantly greater than the electrical time constants. Provided that current peaks due to inverter switching
may be neglected for this investigation, it is reasonable to use the QuasiStationaryDrive model which
saves a significant amount of simulation time.
The Modelica Association

3

Simulation Results

In the presented results each load impulse has the
same duration (2 s), equal rise and fall times (0.1 s)
and the torque amplitude is twice the nominal torque.
The first load impulse starts at t = 30 s, the second
impulse starts at t = 40 s (cp. Fig. 8 and Fig. 12).
3.1

Slip Ring Motor

Simulation results for the chipper drive with slip ring
motor are depicted in Fig. 811, where Rc = 0  and
Rc = 10Rr were set consecutively. The duration of the
linear ramp for decreasing the variable resistor
(Rv,max = 40Rr) is 10 s. From Fig. 8 and 9 it can be
deduced that the torque and current, respectively, get
reduced due to the additional resistances in the rotor
circuit. The supply current of the slip ring motor
drive equals the stator phase current.

Figure 8: Load response of the slip ring motor (Rc = 0 
versus Rc = 10Rr and Rv,max = 40Rr) and wave form of the
modeled load impulses

Figure 9: Stator phase current during start-up and during
periodic loading of the chipper drive with slip ring motor
(Rc = 0  versus Rc = 10Rr and Rv,max = 40Rr)

365

Modelica 2008, March 3rd  4th , 2008

H. Kapeller, A. Haumer, C. Kral, G. Pascoli, F. Pirker

From Fig. 10 it is evident, that the additional resistance in the rotor circuit decreases the maximum
voltage sag at the motor terminals. Figure 11 shows
that higher external rotor resistance leads to larger
speed drop during the load impulses.

3.2

Squirrel Cage Motor

Simulation results for the chipper drive with squirrel
cage motor are depicted in Fig. 1215. From Fig. 12
and 13 it can be seen, that the overloading of the machine is limited effectively by the current controller.
The diminishing of the supply current peaks shows a
significant improvement and the voltage drops are
less than 2 % (cp. Fig. 14). Figure 15 illustrates, that
the speed drop during the load impulses shows a
similar dynamic characteristic as the chipper drive
with slip ring motor (Rc = 10Rr and Rv,max = 40Rr).

Figure 10: Stator phase voltage during start-up and during
periodic loading of the chipper drive with slip ring motor
(Rc = 0  versus Rc = 10Rr and Rv,max = 40Rr)

Figure 12: Load response of the speed controlled squirrel
cage motor and wave form of the modeled load impulses

Figure 11: Speed during start-up and during periodic loading of the chipper drive with slip ring motor (Rc = 0 
versus Rc = 10Rr and Rv,max = 40Rr)

Figure 13: Supply current and stator phase current during
start-up and during periodic loading of the chipper drive
with speed controlled squirrel cage motor

The Modelica Association

366

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Large Chipper Drive

Figure 14: Supply voltage during start-up and during periodic loading of the chipper drive with speed controlled
squirrel cage motor

Disadvantages of the slip ring motor are the deterioration of efficiency due to additional losses in the
external rotor circuit and the high abrasion of the
brushes, which gives rise to an increased deposit of
brush dust in the motor. This brush dust subsequently increases the risk of isolation breakdown and
causes higher costs of maintenance.
Contrarily, the inverter drive has lower costs of
maintenance but higher investment costs. Although
the squirrel cage induction motor is cheaper, more
expensive additional equipment is needed: a transformer as well as a frequency inverter and the entire
speed control unit with all necessary sensors.
However, the efficiency savings over a wide operating range and the absence of brushes indicates the
main advantages compared to the slip ring motor.

References
[1]
[2]

[3]

[4]

Figure 15: Speed during start-up and during periodic loading of the chipper drive with speed controlled squirrel
cage motor

[5]

4

[6]

Conclusions

In this paper two large chipper drives are modeled in
Modelica. The first drive is a slip ring motor with an
external resistance in the rotor circuit; the second
drive is a speed controlled squirrel cage motor. Both
drives lead to a satisfactory reduction of voltage dips
and current peaks during the start-up and the pulse
load operation.
Using a chipper drive with a slip ring induction motor, the investment costs for the motor are higher
than for an induction motor with squirrel cage. In
case of the slip ring motor the rather simple additional equipment  the rheostat and its control 
leads to low total investment costs.

The Modelica Association

367

[7]
[8]

P. L. Alger, Induction Machines. New York:
Gordon and Breach Science Verlag, 1970.
S. Nasar and I. Boldea, Electric Machines;
Dynamics and Control. 2000 Corporate
Blvd, USA: CRC Press, 1st ed., 1993
P. Fritzson, Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1.
Piscataway, NJ: IEEE Press, 2004.
C. Kral and A. Haumer, Modelica Libraries
for Dc Machines, Three Phase and Polyphase Machines. Modelica Conference, 549558, 2005.
H. Giuliani, C. Kral, J.V. Gragger and F.
Pirker, Modelica Simulation of Electric
Drives for Vehicular Applications. The Smart
Electric Drives Library. ASIM, 2005.
R. Fischer, Elektrische Maschinen. Mnchen: C. Hanser Verlag, 5 ed., 1983.
O. Fllinger, Regelungstechnik. Heidelberg:
Hthig Verlag, 8th ed., 1994.
H. Lutz, W. Wendt, Taschenbuch der Regelungstechnik. Frankfurt am Main: Wissenschaftlicher Verlag Harri Deutsch, 5th
enlarged ed., 2003.

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

368

Modelica 2008, March 3rd  4th , 2008

Simulation and Validation of Power Losses in the Buck-Converter Model included in the SmartElectricDrives
Library

Simulation and Validation of Power Losses in the Buck-Converter
Model included in the SmartElectricDrives Library
Harald Giuliani

1

Claus-J. Fenz Anton Haumer Hansjrg Kapeller
arsenal research
Giefinggasse 2, 1210 Vienna, Austria
harald.giuliani@arsenal.ac.at

Abstract

In this work a buck converter model included in the
simulation software tool - the SmartElectricDrives
library - is verified. The main focus is put on the
converter losses. For these purposes a buck converter
test bench was designed and set up. The power losses
where measured according a defined series of
measurements. Conduction and switching losses are
investigated in this paper and their impact on the
converter behavior is analyzed. As a result of the
implemented losses concept the user should be able
to parameterize the converter without comprehensive
knowledge about transient transistor effects and data
sheet availability.

2

Introduction

DC-DC converters are used to convert the
unregulated DC input into a controlled DC output at
a desired voltage level. The input voltage can be
provided by a DC voltage source (e.g. a battery) or
the DC-bus of an AC-DC-converter. The DC-DC
converters are widely used in regulated switched
mode DC power supplies and in DC motor drive
applications.
In this paper one DC-DC-converter, like those
utilized in electric vehicles, is investigated. The
measurements on an electric vehicle emphasize the
role of the dc-dc converter on the automotive market.
In the investigated vehicle there are utilized three
DC-DC converters in total. Two of them are used for
feeding the electrically excited DC motor and one of
them for charging the board system battery.
For shortening the period of development and
reducing costs, simulation is a crucial step in the
continuous design process. For the simulation of the
energy flow of an entire hybrid vehicle [5] [6], the
losses of each component have to be taken into
account. So the modeling of the power losses in DCThe Modelica Association

DC converter are relevant regarding the power
balance of the whole system. Special software tools
are necessary for this development process because
the conventional simulation and calculation
programs do not meet interdisciplinary and dynamic
demands. In this contribution the Modelica [1] model
of a DC-DC converter, taking the power dissipation
into account, will be presented. Moreover the
simulation results will be validated through
measurements.

3
3.1

The Buck-Converter Model
The SmartElectricDrives Library

The SmartElectricDrives (SED) library [2] is written
in Modelica and developed by arsenal research, with
the focus on automotive applications. The SED
library contains all basic machine types like
asynchronous induction machines, permanent
magnet synchronous machines, and direct current
machines combined with various components needed
for modern closed loop controlled drive systems like
controllers and power electronic converters.
The most common DC-DC converters such as the
chopper, the buck (step-down) converter, the boost
(step-up) converter, the buck-boost converter and the
full bridge are already included in the current version
of the SED. The consideration of losses is planned to
be implemented in the next release of the SED.
An important feature of the SED is that some
components e.g. all the converter models are
implemented at two different level of abstraction.
The user can choose between power balance
converters and ideal switching converters. In power
balance converters the current flow is adjusted
automatically due to the energy balance between the
supply side and the load side considering switching
and conduction losses. In switching converters the
output voltage and the current flow is given by
transistors switching states which are controlled by

369

Modelica 2008, March 3rd  4th , 2008

H. Giuliani, C. J. Fenz, A. Haumer, H. Kapeller

pulse width modulation. Power balance converters
are designed for simulations in which switching
effects do not have to be considered. Their big
advantage is that simulations work much faster with
these models since the calculation effort for the
power balance equation is much smaller compared to
processing a large number of switching events.
3.2

The Buck-Converter

The basic structure of a buck converter is shown in
Figure 1. A buck converter produces an average
output voltage vLoad less than the DC input voltage
vSupply. By varying the duty ratio
(1)
t on
D=

TS

of the switch, vLoad can be controlled.

ton switch on duration

toff switch off duration
TS switching time period

The conduction and switching losses are considered
in both the power balance and the ideal switching
converter model.
 Conduction losses of the ideal switching model
are affected by forward state-on resistance and
the forward threshold voltage of the transistor
and the diode, respectively. The power balanced
converter model uses a controlled voltage drop
to take the conduction losses into account. The
losses of the inductor are considered too,
whereas the losses in the capacitor are neglected.
A parameter estimation function supports the
user in determining consistent parameters.
 Both the power balance and the switching
converter model use a controlled current sink at
the input terminal to take the switching losses
into account. For calculating the actual switching
losses, the nominal switching power dissipation
with respect to the rated operation point has to be
known.

4

L inductance
C capacitance

Calculation of Converter Losses

4.1

Conduction Losses

For the calculation of conduction losses it is assumed
that the inductor current flows continuously. In this
case one converter switching period consists of two
converter circuit states (Figure 2 and Figure 3).
Figure 1: Basic structure of the buck-converter
The ideal output voltage vLoad of the buck converter
without considering the conduction losses is:
vLoad = vSupply  D
(2)
Normally, the switch is either an IGBT (InsulatedGate Bipolar Transistor) or a MOSFET (Metal Oxide
Semiconductor Field Effect Transistor).
3.3

Figure 2: Buck-Converter circuit state: switch on

The Losses in the Buck-Converter Model

The losses of the buck converter [3] [4] are mainly
conduction losses and switching losses. Conduction
losses occur when the converter current flows
through the internal power electronic components
and involves a voltage drop, reducing the output
voltage. Switching losses arise during the switching
of the transistor or diode. During switching on the
voltage drop decreases whereas the current rises,
causing high losses. Contrarily, during switching
off the losses are causes by a rising voltage drop and
a decrease of the current.

The Modelica Association

Figure 3 Buck-Converter circuit state: switch off
In steady state operation the waveform of voltages
and currents repeat periodically. Therefore the
integral of the inductor voltage vl over one period,
Ts, is zero:

370

Modelica 2008, March 3rd  4th , 2008

Simulation and Validation of Power Losses in the Buck-Converter Model included in the SmartElectricDrives
Library
t on

Ts





vl dt = vl dt +

0

0

(3)

t off



(9)-(15) is taken into account in the SED buckconverter.

vl dt =0

t on

PS = PS _ T + PS _ D

According to the Kirchhoff's voltage laws applied to
both converter circuit states (Figure 2 and Figure 3),
(3) leads to:

[vSupply  vLoad  VkneeT  i  ( RonT + RL )] D =
[vLoad + i  ( RonD + RL ) + VkneeD )] (1  D)

PS _ T = PS  (1 r S _ D ) 

PS _ D = PS r S _ D 

[VkneeT + i  ( RonT + RL )] D +
[VkneeD + i  ( RonD + RL ))] (1  D)

and the diode

]

(6)

[

]

(7)

PC _ D = i 2  ( R onD + RL ) + VKneeD  i  (1  D)



vblocking _ T



iT _ Nom vblocking _ TNom

f

(10)

f Nom

iD



vblocking _ D

iD _ Nom vblocking _ D Nom



f

(11)

f Nom

The blocking voltages of the transistor and the diode
are:
vblocking _ T = vSupply + iD  RonD + VkneeD
(12)
vblocking _ D = vSupply  iT  RonT  VkneeT

The conduction losses of the power transistor

[

iT

(4)

From (3) we obtain the average voltage drop
between ideal (2) and real output voltage:
v = vSupply  D  vLoad =
(5)

PC _ T = i 2  ( R onT + RL ) + VKneeT  i  D

(9)

(13)

The nominal blocking voltages of the transistor and
the diode are:
vblocking _ T Nom = VDC + iT _ Nom  RonD + VkneeD
(14)
vblocking _ D Nom = VDC  iD _ Nom  RonT  VkneeT

(15)

sum up to the total conduction losses:
PC = PC _ T + PC _ D

(8)

PS _ T , PS _ D switching losses in transistor/ diode

Equation (6) and (7) prove that the model of the ideal
switching power semiconductors inherently model
the conduction losses. The voltage drop of the power
balance model is based on (5).
vl inductor voltage
vSupply , vLoad .average supply voltage, average load

voltage

voltage

of

i average inductor current (equals average load current)

iLoad average load current

4.2

iD , iD _ Nom diode current, nominal diode current
vreverse _ T /

vreverse _ D blocking

voltage

of

transistor/diode

VDC nominal DC supply voltage
f , f Nom switching frequency/ nominal switching
frequency

5

Switching Losses

Detailed modeling of the switching losses through
switching events leads to a high numeric effort.
Therefore the average of these losses according to

The Modelica Association

iT , iT _ Nom transistor current/ nominal transistor current

transistor/ diode

RL inductor resistance

threshold

rS _ D ratio of switching losses in the diode

vreverse _ TNom / vreverse _ D Nom nominal blocking voltage of

RonT , RonD state-on resistance of transistor/ diode
VkneeT , VkneeD forward
transistor/diode

PS sum of switching losses

Measurement Setup

The measurement setup is shown in Figure 4.

371

Modelica 2008, March 3rd  4th , 2008

H. Giuliani, C. J. Fenz, A. Haumer, H. Kapeller

Figure 4 Measurement setup
Two power MOSFETs are used. One of them
(MOSFET_1) is used as switch. The freewheeling
diode of the other one (MOSFET_2) is used as buck
diode. The converter is fed by a constant DCvoltage. A constant current source is used as the
converter load. The switching MOSFET_1 is
controlled by a waveform generator. The pulsewidth
of the waveform generator is variable from 0 to 1 (0
means an open switch, whereas at duty cycle 1 the
switch is closed all the period).
The parameters in Table 1 are obtained from the data
sheet [7] of the used MOSFETs and measurements,
respectively.

6

Simulation and Comparison with
Measurement Results

6.1

Simulation

Figure 6 shows the simulation model of the buck
converter. The operation conditions summarized in
Table 1 are also applied to the simulations.

RonT = 7m (data sheet)

MOSFETs

Figure 5: Power losses @25A

RonD = 3m (data sheet)
VkneeT = 0V (data sheet)
VkneeD = 0.8V (data sheet)
RL = 2.9m (measured)

Inductor

L = 4.57 H (measured)

C = 1000 F (measured)

Capacitor

Table 1
The conducted measurements are summarized in the
Table 2.
ID

VDC

iLoad

f

duty cycle

M1
M2
M3
M4
M5
M6
M7
M8

30 V
30 V
30 V
30 V
30 V
30 V
30 V
30 V

5A
10 A
15 A
20 A
25 A
30 A
35 A
40 A

100kHz
100kHz
100kHz
100kHz
100kHz
100kHz
100kHz
100kHz

0.2,..0.8 (step 0.1)
0.2,..0.8 (step 0.1)
0.2,..0.8 (step 0.1)
0.2,..0.8 (step 0.1)
0.2,..0.8 (step 0.1)
0.2,..0.8 (step 0.1)
0.2,..0.8 (step 0.1)
0.2,..0.8 (step 0.1)

Figure 6: Simulation model of the buck converter

Table 2
Figure 5 illustrates the obtained power losses versus
duty cycle for measurement M5.

The Modelica Association

The measurement result of the total power losses at
the nominal operating point (load current of 25 A;
duty cycle of 0.5; switching frequency 100 kHz) is
Pl = 48.85W . The conduction losses at the nominal
operating point are calculated according to (6)-(8)
PC = 14.93W . The switching losses are calculated as
the difference between total losses and conduction
losses: PS = 33.92W . The simulation reference values
of switching losses in the nominal operating are
defined by this calculated value. The simulation is
fed by this value of switching losses. By changing
the nominal operating point the value of the power
dissipation is calculated by equations (9)-(15).

372

Modelica 2008, March 3rd  4th , 2008

Simulation and Validation of Power Losses in the Buck-Converter Model included in the SmartElectricDrives
Library

In Figure 7 the measured and the simulated power
losses versus the duty cycle for measurements M2,
M5 and M8 are compared.

Figure 9: Simulated voltage error at different duty
cycles and load currents
6.2

Figure 7: Comparison of measured and simulated
power losses at different load currents
The output voltage is strongly dependent on the duty
cycle, and almost independent of the load current.
Figure 8 presents the load voltage versus duty cycle
at three different load currents.

Parameter Optimization

Temperature dependency and other physical effects
lead to simulation results deviating from
measurements. The measured losses in Figure 10
were linearly approximated, leading to the fitted
parameters shown in Table 3.
MOSFETs

RonT = 13.8m
RonD = 3m
VkneeT = 0V
VkneeD = 0.5245V

Table 3

Figure 8: Measured output voltage at different load
currents
The deviation of the simulated output voltage from
the measurements results is less than 4 % (Figure 9).

Figure 10: Power losses curve fitment
The change of the operation condition summarized
in Table 1 is applied to the simulations.
Figure 11 illustrates the average errors (average error
using parameter set from Table 1 and average error
using parameter set from Table 3) of the simulated
The Modelica Association

373

Modelica 2008, March 3rd  4th , 2008

H. Giuliani, C. J. Fenz, A. Haumer, H. Kapeller

losses from the measurement results at different load
currents. Average error means the averaged error
value over the duty cycle at a specific load current.

References
[1]

[2]

[3]
[4]
[5]
Figure 11: Average errors
It is obvious that the simulation with the new
parameter set delivers better results in a large range.

7

[6]

Conclusion

In many applications DC-DC power converters are
employed in a variety of applications, including
power supplies for computers, power systems and
telecommunications equipment, as well as dc motor
drives.
For the simulation of the energy flow of an entire
hybrid vehicle, the losses of each component have to
be taken into account. The consideration of losses in
DC-DC converter simulations should be organized
user-friendly. This means that without big
knowledge of all converter elements parameter it
should be possible to carry out significant simulation
results for a large operating range. As the measuring
and simulating results have already shown, this
target is fulfilled by the in the SED implemented
DC-DC buck converter. The conduction losses are
defined by forward resistances and threshold
voltages. These parameters can get by data sheets or
by measurements. To consider the switching losses,
the nominal switching power dissipation with respect
to the rated operation point has to be known. An
optimization in a sub-operating range is easy done by
calculating new parameters from the linear
approximated measured power losses curve and
using this improved set of parameters in the
simulation.

The Modelica Association

374

[7]

P. Fritzson, Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1.
Piscataway, NJ: IEEE Press, 2004.
J.V.
Gragger,
H.
Giuliani,
The
SmartElectricDrives Library -- Powerful
Models for Fast Simulations of Electric
Drives,
5th
International
Modelica
Conference 2006, Vienna, Austria, 2006
N. Mohan, T.M. Undeland, W. Robbins,
Power Electronics, J. Wiley Verlag, 1989
B. Bose, Power Electronics and Motor
Drives, Elsevier, 2006
H. Giuliani, D. Simic, J.Gragger, C. Kral, C,
Optimization of a four wheel drive hybrid
vehicle by means of the SmartElectricDrives
and the SmartPowerTrains library, The 22nd
International Battery, Hybrid and Fuel Cell
Electric Vehicle Symposium & Exposition,
EVS22, 2006
D. Simic, H. Giuliani, C. Kral, J.V. Gragger,
Simulation of Hybrid Electric Vehicle, 5th
International Modelica Conference, Vienna,
Austria, 2006
Data
sheet,
International
Rectifier,
IRFPS3810, PD-93912B, HEXFET Power
MOSFET

Modelica 2008, March 3rd  4th , 2008

Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC

Real-Time Modelica Simulation
on a Suse Linux Enterprise Real Time PC
Arno Ebner

Martin Ganchev
Helmut Oberguggenberger
Arsenal Research
Giefinggasse 2  1210 Vienna Austria
arno.ebner@arsenal.ac.at

Abstract
This paper presents a real-time simulation system for
a Suse Linux Enterprise Real-Time (SLERT) operating system workstation. With this system can be
executed Hardware-in-the-loop (HIL) simulation.
HIL is the integration of real components and system
models in a common simulation environment. The
main focuses of this simulation system presented in
this paper are the development and the validation of
simulation models of electric components (e.g. battery systems, electric drives etc.) for Hybrid (HEV)
and Electric Vehicles.
The system is based on a Linux real-time computer
with numerous analoge/digital input and output
channels and all simulation models are implemented
in Modelica using the for example the SmartPowertrains and SmartElectricDrives libraries. The models
are simulated with the Dymola simulation environment for Linux.
Keywords: Real-time simulation, hardware-in-theloop simulation, hybrid electric vehicle

1

Intoduction

Hardware-in-the loop (HIL) is a useful method for
the testing hybrid and electric vehicles components
and is important for the validation and the verification of implemented simulation models. The integration of real components and virtual models in a
common simulation environment highly supports the
development processes of hybrid and electric vehicle
components like electric drive systems or energy
storage systems.
At Arsenal Research vehicle models are implemented in Modelica using the powerful SmartPowerTrains and SmartElectricDrives libraries. These
vehicle models can be simulated with the Dymola
simulation environment. The proposed hardware-inthe-loop simulation workstation is based on a Dual

The Modelica Association

Franz Pirker

CPU Xeon system with a SUSE Linux Enterprise
Real-Time (SLERT) operating system. This operating system allows CPUs to be shielded from other
processes and guarantees a highly deterministic execution environment. This system guarantee short response times and fast cycle times which are essential
to meet the requirements of HIL simulations of for
example electric drive trains. On this computer system can be executed standard Linux application such
as the Dymola simulation tool. With the Modelica
Real-Time Interface software, which was developed
by Arsenal Research an interconnection between the
simulation tool and I/O processes was realized. On
this system sampling times up to 400 microseconds
can be achieved depending on the complexity of the
simulation model and the number of input and output
channels. The I/O functionality of the HIL workstation is realized by data acquisition cards on which
can be connected the high-power energy storage test
bench and the high dynamic dynamometer. The energy storage test bench has a maximum charge
power of 48kW and a maximum discharge power of
44kW at a maximum voltage of 600V. With the
drive train test bed (dynamometer) can be tested
electric drives with a maximum power of 110kW and
up to a speed of 8000rpm. To connect Electronic
Control Units (ECU) to the HIL simulator there exists also a CAN interface to the simulation environment. In that way the simulation can for example
generate reference values which will be transmitted
by CAN to the testing system or for example the
simulation receives signals from the ECU and can
evaluate these signals.
Detailed information about the implemented hybrid
and electric vehicle models and especially about
their real-time capability will be given in the paper.
Also the connection between the Dymola simulation
tool and the I/O functionalities will be described.
Finally as an application example for the test facility
a HIL simulation of a real electric drive system
(electric drive, power electronics and battery) for a
two wheels vehicle will be shown.

375

Modelica 2008, March 3rd  4th , 2008

A. Ebner, M. Ganchev, H. Oberguggenberger, F. Pirker

Figure 1: System overview of a HIL configuration for testing the electric components of a hybrid electric
vehicle

2
2.1

System Overview
Real Time Computer

The main part of the proposed system is a 3.2 GHz
Dual CPU Workstation with a SUSE Linux Enterprise Real-Time (SLERT) operating system. On this
system operates a normal Dymola simulation environment for Linux on which can be implemented and
simulated Modelica models. The effort of this system
is that the simulation models can be executed in realtime directly from the simulation environment.
The proposed simulation computer with the SLERT
operating system guarantees short response times
and fast cycle times; such fast sampling time is for
example required for HIL simulations of drive trains.
A sampling frequency of over 2 kHz can be achieved
depending on the complexity of the simulation
model and the number of input and output channels.
The input and output functionality to the test benches
is provided by an analoge/digital data acquisition
card connected and for the digital communication
with Electronic Control Units (ECU) by an external
CAN interface.
2.2

bench on which is connected the testing drive and for
the energy storage test bench on which is for example connected a real battery. As feedback the simulation tool receives measured values from the real
components. In figure 1 is given a possible schematic overview of the HIL system for testing the
electric components for a hybrid or an electric vehicle. In this case the motor control unit (MCU), the
power electronics (inverter), the electric drive, the
battery management system (BMS) and the battery
stack are the systems under test. The behavior of the
vehicle for example the internal combusting engine,
the driving dynamics, the ambient conditions, the
drive cycle and the driver will be simulated on the
real-time simulation workstation.
Table 1: Technical data of drive-train test-bench
(dynamometer)
Peak Power
Peak Torque
Peak Speed
Control Modes
Ext. Data I/O Freq.

110 kW
500 Nm
8000 rpm
Torque or Speed
500 Hz

Testing Infrastructure

The simulation environment on the Linux computer
generates reference values for the drive train test
The Modelica Association

376

Modelica 2008, March 3rd  4th , 2008

Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC

Table 2: Technical data of electric energy storage
test-bench
Charge mode
Peak Voltage
Peak Current
Discharge mode
Peak Voltage
Peak Current
Control Modes

3

memory and the DAQ functions for analoge and
digital In- and Output.

480 V
100 A @ 480 V or
500 A @ 60 V
600 V
540 A @ 600 V or
750 A @ 60 V
Voltage, Current, Power,
Resistance

Modelica Real-Time Interface

The Modelica Real-Time Interface provides an interconnection between the Dymola simulation tool and
the input and output functionalities of the system.
The interface guarantees the synchronisation between the simulation time and the real time. Simulation time means the virtual time inside of the simulation time which will be matched with the time in the
real world by the Real-Time Interface. The interface
provides also the signal conditioning of the simulation variables to input and output values of the DAC
channels, in that way the test benches can be connected directly to the simulation workstation.

Figure 3: The two main processes for the real-time
simulation
For a running real-time simulation two main processes the so-called Dymosim process and the RTmod
process works together. The model and solver are
executed in the Dymosim process, this is the lefthanded process in figure 3 . The model can be build
with the RTInterface blocks for example for Trigger
functions and data I/O. Data I/O is implemented by a
Shred Memory and synchronized by semaphores. All
functionality in Modelica is implemented using external c-functions and Modelica standard blocks. The
RTmod process (right-handed process in figure 3) is
completely c-written it includes the Frequency Based
Scheduler synchronization the Data I/O over shared

The Modelica Association

Figure 2: Functional overview of the Modelica realtime interface

4
4.1

Application Examples
Hybrid Electric Vehicle HIL Simulation

A hardware-in-the-loop simulation of a HEV system
will be shown as an application example. The behavior of a Mild HEV is simulated on the Linux realtime computer on which is connected a real electric
drive with a peak power of 12 kW and the motor
control unit for this electric drive. The whole HEV is
modeled in Modelica using the SmartPowertrains
library and the SmartElectricDrives library. Based on
suited power requirements pointed out by a drive
cycle, the simulation model generates the reference
values for the testing drive, (e.g. a reference torque)
which are communicated to the Motor Control Unit
(MCU) via the CAN bus and the power inverter generates the electric signals for the drive. The measured
torque in the load cell of the test bench corresponds
to the torque of the power train, this feedback value
goes back the simulation model and new reference
values can be calculated.

377

Modelica 2008, March 3rd  4th , 2008

A. Ebner, M. Ganchev, H. Oberguggenberger, F. Pirker

5

Figure 4: HEV hardware-in-the-loop simulation

4.2

Electric Two-Wheeler HIL Simulation

The capabilities of electric two-wheelers are intensively investigated due to their high potential for improved urban mobility as well as tourist or sport application. Nevertheless existing products are in many
cases lacking of appropriate range or power to
achieve a broad (satisfactory) customer acceptance.
To evaluate the technological potential of electric
two-wheelers different e-scooter concepts have been
analyzed by simulation. Based on the simulation environment available at arsenal research an electric
scooter model was set up and simulations using different electric drive configurations have been performed. The results allow for determination of high
power scooter concepts. For validation and demonstration of a high power two-wheeler an e-scooter
prototype has been realized and tested. The simulation and test results in e.g. performance and range
will be given as well as the further improvement potential will be discussed.

Conclusion

In the provided paper is presented a HIL simulation
solution for development and for testing of components for HEV`s. The powerful hardware of the
simulation computer and the real-time operating system allows the simulation of complex models with a
fast data exchange with the real components which
are connected to test benches. With the described
Modelica Real-Time Interface it is possible to execute the HIL simulation direct from the Dymola
simulation tool with which was implemented the
model.
The benefit of this system is that a simulation engineer can for example validate an implemented model
directly, matching the simulation results with the
measured values at the connected real component. Or
in the advanced development an engineer can test a
developed component also when the entire system is
not available; the prototype of the system exists only
as a virtual model in the simulation.

References
[1]

[2]

[3]

[4]

[5]

Figure 5: Electric two-wheeler hardware-in-the-loop
simulation

[6]

The Modelica Association

378

Peter Fritzson, Principles of ObjectOriented Modeling and Simulation with
Modelica 2.1, IEEE Press, Piscataway, NJ,
2004
M. Otter, H. Elmqvist, Modelica  Language, Libraries, Tools, Workshop and EUProject RealSim, Simulation News Europe,
pp. 3-8, Dec. 2000
A. Ebner, A. Haumer, D. Simic, F. Pirker:
Interacting Modelica using a Named Pipe
for Hardware-in-the-loop Simulation, 5th
International Modelica Conference Proceedings Vol.1, pp. 261-266, Vienna, Austria,
2006.
A. Ebner, F. V. Conte, F. Pirker: Rapid
Validation of Battery Management System
with a Dymola Hardware-in-the-Loop Simulation Energy Storage Test Bench, 22nd International Battery, Hybrid and Fuel Cell
Electric Vehicle Symposium & Exposition;
pp. 1570-1574, Yokohama, Japan, 2006.
D. Simic, H. Giuliani, C. Kral, J. Gragger,
Simulation of Hybrid Electric Vehicles,
5th International Modelica Conference Proceedings Vol.1, pp. 25-32, Vienna, Austria,
2006.
J. Gragger, D. Simic, C. Kral, H. Giuliani, V.
Conte, F. Pirker, A Simulation Tool for

Modelica 2008, March 3rd  4th , 2008

Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC

[7]

Electric Auxiliary Drives in HEVs - the
Smart Electric Drives Library, FISITA
World Automotive Congress, Yokohama, Japan, 2006.
M. Noll, D. Simic, A. Ebner, Evaluation of
the Technological Potential of Electric TwoWheelers Based on a High-Power Electric
Scooter, EET-2007 European Ele-Drive
Conference, http://www.ele-drive.com, accessed on 2007-03-06

The Modelica Association

379

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

380

Modelica 2008, March 3rd  4th , 2008

2008
6

th

Proceedings of the
International Modelica Conference
March 3rd  4th , 2008
University of Applied Sciences Bielefeld,
Bielefeld, Germany

Bernhard Bachmann (editor)

Volume 2

organized by
The Modelica Association and
University of Applied Sciences Bielefeld
All papers of this conference can be downloaded from
http://www.Modelica.org/events/modelica2008/

Proceedings of Modelica 2008
University of Applied Sciences Bielefeld,
Bielefeld, Germany, March 2008
Editor:
Prof. Dr. B. Bachmann
Published by:
The Modelica Association (http://www.Modelica.org) and
University of Applied Sciences Bielefeld (http://www.fh-bielefeld.de)
Printed by:
Printmedien Elbracht

The Modelica Association

Modelica 2008, March 3rd  4th , 2008

Preface
The first International Modelica Conference took place in October 2000 in Lund, Sweden. Since
then, Modelica has increasingly become the preferred language tool for physical modelling of complex
systems. This is indicated by the high number of registrations from industry and science at the 6th
International Modelica Conference held between 3rd and 4th March 2008 at the University of Applied
Sciences, Bielefeld, Germany. It is also indicated by the number of excellent papers submitted to the
program committee which made the task of selecting papers for oral and poster presentation very
difficult and, last but not least, by the exhibition during the conference at which several companies
will be represented. This volume contains the papers of the 68 oral presentations and 14 poster
presentations at the conference. The ability of Modelica as a multi domain simulation language is
demonstrated impressively by the various fields the papers are covering.
Due to the special features of the Modelica language, such as object-oriented modelling and the
ability to reuse and exchange models, Modelica strongly supports an integrated engineering design
process. Thus in various fields Modelica has become the standard tool for model exchange between
suppliers and OEMs. A key issue for the success of Modelica is the continuous development of the
Modelica language as well as the Modelica Standard Library under strict observance of compatibility
to previous versions by the Modelica Association. The broad base of private and institutional members of the Modelica Association as a non-profit organization ensures language stability and security
in software investments.
The 6th International Modelica conference was organized by the Modelica Association and by the
University of Applied Sciences, Bielefeld, Germany. I would like to thank the local organizing committee, the technical program committee and the reviewers for offering their time and expertise throughout
the organization of the conference. Together with the entire team of the local organizing committee I
would like to wish all participants an excellent and fruitful conference.

Bielefeld, March 1st , 2008

Bernhard Bachmann

The Modelica Association

I

Modelica 2008, March 3rd  4th , 2008

Program Chair
 Prof. Bernhard Bachmann, University of Applied Sciences Bielefeld, Bielefeld, Germany

Program Board
 Prof. Martin Otter, DLR, Oberpfaffenhofen, Germany
 Prof. Peter Fritzson, Linkoping University, Sweden
 Dr. Hilding Elmqvist, Dynasim AB, Lund, Sweden
 Dr. Michael Tiller, Emmeskay Inc., Michigan, USA

Program Committee
 Prof. Karl-Erik Arzen, Lund University, Lund, Sweden
 Dr. John Batteh, Emmeskay Inc., Michigan, USA
 Dr. Ingrid Bausch-Gall, Bausch-Gall GmbH, Munich, Germany
 Daniel Bouskela, EDF, Paris, France
 Prof. Felix Breitenecker, University of Technology, Vienna, Austria
 Dr. Thomas Christ, BMW, Michigan, USA
 Prof. Francesco Casella, Politecnico di Milano, Milano, Italy
 Prof. Francois E. Cellier, ETH Zurich, Zurich, Switzerland
 Mike Dempsey, Claytex Services Limited, Leamington, U.K.
 Denis Fargeton, LMS Imagine, Roanne, France
 Dr. Rudiger Franke, ABB, Heidelberg, Germany
 Rui Gao, Dassault Systemes K.K., Nagoya, Japan
 Anton Haumer, Technical Consulting, Vienna, Austria
 Dr. Christian Kral, arsenal research, Vienna, Austria
 Gerard Lecina, Dassault Systemes, Paris, France
 Dirk Limperich, Daimler AG, Sindelfingen, Germany
 Kilian Link, Siemens AG, Erlangen, Germany
 Dr. Jakob Mauss, QTronic GmbH, Berlin, Germany
 Dr. Ramine Nikoukhah, INRIA, Rocquencourt, France
The Modelica Association

II

Modelica 2008, March 3rd  4th , 2008

 Franz Pirker, arsenal research, Vienna, Austria
 Prof. Gerhard Schmitz, Technical University Hamburg-Harburg, Germany
 Peter Schneider, Fraunhofer IIS/EAS, Dresden, Germany
 Dr. Edward D. Tate, General Motors, Michigan, USA
 Dr. Wilhelm Tegethoff, TLK-Thermo GmbH, Braunschweig, Germany
 Dr. Hubertus Tummescheit, Modelon AB, Lund, Sweden
 Dr. Andreas Uhlig, ITI GmbH, Dresden, Germany

Local Organizing Committee
 Prof. Bernhard Bachmann
 Dr. Elke Koppenrade
 Jens Schonbohm
 Ralf Derdau
 Eveni, Konferenz-Management-Software, www.eveni.com
 Bielefeld Marketing GmbH, www.bielefeld-marketing.de

The Modelica Association

III

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

IV

Modelica 2008, March 3rd  4th , 2008

Contents
Volume 1

1

Session 1a
Language, Tools and Algorithms

1

D. Broman, P. Aronsson, P. Fritzson: Design Considerations for Dimensional Inference
and Unit Consistency Checking in Modelica . . . . . . . . . . . . . . . . . . . . . . . .
S. E. Mattsson, H. Elmqvist: Unit Checking and Quantity Conservation . . . . . . . . .
H. Olsson, M. Otter, S. E. Mattsson, H. Elmqvist: Balanced Models in Modelica 3.0
for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 1b
Language, Tools and Algorithms
M. Najafi, R. Nikoukhah: Initialization of Modelica Models in Scicos . . . . . . . . .
D. Zimmer: Introducing Sol: A General Methodology for Equation-Based Modeling
Variable-Structure Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
J. Akesson : OptimicaAn Extension of Modelica Supporting Dynamic Optimization

. .
of
. .
. .

Session 1c
Automotive Applications
J. Batteh, C. Newman: Detailed Simulation of Turbocharged Engines with Modelica . .
H. Oberguggenberger, D. Simic: Thermal Modelling of an Automotive Nickel Metall
Hydrid Battery in Modelica using Dymola . . . . . . . . . . . . . . . . . . . . . . . . .
M. Corno, F. Casella, S. M. Savaresi, R. Scattolini: Object Oriented Modeling of a
Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 1d
Electric Systems & Applications

3
13
21

35
37
47
57

67
69
77
83

93

M. Kuhn, M. Otter, L. Raulin: A Multi Level Approach for Aircraft Electrical Systems
Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
C. Schallert : Incorporation of Reliability Analysis Methods with Modelica . . . . . . . . 103
F. Wagner, L. Liu, G. Frey: Simulation of Distributed Automation Systems in Modelica 113

Session 2a
Language, Tools and Algorithms

123

A. Jardin, W. Marquis-Favre, D. Thomasset, F. Guillemard, F. Lorenz: Study of
a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1 125
T. Johnson, C. Paredis, R. Burkhart: Integrating Models and Simualtions of Continuous
Dynamics into SysML . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 135
The Modelica Association

V

Modelica 2008, March 3rd  4th , 2008

Contents
A. Leva, F. Donida, M. Bonvini, L. Ravelli: Modelica Library for Logic Control
Systems written in the FBD Language . . . . . . . . . . . . . . . . . . . . . . . . . . . 147

Session 2b
Thermodynamic Systems & Applications

155

F. Casella, C. Richter : ExternalMedia: A Library for Easy Re-Use of External Fluid
Property Code in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
F. Cellier, J. Greifeneder: ThermoBondLib - A New Modelica Library for Modeling
Convective Flows . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 163
T. Vahlenkamp, S. Wischhusen: FluidDissipation - A Centralised Library for Modelling
of Heat Transfer and Pressure Loss . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 173

Session 2c
Mechanical Systems & Applications

179

G. Verzichelli : Development of an Aircraft and Landing Gears Model with Steering System
in Modelica-Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
G. Looye : The New DLR Flight Dynamics Library . . . . . . . . . . . . . . . . . . . . . . 193
I. Kosenko, E. Alexandrov: Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203

Session 2d
Electric Systems & Applications

213
D. Winkler, C. Guhmann: Modelling of Electric Drives using freeFOClib . . . . . . . . 215
T. Bodrich : Electromagnetic Actuator Modelling with the Extended Modelica Magnetic
Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 221
A. Haumer, C. Kral, J. V. Gragger, H. Kapeller: Quasi-Stationary Modeling and
Simulation of Electrical Circuits using Complex Phasors . . . . . . . . . . . . . . . . . 229

Session 3a
Language, Tools and Algorithms

237
T. Pulecchi, F. Casella: HyAuLib: Modelling Hybrid Automata in Modelica . . . . . . . 239
G. Fish, M. Dempsey : Application of Neural Networks to model Catamaran Type
Powerboats . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 247
M. Malmheden, H. Elmqvist, S. E. Mattsson, D. Henriksson, M. Otter: ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . 255
U. Donath, J. Haufe, T. Blochwitz, T. Neidhold: A new Approach for Modeling and
Verification of Discrete Control Components within a Modelica Environment . . . . . 269

Session 3b
Thermodynamic Systems & Applications

277

R. Franke, B.S. Babij, M. Antoine, A. Isaksson: Model-Based Online Applications in
the ABB Dynamic Optimization Framework . . . . . . . . . . . . . . . . . . . . . . . .
J. I. Videla, B. Lie: Using Modelica/Matlab for Parameter Estimation in a Bioethanol
Fermentation Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
L. Imsland, P. Kittilsen, T. Steinar Schei: Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
F. Casella, F. Donida, B. Bachmann, P. Aronsson: Overdetermined Steady-State
Initialization Problems in Object-Oriented Fluid System Models . . . . . . . . . . . .
The Modelica Association

VI

279
287
301
311

Modelica 2008, March 3rd  4th , 2008

Contents

Session 3c
Automotive Applications

319

W. Chen, G. Qin, L. Li, Y. Zhang, L. Chen: Modelling of Conventional Vehicle in
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
J. Andreasson, M. Jonasson: Vehicle Model for Limit Handling: Implementation and
Validation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H. Isernhagen, C. Guhmann: Modelling of a Double Clutch Transmission with an Appropriate Controller for the Simulation of Shifting Processes . . . . . . . . . . . . . . .
A. Junghanns, J. Mauss, M. Tatar: TestWeaver - A Tool for Simulation-Based Test of
Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 3d
Electric Systems & Applications

321
327
333
341

349

C. Kral, A. Haumer: Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the ExtendedMachines Library . . . . . . . . . . . . . . . . . . . .
H. Kapeller, A. Haumer, C. Kral, G. Pascoli, F. Pirker: Modeling and Simulation
of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
H. Giuliani, C. J. Fenz, A. Haumer, H. Kapeller: Simulation and Validation of Power
Losses in the Buck-Converter Model included in the SmartElectricDrives Library . . .
A. Ebner, M. Ganchev, H. Oberguggenberger, F. Pirker: Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . . .

Volume 2

351
361
369
375

381

Session 4a
Language, Tools and Algorithms

381
A. Abel, T. Nahring: Frequency-Domain Analysis Methods for Modelica Models . . . . . 383
F. Cellier : World3 in Modelica: Creating System Dynamics Models in the Modelica Framework . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 393
F. Donida, A. Leva: Modelica as a Host Language for Process/Control Co-Simulation and
Co-Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 401
A. Pop, K. Stavaker, P. Fritzson: Exception Handling for Modelica . . . . . . . . . . . 409

Session 4b
Thermodynamic Systems & Applications

419

J. Fahlke, S. Puschel, F. Hannemann, B. Meyer: Modelling of the Gasification Island
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
M. Bockholt, W. Tegethoff, N. Lemke, N.-C. Strupp, C. Richter: Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration Cycles . . . .
C. Junior, C. Richter, W. Tegethoff, N. Lemke, J. Kohler: Modeling and Simulation
of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
P. Li, Y. Li, J. Seem: Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

Session 4c
Automotive Applications
The Modelica Association

421
429

437
447

465
VII

Modelica 2008, March 3rd  4th , 2008

Contents
M. Najafi, Z. Benjelloun-Dabaghi: Using Modelica for Modeling and Simulation of
Spark Ignited Engine and Drilling Station in IFP . . . . . . . . . . . . . . . . . . . . . 467
S. Karim, H. Tummescheit: Controller Development for an Automotive Ac-system using
R744 as Refrigerant . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 477
H. Wigermo, J. von Grundherr, T. Christ: Implementation of a Modelica Online
Optimization for an Operating Strategy of a Hybrid Powertrain . . . . . . . . . . . . . 487
E. Tate, M. Sasena, J. Gohl, M. Tiller: Model Embedded Control: A Method to
Rapidly Synthesize Controllers in a Modeling Environment . . . . . . . . . . . . . . . 493

Session 4d
Mechanical Systems & Applications

503

F. Casella, M. Lovera: High-Accuracy Orbital Dynamics Simulation through Keplerian
and Equinoctial Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 505
J. Andreasson, M. Gafvert: Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 515
S. Wolf, J. Haase, C. Clau, M. Jockel, J. Losch: Methods of Sensitivity Calculation
Applied to a Multi-Axial Test Rig for Elastomer Bushings . . . . . . . . . . . . . . . . 521
M. Pfennig, F. Thielecke: Implementation of a Modelica Library for Simulation of HighLift Drive Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 531

Session 5
Poster Session

541

T. Hirsch, M. Eck: 4-Dimensional Table Interpolation with Modelica . . . . . . . . . . . 543
M. Hobinger, M. Otter : PlanarMultiBody - A Modelica Library for Planar Multi-Body
Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 549
D. Simic, T. Bauml: Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the SmartElectricDrives Libraries . . . . . . . . . . . . . . . . . . . . . . . . 557
P. Machanick, A. Liebman, P. Fritzson: Modeling of CO2 Reduction Impacts on Energy
Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 565
M. Schicktanz : Modelling of an Adsorption Chiller with Modelica . . . . . . . . . . . . . 573
T. Blochwitz, G. Kurzbach, T. Neidhold : An External Model Interface for Modelica

579

B. El Hefni, B. Bride, B. Pechine: Two Steady State CHP Models with Modelica :
Mirafiori overall Model and Multi-configuration Biomass Model . . . . . . . . . . . . . 585
J. V. Gragger, A. Haumer, C. Kral, F. Pirker: Efficient Analysis of Harmonic Losses
in PWM Voltage Source Induction Machine Drives with Modelica . . . . . . . . . . . . 593
J. Haase, S. Wolf, C. Clau: Monte Carlo Simulation with Modelica . . . . . . . . . . . 601
O. Enge-Rosenblatt, C. Clau, P. Schwarz, F. Breitenecker, C. Nytsch-Geusen:
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . 605
O. Enge-Rosenblatt, P. Schneider: Modelica Wind Turbine Models with Structural
Changes Related to Different Operating Modes . . . . . . . . . . . . . . . . . . . . . . 611
K. Tuszynski : ExcelInterface - A Tool for Interfacing Dymola through Excel . . . . . . . 621
K. Dietl, J. Vasel, G. Schmitz, W. Casas, C. Mehrkens: Modeling of Cold Plates for
Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
N. Philipson, J. Andreasson, M. Gafvert, A. Woodruff: Heavy Vehicle Modeling
with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
The Modelica Association

VIII

Modelica 2008, March 3rd  4th , 2008

Contents

Session 6a
Language, Tools and Algorithms

635
K. Stavaker, A. Pop, P. Fritzson: Compiling and Using Pattern Matching in Modelica 637
M. Tiller : Patterns and Anti-Patterns in Modelica . . . . . . . . . . . . . . . . . . . . . . 647
P. Fritzson, A. Pop, K. Norling, M. Blom: Comment- and Indentation Preserving
Refactoring and Unparsing for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . 657

Session 6b
Language, Tools and Algorithms

667
A. Elsheikh, S. Noack, W. Wiechert: Sensitivity Analysis of Modelica Applications via
Automatic Differentiation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 669
R. Nikoukhah, S. Furic : Synchronous and Asynchronous Events in Modelica: Proposal
for an Improved Hybrid Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
F. Dshabarow, F. Cellier, D. Zimmer: Support for Dymola in the Modeling and Simulation of Physical Systems with Distributed Parameters . . . . . . . . . . . . . . . . . 683

Session 6c
Thermodynamic Systems & Applications

691

H. Tummescheit, K. Tuszynski, P. Arnold: Simulation of Peak Stresses and Bowing
Phenomena during the Cool Down of a Cryogenic Transfer System . . . . . . . . . . . 693
A. Joos, G. Schmitz, W. Casas: Enhancement of a Modelica Model of a Desiccant Wheel701
M. Gafvert, T. Skoglund, H. Tummescheit, J. Windahl, H. Wikander, P. Reutersward:
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . 709

Session 6d
Mechanical Systems & Applications

717

T. Juhasz, U. Schmucker: Automatic Model Conversion to Modelica for Dymola-based
Mechatronic Simulation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 719
I. I. Kosenko, A. S. Kuleshov : Modelica Implementation of the Skateboard Dynamics 727
T. Hoeft, C. Nytsch-Geusen: Design and Validation of an Annotation-Concept for the
Representation of 3D-Geometries in Modelica . . . . . . . . . . . . . . . . . . . . . . . 735

The Modelica Association

IX

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

X

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Akesson, Johan: Lund University, Lund, Sweden
OptimicaAn Extension of Modelica Supporting Dynamic Optimization . . . . . . . . . . . . . . . . . . . . . 57
Abel, Andreas: ITI GmbH, Dresden, Germany
Frequency-Domain Analysis Methods for Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
Alexandrov, Evgeniy: Moscow State University of Tourism and Service, Moscow, Russian Federation
Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica . . . 203
Andreasson, Johan: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics . . . . . . . . . . . . . . . . . . . 515
Vehicle Model for Limit Handling: Implementation and Validation . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Antoine, Marc: ABB Power Technology Systems, Mannheim, Germany
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Arnold, Philip: Linde Kryotechik AG, Pfungen, Switzerland
Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic
Transfer System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
Aronsson, Peter: Mathcore Engeneering, Linkoping, Sweden
Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica . . 3
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Bauml, Thomas: Arsenal Research, Vienna, Austria
Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the
SmartElectricDrives Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
Bodrich, Thomas: Dresden University of Technology, Dresden, Germany
Electromagnetic Actuator Modelling with the Extended Modelica Magnetic Library . . . . . . . . . 221
Babji B.S.: ABB Corporate Research, Bangalore, India
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Bachmann, Bernhard: Bielefeld University of Applied Sciences, Bielefeld, Germany
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Batteh, John: Ford Motor Company, Dearborn, U.S.A.
Detailed Simulation of Turbocharged Engines with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Benjelloun-Dabaghi, Zakia: INRIA, Rocquencourt, France
Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station
in IFP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Blochwitz, Torsten: ITI GmbH, Dresden, Germany
The Modelica Association

XI

Modelica 2008, March 3rd  4th , 2008

Index of Authors
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
An External Model Interface for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Blom, Mikael: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Bockholt, Marcos: Braunschweig University of Technology, Braunschweig, Germany
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Bonvini, Marco: Politecnico di Milano, Milano, Italy
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Breitenecker, Felix: Vienna University of Technology, Vienna, Austria
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Bride, Benot: EDF R&D, Chatou, France
Two Steady State CHP Models with Modelica: Mirafiori overall Model and
Multi-configuration Biomass Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
Broman, David: Linkoping University, Linkoping, Sweden
Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica . . 3
Burghart, Roger: Hamburg University of Technology, Hamburg, Germany
Integrating Models and Simualtions of Continuous Dynamics into SysML . . . . . . . . . . . . . . . . . . . 135
Casas, Wilson: Hamburg University of Technology, Hamburg, Germany
Enhancement of a Modelica Model of a Desiccant Wheel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
Casas, Wilson: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Casella, Francesco: Politecnico di Milano, Milano, Italy
ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica. . . .157
High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters 505
HyAuLib: Modelling Hybrid Automata in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Cellier, Francois: ETH Zurich, Zurich, Switzerland
Support for Dymola in the Modeling and Simulation of Physical Systems with
Distributed Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 683
ThermoBondLib - A New Modelica Library for Modeling Convective Flows . . . . . . . . . . . . . . . . . 163
World3 in Modelica: Creating System Dynamics Models in the Modelica Framework . . . . . . . . 393
Chen, Liping: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Chen, Wei: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Christ, Thomas: BMW Hybrid Cooperation, Troy, U.S.A.
Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid
Powertrain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
Clau, Christoph: Fraunhofer Institut, Dresden, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
The Modelica Association

XII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Monte Carlo Simulation with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601
Corno, Matteo: Politecnico di Milano, Milano, Italy
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Dempsey, Mike: Claytex Services Ltd, Leamington Spa, United Kingdom
Application of Neural Networks to model Catamaran Type Powerboats . . . . . . . . . . . . . . . . . . . . . 247
Dietl, Karin: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Donath, Ulrich: Fraunhofer Institut, Dresden, Germany
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
Donida, Filippo: Politecnico di Milano, Milano, Italy
Modelica as a Host Language for Process/Control Co-Simulation and Co-Design . . . . . . . . . . . . 401
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Overdetermined Steady-State Initialization Problems in Object-Oriented Fluid System
Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 311
Dshabarow, Farid: ABB Turbo Systems AG, Baden, Switzerland
Support for Dymola in the Modeling and Simulation of Physical Systems with
Distributed Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 683
Ebner, Arno: Arsenal Research, Vienna, Austria
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Eck, Markus: German Aerospace Center, Oberpfaffenhofen, Germany
4-Dimensional Table Interpolation with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
El Hefni, Baligh: EDF R&D, Chatou, France
Two Steady State CHP Models with Modelica: Mirafiori overall Model and
Multi-configuration Biomass Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
Elmqvist, Hilding: Dynasim AB, Lund, Sweden
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Unit Checking and Quantity Conservation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Elsheikh, Atya: Siegen University, Siegen, Germany
Sensitivity Analysis of Modelica Applications via Automatic Differentiation . . . . . . . . . . . . . . . . . 669
Enge-Rosenblatt, Olaf: Fraunhofer Institut, Dresden, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Modelica Wind Turbine Models with Structural Changes Related to Different Operating
Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611
Fahlke, Julia: Freiberg University of Technology, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Fenz, Claus J. : Arsenal Research, Vienna, Austria
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Fish, Garron: Claytex Services Ltd, Leamington Spa, United Kingdom
Application of Neural Networks to model Catamaran Type Powerboats . . . . . . . . . . . . . . . . . . . . . 247
Franke, Ruediger: ABB Power Technology Systems, Mannheim, Germany
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Frey, Georg: Kaiserslautern University of Technology, Kaiserslautern, Germany
The Modelica Association

XIII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Simulation of Distributed Automation Systems in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Fritzson, Peter: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Compiling and Using Pattern Matching in Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .637
Design Considerations for Dimensional Inference and Unit Consistency Checking in Modelica . . 3
Exception Handling for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Modeling of CO2 Reduction Impacts on Energy Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . 565
Furic, Sebastien: LMS-Imagine, Roanne, France
Synchronous and Asynchronous Events in Modelica: Proposal for an Improved Hybrid
Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
Gafvert, Magnus: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics . . . . . . . . . . . . . . . . . . . 515
Guhmann, Clemens: Technische Universitat Berlin, Berlin, Germany
Modelling of a Double Clutch Transmission with an Appropriate Controller for the
Simulation of Shifting Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
Modelling of Electric Drives using freeFOClib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Ganchev, Martin: Arsenal Research, Vienna, Austria
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Giuliani, Harald: Arsenal Research, Vienna, Austria
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Gohl, Jesse: Emmeskay, Inc., Plymouth, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Gragger, Johannes V.: Arsenal Research, Vienna, Austria
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Greifeneder, Jurgen: Kaiserslautern University of Technology, Kaiserslautern, Germany
ThermoBondLib - A New Modelica Library for Modeling Convective Flows . . . . . . . . . . . . . . . . . 163
Guillemard, Franck: PSA Peugeot Citroen, Velizy-Villacoublay Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Hobinger, Mathias: Vienna University of Technology, Vienna, Austria
PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems . . . . . . . . . . . . . . . . . . . . . 549
Haase, Joachim: Fraunhofer Institut, Dresden, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Monte Carlo Simulation with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601
Hannemann, Frank: Siemens Fuel Gasification Technologie, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Haufe, Jurgen: Fraunhofer Institut, Dresden, Germany
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
Haumer, Anton: Arsenal Research, Vienna, Austria
The Modelica Association

XIV

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the
ExtendedMachines Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Henriksson, Dan: Dynasim AB, Lund, Sweden
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Hirsch, Tobias: German Aerospace Center, Oberpfaffenhofen, Germany
4-Dimensional Table Interpolation with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 543
Hoeft, Thomas: Fraunhofer Institut, Berlin, Germany
Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 735
Imsland, Lars: Cybernetica AS, Trondheim, Norway
Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . 301
Isaksson, Alf: ABB Corporate Research, Bangalore, India
Model-Based Online Applications in the ABB Dynamic Optimization Framework . . . . . . . . . . . 279
Isernhagen, Henrik: Technische Universitat Berlin, Berlin, Germany
Modelling of a Double Clutch Transmission with an Appropriate Controller for the
Simulation of Shifting Processes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 333
Jockel, Michael: Fraunhofer Institut, Darmstadt, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Jardin, Audrey: INSA-Lyon AMPERE, Villeurbanne Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Johnson, Thomas: Georgia Institute of Technology, Atlanta, U.S.A.
Integrating Models and Simualtions of Continuous Dynamics into SysML . . . . . . . . . . . . . . . . . . . 135
Jonasson, Mats: Volvo Car Corporation, Goteborg, Sweden
Vehicle Model for Limit Handling: Implementation and Validation . . . . . . . . . . . . . . . . . . . . . . . . . . 327
Joos, Andreas: Hamburg University of Technology, Hamburg, Germany
Enhancement of a Modelica Model of a Desiccant Wheel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
Juhasz, Tamas: Fraunhofer Institut, Magdeburg, Germany
Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation . . . . . . . . 719
Junghanns, Andreas: QTronic GmbH, Berlin, Germany
TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . 341
Junior, Christine: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Kohler, Jurgen: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Kapeller, Hansjorg: Arsenal Research, Vienna, Austria
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
The Modelica Association

XV

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Simulation and Validation of Power Losses in the Buck-Converter Model included in the
SmartElectricDrives Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 369
Karim, Sanaz: Modelon AB, Lund, Sweden
Controller Development for an Automotive Ac-system using R744 as Refrigerant . . . . . . . . . . . . 477
Kittilsen, Pal: Cybernetica AS, Trondheim, Norway
Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . 301
Kosenko, Ivan I.: Moscow State University of Tourism and Service, Moscow, Russian Federation
Implementation of the Hertz Contact Model and Its Volumetric Modification on Modelica . . . 203
Modelica Implementation of the Skateboard Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727
Kral, Christian: Arsenal Research, Vienna, Austria
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Quasi-Stationary Modeling and Simulation of Electrical Circuits using Complex Phasors . . . . 229
Simulation of Electrical Rotor Asymmetries in Squirrel Cage Induction Machines with the
ExtendedMachines Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 351
Kuhn, Martin: German Aerospace Center, Oberpfaffenhofen, Germany
A Multi Level Approach for Aircraft Electrical Systems Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Kuleshov, Alexander S.: Lomonosov Moscow State University, Moscow, Russian Federation
Modelica Implementation of the Skateboard Dynamics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 727
Kurzbach, Gerd: ITI GmbH, Dresden, Germany
An External Model Interface for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Losch, Jurgen: Fraunhofer Institut, Darmstadt, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Lemke, Nicholas: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Lemke, Nicholas: TLK-Thermo GmbH, Braunschweig, Germany
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Leva, Alberto: Politecnico di Milano, Milano, Italy
Modelica as a Host Language for Process/Control Co-Simulation and Co-Design . . . . . . . . . . . . 401
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Li, Lingyang: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Li, Pengfei: University of Wisconsin, Milwaukee, U.S.A.
Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . 447
Li, Yaoyu: University of Wisconsin, Milwaukee, U.S.A.
Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . 447
Lie, Bernt: Telemark University College, Porsgrunn, Norway
Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model . . . . . 287
Liebman, Ariel: University of Queensland, Brisbane, Australia
Modeling of CO2 Reduction Impacts on Energy Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . 565
Liu, Liu: Kaiserslautern University of Technology, Kaiserslautern, Germany
The Modelica Association

XVI

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Simulation of Distributed Automation Systems in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Looye, Gertjan: German Aerospace Center, Oberpfaffenhofen, Germany
The New DLR Flight Dynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193
Lorenz, Francis: LorSim, Liege, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Lovera, Marco: Politecnico di Milano, Milano, Italy
High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters 505
Machanick, Philip: University of Queensland, Brisbane, Australia
Modeling of CO2 Reduction Impacts on Energy Prices with Modelica . . . . . . . . . . . . . . . . . . . . . . . 565
Malmheden, Martin: Dynasim AB, Lund, Sweden
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Marquis-Favre, Wilfrid: INSA-Lyon AMPERE, Villeurbanne Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Mattsson, Sven Erik: Dynasim AB, Lund, Sweden
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
Unit Checking and Quantity Conservation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
Mauss, Jakob: QTronic GmbH, Berlin, Germany
TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . 341
Mehrkens, Christian: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Meyer, Bernd: Freiberg University of Technology, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Nahring, Tobias: ITI GmbH, Dresden, Germany
Frequency-Domain Analysis Methods for Modelica Models . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 383
Najafi, Masoud: INRIA, Rocquencourt, France
Initialization of Modelica Models in Scicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station
in IFP . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 467
Neidhold, Thomas: ITI GmbH, Dresden, Germany
A new Approach for Modeling and Verification of Discrete Control Components within
a Modelica Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
An External Model Interface for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 579
Newman, Charles: Ford Motor Company, Dearborn, U.S.A.
Detailed Simulation of Turbocharged Engines with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 69
Nikoukhah, Ramine: INRIA, Rocquencourt, France
Initialization of Modelica Models in Scicos . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
Synchronous and Asynchronous Events in Modelica: Proposal for an Improved Hybrid
Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 677
Noack, Stephan: Research Center Julich GmbH, Julich, Germany
Sensitivity Analysis of Modelica Applications via Automatic Differentiation . . . . . . . . . . . . . . . . . 669
Norling, Kristoffer: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Nytsch-Geusen, Christoph: Fraunhofer Institut, Berlin, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
The Modelica Association

XVII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in
Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 735
Oberguggenberger, Helmut: Arsenal Research, Vienna, Austria
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Thermal Modelling of an Automotive Nickel Metall Hydrid Battery in Modelica using
Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Olsson, Hans: Dynasim AB, Lund, Sweden
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
Otter, Martin: German Aerospace Center, Oberpfaffenhofen, Germany
A Multi Level Approach for Aircraft Electrical Systems Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Balanced Models in Modelica 3.0 for Increased Model Quality . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 21
ModeGraph - A Modelica Library for Embedded Control Based on Mode-Automata . . . . . . . . . 255
PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems . . . . . . . . . . . . . . . . . . . . . 549
Puschel, Stephan: Freiberg University of Technology, Freiberg, Germany
Modelling of the Gasification Island with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 421
Paredis, Chris: Georgia Institute of Technology, Atlanta, U.S.A.
Integrating Models and Simualtions of Continuous Dynamics into SysML . . . . . . . . . . . . . . . . . . . 135
Pascoli, Gert: Arsenal Research, Vienna, Austria
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Pechine, Bruno: EDF R&D, Chatou, France
Two Steady State CHP Models with Modelica: Mirafiori overall Model and
Multi-configuration Biomass Model . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585
Pfennig, Malte: Hamburg University of Technology, Hamburg, Germany
Implementation of a Modelica Library for Simulation of High-Lift Drive Systems . . . . . . . . . . . . 531
Philipson, Niklas: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Pirker, Franz: Arsenal Research, Vienna, Austria
Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives
with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 593
Modeling and Simulation of a Large Chipper Drive . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 361
Real-Time Modelica Simulation on a Suse Linux Enterprise Real Time PC . . . . . . . . . . . . . . . . . . 375
Pop, Adrian: Linkoping University, Linkoping, Sweden
Comment- and Indentation Preserving Refactoring and Unparsing for Modelica . . . . . . . . . . . . . 657
Compiling and Using Pattern Matching in Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .637
Exception Handling for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Pulecchi, Tiziano: Politecnico di Milano, Milano, Italy
HyAuLib: Modelling Hybrid Automata in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 239
Qin, Gang: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Raulin, Loic: Airbus, Toulouse, France
A Multi Level Approach for Aircraft Electrical Systems Design . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 95
Ravelli, Lorenzo: Politecnico di Milano, Milano, Italy
Modelica Library for Logic Control Systems written in the FBD Language . . . . . . . . . . . . . . . . . . 147
Reutersward, Philip: Modelon AB, Lund, Sweden
The Modelica Association

XVIII

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Richter, Christoph: Braunschweig University of Technology, Braunschweig, Germany
ExternalMedia: A Library for Easy Re-Use of External Fluid Property Code in Modelica. . . .157
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Sasena, Michael: Emmeskay, Inc., Plymouth, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Savaresi, Sergio M.: Politecnico di Milano, Milano, Italy
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Scattolini, Riccardo: Politecnico di Milano, Milano, Italy
Object Oriented Modeling of a Gasoline Direct Injection System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
Schallert, Christian: German Aerospace Center, Oberpfaffenhofen, Germany
Incorporation of Reliability Analysis Methods with Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 103
Schei, Tor Steinar: Cybernetica AS, Trondheim, Norway
Model-Based Optimizing Control and Estimation using Modelica Models . . . . . . . . . . . . . . . . . . . . 301
Schicktanz, Matthias: Fraunhofer Institut, Freiburg, Germany
Modelling of an Adsorption Chiller with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .573
Schmitz, Gerhard: Hamburg University of Technology, Hamburg, Germany
Enhancement of a Modelica Model of a Desiccant Wheel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 701
Schmitz, Gerhard: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Schmucker, Ulrich: Fraunhofer Institut, Magdeburg, Germany
Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation . . . . . . . . 719
Schneider, Peter: Fraunhofer Institut, Dresden, Germany
Modelica Wind Turbine Models with Structural Changes Related to Different Operating
Modes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 611
Schwarz, Peter: Fraunhofer Institut, Dresden, Germany
Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks . . . . . . . . . . . . . . . 605
Seem, John: Building Efficiency Research Group, Milwaukee, U.S.A.
Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers . . . . . . . . . . . . . . . . . . . . 447
Simic, Dragan: Arsenal Research, Vienna, Austria
Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the
SmartElectricDrives Libraries . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 557
Thermal Modelling of an Automotive Nickel Metall Hydrid Battery in Modelica using
Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
Skoglund, Tomas: Tetra Pak Procesing Systems, Lund, Sweden
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Stavaker, Kristian: Linkoping University, Linkoping, Sweden
Compiling and Using Pattern Matching in Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .637
Exception Handling for Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 409
Strupp, Nils-Christian: Braunschweig University of Technology, Braunschweig, Germany
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
The Modelica Association

XIX

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Tatar, Mugur: QTronic GmbH, Berlin, Germany
TestWeaver - A Tool for Simulation-Based Test of Mechatronic Designs . . . . . . . . . . . . . . . . . . . . . 341
Tate, Edward: General Motors, Michigan, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Tegethoff, Wilhelm: Braunschweig University of Technology, Braunschweig, Germany
Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 437
Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration
Cycles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 429
Thielecke, Frank: Hamburg University of Technology, Hamburg, Germany
Implementation of a Modelica Library for Simulation of High-Lift Drive Systems . . . . . . . . . . . . 531
Thomasset, Daniel: INSA-Lyon AMPERE, Villeurbanne Cedex, France
Study of a Sizing Methodology and a Modelica Code Generator for the Bond Graph Tool MS1125
Tiller, Michael: Emmeskay, Inc., Plymouth, U.S.A.
Model Embedded Control: A Methode to Rapidly Synthesize Controllers in a Modeling
Environment . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 493
Patterns and Anti-Patterns in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 647
Tummescheit, Hubertus: Modelon AB, Lund, Sweden
Controller Development for an Automotive Ac-system using R744 as Refrigerant . . . . . . . . . . . . 477
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic
Transfer System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
Tuszynski, Kristian: Modelon AB, Lund, Sweden
ExcelInterface - A Tool for Interfacing Dymola through Excel . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 621
Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic
Transfer System . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 693
Vahlenkamp, Thorben: XRG Simulation GmbH, Hamburg, Germany
FluidDissipation - A Centralised Library for Modelling of Heat Transfer and Pressure Loss . . 173
Vasel, Jens: Hamburg-Harburg University of Technology, Hamburg, Germany
Modeling of Cold Plates for Power Electronic Cooling . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 627
Verzichelli, Gianluca: Airbus, Filton, United Kingdom
Development of an Aircraft and Landing Gears Model with Steering System in
Modelica-Dymola . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 181
Videla, Juan Ignacio: Telemark University College, Porsgrunn, Norway
Using Modelica/Matlab for Parameter Estimation in a Bioethanol Fermentation Model . . . . . 287
von Grundherr, Johannes: BMW Group, Munic, Germany
Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid
Powertrain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
Wagner, Florian: Kaiserslautern University of Technology, Kaiserslautern, Germany
Simulation of Distributed Automation Systems in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 113
Wiechert, Wolfgang: Siegen University, Siegen, Germany
Sensitivity Analysis of Modelica Applications via Automatic Differentiation . . . . . . . . . . . . . . . . . 669
Wigermo, Henrik: BMW Group, Munic, Germany
Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid
Powertrain . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 487
The Modelica Association

XX

Modelica 2008, March 3rd  4th , 2008

Index of Authors
Wikander, Hans: Avensia Innovation AB, Lund, Sweden
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Windahl, Johan: Modelon AB, Lund, Sweden
Real-Time HWIL Simulation of Liquid Food Process Lines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 709
Winkler, Dietmar: Technische Universitat Berlin, Berlin, Germany
Modelling of Electric Drives using freeFOClib . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 215
Wischhusen, Stefan: XRG Simulation GmbH, Hamburg, Germany
FluidDissipation - A Centralised Library for Modelling of Heat Transfer and Pressure Loss . . 173
Wolf, Susann: Fraunhofer Institut, Dresden, Germany
Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer
Bushings . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 521
Monte Carlo Simulation with Modelica. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .601
Woodruff, Andrew: Modelon AB, Lund, Sweden
Heavy Vehicle Modeling with VehicleDynamics Library . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 629
Zhang, Yunqing: Huazhong University of Science and Technology, Wuhan, China
Modelling of Conventional Vehicle in Modelica . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 321
Zimmer, Dirk: ETH Zurich, Zurich, Switzerland
Introducing Sol: A General Methodology for Equation-Based Modeling of
Variable-Structure Systems . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 47
Support for Dymola in the Modeling and Simulation of Physical Systems with
Distributed Parameters . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 683

The Modelica Association

XXI

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

XXII

Modelica 2008, March 3rd  4th , 2008

Session 4a
Language, Tools and Algorithms

The Modelica Association

381

Modelica 2008, March 3-4, 2008

The Modelica Association

382

Modelica 2008, March 3rd  4th , 2008

Frequency-Domain Analysis Methods for Modelica Models

Frequency-Domain Analysis Methods for Modelica Models
Andreas Abel

Tobias Nhring

ITI GmbH
Webergasse 1
01067 Dresden, Germany
{andreas.abel,tobias.naehring}@iti.de

Abstract
In addition to time-domain simulation methods, engineers from different application fields require further types of analysis to be performed on their systems. In particular results from frequency domain
analysis play an important role  this includes the
calculation of natural frequencies and vibration
modes, but also the computation of transfer functions
or the simulation of steady-state behaviour.
If the system equations are formulated using the
Modelica language, there is the potential to use one
and the same model for time-domain as well as frequency-domain computations.
In this paper we will show, how the different methods can be applied to a Modelica model, what kind
of prerequisites and adjustments are required in order
to perform the different types of analysis and how
these methods can be seamlessly integrated into a
Modelica simulation environment.
Keywords: Modelica, Steady State Simulation,
Transfer Function Analysis, Natural Frequency
Analysis

1

Introduction

2

In many engineering disciplines frequency-domain
methods play an important role. Powertrain engineers for instance not only exploit transient simulations, but to a large extend assess the behaviour of
their systems based on the natural frequencies, the
resulting vibration models, and also in terms of
steady state results, which show vibrations under
stationary conditions resulting from the uneven and
multi-order excitation of the driveline by the engine.
Other engineering domains and tasks also require
frequency-domain approaches.

The Modelica Association

However, all these tasks would typically be assigned
to different software tools, which is not really necessary.
Modelica forms the ideal base also for frequencydomain analyses, since it provides complete system
descriptions in an analytic form. However, so far
Modelica is used almost exclusively for transient
time-domain simulation.
In this paper we will show, how Modelica models
are used in order to compute frequency-domain results and how these processes are integrated into the
Modelica simulation environment SimulationX.
The paper will treat the following topics:
 Nonlinear periodic steady-state simulation
and generation of spectral results based on
harmonic balance
 Natural frequencies, vibration modes and
energy distributions based on models linearized in an operating point
 Computation of transfer functions based on
models linearized in an operating point
We focus on the periodic steady-state simulation
since this is the most recent innovation in
SimulationX.

2.1

Periodic Steady-State Simulation
Application to Modelica Models

The main area of application for the nonlinear periodic steady-state simulation in SimulationX is the
vibration analysis of powertrains.
The example Modelica model in Fig. 1 is an adaption
from [4] p. 246 with some added damping and cylinders including oscillating masses and driven by some
typical combustion engine cylinder pressure.

383

Modelica 2008, March 3rd  4th , 2008

A. Abel, T. Nahring

The steady-state for a range of mean rotational
speeds of the engine has to be computed. The oscillation time period is determined by the engine speed
and the periodicity of the excitation over the crank
angle.
Engine Damper

the calculated harmonic torque components in the
mass-damper spring are shown in Fig. 2.
In SimulationX the initial conditions corresponding
to the results of the periodic steady-state simulation
can be calculated and used to initialize a successive
transient simulation.

4-Cylinder Engine

Fly Wheel
Gear Box and Shaft

Differential Gear, Side Shaft

Tyre, and Car

Load Torque
tau

But the method is also applicable to driven systems
in other physical domains. For non-linear electronic
amplifiers and filters most often the frequency or
amplitude of the driving generator is swept and the
period is measured at its phase. Therefore, a general
approach is needed. In SimulationX the following
procedure has been implemented: The user chooses
the varying reference quantity (e.g. mean engine
speed or generator frequency) and the period variable (e.g. crank angle or generator phase) from Modelica model trees containing all variables and parameters. For powertrains (or more general whenever
the reference quantity is not a parameter but the
mean value of a variable) the user also distinguishes
some model parameter as compensation parameter such as the load torque of the powertrain. The algorithm adjusts the compensation parameter for the
steady-state, i.e. the mean engine torque and the load
torque are balanced out by the algorithm. No special
preparation of the Modelica model is needed to enable the steady-state simulation. The same model
may be used for a simulation in time-domain too.
During the simulation the computed spectra of the
Modelica variables are written to special steady-state
protocols. Those results can be visualized in several
different representations (amplitudes, phases, fluctuations, spectral powers and so on). For the powertrain example from Fig. 1 some of the amplitudes of

The Modelica Association

Fig. 2: Spectral results for the torque of the spring in
the engine damper; the sum curve and the amplitudes
of the first harmonic components are shown, the largest amplitudes are labelled with the oscillation orders

In this way the periodic solution can be recalculated
with a transient simulation and the steady-state results can easily be checked. Fig. 3 shows a very good
match of the steady-state simulation result with the
transient simulation result.
200
150
Torque of Engine Damper/Nm

Fig. 1: Example of a Modelica model of a powertrain
analyzed with the periodic steady-state simulation

100
50
0
50
100
150
200

0

120

240

360

480

600

720

Crank Shaft Angle/degree

Fig. 3: Torque in the spring of the engine damper (full
line: steady-state simulation, dashed line: transient
simulation); the results are almost identical

384

Modelica 2008, March 3rd  4th , 2008

Frequency-Domain Analysis Methods for Modelica Models

2.2

Computational Background

In this subsection we give some insight in the computational background specific to the periodic
steady-state simulation. If the reader is only interested in applications he may safely skip to subsection 2.3.
For the periodic steady-state simulation the harmonic
balance method is employed. This method gives a
high spectral precision of the results and prepares the
numerical base for behavioural modelling in the frequency domain.
2.2.1 System Equations
The symbolic analysis compiles from the Modelica
model a system of equations for the stationary simulation. If the simulation time appears explicitly in the
model equations (for instance in a driven system) it
is replaced by a state x time with dx time / dt = 1 which
leaves us with an autonomous algebraic differential
equation system

f ( x (t ), x& (t ), xC ) = 0

(1)

where x is the R n -valued state vector with corresponding time-derivative x& , and xC  R is the compensation parameter (see section 2.1). It is convenient to represent oscillations not over time but over
the phase angle  :=  t for which the period length
keeps constant at 2 independent of the period duration (  is the phase velocity of the oscillation).
Substituting the derivative w.r.t. time through the
derivative w.r.t. phase x& (t ) =  x ' ( ) in eq. (1)
gives

f ( x ( ),  x ' ( ), xC ) = 0 .

(2)

Throughout the remainder of this section we represent x in dependence of the phase angle.
The system is assumed to be freely displaceable in
one direction of the state space. Therefore, we chose
x and a
a combination of a 2 -periodic function ~
component linearly dependent on the phase angle as
a solution ansatz

x ( ) =

xP ~
+ x ( )
2

(3)

for the system equation (2) with a constant vector
xP  R n , called period vector in the sequel.
This setup is rather general. It includes freely rotating powertrains and periodically driven systems.
Solving (2) can now be divided into the two tasks


x
 computation of the periodic function ~
which will be described in the following two sections.
2.2.2 Period Vector Computation
The user selects one model variable as the period
variable (cf. section 2.1). We denote the index of that
variable as iP . For this variable the user specifies
the period length p . The model equations (2) are
then solved for the static case (i.e.  = 0 ) once with
 = 0 and once with  = 2 . Because of the 2 x the difference of these two soluperiodicity of ~
tions just gives the period vector

xP = x (2 )  x (0 ) .

(4)

At  = 0 the displacement of the system (e.g. the
rotational position of a powertrain) is determined by
the additional condition xi P (0) = 0 . This together
with (2) and (3) results in the overall system

f ( x (0),0, xC ) = 0; xi P (0) = 0

(5)

for the case  = 0 which consists of n + 1 equations
for the n + 1 unknowns composed of the n
states x (0) and the compensation quantity xC (e.g.
the load torque of a powertrain).
For  = 2 we use the user-defined periodicity of
the state vector component iP and solve

f ( x (2 ),0, xC ) = 0; xi P (2 ) = p .

(6)

The condition that xC is the same in (5) and (6) offers a possibility to check the computed solutions.
For driven systems the equations in (5), (6) may not
be simultaneously solvable. In that case in each of
these systems the static equation

f ( x,0, xC ) = 0;

is replaced by the condition

f ( x, v, xC ) = 0;
where v

2

v

2

 min

denotes the Euclidian norm of v .

In practice it has proven sufficient to solve the resulting restricted minimization problems by a modified
Gauss-Newton algorithm.
2.2.3 Harmonic Balance
x in the
For the computation of the periodical part ~
ansatz (3) equation (2) is reformulated as the variational equation

computation of the period vector xP

The Modelica Association

385

Modelica 2008, March 3rd  4th , 2008

A. Abel, T. Nahring

1
2



2

0

 ( )  y ( ) d = 0

2 N + 1 left-hand sides of (7) become the
first 2 N + 1 Fourier coefficients f ( x ,  , xc )[k ] of

(7)

with  varying over all continuous R n -valued

functions fulfilling the condition  (0 ) =  (2 ) and
with

x 

x

y ( ) := f  P + ~
x ( ),   P + ~
x ' ( ), x C  . (8)
 2

 2

~
For a fixed phase velocity  the solution x is only
determined up to a multiple of xP and a corresponding phase shift (e.g. for a powertrain the arbitrary
initial angular position). To formally fix the initial
disposition, additionally the mean value of the period
variable is balanced to zero:

1
2



2

0

~
xi P ( ) d = 0 .

(9)

In some cases the user does not want to prescribe the
phase velocity  directly (e.g. for powertrains it is
usual to prescribe the mean rotational speed of the
engine instead). For that reason the user-chosen reference quantity was introduced in section 2.1. Let
iR be the index of the reference quantity and r the
wanted mean value for that variable. Then instead of
a direct assignment to  the equation

1
2



2

0

~
xi R ( ) d = r

(10)

is added to the variational system.
Following Galerkin for the numerical treatment
of (7,8) the function space for  and ~
x is restricted
to the finite-dimensional space spanned by the harmonic orthogonal system of base functions

 [k ] := exp( j k ) with k =  N , K , N .

(11)

In the following we keep using lower indexes for the
state vector components but we use Modelica index
notation to organize the frequency components (as
we have already done so by defining  [k ] above).
x in (3)
Using the base (11) for the periodical part ~
the ansatz becomes

~
x ( ) =

N

 exp( j k ) x[k ]

(12)

the left-hand side of (2), i.e. Fourier coefficients of
the time-domain residuals. Equations (7,8,9,10) together then give the harmonic balance equation system

f ( x , , xC ) = 0
x i P [0] = 0
x i R [0] = r

n (2 N + 1) + 2 scalar equations for the
n (2 N + 1) unknowns in x and the additional two
unknowns  , xC . The fast Fourier transformation
of

(FFT) is used to approximate the Fourier-coefficients of y . Because of the nonlinearities in f the
spectrum of y is wider than that one of x and some
oversampling is needed for the FFT to keep the aliasing error low.
For solving system (13) Newton's algorithm is applied. Deriving the Newton corrector equation in
time-domain and then transforming it into frequencydomain gives good insight into the structure of the
resulting system of equations. A first order Taylor
approximation of (2) in the current numerical approximation of (~
x , , xC ) yields the equation

f +  1 f   x +  2 f  ( x '+ x '  ) +
+  3 f   xC = 0

(14)

which determines with (3) the Newton correction ( ~
x , ,  xC ) (note: (i) here  k f stands for
the derivative of f w.r.t. the k th argument, and
(ii) for clarity we have omitted the arguments
(x, x' , xC ) of f , (iii) x,  x,  ~x are functions
of  ). The time-domain products in (14) correspond
to frequency-domain convolutions. E.g., the FFT
transforms  1 f   x into

((

)

^
 [k ] =
1 f ) * x

N

 ( f ) [k  l ]  x[l ] .

l = N

^

1

(15)

With I : (I x )[k ] := kx[k ] the spectrum of the de-

rivative x& can be written as ( x ' ) = j I x . So, after
shifting f to the right-hand side (14) is transformed
by the FFT into the equation
^

k = N

where x[k ] is the k -th frequency component of the
state space vector (we use a hat x or ( x ) to denote
complex amplitudes). Since ~
x is real x[k ] is the
complex conjugate of x[  k ] . Thus, the values of x
^

((

are determined by n (2 N + 1) real numbers. With 
replaced by  [k ] for k =  N , K , N the resulting

The Modelica Association

(13)

386

1

)

(

)

^
^
f ) *  x + j  ( 2 f ) * (I x ) +
^
^
+ ( 2 f x ' )  + ( 3 f )  xC =  f

(16)

Modelica 2008, March 3rd  4th , 2008

Frequency-Domain Analysis Methods for Modelica Models

for the unknown Newton correction ( x , ,  xC )
in the frequency domain. Together with (9) and (10)
written as

size is implemented in SimulationX. A short outline
of this algorithm shall conclude this subsection.

 xi P [0] = 0;  xi R [0] = 0

(17)

value rStop of the interval for the reference quan-

this system formally determines the Newton correction in the frequency domain completely.

tity xiR the full system (13) is solved. At intermedi-

With the number of n (2 N + 1) + 2 real unknowns
the system is rather large and the convolution operator in (16) causes large fill-in of the system matrix
making direct solving infeasible in real-world applications. Therefore, the iterative GMRES algorithm is
used instead (see e.g. [5]). This method only requires
the evaluation of the left-hand side of (16) for
known ( x , ,  xC ) . This also makes it possible
to replace the frequency-domain convolutions in (16)
by the cheaper corresponding time-domain products
in (14) (together with the therefore needed FFToperations). GMRES only works well with an appropriate pre-conditioner. Thus, one must be able to
roughly solve systems with the left-hand side of (16)
fast. For this end the block-diagonal preconditioner
is used (see e.g. [6]). This approximates the convolutions by only retaining the mean value component
of ( k f

)^ :
((1 f )^ *  x )[k ]  (1 f )^ [0]   x[k ]
(( 2 f )^ * ( I x ))[k ]  ( 2 f )^ [0]  k x[k ]

(18)

The so approximated system (16) can be solved frequency-component wise.
If the dynamical system is linear then the Jacobians  1 f ,  2 f are constant in time and the corresponding higher spectral components in the convolu-

tions (e.g. ( 1 f ) [k  l ] with k  l  0 in (15)) are
zero. In this case `   in (18) can be replaced by `=
and the approximations are exact. For increasing
nonlinearities the higher spectral components of
 1 f ,  2 f omitted in the preconditioner gain influence, the approximations become more coarse. In
general one can say that with stronger nonlinearities
the number of GMRES iterations per Newton step
and the number of Newton-iterations increase.
If the local Newton method does not converge fast
enough then the Newton-algorithm with backwarderror minimization via backtracking (see [1] and [7])
is applied. For a better numerical condition the states
are automatically scaled during the computation.
In section 2.3 we will give an example of a nonlinear
system with a turning point in its frequency response. To make the computation of such points possible a curve tracing algorithm with variable step^

The Modelica Association

Only at the starting value rStart and the end

ate points for xiR the last equation determining the
value of the reference quantity is removed resulting
in

F(X ) = 0

X

X (k )
X (k )

F ( X ) = F (X P ( k ) )
X P( k )

X ||(k 1)

X ( k 1)

xiR
rStop

rStart

Fig. 4: Curve tracing algorithm (see text for details)

 f ( x ,  , xC )

F ( X ) = 0 with F ( X ) := 


[
0
]
x
iP



(19)

and with the unknowns collected in X := ( x ,  , xC ) .
Since (19) has one scalar equation less than unknowns it formally defines a solution curve (see also
upper branch in Fig. 4) instead of a single point.
Given the last solution point X (k 1) on the solution
curve and the tangent direction  X ||(k 1) of the solution curve in that point a prediction

X P (k ) = X (k ) + s  X ||(k 1)
for the new solution point is computed. Thereby, the
step size s is chosen in dependence of the estimated
curvature of the solution path, the estimated distance
of X P (k ) to the solution path, and the local convergence behaviour of Newton's algorithm (for details
see [2]). In the predicted point a new estimation  X (k ) for the tangent vector is computed as
the solution of the system

D F (X P (k ) ) X ( k ) = 0,

( X ( ) )

|| k 1 T

  X (k ) = 1.

This is not the tangent direction to the solution curve
but to the curve defined by F ( X ) = F X P (k ) (see
Fig. 4). Nevertheless, these curves and their tangents
are supposed to be close to each other. The Newton
correction for the computation of the next solution X (k ) of (19) is then carried out in the affine
plane with X P (k ) as origin and  X (k ) as normal

387

(

)

Modelica 2008, March 3rd  4th , 2008

A. Abel, T. Nahring

direction. The point X (k ,0 ) := X P (k ) is used as an
initial guess and the Newton corrections  X (k ,i ) as
well as the iterated solution approximations X (k ,i )
(i = 0,1, K) are defined by the system

DF (X (k ,i ) )  X (k ,i ) =  F (X (k ,i ) ),

( X ( ) )
k

T

  X (k ,i ) = 0,
X (k ,i +1) = X (k ,i ) +  X (k ,i ) .

(20)

As Fig. 4 suggests X (k ) is a better approximation
of the tangent to the solution curve at the new solution point X (k ) than X ||(k 1) . Using X (k ) lets the
Newton iterations run on nearly the shortest path to
the solution curve, gives (20) a better numerical condition, and avoids jumping between different solution branches at sharp turning points of the solution
path.

As an example in Fig. 7 the limit cycles from the two
stable branches (lowest and highest) of the frequency
characteristic at 0.405 Hz are shown.

Example: Nonlinear Spring-Mass-System
with Turning-Point in Frequency Response

Unlike linear systems nonlinear systems may exhibit
turning points in the frequency characteristic. The
curve tracing algorithm implemented in SimulationX
makes the computation of such kind of frequency
characteristics possible.
The simple mechanical system of Fig. 5 is a torque
excited spring-mass-oscillator. The frequency of the
sinusoidal torque source is chosen as the reference
quantity and swept between 0.2 Hz and 0.7 Hz .
Since this reference quantity is a parameter and not a
variable SimulationX chooses it automatically as
compensation parameter as well. The phase of the
sine oscillator is the period variable with period 2 .
The quadratic term added to the spring characteristic
makes the system nonlinear in such a way that it
shows a turning point in the frequency characteristic
(see Fig. 6).
sqr

10
Speed of Inertia rad/s

2.3

Fig. 6: Frequency response with turning-point for the
angular speed of inertia1 in the nonlinear spring-masssystem; the sum curve and the first three harmonic
components are distinguishable in this diagram

0

5

10
0

60

120

180

240

300

360

Phase of Oscillation / degree

Fig. 7: Angular speed curves for the two possible stable
limit cycles of the nonlinear spring-mass-system at
excitation frequency 0.405 Hz represented over
phase.

We kept this example simple to demonstrate that
even very basic nonlinear systems may have frequency responses with turning-points. More complicated examples can be found in [8], and [9].
2.4

angleSensor1

5

Example: Active Electronic Filter

sineOsc

torque1

inertia1

p

SD1=8

tau
amplitude=1

J=1

fixed1= 0

torque2

d=0.1

Fig. 5: Nonlinear Spring-Mass-system

In the interval from 0.397 Hz to 0.426 Hz the frequency characteristic is multi-valued. That corresponds to multiple periodic limit cycles at those excitation frequencies.

The Modelica Association

The periodic steady state simulation is not restricted
to mechanical systems. As an example the periodic
steady state simulation is applied to a Modelica
model for an active electronic pass-band filter (see
Fig. 8). The reference and compensation quantity in
this example is the frequency of the sinusoidal
source vin and its phase is the phase variable.

388

Modelica 2008, March 3rd  4th , 2008

5
Collector Voltage of q1/V

q2

ground1

ground3

-

+

q1
power

C=6.4e-9

R=20e3

re2

R=2.5e3

V

R=1e3

c1

6

vin

rin

rc1

vc1

rb1

c2

R=250e3

C=6.4e-9

Frequency-Domain Analysis Methods for Modelica Models

ground2

ground4

4
3
2
1

Fig. 8: Modelica model of the active electronical filter

At resonance frequency the transistor amplifier of
the pass-band filter is overdriven which causes
nonlinear harmonic distortions. The nonlinear frequency response of the collector voltage of transistor q1 is shown in Fig. 9.

0

0

60

120
180
240
Phase of Oscillation / degree

300

360

Fig. 10: Collector voltage of q1 in the active electronic
filter at excitation frequency 1.15 kHz represented over
phase; full line: periodic steady state simulation,
dashed line: transient simulation;

The results are in good accordance. Nevertheless, a
slight difference of the results from the periodic
steady state simulation and the transient simulation is
visible at about 75 . The steep slopes of the spike
are somewhat smoothened by the limited number of
equidistant sample-points for the steady state simulation (256 sample points per period were used).

3
3.1

Fig. 9: Frequency response of the collector voltage of
q1 in the active electronic filter; top: sum signal and
first harmonic, bottom: zoomed view of the other harmonics in the resonance region where the amplifier is
overdriven; the harmonics are decreasing with order,
only the 2nd and 3rd harmonic are labelled

In Fig. 10 the periodic steady state result and the
time domain result of this voltage over phase angle
for an excitation frequency of 1.15 kHz are compared. At about 75 the base-emitter diode of q2
blocks and the voltage amplification of q1 grows
which causes the spike in the collector voltage of q1.

The Modelica Association

Transfer Function Analysis and
Natural Frequencies
Linear System Analysis

Beside the nonlinear algorithm for the steady-state
simulation also linear frequency-domain analysis
methods are applicable to Modelica models and are
implemented in SimulationX. Those are based on the
linear system which results from the linearization of
the nonlinear system equations for the Modelicamodel in the current operating point. The operating
point may be determined by a previous transient
simulation or an equilibrium computation (in electronics also called DC-analysis). Some of the algorithms may be applied to any Modelica model without changes by the user. This includes the computation of the eigensystems, the Campell diagram, and
methods for the animation of the eigenmodes.
Other frequency-domain results such as the deviations in mechanical quantities (vibration modes) and
the distribution of vibration energies and losses require special internal blocks that can be included into
the Modelica-model. The following Modelica source
code shows how the inertia from the standard Modelica library can be supplemented with an internal

389

Modelica 2008, March 3rd  4th , 2008

A. Abel, T. Nahring

energy calculation block which SimulationX uses in
order to compute the energy distribution.
model RotInertiaEnergyBlock
import M=Modelica.Mechanics;
extends M.Rotational.Inertia;
Mechanics.Rotation.CalcEnergyBlock eb;
equation
eb.dom = w;
eb.T = J*a;
end RotInertiaEnergyBlock;

The modification of the Type SpringDamper is
similar. For a demonstration the (rotational and
translational) masses and spring-dampers in the
powertrain from Fig. 1 have been substituted by the
modified types. The distribution of energy calculated
by SimulationX for the eigenmode at 1.6664 Hz is
shown in Fig. 12. In practical applications such representations show the engineer which masses,
springs, and dampers dominate the behaviour in certain eigenmodes of the system, so he can take systematic countermeasures to avoid unwanted oscillations.
Up to now these blocks are not documented and only
used for the internal element libraries of SimulationX. But this may change in future.

earized system. Any result variable of the model may
be used as the system output. SimulationX has a special class of signal inputs that may be open even for
the top-level model. Those inputs may be used for
the input-output-analysis. In Fig. 11 a cut-out of the
powertrain from Fig. 1 is shown where a torque
source with such an input has been added. The inputoutput behaviour is described by the frequency response function and the pole-zero diagram of the
system.

Fig. 12: Element linSysAnaOpenInput in the example
from Fig. 1 with open input for the input-outputanalysis

Fig. 13 and Fig. 14 show the pole-zero plot and the
frequency characteristic, resp., for the powertrain
from Fig. 1 with the torque at the first cylinder as
input (Fig. 12) and the torque in the engine damper
as output.

Fig. 13: Pole-zero plot of the system in Fig. 1; crosses:
poles, circles: zeros

For further analysis in external tools the linearized
system matrices may be exported in Modelica or
MATLAB syntax.

4
Fig. 11: Distribution of energy for the powertrain example from Fig. 1

3.2

Input-Output Analysis

For the analysis of the input-output-behaviour the
user must select the input and the output of the lin-

The Modelica Association

Conclusions and Outlook

Periodic steady state simulation proves useful for the
vibration analysis of nonlinear systems. SimulationX
allows its application to Modelica models, in particular to powertrains, without the decomposition into
nonlinear exciter and linear drivetrain. Furthermore,
the method is applicable to driven systems of other

390

Modelica 2008, March 3rd  4th , 2008

Frequency-Domain Analysis Methods for Modelica Models

physical domains since it is purely equation-based.
Only very little knowledge of the system is required
from the user. Two mechanical examples and one
from electronics were given in the paper.

 Autonomous Systems: The ansatz used for the
harmonic balance also bears the potential for the
simulation of autonomous systems. The required
randomization of the start values for the harmonic
balance could be implemented.
 Detection of Stable/Unstable Limit Cycles: Up to
now there is no automatic discrimination of the stable and unstable branches in the nonlinear frequency
response computed via harmonic balance. This can
be implemented by an eigenvalue analysis of the
monodromy matrix of the computed limit cycles.

References
[1]

Fig. 14: Frequency response of the system in Fig. 1;
top: amplitude, bottom: phase

Furthermore, we discussed methods for the smallsignal analysis in the current operating point (resulting from a transient or equilibrium computation).
Beside pole-zero plots and frequency response functions also some remarks about the deviation- and
energy distribution analysis for oscillation modes
were given. They are especially useful for the mechanical engineer to detect the powertrain elements
which participate in selected oscillation modes.
 Behaviour Description In Frequency Domain:
In future it is planned to include a behavioural description in frequency domain (e.g., for modeling of
dynamic stiffness) for the periodic steady state simulation as well as for the frequency response computation, which was one main argument for the harmonic
balance method to be preferred over the shooting
method (see e.g. [11] for a short introduction and
further references). One major reason for the frequency domain description not yet being implemented in SimulationX is that Modelica currently
still lacks a standardized way for computations with
complex numbers (even if some steps in this direction have already been taken, see e.g. [10]).
 Event Iterations: Event iterations are already embedded into the harmonic balance algorithm. But
there remains still some work for the treatment of
time-discrete variables in special cases.
 Improved Convergence for Strongly Nonlinear
Systems: As long-term objective the convergence
speed of the harmonic balance for strongly nonlinear
systems can be improved by time domain preconditioners (see [6]).
The Modelica Association

391

J. E. Jr. Dennis and Robert B. Schnabel:
Numerical Methods for Unconstrained Optimization and Nonlinear Equations. SIAM
1996.
[2] E. L. Allgower and K. Georg: Numerical
Continuation Methods: An Introduction.
Springer-Verlag, 1990.
[3] http://www.simulationx.com
[4] H. Dresig and F. Holzweiig: Maschinendynamik. 5th ed., Springer-Verlag Berlin, 2004.
[5] A. Meister: Numerik linearer Gleichungssysteme. Vieweg-Verlag, Wiesbaden, 2005.
[6] Ognen J. Nastov: Methods for Circuit Analysis. PHD-theses, Massachusetts Institute of
Technology, 1999.
[7] U. Feldmann, U. A. Wever, Q. Zheng, R.
Schultz, and H. Wriedt: Algorithms for Modern Circuit Simulation. AE, Vol. 46 (1992),
No. 4.
[8] A. Al-shyyab and A. Kahraman: Non-linear
dynamic analysis of a multi-mesh gear train
using multi-term harmonic balance method:
period-one motions. Journal of Sound and
Vibration, 284 (2005) 151-172.
[9] Wen-I Liao, Tsung-Jen Teng, and ChauShioung Yeh: A method for the response of
an elastic half-space to moving sub-Rayleigh
point loads. Journal of Sound and Vibration
284 (2005) 173-188.
[10] Peter Aronsson at al.: Meta Programming
and Function Overloading in OpenModelica.
Modelica 2003, November 3-4, 2003.
[11] Kenneth S. Kundert: Introduction to RF
Simulation and Its Application. IEEE Journal
of Solid-State Circuits, Vol. 34, No. 9, September 1999.

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

392

Modelica 2008, March 3rd  4th , 2008

World3 in Modelica: Creating System Dynamics Models in the Modelica Framework

World3 in Modelica: Creating System Dynamics Models
in the Modelica Framework
Franois E. Cellier
ETH Zrich

Switzerland
FCellier@Inf.ETHZ.CH

Abstract
This paper introduces a new release of the SystemDynamics library of Modelica and shows how it is
being used by discussing a fairly large application
code: Meadows World3 model. The newest version
of that model has been made available in the library.
Keywords: System Dynamics, World Dynamics,
Soft Science Modeling

1

Introduction

System Dynamics represents a fairly low-level modeling paradigm. Its implementation does not place
heavy demands on the modeling software. Hence
Modelica may in fact be a bit of an overkill for dealing with System Dynamics models. However, it is
considerably better suited than the state-of-the-art
software for this type of modeling, i.e., Stella [11],
the code that most System Dynamics modelers use
today.
A first version of a System Dynamics library for
Modelica was released in 2002 [3]. In the present
paper, a new release, SystemDynamics 2.0, is being
discussed. SystemDynamics 2.0 is not an upgrade of
SystemDynamics 1.0, but rather a re-implementation
of the methodology. Inherited from SystemDynamics 1.0 were only two application codes, a small introductory model concerning lynxes eating hares,
and a considerably more complex model borrowed
from Forresters Industrial Dynamics book [4].
As already mentioned above, the basic models
implementing the System Dynamics methodology,
levels and rates, are so simple that their implementation in Modelica requires very little time and effort.
The value of the library is not in its basic models, but
rather in its application codes.

The Modelica Association

Among other applications, SystemDynamics 2.0
offers two full World models, namely Forresters
World2 model [5], and Meadows World3 model
[7,8].
Whereas Forrester described his model in full in
his World Dynamics book [5], Meadows only talked
in Limits to Growth about the results obtained with
the model [8]. The model itself, originally coded in
Dynamo [10], was described in a separate book [7].
Meadows World3 model has seen two major
upgrades since its original inception, one in 1992, i.e.
after 20 years, and the second in 2002, i.e., after 30
years. The World3 application code contained in
SystemDynamics 2.0 implements the 2002 version
of the World3 model. In the code, we offer not only
the basic model, but also all 10 scenarios that Meadows and co-workers are talking about in Limits to
Growth: The 30-Year Update [8].
Although the work of Forrester and Meadows
caused quite a stir in the early 70s when their books
first appeared, world modeling became unfashionable fairly quickly, because essentially all sources of
funding dried out for political reasons.
Only very recently, in the context of the looming
Peak Oil event and because of the ongoing discussions concerning Global Warming, has world modeling become respectable again.
It turned out that Forrester and Meadows were
essentially correct in their assessments, in spite of
the fact that their models were very crude in comparison with real world dynamics.
With this paper, I wish to open up world modeling to the community of Modelica users.

393

Modelica 2008, March 3rd  4th , 2008

F. Cellier

2

Short History of System Dynamics

The System Dynamics approach to modeling dynamic systems was developed in the 1960s by Jay
Forrester with the aim of creating a modeling and
simulation tool that economists would be able to
handle.
Instead of talking about differential equations, he
talked about levels, the values of which were
changed by rates. Level variables are variables
that can accumulate. For example, population might
be used as a level variable. It is controlled by two
rate variables, the birth rate and the death rate.
Forrester would draw this relationship in a diagram similar to the one shown in Fig.1.

Figure 2: Typical level and rate variables

The modeler would then need to decide, which
other variables the rates depend on, and write these
down in a so-called laundry list. A possible laundry list for the birth rate is offered in Fig.3.

Figure 1: Population with birth and death rates

Figure 3: Birth rate laundry list

The blue square box represents a level. It requires an
initial value. The blue icons to the left and right of
the level represent rates. Both the birth and the death
rate are proportional to the population. The two
clouds represent sources and sinks of material. They
are used for documentation purposes only. There are
no equations associated with these models. The lilac
lines represent material flows, whereas the blue lines
represent information flows.
Of course, Forrester didnt have a computer
available with a graphical user interface. He drew
his diagrams only by hand and then translated them
manually (and quite mechanically) down to a set of
equations that he then encoded in Dynamo [10], a
simulation language that had been outdated already at the time of its creation.
Forrester explained to his disciples that every
modeling exercise should always start with pondering, which are the most important accumulator variables that ought to be captured in the model. These
variables should be declared as level variables. Subsequently, it needs to be decided, what other variables can be viewed as inflows and outflows to and
from these levels. The inflows and outflows would
then become the rate variables. Fig.2 shows a typical set of levels and their rates.

So far so good, but now comes the most daring
assumption, the quantum leap of System Dynamics.
The functional relationship represented by such a
laundry list can be assumed to be a static non-linear
function in multiple variables, e.g.:

The Modelica Association

Yet, since such a function may be too difficult to
identify, Forrester chose to ignore the mutual relationship among the different input variables, and
postulate the following model instead:

The birth rate is essentially computed as the average
birth rate, BRN, multiplied by the population. All
other dependencies are expressed as small signal deviations from the norm. The single-valued functions
can most of the time be easily approximated using
information from the open literature, e.g. from statistical yearbooks.
Forrester was wildly successful with his approach to modeling. Whereas engineers and physicists mostly ignored him, if they didnt even sneer at
his methodology, researchers from the soft sciences loved it. Already by the early 1980s, several
thousands of papers making use of System Dynamics
for a variety of modeling projects had been published
[6].

394

Modelica 2008, March 3rd  4th , 2008

World3 in Modelica: Creating System Dynamics Models in the Modelica Framework

By 1984, the Macintosh became available, and
with it, programmers were for the first time offered
an easily programmable graphical user interface.
Within a short time, a graphical modeling environment for System Dynamics modeling, Stella [11],
became available that quickly replaced Dynamo [10]
as the tool of choice for System Dynamics modeling.
Today, more than 20 years later, Stella is still the
most widely used tool for System Dynamics modeling. The language has seen a few improvements
over the years, but by and large, it is still the same
software that had been created in the mid 1980s.
A Stella model of population and its two rate
variables is shown in Fig.4.

Figure 5: Population dynamics in WORLD3

The model is quite easy to read. The population is
subdivided into four separate levels, representing:
1.
2.
3.
4.

Figure 4: Stella model of population growth

3

The WORLD3 Model

World Dynamics became quickly one of the most
prominent endeavors of System Dynamics modelers.
Among the earliest world models created for the
Club of Rome were Forresters WORLD2 and
Meadows WORLD3 models. Both of these models
are made available as part of the new SystemDynamics library.
Which are the most important drivers (accumultors) behind any world model? The list of levels
ought to include at least:







population
pollution
resource utilization
invested capital
work force
food

Different world models vary in the degree of sophistication, with which they consider these sectors.
In this paper, we shall primarily focus on the
WORLD3 model, as this model has been upgraded
several times, and therefore is still up-to-date.
3.1

Population Dynamics

The population dynamics model of WORLD3 is
shown in Fig.5.

The Modelica Association

children (until age 14)
young adults (until age 44)
older adults (until age 64)
seniors

This division makes sense, as the work force is comprised of groups #2 and #3 only, and people of reproductive age are those in group #2. The rates between the levels compute the maturation from one
group into the next. Beside from the births and the
final deaths, there are also people dying prematurely
out of each of the four groups.
The birth rate depends on the fertility, which is
computed by another module. The death rates in the
four groups are modeled as tabular functions of the
life expectancy, which is also computed elsewhere.
The model exports the total population and the
labor force, as these variables are used by other
modules.
Notice that WORLD3 is a global model. All
variables are averaged over the entire globe. The
model does not distinguish between Europe and Africa, for example. This limits the types of questions
that may be answered by it.
3.2

Pollution Dynamics

The pollution dynamics model of WORLD3 is depicted in Fig.6.
The pollution model contained originally a single state variable: the accumulated pollution. New
pollution is being generated in proportion to the total
resource utilization and in proportion to the arable
land used for agriculture. Pollution is being assimilated again in proportion to the accumulated pollution by the self-regulating mechanisms of this planet.

395

Modelica 2008, March 3rd  4th , 2008

F. Cellier

Figure 6: Pollution dynamics in WORLD3

Of a more recent vintage is the second state variable that denotes the capital invested in pollution
avoidance technology. Meadows and coworkers recognized at some point in time that the amount of pollution generated may be partly mitigated by investing in pollution avoidance technology. The inflow
rate associated with this second state variable is an
unrestricted rate that can also assume negative values, thereby turning the inflow rate into an outflow
rate.
Notice that this is not a greenhouse gas emission
model. The model attempts to estimate total pollution of various kinds. The measurement units associated with pollution in the model are somewhat obscure.
This would, however, be the place where a
global greenhouse gas emission model could (and
probably should) be added at some point in time.
3.3

The model is similar in structure to the pollution
dynamics model. Originally, there was only a single
state variable describing the non-recoverable natural
resources that are being depleted. Resource depletion occurs approximately proportional to the total
industrial output. The resources get consumed in the
process of producing goods. As the resources get
depleted, production inevitably slows down.
A second state variable was introduced in a later
version of the model describing the effects of recycling. As resources get recycled rather than discarded, resource utilization for the same amount of
produced goods slows down. The same technological advances that enable recycling also reduce the
generation of pollution.
In WORLD3, the production sector is subdivided
into three sub-areas concerning the production of
consumer goods, the production of food, and the production of services.
Resource depletion is an important factor in the
model as it negatively influences all three production
sectors.
Notice that the resources, as computed by the
model represent primarily minerals, not fossil fuels.
WORLD3 does not model fossil fuel utilization directly.
Fossil fuels could (and probably should) be included as a separate state variable within the resources sector of the model.
3.4

The Overall Model

The overall WORLD3 model is depicted in Fig.8.

Resource Utilization Dynamics

The resource utilization dynamics
WORLD3 is depicted in Fig.7.

model

of

Figure 8: Overall WORLD3 model

Figure 7: Resource utilization dynamics in WORLD3

The Modelica Association

I subdivided the WORLD3 model into 13 different sectors, capturing the dynamics of population,
pollution, arable land development, food production,
the service sector, human fertility, industrial invest-

396

Modelica 2008, March 3rd  4th , 2008

World3 in Modelica: Creating System Dynamics Models in the Modelica Framework

ments, the work force, land fertility, the human ecological footprint, the human welfare index, life expectancy, and last but not least the utilization of nonrecoverable natural resources. Three of those were
presented in the previous sections of this paper. The
overall model invokes one of each of the 13 sector
models and connects the terminal variables of those
sector models among each other.
We are now ready to simulate the model. The
compiled model contains 41 state variables and 265
algebraic variables. A few simulation results are
shown in Figs.9 and 10.

the population can continue to grow for some time
after 2030.

Figure 9: Population as a function of time

Figure 12: Resources as a function of time (scenario #2)

Figure 10: Natural resources as a function of time

The simulation results are identical to those
shown in the book Limits to Growth [8]. The population grows until roughly 2030. At that time, the
non-recoverable resources have been depleted to an
extent where production can no longer proceed as
before. In particular, less food gets produced, which
leads to a decline in the population.
Can we trust these results? To answer this question, it may be useful to look at scenario #2. In this
scenario, Meadows and his co-workers postulated
that the amount of the remaining non-recoverable
natural resources had been massively underestimated. The amount sill available in 1900 is thus
doubled. Furthermore, it is proposed that, in 2002,
money is being invested in producing the remaining
resources more efficiently.
Some simulation results of this scenario are
shown in Figs. 11 and 12. The results from scenario
#1 are superposed for comparison. We would expect
that, since resource depletion wont occur as quickly,

The Modelica Association

Figure 11: Population as a function of time (scenario #2)

In this scenario, the population is indeed able to
grow for a little while longer, but now it starts
shrinking at 2045, although the resources arent getting depleted until 2080. This time around, the cause
of the die-off is the pollution. Pollution is allowed to
continue to increase unabated, which eventually
hampers our ability to grow food.
Whereas scenario #1 suffers (in a general sense)
the effects of Peak Oil, scenario #2 is plagued by
Global Warming. Similar results were shown in earlier editions of Limits to Growth [8]. The main difference between the models is the year, in which corrective action is being taken in the different scenarios. In the first edition of the book, corrective actions were taken in 1972. However, we already
know that this didnt happen. Hence, the 3rd edition
proposes corrective actions to take place in 2002
only. By postponing the intervention, the window of
opportunity for still influencing the simulation results in a significant way shrinks.
Why do I believe these results? It is, because
they arent very sensitive to the scenario chosen.
Whatever we do, if it is not one factor that brings us
to the limits of growth, it is another  and irrespective of what we do, it always happens in the 21st century. It may happen a few years earlier or a few
years later, but the general picture doesnt change at
all.
Also the (much simpler) WORLD2 model that
features a different set of state variables and different

397

Modelica 2008, March 3rd  4th , 2008

F. Cellier

interactions between them essentially paints the same
picture.
Since the 1980s, we are consuming more resources per time unit than the planet is able to regrow [1,12]. We are living beyond our means. This
is not sustainable. It cannot continue indefinitely.
So, will the decline take place? Maybe it wont.
Maybe the moon is made out of Swiss cheese.
3.5

average human dies before age 30 due to huge infant
mortality.
Let us now look at scenario #9. In that scenario,
additional interventions are chosen. The scenario
starts out with scenario #6, but in addition enforces
strict population control (scenario #7), and products
are being built that last 25% longer on average (scenarios #8 and #9).
Some simulation results are depicted in Fig.14.

Analysis of Simulation Results

Meadows and co-workers found two scenarios that
look a bit more hopeful. These are scenarios #6 and
#9. Let me analyze these two scenarios in more detail. To this end, we shall continue the simulation all
the way until 2500.
In scenario #6, a whole palette of interventions
was enacted in 2002. These include the interventions of scenario #2. In addition, money was invested in improved pollution control technology
(scenario #3), in enhanced land yield (scenario #4),
in increased land erosion control (scenario #5), and
in augmented resource utilization efficiency (scenario #6).
Some simulation results are depicted in Fig.13.

Figure 14: Simulation results of scenario #9

By enforcing strict population control, the world
population is kept at a maximum value of 8 billion
people. The scenario promises a golden age that will
last for 400 years. Unfortunately, the scenario is not
fully sustainable, as the natural resources continue to
be used up, and by the year 2400, the industrial output, and with it also the population and life expectancy start declining again.

4

Figure 13: Simulation results of scenario #6

This scenario is indeed sustainable. The world
population hovers at approximately 10 billion people. The remaining natural resources get no longer
consumed.
Yet, humanity is paying a heavy price for insisting on maintaining such a large population. It
spends all of its resources in producing food, and
does so with the most primitive of means. The industrial output, and also the service sector output get
reduced to almost zero. This is also why the remaining natural resources are no longer being consumed.
Worst of all, the life expectancy is back at a value as
it was experienced prior to the industrial age. The

The Modelica Association

Dymola vs. Stella

What have we gained by offering a System Dynamics modeling capability in Dymola and by porting the
WORLD3 model to that new environment?
Stella, contrary to Modelica, is not truly objectoriented. Large models are handled in Stella by supporting the concept of a virtual canvas. The physical
screen can be scrolled over the virtual canvas, enabling the user to look at parts of the model separately. However, there is no feature available that
would help a user find a particular spot, such as the
population dynamics model, on the canvas.
Stella furthermore does not offer an icon editor.
Stella only supports three types of icons that are all
displayed in Fig.4. The square boxes represent levels (or stocks, as they are being called in Stella);
the circles with the tap on top denote the rates (or
flows, as they are being named in Stella), and the
circles without a tap are everything else (linear and

398

Modelica 2008, March 3rd  4th , 2008

World3 in Modelica: Creating System Dynamics Models in the Modelica Framework

non-linear functions, tabular functions). For this reason, Stella diagrams dont offer mnemonic hints.
They look all the same, irrespective of what they
represent (just like a bond graph [2]).
The numerical ODE solvers offered by Stella are
rather poor. Also, Stella computes internally with an
accuracy of 2 digits after the comma only (triggered
by the fact that Stella is frequently used by economists who think in terms of dollars and cents).
On the other hand, Stella offers better support in
dealing with tabular functions. Each 1D table is immediately plotted in the parameter window, and the
user can tweak the curve by moving supporting values around using the mouse.
Furthermore, Dymola forces the user to create a
separate block for each non-linear function and program the non-linear relationship either graphically in
its diagram window or alphanumerically in its equation window. In contrast, Stella offers a generic nonlinear function block that enables the user to create
the non-linear relationship interactively in the parameter window of that generic block. The user
doesnt even need to retype the names of the input
variables. The parameter window of that generic
function offers a scroll-down list of the names of all
input variables, and the user can simply click on any
of those in order to get them included in the expression.
Finally, Modelica has been designed by engineers for engineers. It is based heavily on SI units.
Whereas the user can declare types based on these
units, he cannot declare new units. Whereas this
works well for most engineering endeavors, it causes
problems when dealing with soft science models.
Sometimes, new derived units are needed. For
example, time in System Dynamics models is often
measured in years rather than seconds. Whereas
Dymola offers the possibility to declare new display
units, the user cannot change the units used in computations. This is inconvenient. Of course, the types
encoded in the SIunits library are based on SI units.
Thus, if a user wishes to declare his own units, he
will have to declare his own types based on these
units also.
Even worse, however, are those units that cannot
be expressed at all in terms of SI units. For example,
many System Dynamics models operate on units of
money. Dollars cannot be expressed in terms of SI
units at all.
The most important advantage of Dymola is the
fact that the entire System Dynamics knowledge is
encoded at the level of Modelica. The interface can
therefore be easily modified and enhanced by the

The Modelica Association

user. In contrast, Stellas user interface is completely hard-wired. The user cannot modify the syntax or semantics of Stella in any way, and therefore,
new ideas cannot be incorporated into the code except by talking the designers of the tool into including them with their next software release.

5

Conclusions

In this paper, a new release, or rather reimplementation, of the System Dynamics library of
Modelica was presented.
The System Dynamics methodology is very easy
to use, and consequently, does not really require
much of an introduction. The most important value
of a System Dynamics library is the knowledge encoded in its application examples. Currently, the by
far most valuable part of the new library are its world
models.
What future additions are in the works? In todays world of dwindling fossil fuel reserves, it becomes important to track how much energy we are
actually using. Whereas classical System Dynamics
is designed to track material flows, it does not track
energy flows. This is a major drawback of the methodology.
For this reason, a second version of the System
Dynamics library has also been released as a sublibrary of BondLib [2], our bond graph library. In
that version, all material flows are represented internally by bond graphs. A bond graph naturally tracks
energy flows. Each energy flow, in that version of
the library, is represented as the product of a specific
enthalpy and a mass flow. Hence we can track material flows and energy flows simultaneously.
When I drive my car from home to work, I am
not only spending energy in the form of the gas that
my car consumes. Some energy was also spent in
producing the car, and more energy will be spent in
discarding it at the end of its lifecycle and in recovering those materials from it that can be recycled.
The accumulated energy that accounts for all of
those indirect uses of energy is called emergy [9].
The specific enthalpy can be used to encode in the
model the specific emergy, i.e., the emergy per unit
of mass.
I plan on porting examples of emergy modeling,
as described in the publications by Howard Odum,
over to the bond graph implementation of the System
Dynamics library, but this work has not yet been
completed.

399

Modelica 2008, March 3rd  4th , 2008

F. Cellier

Acknowledgments
I wish to express my gratitude to Dennis Meadows
and Jrgen Randers. Without their generous help
and support, I would have been unable to port the
WORLD3 model and all of its 10 scenarios over
from Stella to Dymola (Modelica).

References
[1]

Cellier, F.E.: Ecological Footprint, Energy Consumption, and the Looming Collapse. The Oil
Drum, May 16, 2007

[2]

Cellier, F.E., Nebot, A.: The Modelica Bond
Graph Library. In: Proceedings of the 4th International Modelica Conference, Hamburg-Harburg,
Germany (2005) Vol. 1, 57-65

[3]

Fabricius, S.M.O.: SystemDynamics Modelica
Library; Brief Feature and Example Documentation. Modelica Website, 2002

[4]

Forrester, J.W.: Industrial Dynamics. M.I.T.
Press, 1961

[5]

Forrester, J.W.: World Dynamics. Pegasus Communications, 1971

[6]

Lebel, J.D.: System Dynamics. In: Progress in
Modelling and Simulation (F.E. Cellier, ed.),
Academic Press, London (1982) 119-158

[7]

Meadows, D.L., Behrens III, W.W., Meadows,
D.H., Naill, R.F., Randers, J., Zah, E.K.O.:
Dynamics of Growth in a Finite World. WrightAllen Press, 1974

[8]

Meadows, D.H., Randers, J., Meadows, D.L.:
Limits to Growth: The 30-Year Update. Chelsea
Green, 2004

[9]

Odum, H.T.: Environmental Accounting: Emergy
and Environmental Decision Making. John
Wiley, 1995

Franois E. Cellier received his
BS degree in electrical engineering
in 1972, his MS degree in automatic control in 1973, and his PhD
degree in technical sciences in
1979, all from the Swiss Federal
Institute of Technology (ETH) Zurich. Dr. Cellier worked at the University of Arizona
as professor of Electrical and Computer Engineering
from 1984 until 2005. He recently returned to his
home country of Switzerland. Dr. Cellier's main scientific interests concern modeling and simulation
methodologies, and the design of advanced software
systems for simulation, computer aided modeling,
and computer-aided design. Dr. Cellier has authored
or co-authored more than 200 technical publications,
and he has edited several books. He published a textbook on Continuous System Modeling in 1991 and a
second textbook on Continuous System Simulation
in 2006, both with Springer-Verlag, New York.

[10] Richardson, G.P., Pugh III, A.L.: Introduction to
System Dynamics Modeling with DYNAMO.
M.I.T. Press, 1981
[11] Richmond, B., Peterson, S., Vescuso P.: An Academic User's Guide to STELLA. High Performance Systems, Inc., Lyme, N.H., 1987
[12] Wackernagel, M., Rees, W.: Our Ecological
Footprint. Green Teacher, 45 (1995) 5-14

The Modelica Association

400

Modelica 2008, March 3rd  4th , 2008

Modelica as a Host Language for Process/Control Co-Simulation and Co-Design

Modelicaasahostlanguage
forprocess/controlcosimulationandcodesign
FilippoDonida,AlbertoLeva
DipartimentodiElettronicaeInformazione,PolitecnicodiMilano
ViaPonzio,34/520133Milano,Italy
{donida,leva}@elet,polimi.it

Abstract
Themanuscriptdescribesaproject,currentlyunderdevelopmentatthePolitecnicodiMilano,
theaimofwhichistocreateanintegratedenvironmentforthemodellingandsimulationof
processcontrolsystems,wheretheplant(s)aredescribedaccordingtotheModelicaobject
oriented paradigm, while  the control systems  are specified in  an IEC 61131.3compliant
language,andautomaticallytranslatedintoalgorithmicModelica.Preliminaryresultswillbe
reported,  given  the  vast  scope of  the  project, but  even  at  the  present  stage,  interesting
discussionsarepossibleonthepotentialitiesandpitfallsofModelica(andevenofobject
oriented  modelling  at  large)  when  it  comes  to  describe  control  algorithms  of  realistic
complexityandsize.

controlsysteminfulldetail,themosteffective
way  to  do  so  is  not  only  algorithmic,  but
compliantwiththeindustrialstandardacceptedin
that  domain,  the  IEC  611313  being  the  most
importantone[8,18,17,9,5,2,11].Adheringto
an  industry  standard  is  beneficial  not  only  in
termsofacceptabilityofthedevelopedsimulators
onthepartofpeoplewhoknowmuchmoreabout
theirprocessesthanaboutsimulation(aproblem
worthaddressinginanycase,however)butalso
intermsofreducedambiguityintherealisation
ofcontrollermodels[3,4].
Afterseveralyearsofexperienceonthematter,
theauthorsarestronglyconvincedthatModelica
is  very  well  suited  as  a  host  language  for  the
representationofrealisticscaleprocesscontrols,
butthattodosoitishighlydesirabletoallowfor
the  specification  of  such  controls  in  IEC
compliantlanguages.

1.Introduction
Asignificantexperienceisnowadaysavailableon
theuseofModelicatomodel,simulateandassess
controlsystemsintheprocessdomain[15,16,12,
13].Aswitnessedbymanyreferences(samples
willbegiveninthefinalmanuscript,including
somedirectlyrelatedtotheauthors'experience)
there  is  a  correspondingly vast corpus of
libraries,models,andsystemstudies[7,6,15,16,
14,4].
Basedonthatexperience,acriticalpointwhen
dealing  with  applications  of  realistic  size  is
invariantly  the  correct  representation  of  the
controlsystem.Theobjectorientedparadigmcan
be  suitably  exploited  to  allow  for  various,
interchangeable  control  representations  of
different,  scalable  complexity,  and  such  a
possibility  is  definitely a  plus of  Modelica.
However,whenitcomesthetimetodescribethe

The Modelica Association

401

Modelica 2008, March 3rd  4th , 2008

F. Donida, A. Leva

Basedontheaboveidea,theAutoEdit(thename
may  change  in  the  future) project was  started.
The  aim  of  the  project  is  to  set  up  a  tool
composedof

Thepaperorganisedasfollows.Firstaminimal
reviewofthebackground.Then,adiscussionis
carried  out  on  the  opportunity  of  generating
eventdrivenModelicacodewithanadhoctool,
insteadofdescribingcontrolsystemcomponents,
asalreadyattempted,withModelica(continuous
time  based)  models.  The  outcome  of  such
discussion,ascanbeguessed,isthatthebest
approachdependsonthesizeoftheconsidered
application,directgenerationofalgorithmiccode
being  preferable in  the  case  of  large  (control)
systems.TheAutoEditprojectisthendescribed,
illustrating   its  goals,  structure,  organisation,
presentstate,andfuturedevelopments.

a  graphical  Modelica  editor,  aimed  at
writingtheplantmodel,
 an editor for  IEC 61131.3 languages  (at
present  the  Ladder Diagram, Sequential
Functional  Chart  and  the  Functional
Block  Diagram  are  being  considered),
aimedatwritingthecontrolmodel,
 acompilercapableoftranslatingboth
the  plant  and  control  model  in  a
single  Modelica  file,  to  be  fed  to  any
Modelica  translator  for  simulation  (the
term  compiler  being  used  here  for
analogyand compatibilitywiththeIEC
terminology,  albeit the  Modelica  jargon
wouldmostlikelyadvisesomethinglike
pretranslator),
 andasimulationoutputbrowser.
Tothebestoftheauthors'knowledge,suchatool
is  the  only  one  allowing  to  couple  Modelica
process  modelling  with  IEC  (i.e.,  industry
standard)  control  system representation,  greatly
facilitatingthecreationofsimulatorsofprocess
controlsystems.
AutoEdit  is  fully  written in  java  (hence cross
platform),  uses  the  XML  language  as  internal
data  format  for  maximum  openness  and
transparency,  and  is  entirely  free  software,
releasedunderthetermsoftheGPLlicense.Itis
theauthors'intentiontoallowAutoEdittooperate
withanyModelicatranslator,soastomaximise
its  use  and  to  have  the  maximum  amount  of
feedback  for  improvement.  At  present,  the
AutoEdit  site  is  hosted  at  the  URL
http://home.dei.polimi.it/donida/projects.php?proj
ect=AutoEdit


The Modelica Association

2.Background
Recent  advances  in  objectoriented  modelling
allowtotacklethesimulationandthecomputer
aidedcontrolsystemdesignofindustrialplantsin
aunifiedframework.Traditionally,however,the
plant  study  and  design,  the  following  design
assessment  simulations,  the  control  system
design,  the  overall  system  validation,  and  the
operator  training,  are  not  developed  in  a
coordinatewaywithinasingleenvironment.By
vastlyacknowledgedopinion,doingsoisawaste
oftimeandresources,nottosayapossiblesource
oferrors,becausetheinvolvedenvironmentsare
frequently not  compatible each  other,  requiring
manualinterventiontotransferinformationfrom
onetooltoanother..
TheModelicamultiphysicsapproachallowsper 
se to  perform  a  first  integration of  two  of  the
involved  frameworks:  the  plant  model  and  its
controlaredefinedwithan equation sectionfor
theplantandanalgorithmsectionforthecontrol
code,andthenthetwosectionsareunifiedina
singlemodelandsimulatedsimultaneously.
In  the  present  software  engineering  arena,
translatorsandcrosscompilersarewelldiffused,

402

Modelica 2008, March 3rd  4th , 2008

Modelica as a Host Language for Process/Control Co-Simulation and Co-Design

but  basically  such  tools  are  available  for  the
software  development only.  To  the  best  of  the
authors'knowledgetherearenosimilarexamples
in simulationforcontrol area,except forsome
ad  hoc solutions  pertaining  to  the  micro
controllerrealtimeapplications.
The  AutoEdit  is  an  attempt  to  fill  the  gap
sketched  above.  It  is  in  the  first  place  an
integratedIEC61131.3compliantenvironmentfor
the  graphical  development  of  the  control
programs,having(algorithmic)Modelicaasthe
target  language.  Moreover,  it  proposes  new
standard  for  the  Ladder  Diagram  (LD)  and
Sequential  Function  Chart  (SFC)  file
representations,  using  the  XML  language  and
DTD  validation.  AutoEdit  also  encompasses  a
converter  from  the  SFC  XML  to  LD  XML
format,  managing  different  level  of  variables'
scope,asrequiredtobecompatiblewiththeway
IECcompliant  projects  are  organised.   In  one
word,AutoEditisanattempttoallowdeveloping
the  model  of  a  complete  control  application
(process  and  control  system)  in  a  single
environment,  and  having  as  final  output  a
completesimulatoroftheoverallapplication.





producingasoutputasingleModelicamodel,to
befedtoanyModelicatranslatorforsubsequent
simulation.
Thequestion,then,ishowtodescribethecontrol
application.
Basically,onecanfollowtwostrategies.Oneisto
describe  the  IEC  languages'  elements  as
Modelica  models:  this  is  somehow  tempting
especially  if  one  considers  the  graphical  IEC
languages(FBD,LD,andSFC).Doingsoallows
totakeprofitfromthemanipulationcapabilities
of  the  adopted  translator,  to  the  apparent
advantageofsimulationefficiency.
The  other  strategy  is  to  translate  the  IEC
programs  into  Modelica  algorithms,  to  be
assembledconvenientlyinblocks,andconnected
totheplantmodelintheusualway.
AutoEdittakesthesecondway,forthereasons
summarised  in  the  following.  First,  especially
large  can  easily  lead  symbolic  manipulator  to
dealwiththousandsandthousandsofvariables:
many  of  them  are  managed  trivially,  but  the
overheadremains.Then,manyproblemsinIEC
specifiedcontrolsystemsresideintheincorrect
synchronisation  of  control  threads  and
applications,  and  therefore    for  a  credible
validation  of  the control  system    representing
that  timing  (e.g.,  and  typically,  with  when
clauses)isveryimportant;ifthisisdone,given
thelimitationsofwhenequations,describingthe
code as algorithms starts looking advisable. In
addition,theorganisationofthecodeinthreads
andsubapplicationsistypicallyfunctional,thus
betterreflectedinalgorithmsthaninequations.

3.ModellingcontrolcodeinModelica
Consider  the  way  a  control  application  is
typically  developed  in  an  IECcompliant
environment.  The  application  is  composed  of
programs,  written  in  one  or  more  of  the
supportedlanguages,andlinkedtogetherbythe
developmenttool.Theprogramsofanapplication
areorganisedintosubapplications,thatinturn
aredeployedtooneormoreCPUsandarranged
intothreads,eachonecomposedofprogramsthat
sharethecycletime.i.e.,thetemporalcadence
fortheupdateofinputsandoutputs.
The  goal  of  AutoEdit  is  to  take  as  inputs

The Modelica Association

amodeloftheplantwritteninstandard
Modelica
and  some  description  of  the  control
application(thetermapplicationbeing
intended in  the  IEC  sense  summarised
above,

403

Modelica 2008, March 3rd  4th , 2008

F. Donida, A. Leva

Finally,andinsomesenseasabyproduct,ifa
tool  like  AutoEdit  generates  algorithmic
ModelicacodestartingfromanIECsource,then
thesametoolcaneasilybeextendedtogenerate
from  the  same  source   code in  virtually  any
procedural  programming  languages.  Exploiting
that  possibility  is  in  the  future  plans  of  the
AutoEditproject,andwillleadtoasingletoolfor
thesimulationofacompletesystem(avoidingthe
howtoclosetheloop  problem  of  IEC
development  environments)  and  also  for  the
generation  of  the  control  code  to  be  actually
deployedtothesystem'sCPU(s).

START_CYCLE  variable,  assumed  here  to  be
managedbysomeclockexternaltotheprogram),
eachofthevalves(V1toV3)hastobeopened.
Eachvalve,oneforeachzone,remainsopened
for10minutesandthenisclosed.Thereisalsoa
ON/OFFcommand:ifONistruethentheplant
works  as  described  below,  otherwise  all  the
valvesareopened,andthepumpisstopped.
Figure  2  shows  the  overall  control  program,
writtenintheSFClanguage,asisappearsinthe
AutoEditwindow.Itispossibletorecognisethe
various  elements  of  the  (very  simple)  control
logic,andtoappreciatethesimilarityoftheuser
interface  to  that  of  the  typical  IECcompliant
environments(totheadvantageofacceptability
onthepartofcontrolsystemdevelopers).Wedo
not reportsimulations heresincetheplant and
controloperationinthisexampleareverysimple,
andwouldnotcontributetothepurposeofthis
paper.

4.Anexample
Averysimpleexampleisnowreportedtobetter
illustratetheideasofsection3.Inthisexample,a
homeirrigationplantisintroduced.Theplanthas
anaccumulatingtank,apump,twolevelsensors,
and  three  valves,  each  one  connected  to  an
irrigationline.Aschematicfigureoftheplantis
reportedasfigure1.

Figure1:theexampleplant.
Thepumpstartspumpingwaterinthetankwhen
thelevelofthewaterislesserthanaOK_LEVEL
(boolean sensor that returns  true if  covered  by
water)  level  since  the  water  reaches  the  level
FULL_LEVEL  (similar  boolean  sensor).
Everyday,  say  at  20:00  (event  launched  by  a

The Modelica Association

Figure2:theexampleplantcontrolinSFC.
Intheexamplethetranslationwasverysimple
but,whenconsideringindustrialapplicationsof
realisticsize,thenumberandlengthofthelines

404

Modelica 2008, March 3rd  4th , 2008

Modelica as a Host Language for Process/Control Co-Simulation and Co-Design

ofcontrolcodewouldincreasedramatically,and
automatic  generation  of  the  algorithmic  code
wouldprovenecessary.Inadditiontothisifwe
consider  the  possibility  to  have  heterogeneous
IECcompliantprogramsamixtureofST,LDand
SFC  implementation,  the  complexity  further
increases.
Thanks to theAutoEditconversion utility,it is
possibletotranslatetheSFCprogramsintoLD
andthen,automatically,toModelicaalgorithm
based  models.  The  translation  of  an

heterogeneousIECcontrolprogramisperfectly
transparenttotheAutoEdituser.
4.TheAutoEditproject
Theprojectstartedinthe2004withtheintentto
realise  a  Java  graphical application to  support
graphical  programming  for  the  LD,  SFC  and
StructuredText(ST)languages.
From2004to2006agraphicalapplicationwas
therefore  developed  to  graphically  support  the
SFCandLDprogramming.

Figure3:TheAutoEditmainwindow.
Starting  from  2006, the target  was widened as
illustrated in  section 3,  so  as  to  integrate  the
AutoEdit  environment with  a  Modelica editor,
andthen(startingin2007)tocreateaconverter
fromSFC,LDXMLandModelicaalgorithmic
based .mo files.  This is    more or  less    the
present  state of the project. Notice that a high
developmenteffortisbeingspentonAutoEdit,so
that  the  mentioned  state  is  continuously
changing.Thereaderisreferredtotheprojectsite

The Modelica Association

foruptodateinformation.
Here,  just  some  samples  of  the  AutoEdit
operation  are  given.  Space  limitations  prevent
fromreportinghereanytechnicaldetail,thatcan
anywaybefiguredoutfromthesite,andwillalso
beavailableinthesystemdocumentation.
Figure 3  shows  the  main window  of  AutoEdit
with  a  Modelica model open for  editing.  It  is

405

Modelica 2008, March 3rd  4th , 2008

F. Donida, A. Leva

possibletoseethemultiplesubwindowsscheme,
allowing  simultaneous  editing  of  multiple
(process and/or control)  models. The  AutoEdit
texteditor,thankstotheintegrationoftheJEdit
software,  offers  many  functionalities,  among
whichsyntaxhighlighting,brackethighlighting,
text  folding  (also  for  annotations),  word  auto
completion,  autoindentation  and  many  others
utilities.ofmultiplemodels.

Figure4,ontheotherhand,showstheconversion
from SFC to LD, namely of the pump control
programintheexampleintroducedabove.Itis
possible to appreciate the usefulness  of  having
simultaneous  views  of  the  same  code  with
different  representations,  a  facility  offered  by
severalIECcompliantenvironments,andofhigh
usefulness  according  to  the  opinions  of  the
industrialcommunity.

Figure4:thepumpcontrolprogramconvertedfromSFCtoLDbyAutoEdit.
functionalities,
 theexploitationofinteraction/integration
possibilities  with  other  IECcompliant
tools,
 the  output  of ad  hoc realtime  code in
severallanguages,theClanguagesbeing
for  obvious  reasons  the  first  to  be
considered,
 theadditionofmultitaskingsupport.
6.Conclusions
A  Javabased  integrated  environment  for  the

5.Futuredevelopments
Many  interesting  future  works  arise  for  the
AutoEditprojectfromthescenariosynthetically
described  above.  Among  those  possible
developments,thosethatseemmorepromising,
andarethereforescheduledasworktobedonein
thenearfuture,are




the developmentof a3d viewerforthe
simulationdata,
the  addition  of  other  advanced  editing

The Modelica Association

406

Modelica 2008, March 3rd  4th , 2008

Modelica as a Host Language for Process/Control Co-Simulation and Co-Design

development  of  complete  objectoriented
simulation models  of  controlled plants, namely
theAutoEditproject,waspresented.
ThegoalofAutoEditistoallowtheusertocreate
both  the  plant  model,  using  the  power  of  the
Modelicalanguage,andanalgorithmicmodelof
thecontrolprogram,adheringtotheIEC61131.3
industrystandard,
Assuch,AutoEditnotonlyproposesasoftware
solution,butalsotriestosuggestnewstandards
andideasforunifyingtwoofthemostimportant
activities  of  the  computeraided  engineering
tasks:modelandcontrolcosimulation.

Control  Programming  Environment
Enhanced by Extensible Graphic Symbols,
SICEICASEInternationalJointConference
2006inBexco,Busan,Korea, Oct.1821,
2006.
[6] Y.  Qiliang,  X.  Jianchun,  W.  Ping,  Water
Level  Control  of  Boiler Drum  Using  One
IEC611313BasedDCS,Proceedingsofthe
26th  Chinese  Control  Conference,
Zhangjiajie,  Hunan,  China,   July  2631,
2007.
[7] M.  Bonfe',  C.  Fantuzzi,  L.  Poretti,   PLC
Objectoriented  programming  using
IEC611313normlanguages:anapplication
to  manufacture  machinery,  in  Proc.  of
IEEE/ASME  Int.  Conf.  on  Advanced
IntelligentMechatronics,vol.2,pp.787792,
2001.
[8] [Online].Availablehttp://www.plcopen.org.
[9] J.  Roger  Folch,  J.  Prez,  M.  Pineda,  R.
Puche,GraphicalDevelopmentofSoftware
for  Programmable  Logic  Controllers,  12th
InternationalPowerElectronicsandMotion
ControlConference.
[10] [Misc].  DeltaV:  Monitor  and  control
software.
[11] [Misc].

Labview:
http://www.ni.com/labview.
[12] [Online].Dymola:http://www.dynasim.se
[13] [Online].

Openmodelica:
http://www.ida.liu.se/labs/pelab/modelica/O
penModelica.html
[14] A.  Nobuo, I.  Kenichi, Y.  Eiji,  Application
portfolios  for  stardom,  12th  International
Power  Electronics  and  Motion  Control
Conference.
[15] M.  Otter,  K.  E. rzn,  I.  Dressler,
StateGraphA  Modelica  Library  for
Hierarchical  State  Machines,  4th
International  Modelica  Conference, March
78,2005.

References
[1] T.  Sato,  E.  Yoshida,  Y.  Kakebayashi,  J.
Asakura,  N.  Komoda,  Application  of
IEC611313  For Semiconductor  Processing
Equipment, Emerging  Technologies  and
FactoryAutomation.Proceedings.20018th
IEEEInternationalConferenceon,2001.
[2] J.Huang,Y.Li,W.Luo,X.Liu,K.Nan,The
Design  of  NewType  PLC  based  on
IEC611313,  Proceeding  of  the  Second
International  Conference  on  Machine
Learning  and  Cybernetics,  Xi,  25,
November2003.
[3] A.  Leva,  A.  M.  Colombo,  Method  for
optimising  setpoint  weights  in  ISAPID
autotuners,      IEE  ProcControl  The09
Appl.,Vol.146,No.2,March1999.
[4]   H.  Takada,  H.  Nakata,   S.  Horiike,  A
Reusable  Object  Model  for  Integrating
Design  Phases  of  Plant  Systems
Engineering,  Proceedings  of  the  Fourth
InternationalConference on Computerand
InformationTechnology(CIT04).
[5] H.Taruishil,S.Kajiharal,J.Kawamotol,M.
Ono,H.Ohtani,DevelopmentofIndustrial

The Modelica Association

407

Modelica 2008, March 3rd  4th , 2008

F. Donida, A. Leva

[16] O.  Johansson,  A.  Pop,  P.  Fritzson,
Engineering  Design  Tool  Standards  and
Interfacing  Possibilities  to  Modelica
SimulationTools,5thInternationalModelica
Conference,September45,2006.
[17] E.Tisserant,L.Bessard,M.deSousa,An
Open  Source  IEC  611313  Integrated

The Modelica Association

Development  Environment,  Industrial
Informatics,  5th  IEEE  International
Conferenceon,2007.
[18] [Online].

ISaGRAF:
http://www.icpdas.com/products/PAC/i
8000/isagraf.htm

408

Modelica 2008, March 3rd  4th , 2008

-1-

Exception Handling for Modelica

Exception Handling for Modelica
Adrian Pop, Kristian Stavker, Peter Fritzson
PELAB  Programming Environment Lab, Dept. Computer Science
Linkping University, SE-581 83 Linkping, Sweden
{adrpo, krsta, petfr}@ida.liu.se

Abstract
Any mature modeling and simulation language should
provide support for error recovery. Errors might always
appear in the runtime of such languages and the developer should be able to specify alternatives when failures happen. In this paper we present the design and
implementation of exception handling in Modelica. To
our knowledge this is the first approach of integrating
equation-based object-oriented languages (EOO) with
exception handling.

incomplete, not implemented, and no further work was
done at that time.
The design of exception handling capabilities in
Modelica is currently work in progress. The following
constructs are being proposed:
 A try...catch statement or expression.
 A throw (...) call for raising exceptions.

Keywords: Exception handling, Modelica.

We have tried to keep the design of syntax and semantics of exception handling in Modelica as close as possible to existing language constructs from C++ and
Java, while being consistent with Modelica syntax
style.

1

2

Introduction

According to the terminology defined in IEEE Standard
100 [9], we define an error to be something that is
made by humans. Caused by an error, a fault (also bug
or defect) exists in an artifact, e.g. a model. If a fault is
executed, this results in a failure, making it possible to
detect that something has gone wrong.
Approaches to statically prevent and localize faults
in equation-based object-oriented modeling languages
are presented in [16] and [17]. However, in this paper
we focus on language mechanisms for dynamically
handling certain classes of faults and exceptional conditions within the application itself. This is known as exception handling. An exception is a condition that
changes the normal flow of control in a program.
Language features for exception handling are available for most modern programming languages, e.g.
object oriented languages such as Java [15], C++ [14],
and functional languages such as Haskell [3], OCaml
[12], and Standard ML [13].
However, exception handling is currently missing
from Object-Oriented Equation-Based (EOO) Languages like Modelica [2][6], VHDL-AMS [10],
gPROMS [11].
A short sketch of the syntax of exception handling
for Modelica was presented in a paper on Modelica
Metaprogramming extensions [5], but the design was

The Modelica Association

Applications of Exceptions

In this section we provide examples of exception handling usefulness. There are three contexts in which exceptions can be thrown and caught: expression level,
algorithm level and equation level.
import Modelica.Exceptions=Exn;
function log
input Real x;
output Real y;
algorithm
y :=
if x <= 0
then
throw (Exn.InvalidArgumentException(
message="Logarithm is undefined
for ..."))
else
Modelica.Math.log(x);
end log;

Function log defined above will throw an exception if
it is provided with an invalid argument. This is not only
useful for mathematical functions, but also for functions (i.e. like the ones in Modelica.Utilities
package) that deal with errors due to the operating system. A common for all tools standard hierarchy of exceptions could be defined in the Modelica Standard
Library for all the exceptions categories needed. Depending on the simulation runtime implementation (i.e.
language of choice) of the Modelica tool exceptions

409

Modelica 2008, March 3rd  4th , 2008

A. Pop, K. Stavaker, P. Fritzson

-2-

could be translated from Modelica to the runtime and
back.
A model that uses the try-catch construct in the expression and equation contexts is presented below:

named_arguments:
named_argument [ "," named_arguments ]
named_argument:
IDENT "=" expression
name:
IDENT [ "." name ]

model Test
// try to read a value from file
// and if it fails just give it
// a default value.
parameter Real p=
try
readRealParameter("file.txt","p")
catch(Exn.IOException e)
0
end try;
Real x;
Real y;
equation
try
y = log(x);
catch(Exn.InvalidArgumentException e)
// terminate the simulation with
// a message on what went wrong
terminate(e.message);
end try;
end Test;

throw_clause:
throw ["(" name
[ "(" exception_arguments ")"] ")" ]
try_clause_expression:
try
expression
( else_catch_clause_expression
| catch_clause_expression
{ catch_clause_expresion }
[ else_catch_clause_expression ] )
end try
catch_clause_expression:
catch "(" exception declaration ")"
expression
else_catch_clause_expression:
elsecatch
expression

In this model exception handling in expressions and
equations are shown. In the case of exception handling
in equations the example just terminates the simulation
with an exception.
As one may have noticed the exceptions can be
thrown during:

try_clause_algorithm:
try
{ statement ";" }
( else_catch_clause_algorithm
| catch_clause_algorithm
{ catch_clause_algorithm }
[ else_catch_clause_algorithm ] )
end try

 Compilation time for expressions or functions that
are evaluated at compile time
 Simulation time, due to exceptions raised into the
solver, functions, expressions or equations.

catch_clause_algorithm:
catch "(" exception declaration ")"
{ statement ";" }

All the exceptions raised during compile time are reported to the user. The exceptions which are caught are
reported as warnings and the un-caught ones are reported as errors.

3

else_catch_clause_algorithm
elsecatch
{ statement ";" }
try_clause_equation
try
{ equation ";" }
( else_catch_clause_equation
| catch_clause_equation
{ catch_clause_equation }
[ else_catch_clause_equation ] )
end try

Exception Handling

In this section we present the design of the exception
handling constructs. The grammar of the try-catch constructs is given below. The grammar follows the style
from the Modelica Specification [6] and uses constructs
defined there. Different try clauses for each of the expression, statements and equations contexts are defined.

catch_clause_equation:
catch "(" exception_declaration ")"
{ equation ";" }

exception_declaration:
type_specifier IDENT
["(" exception_arguments ")"]
exception_arguments:
expression
[ "," exception_arguments ]
| named_arguments

The Modelica Association

else_catch_clause_expression:
elsecatch
{ equation ";" }

Throwing via throw; without any parameter can only
appear inside the catch clause and will throw the currently caught exception. This constraint is not specified

410

Modelica 2008, March 3rd  4th , 2008

-3in the above grammar to keep it simple. Of course, it
could be also checked by the semantics phase.
The try-catch clauses shown here are part of the
various contexts rules in Modelica grammar: expressions, algorithm and equation.

3.1

Exception Handling for Statements

The statement variant has approximately the following
syntax:
try
<statements1>
catch(<exception_declaration>)
<statements2>
end try;

The semantics of a try-catch for statements is as follows: An exception generated from a failure during the
execution of statements1 will lead to the execution
of statements2 if the exception matches the catch
clause.

3.2

The semantics of a try-catch for equations is as follows:
If a failure generating an exception occurs during the
solution of the equations in the set of equations denoted
equations1, then if the catch matches the raised exception, then instead the equations2 set is solved.
The source of the exception can be in the expressions and functions called in equations1, which are
evaluated during the solving process. Certain exceptions might originate from the solver. In that case, a
few selected solver exceptions need to be standardized
and predefined.
The semantics of try-catch for equations is similar
to the one for if-equations, with the difference that the
event triggering the catch block is when an exception is
thrown.
There could be several semantics for try-catch in
equation section and they are discussed in Section 8.

3.4

 Report an error if the catch part tries to catch an exception that will never be thrown.
 Report exceptions that are not caught anywhere
 Generate efficient code for exceptions

try
<expression1>
catch(<exception_declaration>)
<expression2>
end try;

The semantics of a try-catch for expressions is as follows: An exception generated from a failure while executing expression1 will lead to the execution of expression2 if the exception matches the catch clause.

Exception Handling for EOO

What does it mean to have exception handling for equation-based models? For example, if an uncaught exception, e.g. division by zero, occurs in any of the expressions or statements executed during the solution of the
equation-system generated from the model, the catch
could handle this, e.g. by simulating an alternative
model (providing alternate equations), or stopping the
simulation in a graceful way, e.g. by an error-message
to the user. The number of equations within the try construct must be the same as the number of equations in
the catch part. This restriction is needed because models must be balanced. Of course, the restriction does
not apply for the catch parts that only terminates the
simulation and reports an error.
The syntax of the equation variant is as follows:
try
<equations1>
catch(<exception_declaration>)
<equations2> | <terminate(...)>
end try;

The Modelica Association

Exception Handling and external functions

The compiler should be able to check the exceptions in
order to:

Exception Handling for Expressions

The syntax of the expression variant is as follows:

3.3

Exception Handling for Modelica

The compiler can find automatically at compilation
time what exceptions are thrown from models and
functions defined in Modelica. However, the compiler
must be provided with additional help when it comes to
external functions. Therefore, when declaring external
functions, the exceptions that might be thrown by them
have to be declared too.
We could model this additional information in two
ways: directly in the grammar or as annotations.
Directly in the grammar as part of the element_list (check the Modelica grammar for the element list specification) of the function or model:
throws_declaration:
throws name { "," name } ";"

Is not really needed to specify in the grammar the possible exceptions to be thrown, we could use annotations
instead:
annotation(throws={name1, name2, ... };

Names used above are constructed according to name
grammar rule specified in the beginning of this section.
In the literature this feature of the compiler (or the
language) is called Checked exceptions [18].

411

Modelica 2008, March 3rd  4th , 2008

A. Pop, K. Stavaker, P. Fritzson

4

-4-

Transforming matchcontinue Fail
Semantics

The current MetaModelica language extension has a
simple fail semantics: fail exceptions can be thrown
explicitly (via a fail() call) or implicitly (e.g., via a
failure due to no patterns matching in a called function), and be caught/handled within the subsequent
case(s) in the matchcontinue construct matching the
same pattern.
The matchcontinue construct can be transformed
into a match-expression that does not have the continue
semantics after a failure, however requiring that the fail
exception is caught in the same case branch.

5.1 Exceptions as Types
We can model exceptions as a built-in Modelica type
Exception. A pseudo-class declaration of such a type
and its usage would look like:
type Exception
// the value of the exception is
// a string, accessed directly
StringType value
end Exception;
// Defining a new exception
type E1
extends Exception;
end E1;
// Instantiate new exception
E1 e1 = "exception E1";
// Raise new exception
throw e1;

Example:
matchcontinue x local ...
case Plus(a,b) equation
// raise
...generateFailureException...
case Plus(a,b) equation
// Catch
handleFailure(a,b)
case _ handle_All_Inclusive_case();
end matchcontinue

// Adding more information to an exception
type E2
extends E1;
parameter String moreInfo;
end E2;
// Instantiate the exception
E2 e2(moreInfo="E2 add") = "exception E2";

can be transformed into the following:

// Throw exception
throw(e2);

match x local ...
case Plus(a,b) equation
try
...generateFailureException...
catch(Fail fail)
handleFailure(a,b)
end try;
case _ handle_All_Inclusive_case();
end match;

try
...
catch(E2 e2)
// here you can access the
// e2 value directly
// but you cannot access e2.moreInfo

This transformation will be supported by a refactoring
tool to transform existing code based on matchcontinue constructs into faster and clenrer code based on
the match construct combined with exception handling. Such transformation will speed up the OpenModelica compiler, by removing many uses of matchcontinue with repeated matching due to overlapping
patterns.

5

catch(E1 e1)
// here you can access the
// value of e1 directly
end try;

Because we extend a basic type, it is possible to add
more information to the exception, but this information
cannot be accessed via dot notation.

5.2

Exceptions as Records

Another way to model exceptions is as Modelica records.

Exception Values

In this section we discuss different ways of representing exception values in Modelica. In general exceptions
are values of a user defined type. Certain exceptions,
such as DivisionByZero or ArrayIndexOutOfBounds are predefined. The user should be able to define exceptions hierarchically (i.e. packages of exceptions) and use inheritance to add extra information
(components) to existing exceptions, thus creating specialized exceptions.

record Exception
parameter String message;
end Exception;
// defining a new exception
record E1
extends Exception(message="E1");
parameter String moreInfo;
end E1;
// instantiate new exception
E1 e1(moreInfo="More Info");
// raise new exception
throw(e1);

The Modelica Association

412

Modelica 2008, March 3rd  4th , 2008

-5-

catch(E2 e2)
// here you can access e.message
// and e.moreInfo
catch(E1 e1)
// here you can access e.message
end try;

// Try and catch
try
...
catch (E1 e1)
// here you can access e.message
// and e.moreInfo
catch (Exception e)
// here you can access e.message
end try;

Having a specific restricted class for exceptions would
have the following advantages:

Modeling exceptions as records has many of the desired properties that a user might want. The problems
we see here are that:
 Is not very intuitive to throw and catch arbitrary records.
 The hierarchical structure is partly lost during flattening, which means that for the records used in the
throw/try-catch constructs this information should
be preserved.
 The inheritance hierarchy is flattened for records
and one would like to keep it intact to be able to
catch exceptions starting from very specific (at the
bottom of the inheritance hierarchy) to more general
(at the top of the inheritance hierarchy)
We think that a better approach is with a new restricted
Modelica class called exception.

5.3

 Throwing and catching only values of restricted
class exception is more intuitive than using records.
 Both the structural hierarchy and the inheritance hierarchy of the exceptions can be kept during flattening and translated to C++, Java, Standard ML or
OCaml code more easily.
 The type checking of throw and try-catch constructs
would be more specific and straightforward.

6

 Only restricted classes of type exception can be
thrown.
 When elaborating declarations of restricted class
exception the subtype relationship applies only if
there is specific inheritance relation between exceptions. This is needed because the exceptions have to
be matched by name and have to be ordered so that
the most specific case (supertype) is first and the
least specific (subtype) is last in a catch clause.
 When translation declarations of restricted class exception there will be no flattening of the inheritance
hierarchy.
 When elaborating catch clauses the compiler has to:
i) match the exception by name, ii) reorder the catch
clauses in the inverse order of the inheritance relation between exceptions or give an error if the less
specific exceptions are matched before the more
specific ones.
 The compiler has to check if an exception specified
in the catch clause will actually be thrown from the
try body or not. If such exception is not thrown the
compiler can either discard the catch clause or issue
a warning/error at that specific point.

We believe that the best way to model exceptions in
Modelica is by extending the language with a new restricted class called exception. Moreover, similar design choices have been made in Java or Standard ML,
with their predefined exception types. In Java one can
only throw objects of the java.lang.Throwable and
its superclass java.lang.Exception. The C++ language allows throwing of values of any type. In Standard ML and OCaml exceptions values and their type
need to be defined using a special syntax.
Exceptions can be represented in Modelica as a new
restricted class in the following way:
exception E1
parameter String message;
end E1;
E1 e1(message="More Info");
throw(e1); // raise new exception
// defining a new exception
exception E2
extends E1(message="E2");
parameter String moreInfo;
end E2;

try
...

The Modelica Association

Typing Exceptions

Modelica features a structural type system, which
means that two structures can be in the subtype relationship even if they have no explicit inheritance specified between them.
The type checking procedure for exceptions has to
be different than for all the other constructs, namely:

New Restricted Class: exception

// instantiate new exception
E2 e2(moreInfo="More Info");
throw(e2); // raise new exception

Exception Handling for Modelica

With these new rules the typing of exception declarations, exception values and catch clauses can be
achieved. After the translation, the runtime system and
the language in which was implemented (C++, Java,

413

Modelica 2008, March 3rd  4th , 2008

A. Pop, K. Stavaker, P. Fritzson

-6-

Standard ML) will provide the rest of the checking for
exceptions.

7

Both the structural and the inheritance hierarchy of the
exceptions are passed through the OpenModelica compiler until C++ code is generated.

Implementation

Modelica Code
with Exceptions

In this section we briefly present the OpenModelica
implementation of exception handling. When referring
to Exception Hierarchy we mean both the structural
hierarchy and the inheritance hierarchy.

Parse

Modelica Code
with Exception handling and
Exception Hierarchy

Absyn

SCode
SCode

Inst

FlatModelica Code
with Exception handling and
the Exception Hierarchy

DAE Functions

DAE Eq/Alg

CodeGen

DAELow

C++ Functions

DAELow

SimCodeGen
DAE with Exception handling
and the Exception Hierarchy

C++ Simulation Code

C++ Code and
C++ Exception handling and
C++ Exception Hierarchy
C++ Code and
C++ Exception handling and
C++ Exception Hierarchy

Figure 2. OpenModelica implementation.

7.2
Figure 1. Exception handling translation strategy.

7.1

Overview

The general translation of Modelica with exception
handling follows the path described in Error! Reference source not found.. The exception handler and the
exception hierarchy are passed through the compiler via
the intermediate representations of each phase until the
C++ code is generated (or any other language code
used in the backends of different Modelica compilers).
The specific OpenModelica translation path for
Modelica code with exception handling is presented in
Figure 2.

The translation from the internal representation to C++
code is straightforward: a Modelica exception maps to
a C++ class. For example, the following Modelica code
with exceptions:
exception E
parameter String message;
end E;
exception E1
extends E(message="E1");
parameter Integer id = 1;
end E1;

is translated into the following C++ code:

Exception handling in OpenModelica required the following extensions:
 The parser was extended with the proposed exception handling grammar.
 Each intermediate representation of the OpenModelica compiler was augmented with support for exceptions.

The Modelica Association

Translation of Exception values

414

class E
{
public:
modelica_string message;
E(modelica_string message_modification)
{
message = message_modification;
}
E()
{ message = ""; }
}

Modelica 2008, March 3rd  4th , 2008

Exception Handling for Modelica

-7-

class E1 : public E
{
public:
modelica_integer id;
E1(modelica_string message_modification,
modelica_integer id_modification)
{
message = message_modification;
id = id_modification;
}
E1()
{
message = "E1";
id = 1;
}
}

The following Modelica code for exception instantiation and exception throwing:

Modelica
Statements

C++

try
<statements>
catch(E e)
<statements>
end try;

try
{
// Modelica
// corresponding
// C++ statements
}
catch(E *e)
{
// Modelica
// corresponding
// C++ statements
}

Modelica
Equations

C++

try
<eqnsA>
catch (Ex1 e1)
<eqnsB>
end try;

E e; throw(e);
E1 e1; throw(e1);
E1 e2(message="E2", id=2);
throw(e2);
E1 e3(message="E3");
throw(e3);

is translated to the following C++ code:

try
<eqnsC>
catch (Ex2 e2)
<eqnsD>
end try;

E *e = new E(); throw e;
E1 *e1 = new E1(); throw e1;
E1 *e2 = new E1("E2", 2);
throw e2;

event1=false;
event2=false;
while time < stopTime
{
try{
call SOLVER for problem:
if event1
then
eqnsB;
else
eqnsA
end if;
if event2
eqnsD;
else
eqnsC;
end if;

E1 *e3 = new E1();
e3->message = "E3;
throw e3;

}
catch(Ex1 *e1)
{
discard posible
calculated current
step values;
reinit the solver
with previous step
values;
event1 = true;
}
catch(Ex2 *e2)
{
discard posible
calculated current
step values;
reinit the solver
with previous step
values;
event2 = true;
}

Is also possible to represent exception values in C++ as
objects allocated on the stack, i.e.: E1 e2("E2", 2);.

7.3

Translation of Exception handling

The C++ exception handling code follows the Modelica
code. The table below defines the translation procedure
for Modelica including the MetaModelica extensions.
Modelica
Expressions

C++

x :=
try
exp1
catch(E e)
exp2
end try;

modelica_type temp;
try
{
temp = exp1;
}
catch(E *e)
{
temp = exp2;
}
x = temp;

The Modelica Association

}

8

Further Discussion

During the design and implementation of exception
handling we have encountered various issues which we
will present in this section. The exception handling in

415

Modelica 2008, March 3rd  4th , 2008

A. Pop, K. Stavaker, P. Fritzson

-8-

expressions and algorithm sections are straightforward.
However when extending exception handling for equation sections there are several questions which influence the design choices that come to mind:
Questions: Is the exception handling necessary for
equation sections? If yes, what are the semantics that
would bring the most usefulness to the language?
Answers: We believe that exception handling is necessary in the equation sections at least to give more useful
errors to the user (i.e. with terminate(message) in
the catch clause) or to provide an alternative for gracefully continuing the simulation. Right now in Modelica
there is no way to tell where a simulation failed. There
are assert statements that provide some kind of lower
level checking but they do not function very well in the
context of external functions. As example where alternative equations for simulation might be needed we can
think of the same system in different level of detail.
Where the detailed system can fail due to complexity
and numerical problem the simulation can be continued
with the less complex system.

lieve in the need for a well designed exception handling
in Modelica. By adding exception handling constructs
to the language we get a more complete language and
provide the developer with means to better control exceptions. There are several issues that have to be considered when designing and implementing these constructs which we have discussed in this paper.

10 Acknowledgements
This work has been supported by Swedish Foundation
for Strategic Research (SSF), in the RISE and VISIMOD projects, by Vinnova in the Safe and Secure
Modeling and Simulation project.

References

Semantics of try-catch in equation sections
Several semantics can be employed to deal with trycatch clauses in equation sections:
1. Terminate the simulation with a message (as we
show in application section)
2. Continue the simulation with the alternative equations from the catch clause activated and the ones
from the try-body disabled. When the exception
occurs the calculated values in that solver step are
discarded and the solver is called again with previous values and the alternative from the catch
clause.
3. Signal the user that an exception occurred and restart the simulation from the beginning with the
catch-clause equations activated.
4. When an exception occurs, discard the values calculated in the current step and activate the alternative equations from catch-clause. However, at the
next step try again the equations from the try-body.
This will make the catch-clause equation active
only for the steps where an error might occur.
We think that the most useful design for exception
handling in equation section is the one that has both
features 1 and 2 active.

9

Conclusions

We have presented the design and the implementation
of exception handling for Modelica. We strongly be-

The Modelica Association

416

[1] Peter Fritzson, Peter Aronsson, Hkan Lundvall,
Kaj Nystrm, Adrian Pop, Levon Saldamli, and
David Broman. The OpenModelica Modeling,
Simulation, and Software Development Environment. Simulation News Europe, 44/45, Dec
2005.
http://ww.ida.liu.se/projects/OpenModelica
[2] Peter Fritzson. Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1, 940
pp., Wiley-IEEE Press, 2004. See also:
http://www.mathcore.com/drmodelica
[3] Paul Hudak. The Haskell School of Expression.
Cambridge University Press, 2000.
[4] Kenneth C. Louden: Programming Languages,
Principles and Practice. 2:nd edition, Thomson
Brooks/Cole, 2003, (ISBN 0-534-95341-7)
[5] Peter Fritzson, Adrian Pop, and Peter Aronsson.
Towards Comprehensive Meta-Modeling and
Meta-Programming Capabilities in Modelica. In
Proceedings of the 4th International Modelica
Conference, Hamburg, Germany, March 7-8,
2005.
[6] The Modelica Association. The Modelica Language Specification Version 3.0, September
2007. http://www.modelica.org.
[7] Mikael Pettersson. Compiling Natural Semantics.
PhD thesis, Linkping Studies in Science and
Technology, 1995.
[8] Peter van Roy and Seif Haridi. Concepts, Techniques, and Models of Computer Programming.
MIT Press, 2004.
[9] IEEE Standards Information Network. IEEE 100
The Authoritative Dictionary of IEEE Standards
Terms. IEEE Press, New York, USA, 2000.

Modelica 2008, March 3rd  4th , 2008

-9-

Exception Handling for Modelica

[10] Christen E. and K. Bakalar. VHDL-AMS-a
hardware description language for analog andmixed-signal applications, In 36th Design Automation Conference, June 1999
[11] Oh Min and C.C. Pantelides (1996) "A Modeling
and Simulation Language for Combined Lumped
and Distributed Parameter System." Computers
& Chemical Engineering, vol 20: 6-7. pp. 611633 1996.
[12] Xavier Leroy et al., The Objective Caml system.
Documentation and users manual, 2007,
http://caml.inria.fr/pub/docs/manual-ocaml
[13] Robin Milner, Mads Tofte, Robert Harper and
David MacQueen, The Definition of Standard
ML, Revised Edition, MIT University Press, May
1997, ISBN: 0-262-63181-4
[14] Bjarne Stroustrup: The C++ Programming Language (Special Edition). Addison Wesley. Reading Mass. USA. 2000. ISBN 0-201-70073-5.
1029 pages. Hardcover.
[15] James Gosling, Bill Joy, Guy Steele, and Gilad
Bracha. The Java Language Specification,
Third Edition, ISBN-13: 978-0321246783, Prentice Hall, June 2005.
[16] Peter Bunus. Debugging Techniques for Equation-Based Languages. Ph.D. Thesis No. 873,
Linkping University, 2004
[17] David Broman. Safety, Security, and Semantic
Aspects of Equation-Based Object-Oriented Languages and Environments. Licentiate Thesis,
Thesis No. 1337, Linkping University, December, 2007.
[18] Exception Handling:
http://en.wikipedia.org/wiki/Exception_handling

The Modelica Association

417

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

418

Modelica 2008, March 3rd  4th , 2008

Session 4b
Thermodynamic Systems & Applications

The Modelica Association

419

Modelica 2008, March 3-4, 2008

The Modelica Association

420

Modelica 2008, March 3rd  4th , 2008

Modelling of the Gasification Island with Modelica

Modeling of the Gasification Island with Modelica
1

Julia Fahlke1
Stephan Pschel1
Frank Hannemann2 Bernd Meyer1
TU Bergakademie Freiberg, Institut fr Energieverfahrenstechnik und Chemieingenieurwesen
Fuchsmhlenweg 9, Haus 1, 09596 Freiberg
2
Siemens Fuel Gasification Technology GmbH
Halsbrcker Strae 34, 09599 Freiberg
Julia.Fahlke@iec.tu-freiberg.de

Abstract
For the modeling and simulation of the Gasification
Island a new Modelica library GasificationIsland
was developed. Therefore new components had to be
generated, like the gasifier or the components of the
pneumatic feeding system. The developed models
are based on the Modelica_Fluid and the Modelica.Media libraries. In this paper the structure of the
most important component models and the main
modeling assumptions are illustrated.
Keywords: Gasification Island modeling; SFG

1

Introduction

Figure 1: usage of the syngas from the gasification [1]

The gasification process is of great importance for
the electrical and basic chemical industry as it converts any carbon-containing material into a synthesis
gas (syngas) composed primarily of carbon monoxide and hydrogen. This syngas can be used as a fuel
in a combined cycle to generate electricity (Integrated Gasification Combined Cycle). But it can also
be used as a basic chemical for a large number of
The Modelica Association

syntheses in the petrochemical and refining industry,
like Methanol or Fischer Tropsch Synthesis (Figure
1). The modeling of the gasification process is till
this day a great challenge.

1.1

The gasification process

Gasification means the thermo-chemical conversion
of fuels with a reactant to a combustible gas, which
is rich of the components CO, H2 and CH4. The most
proceeded reactions are partial oxidation procedures,
which take place with oxygen in free (elemental) or
bounded form (H2O, CO2). These partial oxidations
are interfered in dependence of the process and the
process parameters with pyrolysis or devolatilization
and hydrogenation processes [2].
The gasification process can be divided into different
types according to the gasification agent/heat supply
(autothermic, allothermic or hydrogenating gasification), the gas-solid-contacting (fixed/moving bed,
fluidized bed or entrained flow gasification) or concerning the process temperature (above or below ash
melting point).
This paper deals with the SFG gasification process,
which is an autothermic, entrained flow gasifier with
temperatures in the gasifier above the ash melting
point.
In the gasification process a large number of reactions take place. Principle chemical reactions are
those involving carbon, carbon monoxide, carbon
dioxide, hydrogen, water (or steam) and methane [3]:
combustion reactions

C + 0.5 O2  CO

-111 MJ/kmol

CO + 0.5 O2  CO2

-283 MJ/kmol

H 2 + 0 .5 O 2  H 2 O

-242 MJ/kmol

421

Modelica 2008, March 3rd  4th , 2008

J. Fahlke, S. Puschel, F. Hannemann, B. Meyer

gasifying agent and steam as temperature moderator
into a raw gas. Minerals in the fuel are separated and
leave the bottom of the gasifier as an inert glass-like
slag. The raw gas is cooled down and saturated in the
quench. Afterwards it flows in the venturi wash and
in the partial condenser, where the raw gas is cooled
down and the solid particles are separated from the
raw gas.

Boudouard reaction

C + CO2  2 CO

+172 MJ/kmol

water gas reaction

C + H 2 O  CO + H 2

+131 MJ/kmol

methanation reaction

C + 2 H 2  CH 4

-75 MJ/kmol

2

CO shift reaction

CO + H 2 O  CO2 + H 2

-41 MJ/kmol

steam methane reforming reaction

CH 4 + H 2 O  CO + 3 H 2

+206 MJ/kmol

Most fuels contain additional components beside
carbon, hydrogen and oxygen, e.g. sulfur, nitrogen or
minerals. Sulfur in the fuel is converted into H2S and
COS and the nitrogen into elemental nitrogen, NH3
or HCN.

1.2

The SFG Gasification Island

The SFG Gasification Island consists of the SFG
gasifier itself, the pneumatic feeding system and the
gas treatment system (Figure 2).

GasificationIsland Library Overview

The GasificationIsland library is an in-house Modelica library for the transient simulation of the Gasification Island process. The library is designed in a
joint project with Siemens Fuel Gasification Technology GmbH Freiberg. The intention of the project
is to apply these models to analyze the behavior of
the different sub-processes as well as the whole
Gasification Island at load changes or disturbances
and to test new control strategies (see chapter 4).
Furthermore the library shall be utilized in the plant
shop tests prior real commissioning on site.
The developed models are based on the Modelica_Fluid and the Modelica.Media libraries.
The library is divided into functional sub-packages.
In Figure 3 a screen shot of the first hierarchical
level of the library is shown.

Figure 3: screen shot of the GasificationIsland library
in the package browser

Figure 2: SFG Gasification Island [4]

The solid fuel (e.g. coal) is fed into the SFG-Reactor
through a pneumatic feeding system. In the reactor
the carbon rich fuel will be partially oxidized under
high pressure and under the addition of oxygen as
The Modelica Association

The Media package contains all the used media
models like raw gas, slag or coal. The solids are
simulated as media with constant properties, like the
ConstantPropertyLiquidWater
in
the
Modelica.Media library.
The package LockHopperSystem includes all component models of the pneumatic feeding system, e.g.
lock hopper, storage bin or feeding vessel.

422

Modelica 2008, March 3rd  4th , 2008

Modelling of the Gasification Island with Modelica

The packages Reactor/Quench comprise the models
of the gasification reactor and the quench.
The SlagDischarge package includes the models of
the slag hopper and the flushing tank.
The GasTreatment package contains models of the
venturi scrubber, partial condenser and drums.
The Controller package includes the sequence control of the batch processes for the pneumatic feeding
system and the slag discharge system. The controllers were modeled by the Modelica.StateGraph library.
The package Model comprises the different simulated sub processes of the gasification island and a
model of the complete process.

implementation of a storage bin with six outlets in
the Dymola Diagram Layer.

In the following section the structure and the main
modeling assumptions for some selected components
will be illustrated.

3

Figure 5: screen shot of the Implementation of a storage bin with 6 outlets in the Dymola Diagram Layer

Developed Models
3.1

For the outlet ports the coal mass flow is defined.
The following function is used [5]:

Lock Hopper System

3.1.1 Storage bin
d
 0.1 A

m& c ,out = 0.3  1  e d P



There d A is the diameter of the lock hopper outflow,

Figure 4: screen shot of the storage bin icon

d P is the mean diameter of the coal particle,  P is

The storage bin should ensure the uninterrupted service of the gasification reactor with coal. The storage
bin works at ambient pressure.
In practice the pneumatic feeding system consists of
more then one lock hopper, so the storage bin needs
as many outlets as lock hoppers exist. For solid flow
the outlet form is conical (Figure 4). To simulate the
filling level of this geometrical form the storage bin
was divided into segments. The single segments are
connected through valves. These valves have a huge
Kv flow coefficient and ensure the mass flow between the segments. So it can be guaranteed that the
filling level in each storage bin segment is the same.
There is only one exception: if the filling level is
lower than the high of the cone no more mass transfer between the segments occurs. This is realized by
setting the outlet pressure of the segment connections to a defined minimum value. Furthermore the
inlet flow is split to the segments. Figure 5 shows the
The Modelica Association

   g 0.5  d 2.5 0.5
A
 P
h 
 tan( )   0.36


the particle density,  is the repose angle,  is the
cone angle and h is the fill level of the coal.

3.1.2 Lock Hopper

Figure 6: screen shot of the lock hopper icon

For dosing of the pulverized coal into the reactor it is
necessary to bring it into a pressure system that operates at a pressure level higher than the reactor pressure. This is fulfilled by the lock hoppers. Therefore
4 sequences appear:

423

Modelica 2008, March 3rd  4th , 2008

J. Fahlke, S. Puschel, F. Hannemann, B. Meyer

-

filling of the lock hopper with coal until the
maximum level is reached
pressurizing of the coal. Therefore a pressurized inert gas is fed into the lock hopper
discharging of the lock hopper into the feeding vessel
depressurizing of the gas

In the lock hopper are two different media: the gas
and the coal medium. For each a mass balance is
considered but only one energy balance is implemented. Furthermore the wall material is regarded as
a heat storage system and convective heat transfer
between the gas and the wall is implemented.
The level of the coal is determined by the fixed bulk
density.

pressurizing and depressurizing of the feeding vessel
with inert gas.
In the feeding vessel exist three layers: the fluidized
bed, the bulk and the gas layer (Figure 8).

Figure 8: layers in the feeding vessel

From the fluidized bed the coal suspension is fed to
the reactor. It is assumed that the height of the fluidized bed is fixed. Furthermore a functional correlation among the pressure drop between the feeding
vessel and the reactor and the coal mass flow to the
reactor exists. This functional correlation can be
lodged.
In the feeding vessel only one energy balance is considered. The wall material as heat storage system is
neglected because the appeared temperature fluctuations are only small.

model LockHopper

// Total quantities
m_coal = V_coal*coal.d;
m_gas = (V-V_coal)*gas.d;
U = coal.u*m_coal + gas.u*m_gas;
U_wall = m_wall*cp_wall*T_wall;
V_bulk = m_coal/rho_bulk;
Q = alpha*A*(T_wall  gas.T);
//Mass balances
der(m_coal) = in_c.m_flow + out_c.m_flow;
der(m_gas) = sum(in_g.m_flow) + sum(out_g.m_flow);

3.2

//Energy balances
der(U) = in_c.H_flow + out_c.H_flow + sum(in_g.H_flow)
+ sum(out_g.H_flow) + Q;
der(U_wall) = -Q;

end LockHopper;

Reactor

3.2.1 Gasification Reactor
In the gasification reactor the conversion of the coal
into a combustible raw gas occurs.

3.1.3 Feeding Vessel

Figure 7: screen shot of the feeding vessel icon

The pulverized coal is fed from the feeding vessel
into the gasification reactor. Therefore the feeding
vessel remains a constant level of operating pressure
above the reactor pressure. This is done through
The Modelica Association

Figure 9: calculation of the gasifier DLL

424

Modelica 2008, March 3rd  4th , 2008

Modelling of the Gasification Island with Modelica

The gasifier is implemented in a Dynamic Link Library (DLL), which was developed by the Siemens
Fuel Gasification Technology GmbH Freiberg. In the
DLL the thermodynamic equilibrium is calculated.
Therefore the equilibriums for the reversible reactions mentioned in chapter 1.1 are calculated.
Figure 9 shows the in- and outputs of the gasifier
DLL.

For the calculation of the saturated steam fraction the
following equation is used:

 Steam =

p S , S (TG )  M s
pG  M G

 Steam is the mass fraction of steam, p S ,S (TG ) is the
saturation vapor pressure at the temperature TG , pG

3.2.2 Quench

is the gas pressure and M S , M G are the molar
masses of steam and the gas.
The vaporization flow has to be regarded in the mass
balances of the water and the gas in the gas space.
Furthermore the heat of vaporization has to be taken
into account in the energy balance of the gas space.

Figure 10: screen shot of the quench icon

In the quench the raw gas from the reactor is cooled
down and saturated.
The quench consists of two zones the gas space and
the sump. For each zone own mass and energy balances are considered. However convective heat
transfer between the raw gas in the gas space and the
water in the sump is assumed. In the gas space the
raw gas from the reactor is saturated and therefore
cooled down. This is done by the injection of fresh
water at the top of the quench (Figure 11).

model quench

//mass balances gas space
der(m_gas) = in_g.m_flow + out_g.m_flow + m_ue;
der(mXi[s]) = in_g.mXi_flow[s] + out_g.mXi_flow[s] +
m_ue;
0 = in_w.m_flow + out_w.m_flow  m_ue;

//energy balance gas space
der(U) =  - delta_hv*m_ue;

//calculation of the saturated steam fraction
gas.Xi[s] = p_steam*M_s/gas.p*gas.MM;
p_steam = saturationPressure(gas.T);

end quench;

3.3

Gas Treatment

3.3.1 Venturi Scrubber System

Figure 12: screen shot of the venture scrubber icon

Figure 11: mass flows at the quench

In the gas space one energy balance for the media
water, slag and gas is regarded.

The Modelica Association

The venturi scrubber system is located between the
quench and the partial condenser. It consists of a
venturi jet and a drum. The venturi jet is a pressure
drop component. There are two different types of
venturis: controlled and uncontrolled.

425

Modelica 2008, March 3rd  4th , 2008

J. Fahlke, S. Puschel, F. Hannemann, B. Meyer

The raw gas, which leaves the venturi scrubber system, is saturated. For the calculation of the saturated
gas properties the same equations as in the quench
are used.

- depressurizing of the slag hopper
- drawdown of the slag hopper
As in the below explained components only one energy balance is considered.

3.3.2 Partial Condenser

3.5

For every component the temperature and the filling
levels can be defined. For the components which
cover to the saturation of gas the dry gas composition and for all other components the gas composition have to be deposited.
Furthermore the user can decide for each component
if the pressure should be initialized or not.

Figure 13: screen shot of the partial condenser icon

The partial condenser is located between the venturi
scrubber system and the synthesis gas system. There
the raw gas is cooled down and the condensate is
separated. The raw gas leaving the partial condenser
is saturated.
For the calculation of the gas properties the same
equation as in the quench were used. Furthermore
the energy balance equation is enlarged by the heat
loss flux Q& . This heat flux is a real input value. It
should be so adjusted that the temperature difference
between the inlet and the outlet of the partial condenser reaches a given value.

3.4

Slag Discharge System

3.4.1 Slag Hopper

Figure 14: screen shot of the slag hopper

The function of the slag hopper is to discharge the
slag from the pressurized system of the quench into
the atmospheric pressure environment. Therefore 5
steps appear:
- filling of the slag hopper with water
- pressurizing until the pressure of the quench
is reached
- filling of the slag hopper with slag (thus lead
to a displacement of water from the slag
hopper into the quench)

The Modelica Association

Initialization

4

Simulation Results

As mentioned in the introduction the developed
models shall be used to enhance process control.
Therefore existing control methods can be verified
and in addition tests of advanced process control
conceptions like kinds of MPC (Model Predictive
Control) and virtual sensors are allowed.
The Gasification Island contains a multitude of control systems:
- level control systems
- temperature control systems
- pressure control systems
- mass flow rate control systems
In cooperation with the Siemens Fuel Gasification
Technology GmbH Freiberg, analyses were carried
out on how far advantages appear by applying the
advanced process control strategies in comparison to
the accepted PID controllers. As an example of use
the coal mass flow control system from the feeding
vessel to the reactor was chosen due to the occurred
dead times. Furthermore this mass flow control system is of great importance to the gasification process, because of its impact to the quality (temperature,
composition) of the formed raw gas.
The following two figures show the results of some
simulations. Figure 15 shows the step response of the
controlled coal mass flow for an accepted PI controller and a model based controller. To avoid overshooting both, controllers were designed for aperiodic transient behavior (this is an arbitrary chosen
design case and doesnt reflect the behavior of the
implemented control system in the gasification
plant). The response of the system for a ramp like

426

Modelica 2008, March 3rd  4th , 2008

Modelling of the Gasification Island with Modelica

change of the coal mass set point is given in Figure
16.
Both figures show that the coal mass flow can be
significantly enhanced for this control system design
case by using advanced process control concepts.
The control tests were done in Matlab. Therefore, the
developed Modelica/Dymola models were converted
into a Simulink model.

Abbreviations
SFG

Siemens Fuel Gasifier

References
[1]
[2]

[3]

[4]

Figure 15: step response of the coal mass flow at sudden change of the coal mass flow set point value (arbitrary chosen design case: aperiodic transient behavior
of the controllers)

[5]
[6]
[7]

http://www.gasification.org
Klose, E.; Toufar, W.: Grundlagen der Vergasung, 1. Lehrbrief. Lehrbriefe fr das
Hochschulfernstudium, 1985
Higman, C.; van der Burgt, M.: Gasification.
Gulf Professional Publishing, Amsterdam,
2002
Hannemann, F.: Siemens Fuel Gasification
Technology at a Glance. Virtuhcon Workshop 2007, Freiberg, Germany
Heyde, M.: Fluidisieren von Schttungen.
http://www.fossil.energy.gov
Casella, F.; Otter, M.; Proells, K.; Richter,
C.; Tummescheit, H.: The Modelica Fluid
and Media Library for Modelling of Incompressible and Compressible Thermo-Fluid
Pipe Networks. 5th International Modelica
Conference Proceedings, 2006

Figure 16: ramp like change of the coal mass flow set
point (arbitrary chosen design case: aperiodic transient behavior of the controllers)

5

Conclusion and future work

The Gasification Island was developed in the Modelica language. Therefore new components were designed which are based on the Modelica_Fluid and
Modelica.Media libraries. First analyses were done
to enhance the process control of the coal mass flow
from the feeding vessel to the reactor.
The further step is to enhance the gasifier model.
Therefore the reaction kinetics of the reactions listed
in 1.1 and the complex heat balance (heat radiation,
convective heat transfer ) will be implemented.

The Modelica Association

427

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

428

Modelica 2008, March 3rd  4th , 2008

Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration Cycles

Transient Modelling of a Controllable
Low Pressure Accumulator in CO2 Refrigeration Cycles
Marcos Bockholt1 Wilhelm Tegethoff1 Nicholas Lemke2
Nils-Christian Strupp1 Christoph Richter1
1 Technical

University Braunschweig, Institute of Thermodynamics
Hans-Sommer-Str. 5, 38106 Braunschweig
Email: m.bockholt@tu-bs.de
2 TLK-Thermo

GmbH
Hans-Sommer-Str. 5, 38106 Braunschweig
Email: n.lemke@tlk-thermo.de

Abstract
Low pressure accumulators are usually employed in
mobile R744 HVAC units to assure reliable operating
conditions and consequently to extend equipment life.
Furthermore, the design parameters of accumulator,
e.g. the oil bleed hole, influence the coefficient of performance (COP) of the refrigeration cycle. A poorly
designed accumulator may lead to inefficient refrigeration cycles. Thus, accumulators with a variable oil
bleed hole, also called controllable accumulators, may
be employed to bring the system to optimal operating condition assuring good performance. The aim
of this work is to implement a semi-empirical physically based transient Modelica controllable accumulator model, which is part of TIL (the TLK-IfT-Library).
Transient simulations are carried out to evaluate the
impact of a controllable accumulator in an automotive
refrigeration system.
Keywords: controllable accumulator; refrigeration
cycle control; COP optimisation; fluid systems

1

Introduction

On January 2006 the EU agreed to vanish HFC-134a
from air conditioning systems of new vehicle models
from 1 January 2011. The natural refrigerant R744
is one of the promising candidates to replace R134a.
Therefore, the actual vehicle refrigeration technology
has to be optimized to reach the efficiencies using
R134a. In fixed orifice tube R744 air-conditioning systems a low pressure accumulator is usually placed at
The Modelica Association

the compressor inlet in order to store excess refrigerant, allowing an optimum system performance under
various ambient conditions and compensating refrigerant loss through leakage along the life cycle. The
refrigerant quality at the accumulator inlet is also influenced by the oil bleed hole located in the J tube
of the accumulator, see e.g. Fig. 3. The size of the
oil bleed whole is an optimization parameter in accumulator design and should be variable to attend optimum performance for different operating conditions
and avoid high compressor outlet temperatures. This
variability of the oil bleed hole can be put into practice
by building a controllable accumulator.

2

TIL

TIL is a new component model library for thermodynamic systems that was developed by the Institute for
Thermodynamics (IfT) and the TLK-Thermo-GmbH
and that allows for the steady-state and transient simulation of thermodynamic systems. The underlying
design principles as well as a detailed description of
selected component models is given by [4].
TIL provides component models for the simulation
of refrigeration, air-conditioning, and heat-pump systems. Many component models use a formulation of
the balance equations that is similar to the balance
equations for the accumulator as presented in the following section. TIL uses the object-based fluid property library TILFluids for the computation of fluid
properties. This fluid property library uses a generalized approach to include external fluid property com-

429

Modelica 2008, March 3rd  4th , 2008

M. Bockholt, W. Tegethoff, N. Lemke, N.-C. Strupp, C. Richter

putation codes (e.g., REFPROP) in Modelica and a
number of software tools.

3

d
( Vkv ) = min + mTout + mBout
dt
d
= min + mTout + mBout
Vkv 
dt

Mathematical Modelling

Fig. 1 shows the control volume of the semi-empirical Using the Bridgmanns table the derivative d above
dt
accumulator model Vkv . The following assumptions can be split into:
are made:
 
 
 d  dh  d  d p
d


=   
+  
 The accumulator has adiabatic walls.
dt
dh p dt  d p h dt
 
 
 
 d 
 The control volumes Vkv1 are constant in time.
The partial derivatives  d
and
 d p  are modeled in

dh
p

h

 Changes of kinetic and potential energy are not TILFluids for the one phase and two phase regions.
taken into account.
3.1.2 Energy Balance
 The accumulator characteristics regarding the acst.
cumulated mass is modeled according to steady- The 1 Law of Thermodynamics for an opened sysstate characteristic curves. The characteristic di- tem in its transient form is applied to the control vol1
agram determines the outlet enthalpy depending ume Vkv resulting in the following differential equation:
on the filling level.
 The accumulator outlet enthalpy may be changed
by opening the oil bleed hole.

INLET

min
.

.

. T

.T

H Tin

mTout m in

.

(p,h)

H out

Hin

.

mout
.

.

Hout
.

1
Vkv

Filling
level

m=V . 
kv

. B
mout

.B
H out

mB

in

.B

Hin

Using the mass balance Eq. 1, the Eq. 2 is rewritten
into:
dh
dt

Oil bleed hole

Figure 1: Controlled accumulator model.

3.1

Vkv2

OUTLET

 Oil fraction in the liquid phase is ignored.

dU
= min  hin + mTout  hTout + mBout  hBout
dt

d
T
B
= Hin + Hout
+ Hout
H  p Vkv1
dt
d
dp
T
B
(m  h) = Hin + Hout
+ Hout
+Vkv1 
dt
dt
dh
dm
d
p
T
B
m +h
= Hin + Hout
+ Hout
+Vkv1 
(2)
dt
dt
dt

Conservative Laws

3.1.1 Mass Balance

=

min + mTout

Eq. 1 can be stated as:
The Modelica Association

+ mBout

1
 [min  (hin  h) + mTout  (hout
T  h) +
m
dp
+ mBout  (hBout  h) +Vkv1  ]
(3)
dt

where h is the enthalpy of the in the accumulator accumulated refrigerant. The system of differential
equa

dh d p dm
tions (see Eqs. 1 and 2) is reduced from dt , dt , dt


dp
to dh
,
using the Bridgmanns table. This formudt dt
lation has been shown to be very efficient for transient
simulations (see [2, 7] for further details).

The transient mass balance equation for the control
3.2
volume Vkv1 is stated as follows:
dm
dt

=

Accumulator

The semi-empirical accumulator model Vkv1 in Fig. 1 is
(1) treated here in detail. Different from the existing TIL
accumulator model, the model extended here is able
to influence the outlet enthalpy and hereby to increase
430

Modelica 2008, March 3rd  4th , 2008

Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration Cycles

I)

Accumulator is nearly empty (  min ): in
this operation point no liquid droplet occurs from
eventually accumulated refrigerant in the receiver
and the refrigerant phases are separated. This
means that if the refrigerant enters the accumulator with quality xin = 0.7 it will leave it with
quality xout = S = 1. The liquid part begins to
accumulate.

II)

Accumulator has a filling level with few liquid
droplets at the outlet (min <   drop ): if the
droplet filling level drop is not reached, a very
small amount of liquid droplets from the accumulated refrigerant occurs at the outlet of the accumulator. The refrigerant phases are still separated and the accumulator outlet quality is the
separation efficiency xout = S . This is the most
common operating condition and will be treated
in the steady state simulation presented in a further section.

III)

Accumulator has a filling level with excess of
liquid droplets at the outlet (drop <   max ):
for this operation point, the accumulated refrigerant in the accumulator has reached a level in
that large amount of accumulated liquid starts to
leave the accumulator. The refrigerant phases
cannot be clearly separated. The outlet enthalpy
starts to decrease and enters the two phase area
(xliq < xout < s < xvap ).

IV)

Accumulator is full ( > max ): if the receiver
reached this filling level, it is then flooded and
there is no separation of the refrigerant phases.
The liquid phase dominates in the receiver and
the outlet enthalpy equals or is small than the saturated liquid enthalpy, i.e. S = 0. This is a vary
rare operation condition and is out of the scope of
this work.

or decrease the level of accumulated liquid refrigerant
by opening the oil bleed hole. Basically, the accumulators physical behavior is characterized by its filling
level, a phase separation efficiency and an empirical
characteristic diagram.
3.2.1 Filling level
The filling level is defined as the liquid fraction of the
accumulated refrigerant:


h  hliq
 = 1
.
(4)
hvap  hliq
where h is the enthalpy of the accumulated refrigerant. The outlet enthalpy at the accumulator top hout
depends on this variable as shown in Sec. 3.2.3.

=


min = 0




 drop






if the accumulator is empty.
if fluid droplets occur
at the accumulator outlet.
max = 1 if the accumulator is flooded
with saturated liquid.

A detailed investigation is described in [5] for different accumulator geometries and operation conditions
using a transparent accumulator.
3.2.2 Separation efficiency S
The accumulator separation efficiency S describes the
ability of an accumulator in separating the refrigerant
phases. It is defined as as follows:
S = xout

(5)

where xout is the accumulator outlet quality when the
accumulator filling level is between the droplet filling
level and the minimum filling level, min    drop .
An ideal accumulator without an oil bleed hole would
have a separation efficiency of 100%, i.e. only refrigerant vapor hvap leaves the accumulator. The separation efficiency is strongly dependent on the oil bleed
hole diameter and is estimated from steady-state measurement data, see [3, 5]. These data show that the
separation efficiency may range from 75% up to 98%.
3.2.3 Characteristic diagram

3.3

Controllable accumulator

The controllable accumulator, is shown as an extension of the ideal accumulator of TIL. A prototype of a
controllable accumulator is presented in Fig. 3. The
J-tube with the oil bleed hole may be modeled by
correlating the oil bleed hole in the J-tube with the
separation efficiency stated in Eq. 5.

The accumulator characteristic diagram is divided in
3.3.1 Oil bleed hole 
four different operating conditions according to its filling level. These operating conditions are drawn as fol- To verify the effect of changing the oil bleed hole
diameter in a standard accumulator a measurement
lows:
The Modelica Association

431

Modelica 2008, March 3rd  4th , 2008

M. Bockholt, W. Tegethoff, N. Lemke, N.-C. Strupp, C. Richter

mrefr.=40 g/s

max



IV

Full
max=1
Liquid
Droplets

III

drop

II

Phases
Separation

min=0

I

Empty
h

liq

drop

450

 min

400

max

350

drop

Accumulator Mass [g]

Filling
level

 min
max
drop
 min
max

250
200
150
100

h liq + S(h - h ) h out drop
vap

300

liq

Measurement 0.8 mm

50

 min

Measurement 1.2 mm

0
0.7

Figure 2: Accumulator characteristic diagram.

0.8

0.9
Quality x [-]

1

1.1

Figure 4: Accumulated mass dependence on the oil
bleed hole, from [5].
J-tube
 max

4

Oil bleed hole

 drop

1

Aeff

To investigate the impact of changing the accumulator efficiency in cycle behavior, a high ambient temperature and idle compressor speed condition for an
automotive air-conditioning is applied. The refrigeration cycle characteristics and boundary conditions are
summarized in the Tabs. 1 and 2. As a first approxi-

2

min
oil

Steady-state simulation results

Total
CO2 mass
[kg]
0.5

e-valve

Figure 3: Accumulator prototype, from [1].

Cycle internal
volume
[l]
1.5

Compressor
displacement
[cm3 ]
28

Table 1: Cycle characteristics

configuration developed by the Institut fr Thermodynamik in Braunschweig, for the purpose of determining the liquid level in low-pressure accumulators
with carbon dioxide as refrigerant is used. The measurements are performed varying the gas cooler outlet temperature yielding a variation of the accumulator
outlet quality, see [5] for further details. In Fig. 4 it is
observed that the accumulator outlet quality decreases
by increasing the oil bleed hole diameter, i.e. reducing the separation efficiency. Thus, the separation efficiency will be used as a variation parameter to control
the accumulator. A physical correlation between the
efficiency and oil bleed hole should be further investigated in future works.
The Modelica Association

Compressor
speed
[rpm]
780

mair
evaporator
[g/s]
140

mair
gas cooler
[g/s]
600

Ambient
Temperature
[C]
40

Table 2: Boundary conditions for an automotive application
mation, the compressor volumetric and isentropic efficiencies as well as the heat transfer coefficients in the
heat exchangers are kept constant for the cycle. The
first step in this analysis is to find out the optimum
operation pressure for the chosen boundary conditions
and different accumulator efficiencies. Fig. 5 shows
how the optimal high pressure varies with the accumu-

432

Modelica 2008, March 3rd  4th , 2008

Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration Cycles

lator separation efficiency. The optimal high pressure
Separation
is reached by setting the valve flow area 0.35 mm2 .
efficiency S
The result of the COP-optimized cycles for three different accumulator separation efficiency are summaState variable Unit
0.78
0.85
0.96
rized in Tab. 3. In Fig. 6 the COP-optimized cycle is
mCO2 cycle
[kg]
0.5
0.5
0.5
shown in the pressure-enthalpy diagram for the accumulators with small, medium and large-sized oil bleed
mCO2 accu
[kg]
0.163 0.185 0.214
hole. The increase in the compressor suction density
xaccu out
[-]
0.78
0.85
0.96
is observed in Fig. 6 at point 1, which is shifted to
the two phase region when decreasing the accumulaTcomp out
[C]
91.4
94.5 100.9
tor separation efficiency. In order to keep the same
mCO2 cycle
[g/s]
37.7
35.1
31.6
suction density at the compressor inlet, an enhanced
internal heat exchanger (IHX) with maximal thermopcomp out
[bar] 125.8 118.2 110.0
dynamic efficiency is used. The result is shown in the
Hair
[kW]
3.38
3.34
3.26
pressure-enthalpy diagram in Fig. 7. Now, a change
on the accumulator efficiency has neither effect on the
IHX Hre f
[kW]
1.4
1.3
1.1
system Coefficient of Performance (COP) nor changes
COP
[-]
1.79
1.89
2.04
its cooling capacity. The points 4 and 5 are shifted to
the left at the same amount as the point 6. This fact
evidences a dependence between the accumulator sep- Table 3: Impact of the separation efficiency in steadyaration efficiency and the IHX heat transfer two-phase state cycle simulation.
heat transfer effects.
Large oil bleed hole

4

2.1

Small oil bleed hole

3

2

Expansion device flow area
for max COP =0.35 mm

2

5

6

1
Small oil bleed hole

COP [-]

1.9

Figure 6: Pressure-enthalpy (p-h) diagram for COPoptimized cycles with large, medium and small oil
bleed hole.

1.8
1.7
Large oil bleed hole

1.6
1.5

S=0.96
S=0.94
S=0.90
S=0.85
S=0.78
max COP

5

Transient simulation of a CO2 refrigeration cycle with a controllable accumulator

In this application, a controllable accumulator is used
to avoid that the temperature at the compressor outlet
90
110
130
150
170
Tcomp out exceeds the oil decomposition temperature,
Compressor outlet pressure [bar]
e.g 160 C. The cycle used previously for the steady
Figure 5: Coefficient of Performance (COP) sensitiv- state simulation, see Fig. 8, is now used in a tranity analysis for different accumulator separation effi- sient simulation, where the compressor speed is set
to n = 2100 rpm and the gas cooler and evaporator
ciencies.
air inlet temperature Tevap in are assumed to be 40C.
Fig. 9 shows the results of the transient simulation
for some of the state variables. At time t = 50 s the
1.4

The Modelica Association

433

Modelica 2008, March 3rd  4th , 2008

Temper...

p, m_dot
gasBound...

gascooler
FinAndTube

duration...

Large oil bleed hole

Gas

dp/dt
(1)

Refrig...

4

3

2

free
gsGasSink

M. Bockholt, W. Tegethoff, N. Lemke, N.-C. Strupp, C. Richter

(1)

IHX
5

6

speed

1
(1)

Small oil bleed hole

dur...

(2)

0

SIM

TubeInTube
counterFlo...

Figure 7: Pressure-enthalpy (p-h) diagram for COPoptimized cycles with large, medium and small oil
bleed hole and enhanced IHX, with heat exchange area
(AIHX  ).

(2)
dp/dt
ramp
Eff. v...
area
(2)

(2)

6

free
evapGasSi...

separation efficiency of the accumulator is decreased
from S =96% to S =78%, compare S = xout in Fig.
9. Some refrigerant mass in the accumulator maccu
is moved to the cycle high-side pressure. The suction density at the compressor inlet increases yielding
a higher compressor shaft power Pcomp . An increase
in Pcomp means a decrease in the system coefficient of
performance COP=Hair /Pcomp as observed in Fig. 9.
The compressor outlet temperature is decreased to a
value smaller than the maximum oil working temperature. The increase in the cycle refrigerant mass flow
rate due to higher compressor suction densities causes
an insignificant increase in the cooling capacity for this
modeling assumptions. The evaporator air outlet temperature Tair evap out increases slightly.

Gas
FinAndTube
evaporator

p, m_dot
evapGasS...

Refrig...

duratio...

controllable
accumulator

Figure 8: CO2 refrigeration cycle with controllable accumulator using component models from TIL.
changers it was observed an increase in the system
COP when closing the oil bleed hole. Otherwise, if
the oil bleed hole is opened the compressor outlet
temperature decreases avoiding the oil temperature to
reach critical limits. A second simulation run showed
that using a nearly optimal IHX the oil bleed hole
variation has no effect in the cycle COP and cooling
capacity.

Conclusion

A transient simulation is carried out for a an automotive air-conditioning boundary condition. As a first
The transient model of a controllable accumulator application, it is shown that the compressor outlet
is presented to investigate the effects of varying the temperature may be kept under the oil critical limit
separation efficiency in an automotive CO2 refrig- without loss of cooling capacity.
eration. The model consists of simple models from
the new component model library for thermodynamic Future work will concentrate on finding an optimal
systems that was developed by the Institute for Ther- relationship between IHX efficiency and accumulator
modynamics (IfT) and the TLK-Thermo-GmbH. The separation efficiency as well an optimal control stratmathematical formulation used in the modeling allows egy for a CO2 refrigeration cycle using this innovaan accelerated analysis of the parametric variation.
tive component. Two-phase heat transfer effects in the
IHX and in the other cycle heat exchangers should be
The results from the steady state simulation show a taken into account in order to predict the cycle behavstrong dependency between the accumulator separa- ior more accurately when varying the accumulator oil
tion efficiency and the internal heat exchanger (IHX) bleed hole. The isentropic and volumetric compressor
efficiency if the system Coefficient of Performance efficiencies should also be mapped more accurately so
(COP) is considered. In a first simulation run with that the cycle mass flow rate and compressor outlet
constant heat transfer coefficients in the heat ex- temperature can be precisely estimated.
The Modelica Association

434

Modelica 2008, March 3rd  4th , 2008

Transient Modelling of a Controllable Low Pressure Accumulator in CO2 Refrigeration Cycles

[3] Raiser H., Heckenberger T., Tegethoff T.,
Frsterling S.: Transient Behavior of R744 Vehicle Refrigeration Cycles and the Influence of the
Suction Side Accumulator Design, SAE International, Nr. 2006-01-0162, 2006.
[4] Richter C.: Proposal of New Object-Oriented
Equation-Based Model Libraries for Thermodynamic Systems, TU Braunschweig, PhD-thesis,
2008
[5] Strupp C., Lemke N., Tegethoff T., Khler J.: Investigation of Low Pessure Accumulators in CO2
Refrigeration Cycles, International Congress of
Refrigeration, Beijing, China, ICR07-E1-1480,
2007.

0.2

[6] Tegethoff W.: Eine objektorientierte Simulationsplattform fr Klte-, Klima- und
Wrmepumpensysteme, PhD thesis, TUBraunschweig, Intitute of Thermodynamics,
1999.
[7] Tegethoff W., Lemke N., Correia C., Cavalcante
P., Khler J.: Component modelling and specification using a new approach for transient simulation, VDA Alternate Refrigerant Refrigerant
Winter Meeting- Automotive Air-Conditioning
and Heat Pump Systems, 2004

Figure 9: Simulation results of the transient controllable accumulator model in a CO2 refrigeration cycle

References
[1] Hirota, H.: Refrigertion cycle, European Patent
Application EP 1607698 A2, TGK Company
Ltd., Tokyo, 2005
[2] Lemke N.: Untersuchung zweistufiger Flssigkeitskhler mit dem Kltemittel CO2 , PhD
thesis, TU-Braunschweig, Intitute of Thermodynamics, 2005.
The Modelica Association

435

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

436

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL

Modeling and Simulation of a Thermoelectric Heat Exchanger
using the Object-Oriented Library TIL
Christine Junior, Christoph Richter, Wilhelm Tegethoff, Nicholas Lemke, Jrgen Khler
Institut fr Thermodynamik, TU Braunschweig, Germany
c.junior@tu-bs.de
ch.richter@tu-bs.de

Abstract
Thermoelectric technology allows for the direct conversion of a temperature difference into an electric
potential and vice versa. Thermoelectric devices can
act as coolers, heaters, or power generators and applications of small capacity thermoelectric modules
are widespread. Applications of large capacity thermoelectric devices have been limited for decades by
their low efficiency. New environmental regulations
regarding the manufacture and release of CFCs have
revived the interest in this area. Recent investigations
on thermoelectric materials promise that their thermoelectric efficiency can be improved dramatically.
This would mean a breakthrough for new fields of
applications for thermoelectric modules. A new
Modelica model of a Peltier water-water heat exchanger was developed for transient simulations. The
new model uses component models from the objectoriented Modelica library TIL. The new model was
used to simulate the transient behavior of a Peltier
heat exchanger during a sudden reversion of the applied voltage. The numerical results were compared
to measurement results from a prototype.
Keywords: heat exchanger; simulation; thermoelectrics; Peltier element

1

Introduction

Thermoelectric technology allows for the direct conversion of a temperature difference into an electric
potential and vice versa. The French physicist Jean
Peltier discovered in 1834 that an electric current
sent through a circuit made of dissimilar conducting
materials yields heat absorption at one junction and
heat rejection at the other. Standard thermoelectric
modules utilize doped bismuth telluride as semi-

The Modelica Association

conductor and achieve moderate performance. They
can act as coolers, heaters, or power generators and
applications of small capacity thermoelectric modules are widespread. However applications of large
capacity thermoelectric devices have been limited in
the past by the low efficiency of thermoelectric
modules. Recent scientific advances regarding new
materials and assembly methods for thermoelectric
modules as well as the increasing concerns about
fuel economy, harmful emissions of particulate matter, and chemical refrigerants revived the interest in
thermoelectric technology. The inherent advantages
of thermoelectric systems such as the absence of
moving parts, quiet operation, and environmental
friendliness of the module itself have further increased the interest. Several investigations for applications of large capacity thermoelectric modules in
the fields of refrigeration and air-conditioning [1],
waste heat recovering [2], or superconduction [3]
have been carried out with promising results.
This paper describes the development of a Modelica model that allows the transient simulation of
thermoelectric devices to determine their performance potential. The model for the thermoelectric
devices was developed as an add-on for the objectoriented Modelica library TIL (TLK-IfT-Library)
described in [4] that allows for the simulation of
thermodynamic systems such as air-conditioning and
heat-pump systems.

2

Thermoelectric Refrigeration

Thermoelectric refrigeration is achieved when a direct current I is passed through one or more pairs of
n-type and p-type semiconductors connected with a
metal with high conductivity such as copper as
sketched in Figure 1.

437

Modelica 2008, March 3rd  4th , 2008

C. Junior, C. Richter, W. Tegethoff, N. Lemke, J. Kohler

Figure 1: The Peltier effect (thermoelectric cooling)
from [5].
If the electric current passes from the n-type to the ptype semiconductor, electrons pass from a low energy level in the p-type material through the interconnecting conductor to a higher energy level in the ntype material. Thus the temperature TC of the interconnecting conductor decreases and heat is absorbed
from the environment. The absorbed heat is transferred by electron transport through the semiconductors to the other end of the function. It is liberated as
the electrons return to a lower energy level in the ptype material yielding an increased temperature TH.
This phenomenon is known as the Peltier effect
and is described by the Peltier coefficient , defined
as the product of the Seebeck coefficient  of the
semiconductor material and the absolute temperature. The Peltier coefficient relates to a cooling effect
as the electric current passes from the n-type to the
p-type semiconductor and a heating effect as the polarity of the power supply is changed. Reversing the
direction of the electric current also reverses the
temperatures of the hot and cold ends.
The amount of heat absorbed at the cold end not
only depends on the product of the Peltier coefficient
and the electric current flowing through the thermoelectric module but also on two other effects: Due to
the temperature difference between the cold and the
hot ends of the semiconductors, heat is conducted
through the semiconducting material from the hot to
the cold end. The amount of conducted heat depends
on the thermal conductance  of the material as well
as on the temperature difference. The second effect
occurs when the electric current is passing through
the semiconductors. The electrical resistance R causes the generation of the so-called Joule heat in equal
shares at the cold and the hot side of the thermoelectric device. The Joule heat is dependent on the elec-

The Modelica Association

trical resistance and proportional to the square of the
electric current and therefore becomes eventually the
dominant factor.
The heat absorption rate at the cold side of the
thermoelectric module can be described taking into
account the three different effects mentioned above
1
2
where  is the differential Seebeck coefficient sometimes referred to as  pn, R the electrical resistance of
the thermoelements in series, and  the thermal conductance of the thermoelements in parallel. The
energy efficiency of the thermoelectric device is described by its coefficient of performance (COP) defined as the net heat absorbed at the cold junction
divided by the electric power input
1

2

The refrigeration capability of a semiconductor
material depends on a combined effect of the Seebeck coefficient , the electrical resistivity , and the
thermal conductivity  of the material over the operational temperature range between the cold and the
hot junctions. The electrical resistivity is defined as

where A is the cross-sectional area of the resistive
material and l its length. The three material properties are combined in the thermoelectric figure of merit Z defined as

The figure of merit is used by material scientists to
describe the efficiency of semiconductor materials
for thermoelectric applications.

3

Prototype Peltier Heat Exchanger

The Peltier effect can be used for heating and cooling in practical applications by combining thermoelectric modules with conventional heat exchangers.
The fluid flowing through the heat exchanger acts as
a heat sink at the hot side of the thermoelectric module and as a heat source at the cold side. Figure 2
shows the assembly of the prototype Peltier heat exchanger used for all measurements.

438

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL

4

Heat Exchanger Model

In order to model the prototype Peltier heat exchanger, a model for a Peltier element had to be developed.
The new model was developed based on the component model library TIL (TLK-IfT-Library) that contains models for a steady-state and transient simulation of thermodynamic systems (see [4] for more
information).

Figure 2: CAD drawing of the prototype Peltier water-water heat exchanger. The Peltier elements are
the flat cuboids between two aluminum channels.
The orientation of the Peltier elements changes successively between the rows of channels.
Because of the consolidated design and small size
of the prototype heat exchanger, water was chosen as
coolant at both sides. The heat exchanger consists of
rectangular aluminum channels whose endings are
covered by plates. Aluminum cores act as connecting
tubes. The prototype heat exchanger is assembled so
that both sides of the thermoelectric module are in
contact with a channel. The arrangement of the
thermoelectric modules has to be taken into account
for an efficient utilization of the Peltier effect. It is
necessary to either heat or cool the channels. A combination of heating and cooling does not yield a reasonable application.
To increase the flow velocity and the heat exchange between the fluid and the wall, three barriers
were installed in each channel. A CFD simulation
was carried out to determine the flow situation in the
channel. The simulations results proved that the fluid
meanders through the channel and showed that fluid
circulation caused by the barriers leads to a decrease
in dead storage capacity and thus to an improvement
in the heat exchange between fluid and wall. Figure
3 shows a single channel and the corresponding flow
path.

Figure 3: Single channel element of prototype Peltier heat exchanger.

The Modelica Association

Figure 4: UML class diagram of PeltierElement.
Figure 4 shows a class diagram of the new model
PeltierElement. The material properties of the semiconductor material are stored in a record extending
from BaseMaterial. Two heat ports derived from the
HeatPort connector defined in TIL and two electric
pins defined in the Modelica Standard Library are
the interface of the PeltierElement. Based on the equations presented in Section 2, the following set of
equations is used to describe the Peltier element
0
0
12




Figure 5: PeltierCell model as defined in TIL_AddOn_ThermoElectrics.

439

Modelica 2008, March 3rd  4th , 2008

C. Junior, C. Richter, W. Tegethoff, N. Lemke, J. Kohler

Figure 6: BaseElement and its usage in a Peltier water-water heat exchanger model from
TIL_AddOn_ThermoElectrics. The PeltierCell is shown in Figure 5.

1

The PeltierElement is instantiated in the PeltierCell
model along with two models for electrical insulators
as shown in Figure 5. The electrical insulators prevent a short circuit between the Peltier elements and
the aluminum channels. Note that the naming of the
heat ports in Figure 5 is chosen for the default case
that is a positive electric current in the conventional
current notation. The hot side eventually becomes
the cold side and vice versa if the direction of the
current is reversed. The swapping of the corresponding temperatures TC and TH is implemented using a

smooth transition function with a very short transition period.
In order to model the prototype Peltier heat exchanger shown in Figure 2 in a flexible way, an additional model called BaseElement is introduced that
models a single layer of the heat exchanger.
A layer consists of two aluminum channels as
sketched in Figure 3 and the Peltier element in between those two channels. The model is illustrated in
the left picture in Figure 6. A refrigerant cell and two
wall cells from TIL are combined to model a single
channel. The reason for using a RefrigerantCell instead of a LiquidCell is that the new heat exchanger
model was developed to cover cases of evaporating

Figure 7: UML class diagram of TubeAndTubePeltier heat exchanger in TIL_AddOn_ThermoElectrics. The wall material model and all heat transfer and pressure drop models
are skipped for simplicity.
The Modelica Association

440

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL

Figure 8: Schematic diagram of Peltier heat exchanger test stand.
and condensing fluids in both fluid paths. The two
channels are connected using a PeltierCell as shown
in Figure 5. Note that the BaseElement model in
Figure 6 can directly be used as a single cell heat
exchanger model.
The model for the Peltier heat exchanger assembles instances of BaseElement and PeltierCell as
shown in the right picture in Figure 6. The prototype
heat exchanger shown in Figure 2 for example is
composed of four base elements and three Peltier
cells in between. Figure 7 shows the class diagram of
the new TubeAndTubePeltier heat exchanger model.
Note that the wall material model and all heat transfer and pressure drop models are skipped for simplicity. A more detailed description of the structure of
heat exchanger models in TIL is given in [4].

5

Measurements

A series of measurements was carried out with the
prototype Peltier water-water heat exchanger presented in Section 3. Figure 8 shows a schematic diagram of the test stand used for all measurements.
To ensure a constant temperature at the water inlet of the prototype, a reservoir was used in both
cycles. Water was pumped from the reservoirs into
the prototype and flowed back after running through
the heat exchanger. The reservoirs were chosen large
enough to prevent significant temperature changes
during operation. The volume flow rates were regulated with appropriate throttling devices and measured by using conventional water meters.

The Modelica Association

Besides the volume flow rates characteristic parameters such as the water temperatures at the inlet
and outlet of each aluminum tube or the electric current and voltage dropping out over every Peltier element were taken up. The boundary conditions for the
measurements were selected in consideration of
showing the applicability of the simulation for different premises. Therefore a low, a medium and a
high water inlet temperature were chosen and each
condition measured by using a low and a high volume flow rate respectively. Each measurement was
carried out at a working-voltage of 10 V. A summary
of the boundary conditions for all measurements is
given in Table 1.
Water Stream 1
Water Stream 2
# V1 [l/min] T0 [C] V2 [l/min] T8 [C]
1
2.05
4.00
2.00
4.00
2
0.90
4.00
0.85
4.00
3
2.20
18.00
2.10
18.00
4
0.85
18.00
0.80
18.00
5
2.35
30.00
2.40
30.00
6
1.00
30.00
1.10
30.00
Table 1: Measurements with prototype Peltier waterwater heat exchanger.
All measurements were carried out in the same
way: After reaching a stationary point for the boundary conditions listed in Table 1, the direction of the
electric current was changed from positive to negative in the conventional current notation. The resulting change in temperature was detected until the values became stationary again.

441

Modelica 2008, March 3rd  4th , 2008

Derivation of Balances [%]

C. Junior, C. Richter, W. Tegethoff, N. Lemke, J. Kohler

between the direction of the electric current and the
resulting deviation can not be identified.
To exclude the existence of a statistical error and
to confirm that the deviations of the balances are lying within the measuring accuracy an error analysis
was carried out. Therefore, Gauss' error propagation
law was used according to

10
8
6
4
2
0
-2
-4
-6
-8
-10







Measurement 4 from Table 1 was selected for an
error analysis exemplarily. A variation of relevant
measurands was carried out to find out the impact of
1
2
3
4
5
6
these measurands on the total error and to identify
Measurement
possible potentials for further optimization.
Figure 10 shows the impact of the error occurring
positiv current flow
negativ current flow
during the measurement of the temperature difference T between the inlet and outlet of the Peltier
Figure 9: Deviation of electrical and thermal bal- prototype heat exchanger and during the estimation
ances for all measurement points.
of the volume flow rate V on the resultant heating
or cooling capacity.
An evaluation of the quality of the measurements
Due to the fact that the measuring accuracy of a
was carried out by comparing the sum of the input thermocouple lies at about 0.3 K, the maximum error
power and the gained cooling capacity to the for the mathematical calculation of the temperature
achieved heating capacity according to
difference can be expected to be 0.6 K when using
temperatures measured with two independent therThe cooling capacity as well as the heating capacity mocouples. This error can be reduced to 0.1 K if the
temperature difference is measured using two therwas calculated from
mocouples connected in series which was done for

all measurements presented in Table 1.
and the electric power from
In consideration of the volume flow rate, mea
surements the deviation of the values estimated with
The deviation within the balance has to be zero for conventional flow meters and the actual values lies
the ideal case. The deviation of the two balances for between 4% and 9% which results in a maximum
each measurement is shown in Figure 9. It can be deviation of 0.09 l/min. The concluding summation
seen that the deviation lies between 1% and 8%, and yields - under consideration of these conditions - to
that the average value lies around 4%. A connection

14

V [l/min]
T (T1) [K]

12

T (T2) [K]

Q [%]

16

10

1 < 2

8
6
4
2
0
0

0,1

0,2

0,3

0,4

0,5

0,6

0,7

0,8

Error

Figure 10: Error for Measurement 4 from Table 1. The corresponding units are given in the
key.
The Modelica Association

442

Modelica 2008, March 3rd  4th , 2008

45
40
35
30
25
20
15
10
5
0

Temperature [C]

Temperature [C]

Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL

0

0,25

0,5

0,75

1

45
40
35
30
25
20
15
10
5
0
0

Dimensionless Length [-]

0,25

0,5

0,75

1

Dimensionless Length [-]

Water Stream 1

Water Stream 2

Water Stream 1

Water Stream 2

Wall 1

Wall 2

Wall 1

Wall 2

Figure 11: Temperature distribution in prototype Peltier heat exchanger before and after reversion of the
applied voltage for Measurement 4 from Table 1.
the result that even the measurements with a devia- of the water streams and of the walls refers to the
tion of balances of 8% are lying within measuring numbering of the two independent water circuits as
presented in Figure 8. The water temperatures are
accuracy.
shown for the inlet of each channel and for the outlet
of the last channel for both water streams. The wall
temperatures are averages of the temperatures in the
6 Simulation
center of both wall cells connected to the same refriSimulations were carried out for all measurements gerant cell as shown in Figure 6.
Figure 11 shows that the temperature change in
listed in Table 1. Measurement values were used for
the electric current, for the two volume flow rates, the entrance channel of each water stream is smaller
and for the water temperatures T0 and T8 at the two than in all other subsequent channels. This is caused
heat exchanger inlets. The Peltier modules used in by the fact that the entrance channels are insulated at
the prototype Peltier heat exchanger are standard one side and connected to a Peltier element at the
bismuth telluride modules without any further speci- other side whereas all other channels are connected
fication from the manufacturer. Constant properties to a Peltier element at both sides. The two diagrams
for the Seebeck coefficient  and the thermal con- shown in Figure 11 are mirror-symmetrical which
ductance  taken from Rowe [5, Table 9.1] were demonstrates the reversibility of the process.
Figure 12 shows a comparison of the measured
used in the Peltier element model. The electrical resistance R of the thermoelectric module was not spe- outlet temperature for each water stream with the
cified by the manufacturer and had to be determined values obtained from the transient simulation. The
from the measurements. The reversion of the applied top picture shows the change in the electric current I
voltage was implemented using a smooth transition caused by the reversion of the applied voltage.
Figure 12 illustrates that the simulated start and
function with a period of t = 1s. This section deend
temperatures differ from the measured temperascribes the results obtained for the simulation of
Measurement 4 from Table 1. A constant coefficient tures. The simulated system also reacts slower to the
of heat transfer  = 4,100 W/m2K was used. This sudden reversal of the applied voltage than the real
coefficient of heat transfer was determined based on system. Further Measurements are required to ima CFD simulation of the flow through a single alu- prove the model of the Peltier element that is currently based on material constants taken from the
minum channel.
Figure 11 shows the temperature distribution in literature and the measured electrical resistance as
the prototype Peltier heat exchanger before and after explained in the beginning of this section.
the reversion of the applied voltage. The numbering

The Modelica Association

443

Modelica 2008, March 3rd  4th , 2008

Electrical
Current [A]

C. Junior, C. Richter, W. Tegethoff, N. Lemke, J. Kohler

50
25
0
-25
-50

Temperature [C]

0

20

30

40

50

60

70

20

30

40

50

60

70

32
T0
T7
T7_sim

28
24
20
16
12
0

Temperature [C]

10

10

32

T8
T15
T15_sim

28
24
20
16
12
0

10

20

30

40

50

60

70

Time [s]

7

Figure 12: Measured and simulated water temperatures at inlets and outlets of prototype Peltier
heat exchanger for Measurement 4 from Table 1.
cept to be analyzed in the future using simulations
and experiments is a refrigerant-air heat exchanger
with Peltier modules in between.
Conclusions and Outlook

A new model for a Peltier water-water heat exchanger was presented that can be used in transient system
simulations. Results from measurements with a prototype heat exchanger were used to validate the new
model. Models from the new component mode library TIL [4] were used for many components of the
new Peltier heat exchanger model and the new object-based fluid property library TILFluids was used
to compute all fluid properties. A new model for Peltier cells was presented that was used to assemble the
heat exchanger. The new heat exchanger model demonstrates that TIL can easily be extended to cover a
wide range of thermodynamic systems. The presented model can be extended to cover other Peltier
heat exchangers. A very interesting alternative con-

The Modelica Association

References
[1] J. Winkler, V. Aute, B. Yang, and R. Radermacher. Potential benefits of thermoelectric elements
used with air-cooled heat exchangers. In Proc. of
2006 International Refrigeration and Air Conditioning Conference at Purdue, volume 1, pages R091.1R091.8, West Lafayette, July 2006.
[2] K. Zorbas, E. Hatzikraniotis, and K. Paraskevopoulos. Power and Efficiency Calculation in Commercial TEG and Application in Wasted Heat Recovery in Automobile. In Proc. of 5th European Conference on Thermoelectrics, 2007.

444

Modelica 2008, March 3rd  4th , 2008

Modeling and Simulation of a Thermoelectric Heat Exchanger using the Object-Oriented
Library TIL

[3] K. Bos, R. Huebener, and C. Tsuei. Prospects for
Peltier cooling of superconducting electronics. Cryogenics, 38(3):325-328, March 1998.
[4] C. Richter. Proposal of New Object-Oriented
Model Libraries for Thermodynamic Systems. Dissertation, TU Braunschweig, to be published in 2008
[5] D. Rowe, editor. Thermoelectrics Handbook,
Macro to Nano. Taylor & Francis, 2006.

The Modelica Association

445

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

446

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers
Pengfei Li and Yaoyu Li

John E. Seem

Department of Mechanical Engineering
University of Wisconsin  Milwaukee

Building Efficiency Research Group
Johnson Controls, Inc.

pli@uwm.edu & yyli@uwm.edu

john.seem@gmail.com

Abstract
For the heating, ventilating, and air conditioning
(HVAC) systems for commercial buildings, there has
been a greater demand for reducing energy consumption. The economizers have been developed as a
class of energy saving devices that may increase the
energy efficiency by taking advantage of outdoor air
during cool or cold weather. However, in practice,
many economizers do not operate in the expected
manner and waste even more energy than before installation. Better control strategy is needed for optimal and robust operation. This paper presents two
related aspects of research on dynamic modeling and
control for economizers. First, a Modelica based dynamic model is developed for a single-duct air-side
economizer. The model development was based on
Dymola and AirConditioning Library with some revision on water medium and heat exchanger modeling. Such transient model will lay a more quality
foundation for control design. Second, for a threestate operation for air-side economizers, a selfoptimizing control strategy is developed based on the
extremum seeking control (ESC). The mechanical
cooling can be minimized by optimizing the outdoor
air damper opening via extremum seeking. Such has
much less dependency on the knowledge of economizer model, and thus has more promise for practical
operation. In addition, an anti-windup ESC scheme
is proposed as an enhancement for the existing ESC
techniques. The simulation results validated the effectiveness of the dynamic model of the economizer,
demonstrated the potential of using ESC to achieve
the minimal mechanical cooling load in a selfoptimizing manner, and illustrated the possibility of
ESC malfunctioning under actuator (damper) saturation and the capability of anti-windup ESC in preventing such undesirable behavior.

1

Introduction

Buildings are responsible for a large portion of electricity and natural gas demand. Significant amount of
energy consumption for buildings is due to the heating, ventilation and air conditioning (HVAC) systems. Improving the efficiency of building HVAC
system is thus critical for energy and environmental
sustainability. The economizers have been developed
as a class of energy saving devices that may increase
the energy efficiency by taking advantage of outdoor
air during cool or cold weather [1]. Figure 1 is a
schematic diagram of a typical single-duct airhandling unit (AHU) and controller. The AHU has a
supply fan, three (outdoor air, relief air and mixed
air) dampers for controlling air flow between the
AHU and the outdoors, heating and cooling coils for
conditioning the air, a filter for removing airborne
particles, various sensors and actuators, and a controller that receives sensor measurements (inputs)
and computes and transmits new control signals
(outputs). The air economizer moves the dampers to
let in 100% outdoor air when it is cool but not extremely cold outside. When it is hot outside, the
dampers are controlled to provide the minimum
amount of outdoor air required for ventilation.

Keywords: Modelica; transient modeling; economizer; extremum-seeking control

Relative Humidity Sensor
Relief
Air

Return
Air

Fan
Filter
Cooling Coil

Outdoor
Air

C
C

Mixed
Air
Outputs

Temperature
Sensor

Supply
Air

Fan

Temperature
Sensor

Controller
Inputs

Figure 1: Single duct air handling unit

The Modelica Association

447

Modelica 2008, March 3rd  4th , 2008

P. Li, Y. Li, J. Seem

The American Society of Heating, Refrigerating and
Air Conditioning Engineers (ASHRAE) recommends
using economizers based on the cooling capacity size
and weather characteristics for the building location
[2], as described in the Appendix. ASHRAE [3] describes several control strategies for transitioning
between 100% outdoor air and the minimum outdoor
air required for ventilation. The control strategies are
called high limit shutoff control for air economizer. Following is a list of strategies that can be
programmed in a computer control system.

 Fixed dry bulb temperature. This strategy compares the outdoor temperature to a transition temperature. If the outdoor air temperature is greater
than the transition temperature, then the dampers
are controlled for the minimum outdoor air required for ventilation.
 Differential dry bulb temperature. This control
strategy compares the outdoor and return air temperatures. If the outdoor temperature is greater
than the return air temperature, then the dampers
are controlled for minimum outdoor air required
for ventilation.
 Fixed enthalpy. This control strategy measures the
outdoor air temperature and relative humidity
(RH). Then the outdoor air enthalpy is calculated
and compared with a transition enthalpy. If the
outdoor air enthalpy is greater than the transition
enthalpy, then the dampers are controlled for
minimum outdoor air required for ventilation.
 Differential enthalpy. This control strategy determines the outdoor and return air enthalpy from
measurements of the outdoor and return air temperature and relative humidity. If the outdoor air
enthalpy is greater than the return air enthalpy,
then the dampers are controlled for minimum
outdoor air required for ventilation.
However, in practice, many economizers do not operate as expected and waste even more energy than
before installation [4]. Temperature and RH sensor
errors can have a large impact on the energy savings
or possible penalty of economizer strategies. The
National Building Controls Information Program
(NBCIP) [5] said, In the case of economizers, relative humidity and temperature measurements of outdoor and return air conditions are used to calculate
the enthalpies of the two air streams. The air stream
with the least energy content is then selected to provide building cooling. If one or both of the computed
enthalpies is wrong, as can happen when humidity
transmitters are not accurate, significant energy penalties can result from cooling of the incorrect air
stream. The NBCIP [6] performed long term perThe Modelica Association

formance tests on 20 RH sensors from six manufacturers. Nine of the 20 RH sensors failed during the
testing. All of the remaining sensors had many
measurements outside of specifications. The largest
mean error was 10% RH, and the largest standard
deviation of the error was 10.2%. The best performing sensor had a mean error of 2.9% RH and a
standard deviation of 1.2%. The specifications for
the best performing sensor were 3%. Control
strategies not relying on RH measurement would
greatly enhance the reliability of economizer operation.
Modeling and optimal control of air-handling units
and economizers have been previously studied [7, 8].
However, due to the complex nature of HVAC system operation, the obtained model may not be accurate enough for the optimal operation of an economizer. Therefore, a model based optimal control approach is hardly effective in practice to seek the optimal outdoor air flow for minimizing the mechanical
cooling. In contrast, an on-line self-optimizing control approach appears a more suitable option.
This research investigates the application of the extremum seeking control (ESC) [9-13] to optimize the
use of outdoor air so as to minimize the energy consumption. The input and output of the proposed ESC
framework are the damper opening and power consumption (or equivalently, the chilled water flow
rate), respectively. This approach does not rely on
the use of relative humidity sensor and accurate
model of the economizer for optimal operation.
Therefore, it provides a more reliable control strategy for economizer operation. The proposed ESC
scheme works as part of a three-state economizer
control strategy, as shown in the state diagram in
Figure 2. State 1 uses heating to maintain the supply
air temperature. In state 2, outside air is mixed with
the return air to maintain the supply air at a given
setpoint. In state 3, the extremum seeking control is
used to control the dampers to minimize the mechanical cooling load. Also, the dampers must be
controlled to guarantee enough outdoor air inflow to
satisfy the ventilation requirement for the rooms.
Figure 3 shows the control regions for different outside air conditions on a psychometric chart. The return air condition was 75 F and 50% relative humidity, the cooling coil was ideal, and the minimum
fraction of outdoor air to supply air was 0.3. The
heating region is for state 1, the free cooling region
is for state 2, and the three regions that need mechanical cooling are combined into state 3.

448

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

In addition to the ESC application for economizer
control, an enhancement on the ESC is proposed: an
anti-windup ESC scheme against damper (actuator)
saturation. Due to the inherent integral action incorporated in the ESC loop, the integral windup due to
the damper saturation would disable the ESC, as will
be shown in Section 3. The back-calculation scheme
is applied to the ESC loop to achieve the anti-windup
capability.

Figure 2: State transition diagram for the proposed
control strategy.
0.04

0.02
Return Air Conditons

Mech. Cooling with
30% Outdoor Air

H um idity R atio

0.03

0.01
Heating

Free Cooling
0

20

40

Mech. Cooling
with 100%
Outdoor Air
0.0
60

Temperature

80
100
Mech. Cooling with Outdoor
Air between 30% and 100%

Figure 3: Control states for different outside air conditions for an ideal coil with return conditions 75 F
and 50% RH.
The proposed control scheme has the following advantages over existing economizer strategies:
 Energy Savings. Using ESC will lead to energy
savings because the dampers will be controlled to
minimize the mechanical cooling load. Also, the
proposed strategy will save energy because it is
not dependent on unreliable RH sensors.
 Lower installed costs because the proposed strategy does not require the outside air or return air
temperature or RH sensors.
 Lower maintenance costs because the temperature and RH sensors do not need to be calibrated.

The Modelica Association

In order to design and simulation the proposed control strategy, a quality dynamic model of economizer
is needed. In this study, an economizer simulation
model was developed in Modelica. Dynamic modeling of HVAC equipment has attracted increasing
attention in recent years. A summary of previous
work in dynamic modeling of vapor compression
equipment was presented in [14, 15]. According to
[15], the modeling regimes could be mainly classified as two categories: reference models and lumped
models. The reference models are designed to best fit
the underlying physics of the system, but will often
involve partial differential equations (PDE) and high
system order. In contrast, the lumped models will
lead to lower order ordinary differential equations
(ODE) based on some simplifications and/or space
discretization. In particular, the first category of
models requires extensive dynamic information from
the heat exchanger. The finite-volume method was
studied by MacArthur [16] but with simplifications
in decoupling thermal responses from pressure responses, which may result in less accurate mass distribution predictions. This issue was latter resolved
by MacArthur and Grald [17] from combining the
mass and balance equations, where the pressure responses are involved. Nyers and Stoyan [18] modeled an evaporator using the approach of finitedifference. Williatzen et al [19] employed a profile
assumption for the variation of refrigerant state
within each phase region. Recently, Rasmussen [20]
presents an novel modeling approach with more
freedom of selecting the system states and is claimed
to be equivalent to the common method of simplifying the governing PDEs to the desired ODEs. Zhou
[21] developed a so-called forward model which was
capable of solving the governing differential equations concerning energy storage and transfer in a
cooling and dehumidifying coil. The lumped models
have also been studied by several authors for simulation and control purposes [22-24]. Besides the modeling approaches involved, the fact that different
time scales of the system dynamics are either interwoven or distinctive to a large extent yet poses another serious challenge to the dynamic modeling of
HVAC. However, limited study has been done so far

449

Modelica 2008, March 3rd  4th , 2008

P. Li, Y. Li, J. Seem

on developing effective and efficient dynamic models that are capable of handling system dynamics
with different time scales and simultaneously satisfying research purposes ranging from dynamic analysis
and control design of subsystems (e.g. AHU) to
building energy savings and comfort. As for AHU
modeling in particular, ASHRAE [15] said some of
the quickest phenomena occur in the AHUs (coils,
humidifiers, and economizers), when simulating
such subsystems, realistic dynamics have to be considered for all components involved: heat and mass
exchangers, fans, ducts and pipes, sensors and actuators. Compared to the control oriented transient
analysis which features small time-scale, the energy
saving and human comfort evaluation are coped with
in a much larger time scale, but require accurate energy balances. For instance, the cooling coil usually
has the slowest transient among the four major components in the vapor compression system, and thus
has the largest impact on transient performance. It is
necessary to consider mass distribution within the
cooling coil as a function of time and space and this
requires transient mass balances to allow for local
storage [14]. On the other hand, for an AHU, the
cooling coil is among the quickest responding components. Their transient response may significantly
interact with closed loop controllers [15]. Thus, the
multiple-time-scale compatibility is important for the
dynamic/transient modeling of HVAC systems.

2 Dynamic Economizer Model Design
The dynamic model of economizer was developed
based on the Dymola 6.1, the MFL and the ACL 1.4
and 1.5. In addition to adopting the standard components in the commercial packages, we have made the
following development: modification of water property calculation for the heat exchanger model, initialization with pressure-temperature pair, mixing
box, and fan. Figure 4 shows the economizer model
that we have developed in Dymola, which includes
air ducts, air mixing box, fans, cooling coil, and a
room space. The air duct model was adopted from
the MFL. It allows detailed pressure drop calculation
due to wall friction. The air mixing box model
contains two sub-components: the air-mixing plenum
and the damper module. The air-mixing plenum was
developed using the splitter model from the MFL,
while the damper module was developed by
ourselves. We have also developed a fan model
based on the similarity factors [29]. In addition, the
cooling coil was developed based on the evaporator
model from the ACL. A water medium model
CoolWater was developed based on the IAWSP-IF97
formulation [30], and compared with the water
medium model developed in the ACL. The pressuretemperature pair was used for both initialization and
state derivation with the consideration of practical
HVAC operation. Finally, a mixing volume model
from the MFL was used to represent a room space.
airSink
p
T
X

V=V

Ext
T
pRet

tempRet

ductRet
p

damperPos
Ret

fanRet

(1) Air Mixing Box

outAirTemp

(2) Cooling Coil

heatRoom
X
T
p
w at...

cc
Source
p
T
X
Out
w at...
w atSou...
p
coolWatTe... T
X

heatFlow F...

fanSup

staticHead

ductSup

tempSup

valve

(3) Fan
valvePosition

T

room

V=V pSup
tempSup...

flowRate

Control development for many HVAC systems, e.g.
the economizer in this study, would not be possible
without accurate and computationally efficient dynamic/transient models. Most simulation tools for
HVAC systems have been based on steady-state
modeling. Dynamic modeling and simulation is still
in the research phase and not mature yet. Modelica,
as an object-oriented language for physical modeling, has demonstrated its great capability for simulating multi-physical systems. Several Modelica based
simulation packages have been developed, e.g. the
Thermal-Fluid Library [25], the AirConditioning
Library [26], the Modelica_Fluid Library [25] and
the HITLib [27]. The AirConditioning Library is
capable of handling both steady-state and transient
simulation, however, it was mainly designed for
automotive air conditioning systems. Some components need to be modified for modeling building
HVAC systems such as economizers. In this study, a
dynamic model of a single-duct air-side economizer
is developed using Dymola (Version 6.1) developed
by Dynasim [28], the Modelica Fluid Library (MFL)
and the AirConditioning Library (ACL) (Versions
1.4 and 1.5) developed by Modelon [26].

The remainder of this paper is organized as follows.
Section 2 describes the dynamic economizer model
design. The details of ESC design are described in
Section 3, along with the anti-windup ESC. Finally,
simulation results that demonstrate the effectiveness
of ESC and the two proposed enhancements are presented in Section 4.

p

V=1000

(4) Room

Figure 4: Dymola layout of the economizer model.

The Modelica Association

450

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

2.1 Air Mixing Box
The air mixing box is a component of the AHU that
mixes the outdoor air and the return air from the
conditioned indoor space. It consists of a damper
module (outdoor, return and exhaust dampers) and
an air-mixing plenum. The fraction of the outside air
is regulated by the outdoor damper whose command
signal is interlocked with the exhaust and return air
damper. The supply air flow rate is kept as consistent
as possible to ensure proper pressure balance at the
building side. In addition, to provide adequate ventilation, the minimal OAD opening is limited by an
actuator. The damper model was developed based on
the work by Tan and Dexter [31]. The pressure drop
across the dampers is given by Ploss = Rdampmair2,
where mair is the mass flow rate of the air through the
dampers and Rdamp is the resistance of the damper
given by
if  0.3333
Ropen exp[kd(1)]


Rdamp = 
Ropen

3.0[(1/3)Ld +0.0429]2 if  <0.3333



(1)
where  is the fractional opening of the damper (0
for fully closed and 1 for fully open), kd is a constant
depending on the type of blades used, Ropen is the
resistance of fully open dampers, and Ld is the leakage when the damper is fully closed. In Eq. (1), there
exists a slight discontinuity of the damper resistance
around 0.3333. It was smoothed by a third order
polynomial covering the interval of [0.2833, 0.3833].
The four coefficients of the polynomial were determined with the two functional values and two derivative values at 0.2833 and 0.3833. The air-mixing
plenum was formulated on the basis of the splitter
model from the MFL.

2.2

Fan

Two fan models are employed in this study. The first
fan model was based on the pump model from the
MFL. The only change was on the medium flowing
through, from water to the moist air. The second fan
model was developed based on the similarity factor
model in [29]. The relationship between the flow
factor and pressure factor is given by

 = C1 + C 2 + C 3 2
Q
=
AU
Ptotal
=
Pdynam, periph

The Modelica Association

(2a)
(2b)
(2c)

where A = (D2)/4, U = (DN)/60, Pvel = (v2)/2,
v = Q / Aex , Ptotal = Pstat + Pvel ,  is the flow
factor,  is the pressure factor, Q is the flow rate, A
is the reference area, Aex is the exhaust area, D is diameter of the impeller, v is the velocity of the outflow air, N is the rotation speed in rpm, Pstat is the
static pressure, Pvel is the velocity pressure, and
Pdynam, periph is the peripheral dynamic pressure. C1,
C2 and C3 are coefficients of the polynomials relating
the flow and pressure factors, which are fitted to the
manufactures fan performance data by the leastsquare estimation. A limited proportional-integral
(PI) controller is used to regulate the rotation speed
of the supply fan to maintain the static pressure of
the supply air duct at the setpoint. In addition, the
rotation speed of the return fan is synchronized by
another limited PI controller, with the reference setting satisfying the steady-state equilibrium of overall
flow rate. This is a simplified treatment, and it is being improved by a more accurate treatment described
in the work by Tan and Dexter in [31] which considered the building over-pressurization and leakage
flow.

2.3

Cooling Coil

Cooling coil is the most important component between the primary plant (e.g. chiller) and the air distribution system. As mentioned earlier, the cooling
coil is among the quickest responding components in
AHU and it also responds to the quickest perturbations. Therefore, the transient behavior of cooling
coil may have significant effect on closed loop control performance [15].
Since Version 1.4, the ACL has developed a group
of heat exchanger models that are capable of simulating both transient and steady-state operations. The
dynamic energy and mass balances are formulated
based on the finite-volume method. The number of
discretization at the refrigerant side is proportional to
that for the solid wall and the air side. The heat conduction in the solid wall is modeled as a onedimensional problem perpendicular to the fluid flow
direction. In particular, the simulation results of a
cross-counter flow evaporator model used in an
automotive R134a-system had been validated in an
experiment conducted by Chrysler [32]. The measured data were compared with the simulation results
of the medium properties and the steady-state heat
transfer rates, for three sets of boundary conditions
given by the mass flow rate, the inlet temperature,
the inlet enthalpy, and the relative humidity of the
ambient air. The heat transfer rates had good consistency while the refrigerant-side pressure drop and the
air-side water condensing needed improvement.

451

Modelica 2008, March 3rd  4th , 2008

P. Li, Y. Li, J. Seem

There were some challenges to directly use the heat
exchanger model from ACL for the cooling coil
component in the economizer model. In the ACL
Version 1.5, the choices of state variable pairs include pressure-enthalpy, density-temperature, and
mass-internal energy. Such choices are suitable for
the air flow and two-phase refrigerants in the automotive refrigeration systems. However, for the building HVAC systems, especially for cooling coils in
the AHU, the working medium is typically singlephase, i.e. water. Also, the temperature range is limited to the ambient temperature variation. Therefore,
it is necessary to reformulate the existing heat exchanger model in the ACL to accommodate the specific needs in building HVAC systems.

IAPWS-95 standard. Figures 5 through 8 compare
the relative errors of the IF-97 and LUT models in
density, specific entropy, Cp and Cv, respectively.
Note that Cp and Cv are assumed identical in the LUT
model. More discrepancies were observed for entropy and Cv.
Table 1: Water Properties Based on IF-97 and LUT
Models Relative to IAPWS-95 Standard
Maximum Relative Error (%)
Water Property
Density

IF-97
0.0015

ACL1.5
0.09

Specific Entropy

0.018

28.223

Cp

0.052

0.189

Cv

0.075

11.833

The Modelica Association

452

0.1
0.08
0.06
0.04
0.02
0

280

290

300

310

320

330

340

350

360

370

290

300

310

320

330

340

350

360

370

-3

1.5

x 10

1
0.5
0

280

Temperature (K)

% R ela tiv e E rror (Lo ok up -T a ble )

Figure 5: Density errors of the IF-97 and LUT models relative to the IAPWS95 standard

% R ela tiv e E rror (IF -9 7)

An accurate water medium model is critical for the
transient simulation of cooling and heating coils in
the AHU. For the water property calculation, there
are mainly two international standard formulations,
namely, IAPWS95 [33] and IAPWS-IF97 [30, 33].
The former was developed for scientific computation, while the latter was developed for industrial
applications. Prior to the release of Version 1.4, the
ACL had included a large set of medium models for
many refrigerants, but not the water medium. Since
Version 1.5, the ACL has adopted a lookup-table
(LUT) based incompressible fluid (water) medium
model for heat exchanger modeling. However, it
may have the following drawbacks. First, in the control volumes, pressure responses are decoupled with
thermal responses, which may lead to inaccurate
mass distribution predictions. Second, incompressible water model will also result in inaccurate pressure drop calculations, which will in turn affect the
heat transfer property calculations.
To validate the accuracy of different formulations of
water property model, the IF-97 formulae based
model (abbreviated as IF-97 model later) and the
LUT based incompressible water model (abbreviated
as LUT model later) were compared with the
IAPWS-95 standard. The FLUIDCAL program developed by Wagners group was used to obtain the
IAPWS-95 based water properties [34]. For Dymola
6.1, the water medium in Modelica_Media follows
the IF-97 model, while the water medium of ThermoFluidPro in the ACL Version1.5 follows the LUT
model. The comparison was conducted in the temperature range from 274.15 K to 373.15 K with an
increment of 5 K, and the pressure input was set 5
bars for all cases. Table 1 summarizes the maximum
errors of several properties based on the IF-97 and
LUT models relative to those derived from the

% Relative Error (%) (IF-97) % Relative Error (Lookup-Table)

2.3.1 Medium Model Design and Implementation

30
25
20
15
10
5
0

280

290

300

310

280

290

300

310

320

330

340

350

360

370

320
330
Temperature (K)

340

350

360

370

0.02
0.015
0.01
0.005
0

Figure 6: Specific entropy errors of the IF-97 and
LUT models relative to the IAPWS95 standard

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

0.2
Lookup-Table
IF-97

0.18
0.16

% Relative Error

0.14
0.12
0.1
0.08
0.06
0.04
0.02
0

280

290

300

310

320

330

340

350

360

370

Temperature (K)

% Relative Error (IF-97)

% Relative Error (Lookup-Table)

Figure 7: Cp errors of the IF-97 and LUT models
relative to the IAPWS95 standard
15
10
5
0

280

290

300

310

320

330

340

350

360

370

280

290

300

310 320 330 340
Temperature (K)

350

360

370

0.08
0.06
0.04
0.02
0

Figure 8: Cv errors of the IF-97 and LUT models
relative to the IAPWS95 standard
Within the Modelica_Media Library, a group of waterIF97 models have been well defined to compute
the physical properties for water in the liquid, gas
and two-phase regions based on the IF-97 formulae.
However, there are several technical issues to use
these waterIF97 medium models directly in the functions of ACL. First, waterIF97 medium model contains both single- and multiple-phase calculations, in
which the multiple-phase portion is not needed for
this application. In addition, earlier development in
the ACL is well compatible with the automotive air
conditioning systems whose working medium are
various kinds of refrigerants. The composition is a
critical argument contained in most functions developed in the ACL. For cooling and heating coils in the
AHU, the single-phase water is the only working
medium to deal with. The composition argument in
the existing ACL functions results in significant inThe Modelica Association

convenience. For the single-phase water medium
used in the heating/cooling coils, it would be more
convenient to remove the composition argument.
Second, the medium property computation in the
ACL covers both single- and multiple-phase processes, which are involved not only in the balance
equations of the dynamic control volumes, but also
in the calculations of various thermodynamic states,
such as density, enthalpy and specific heats, which
are irrelevant to the dynamic states of the control
volumes. In addition, there are a lot of computations
related to multiple-phase processes. A process/device
involving only the single-phase water medium, such
as the heating/cooling coil in the AHU, is a much
simpler case. If we can remove all irrelevant computations, the resultant computational efficiency will be
greatly improved.
Thirdly, the refrigerants used by typical automotive
air conditioning systems are modeled on the basis of
the Helmholtz functions with density-temperature as
the pair of state variables. In many HVAC applications, it would be more convenient if the water properties are based on the pairs of pressure-temperature
or pressure-enthalpy. In addition, for physical property calculations in the control volumes, the users
can access the medium functions only at hierarchically higher levels, which limits the customization or
reformulation of these functions for particular applications, especially when the user-preferred pair of
state variables is not supported in the existing package.
To address the above issues, we decided to develop a
simpler and more efficient water model, named as
CoolWater, based on Modelica_Media.Interfaces.
PartialMedium. The basic formulation of the CoolWater model was obtained from [35]. In particular,
all redundant and conflicting variables and options in
the original waterIF97 model were either removed or
modified, e.g. the BaseProperties code. To be consistent with the coding style and physical property calculations preserved in the ACL, several IF-97 based
low-level medium functions and utilities were
adopted from the Modelica_Media Library.
A heat exchanger model was developed based on the
CoolWater medium described above. Heat exchanger
modeling is generally considered the most computationally intensive entity in a refrigeration system
[36]. To properly adapt the CoolWater model to the
refrigerant side, equations in the dynamic control
volumes should be rewritten, but the change should
not degrade the overall inheritance structure and exactness of the heat exchanger model. Since the uppermost hierarchical structure of the heat exchanger
is composed of only a few lines of code, the work of

453

Modelica 2008, March 3rd  4th , 2008

P. Li, Y. Li, J. Seem

implementing single-phase water model should begin from the most rudimentary control volumes. In
the development phase, different choices of statevariable pairs were first compared and evaluated in
order to achieve both engineering convenience and
numerical efficiency. It was stated in [37] that the
mass-internal-energy pair could decrease the numerical efficiency. The density-temperature pair was
considered by [38] a bad choice in the liquid region
for compressible fluids due to the amplification of
numerical error.
Currently, the state-variable pairs of pressuretemperature and pressure-specific-enthalpy have
been formulated into the heat exchanger model for
comparison purpose. The techniques of state variable
transformations were performed in the dynamic balance equations for pressure-temperature and pressure-specific-enthalpy, respectively [38, 39]. The
corresponding partial derivatives appeared in the
balance equations could be computed using rudimentary IF-97 functions. To ensure consistent and convenient initialization, the pressure-temperature pair
(compared to the pressure-enthalpy pair) has been
added into the initialization options, since temperature is easier to set for HVAC operation rather than
some other variables such as enthalpy.

(a) Flow pattern of water and air

(b) Six-pass cooling coil with vertical flow of cooling water and cross flow of air

2.3.2 Validation of Cooling Coil Model
A cooling coil model was derived from the heat exchanger model described in the previous section. To
validate this model, two comparisons were conducted: comparison of pressure-temperature and
pressure-enthalpy and comparison of our cooling coil
model and the cooling coil in ACL Version 1.5.
As described in [38], the advantage of using the
pressure-temperature pair is that there are many medium property models which are explicit in this state
pair. The sensitivity of using this state pair needs to
be checked. It is known that using different dynamic
state variable pairs may change the numerical sensitivity of the corresponding thermodynamic equations
of state (EOS). For a bad choice of state pair, even a
small error in one of variables of the state pairs may
lead to a large error to other variables calculated
from EOS. To address such concern, the pressuretemperature and pressure-enthalpy pairs were compared with an example cooling coil model.
The cooling coil adopted a flat tube louvered fin heat
exchanger model given in the ACL. It consists of
louvered fins and extruded microchannel flat tubes,
both made of aluminum. The schematic diagrams in
Figure 9 show the geometry and flow pattern for the
cooling coil model.

The Modelica Association

(c) Geometry of the triangular louvered fin
Figure 9: Schematic diagrams for the example cooling coil [40]
On both sides of the wall, several parallel flow channels are lumped into one uniform flow path. The
cooling water path through the component is treated
as one pipe flow with circular cross section and one
air element associated with each flow segment. Each
air element is further discretized along its flow direction. The total depth and height were set to be 0.06 m
and 0.21 m, respectively. The width of the cooling
coil could be then calculated from the known number
of flat tubes and dimension of the flat tubes and fins.
For the water side, as shown in Figure 9(b), there are
15 flat tubes in the 2nd and 5th flow passes, and 10
flat tubes in the each of the remaining flow passes.
The dimension of the flat tubes could be determined
through three parameters: height of one flat tube,
center to center distance of two adjoining flat tubes,
and the number of pipes in one flat tube. They were
set to be 1 mm, 10 mm and 20, respectively. The

454

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

wall thickness and radius of each pipe were set to be
0.1 mm and 0.4 mm. At the air side, the shape of the
louvered fins was set to be triangular. The fin dimensions are summarized in Table 2.

Red line: P-T
Blue line: P-h
The difference curve

Table 2: Dimensions of the louvered fins

405.254W (initial)

Fin Dimension

Parameter Setting

Number of fins per 0.1 m

80

Louver length (mm)

7

Louver pitch (mm)

1.4

Louver angle ()

28

Fin thickness (mm)

0.1

Fin radius (mm)

0.4

(0.12s 580.3W)
1928.06W

Time (sec)

Figure 11: Internal energy in the 6th control volume
Red line: P-T
Blue line: P-h
Difference Curve

Close View

Red line: P-T
Blue line: P-h

(0.5s,141.43W)
(0.9s,64.35W)
(0.1s,-1180.67W)

The difference curve

0 to 0.9 second

0 to 0.9 second
-632.336W (initial)
-1100.75W

Time (sec)

Figure 12: Total heat transferred from the heat exchanger

Time (sec)

Figure 10: Internal energy in the 3rd control volume
For the two state pairs, the inlet air conditions were
set identical. The flow rate, temperature and relative
humidity of the inlet air were set to be 0.2 kg/s,
313K and 60%, respectively. For the water side, the
chilled water flow rate was kept as 0.3 kg/s. For the
pressure-temperature state pair, the initial temperature was set to 292.146 K. To be consistent with this
setup, the inlet specific enthalpy was set to 8104
kJ/kg for the pressure-enthalpy state pair. The total
discretization number at the air side and water side
was set to be 12 and 6, respectively. Figures 10
through 12 show the simulation results from our
cooling performance test. The difference curves
shown in the plots are the calculated numerical differences between these twos state variable pairs. The
results indicate that the differences are noticeable
only in the region of numerical transient responses,
i.e. 0 to 0.5 seconds, which is not harmful to the
overall transient and steady-state solutions.

The Modelica Association

A further study was then performed to benchmark
our development with the ACL Version 1.5. The heat
exchanger model from ACL Version 1.5 was
equipped with the LUT water model. In our case, the
CoolWater model was used and pressuretemperature was selected as the state variable pair.
The geometric configuration of the cooling coils was
reinforced to be the same in the two cases. A similar
cooling performance test was conducted, the initial
air flow rate was 0.0675 kg/s and the air temperature
and RH were given by 303.15 K and 60%, respectively. For the water side, the chilled water flow rate
and initial temperature was kept as 0.1 kg/s and
293.15 K respectively. As shown in figure 13, the
inlet temperatures at the water and the air sides respectively experienced ramp changes in sequence: at
30 second, the inlet water temperature first ramped
to 298.15 K within 20 second, and then the inlet air
temperature ramped to 308.15 K at 75 second within
20 second as well. Again, the total numbers of discretization at the air and water sides were set as 12

455

Modelica 2008, March 3rd  4th , 2008

20s

Inlet Air Temperature

3400
Max relative error: 0.51%

3200
3000
2800
2600

Internal Energy (J)

and 6, respectively. Figures 14 through 16 compare
the simulation results of the two cases in terms of the
specific enthalpy, the internal energy and the total
heat transfer rate, respectively. The maximum relative error was found to be around 0.5%. For this single heat exchanger model test in our study, the computation time using the IF-97 model was about 50%
more than that using the LUT model in the ACL
Version 1.5.

Internal Energy (J)

P. Li, Y. Li, J. Seem

[2]
0

2200

Total Heat Transfer Rate (W)

Figure 13: Sequential ramp changes of inlet water
and air temperatures
Specific Enthalpy (J/Kg)

100

120

Max relative error:0.55%

0

20

40

60
Time (sec)

80

100

120

4

0

75s

Time (sec)

Specific Enthalpy (J/Kg)

80

[6]

2000

-0.5

4

CoolWater
LUT

Max relative error: 0.011%

-1
-1.5
-2
-2.5
-3
-3.5
-4

Max relative error: 0.50%

10

-4.5

CoolWater
LUT

9

-5
0

[2]
8
0
1.2

60

CoolWater
LUT

2400

x 10

11

40

Figure 15: Internal Energy in the 2nd and 6th control
volumes

20s

x 10

20

2600

1800

Inlet Water Temperature

30s

LUT
CoolWater

x 10

20

40

60

80

100

40

60
Time (sec)

80

100

120

Figure 16: Total heat transfer rate at heat exchanger

120

5

3

Max relative error: 0.46%
1.1
LUT
CoolWater

1

20

40

60
Time (sec)

80

100

Extremum Seeking Control (ESC)
of Economizer Operation

3.1 Overview of ESC

[6]
0.9
0

20

120

Figure 14: Specific enthalpy in the 2nd and 6th control
volumes

The extremum seeking control deals with the on-line
optimization problem of finding an optimizing input
uopt(t) for the generally unknown and/or time-varying
cost function l(t, u), where u(t) Rm is the input parameter vector, i.e.
uopt (t ) = arg minm l (t , u ) .
u\

(3)

Figure 17 shows the block diagram for a typical ESC
system [41]. The measurement of the cost function
l(t, u), denoted by y(t), is corrupted by noise n(t). The
transfer function FI(s) denotes the linear dynamics of
the mechanism that command the control or optimization parameter vector u(t). FO(s) denotes the transfer function of the sensor dynamics that measure the

The Modelica Association

456

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

cost function, which is often a low-pass filter for removing noise from the measurement.
d1

d2

FHP(s)

FLP(s)

y

FO(s)

l(t, u)

K(s)


u



FI(s)

n

Fig. 17: Block diagram of extremum seeking control
The basic components of the ESC are defined as follows. The dithering and demodulating signals are
denoted by d1T (t ) = [sin(1t ) " sin(mt ) ] and

d (t ) = [ a1 sin(1t ) + 1 " am sin(m t ) +  m ] ,
T
2

respectively, where i are the dithering frequencies
for each input parameter channel, and i are the
phase angles introduced intentionally between the
dithering and demodulating signals. The signal vector d2(t) contains the perturbation or dither signals
used to extract the gradient of the cost function l(t,
u). These signals work in conjunction with the highpass filter FHP(s), the demodulating signal
d1T (t ) = [sin(1t ) " sin(mt ) ] and the low-pass
filter FLP(s), to produce a vector-valued signal proportional to the gradient l (u) of the cost function
u
at the input of the multivariable integrator, where u
is the control input based on the gradient estimation.
By integrating the gradient signal, asymptotic stability of the closed loop system will make the gradient
vanish, i.e., achieving the optimality. Adding compensator K(s) may enhance the transient performance
by compensating the input/output dynamics. For a
detailed explanation of ESC, consult references [12,
13, 41].
The earliest version of ESC can be dated back to
Leblancs work in 1922 [42]. There was great interest in this subject in 1950s and 1960s [10, 11, 43].
The research conducted by Krsti and his coworkers
in the past decade ignited a resurgence of extremumseeking control [12, 13]. Krsti and Wang first provided the stability proof for general SISO nonlinear
plants based on averaging and singular perturbation
methods [12]. More design issues were addressed in
another paper by Krsti [13]. Later, the stability
proof was extended to discrete-time situation [44].
The proposed ESC framework has been applied to
various applications, such as maximizing biomass
production rate [45], maximizing pressure rise in
axial flow compressor [46], minimizing acoustic
pressure oscillation to enhance combustion stability
[47], minimizing the power demand in formation
flight [48], and minimizing limit cycling [49], among
The Modelica Association

others. The extremum seeking control was also studied along different paths. zgner and his coworkers
combined ESC with sliding mode control [50-52] to
study the vehicle ABS control. Based on the assumption of quadratic functional form with a finite number of parameters, Banavar developed an ESC
scheme with an adaptation procedure of on-line identifying the parameters in the assumed function [5355].
3.2 ESC for Energy Efficient Operation of
Economizers
The ESC based economizer control is illustrated in
Figure 18. The economizer control can be considered
as a dual-loop structure. The inner loop is the supply
air temperature control for the cooling coil, which
has faster dynamics. The outer loop is the damper
opening tuning for minimizing the cooling coil demand, which is realized with an ESC framework.
The nonlinear performance mapping is from the outdoor air damper opening to the cooling coil demand,
and the input dynamics are effectively the closed
loop dynamics for supply air temperature control. In
the three-state economizer operation scheme, as described in Section 1, the ESC is used for state 3
where mechanical cooling is required.
d1
FHP(s)

K(s)



FLP(s)

+

d2 Damper
+ command
u




Cooling coil demand Q
C

+

+

Mixed Air

Cooling
Coil

n Supply Air

Mixing
Damper
Setpoint Supply

Kcc(s)

Temperature



+ Air Temperature

(a) Detailed block diagram
d1
FHP(s)

FLP(s)
y

 (t, u)
Q
C



K(s)
Fcc_cL()


u

n

(b) Simplified block diagram
Figure 18: ESC based economizer control
3.3 Extremum Seeking Controller Design
Typical ESC design needs to determine the following parameters: the dither amplitude , the dither
frequency  and phase angle , the high pass filter
FHP(s), the low pass filter FLP(s), and the dynamic
compensator K(s). Based on averaging analysis, the

457

Modelica 2008, March 3rd  4th , 2008

P. Li, Y. Li, J. Seem

dither frequency should be relatively large with respective to the adaptation gain, but should not be too
large to trigger unmodeled dynamics and make the
system more sensitive to measurement noise. Also, if
the dither frequency is well out of the bandwidth of
the input dynamics, the roll-off in the magnitude response will slow down the convergence [13]. Therefore, dither frequency d is typically chosen to be
just a moderate value smaller than the cut-off frequency of the input dynamic as long as it is enough
to separate the time scales of the dither signal and the
inner loop dynamics. Generally, the dynamic compensator should be designed based on the dither signal, adaptation gain and the frequency responses of
the input dynamics. Particularly, a proper proportional-derivative (PD) action can increase the phase
margin of the input dynamics and thus make the inner loop more stable. However, extreme values of
the adaptation gain, especially the derivative gain,
will make the system unnecessarily affected by noise
and thus destabilize the system. Further design
guidelines are summarized as follows.
1) The dither frequency must be in the passband of
the high pass filter and the stopband of the low
pass filter, and it should be below the first cutoff frequency of the tuning schemes FI(s).
2) The dither amplitude should choose to be sufficiently small.
3) The dither phase angle should choose to satisfy


 =  < FI ( j ) +  < and it is desirable to
2

When saturation presents in the ESC loop, integrator
wind-up is unavoidable and, in consequence, leads to
the undesirable windup phenomena. Later in Section
4.3, a simulation study will show that, due to the
windup issue, the ESC action may be totally disabled
even when the air condition changes to a point demanding its re-activation. It is thus necessary to
modify the standard ESC structure in order to avoid
integrator windup.
There has been much work reported in the field of
anti-windup control (AWC) [57, 58]. In order to
keep the simple nature of ESC, a back-calculation
method is proposed as in Figure 19, following the
spirit of the references [58-60]. The difference between the input and output of the actuator is fed back
to the input end of the integrator through some gain
factor. Our simulation results have demonstrated that
this method works well to prevent the integrator
windup in ESC system. Future research needs to investigate the design guidelines for the proposed antiwindup ESC. The analysis will be based on combining the existing method for back-calculation AWC
and the averaging analysis [61, 62].
d1
FHP(s)

FO(s)
n +

design the phase angle  =   < FI ( j ) +  < 
such that  is close to zero.

y
+

+ d2

+

l(t, u)

u

+



FI(s)

Figure 19: Block diagram for the anti-windup ESC

2

4

3.4 Anti-windup ESC
Actuator saturation is often encountered in control
systems. To our best knowledge, the issue of actuator
saturation has not been discussed for extremum seeking control. For the economizer control, the actuator
saturation will happen when it is cool or hot outside.
For instance, when the outdoor air is around 53F,
the outdoor air damper will be positioned fully open
to allow 100% outdoor air to enter the AHU. When it
is warmer than 100 F, the damper will be closed to
a minimum opening which only maintain the lowest
ventilation for indoor air quality [56]. In other words,
the optimal reference input is not inside the saturation limit, but rather at either limit point. Transition
between the ESC operation and the non-ESC operation is affected by the saturation issue. The averaging
analysis of ESC [43] showed that, at a large time
scale, the ESC can be deemed as a linear system
regulating the gradient signal with a PI controller.
The Modelica Association

+

Gain

2

2

FLP(s)

+

Integrator

Simulation Study

The proposed extremum seeking control schemes
were simulated with the Modelica based economizer
model described in Section 2. The economizer model
was used to identify the system dynamics and then
illustrate the ESC schemes presented in the Section 3.
At the point of writing this paper, the condensation
computation from ACL 1.5 has not been incorporated into the cooling coil model due to the software
licensing delay. Only the dry air can be simulated.
The simulation results in the following are presented
for illustration purpose. More rigorous treatment will
be done after the condensation computation is made
up to deal with moist air.
4.1 ESC with Standard Design
As previously stated, the control objective in this
study is to minimize the chilled water flow rate of
the cooling coil by tuning the OAD opening. The
input dynamics from the OAD opening to the chilled

458

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

water flow rate was approximated based on several
open-loop simulations. Fast (20 second) ramp input
was used to approximate step input in order to remove the output jitter due to the inner loop PI control.
Two fast-ramp responses are shown in Figure 20,
which shows the second-order system behavior
across the whole range of operating conditions.
4 .2
Inner Loop Dynamics

Fitted

4 .0

A group of tests indicate that  n ranged from
0.0108 to 0.021 rad/sec. As a conservative approximation,  n was chosen to be 0.011 rad/sec. The
damping ratio was estimated from the percent overshoot and was determined as 0.6. To properly separate the dither signal and plant dynamics, the dither
frequency d is selected as one tenth of the natural
frequency. Next, the following high pass filter FHP(s)
was selected:

Water Flow Rate (Kg/s)

3 .8

FHP ( s ) =

3 .6

s
s + 0.0001

(6)

3 .4

which has a unit gain at the d. The low pass filter

3 .2

was designed as

3 .0
2 .8

FLP ( s ) =

2 .6

0.00062
s 2 + 2  0.6  0.0006 s + 0.00062

(7)

2 .4

which has approximately 10dB and 20dB attenuation

2 .2
3000

3250

Time (sec)

3500

3750

at d and 2d, respectively. To be consistent
with the phase lag introduced by the input dynamics FI(s), the dither phase  was selected as 0.5
(radian), which makes  = FI ( j ) +   0.1 . The

(a) Damper opening from 100% to 70%
Inner Loop Dynamics

12

Fitted

Water Flow Rate (Kg/s)

11
10
9
8
7
6
5
4
2600

2800

3000

3200

3400

3600

3800

4000

4200

4400

Time (sec)

(b) Damper opening from 50% to 20%
Figure 20: Chilled water flow rate output under fast
ramp change of outdoor air damper position
The following second order model was assumed to
fit the fast-ramp test data:

FI ( s ) =

n2
s 2 + 2 ns +  n 2

(4)

dither amplitude was chosen to be 10%.
The designed ESC was tested with a fixed operating
condition. To be consistent with standard economizer design conditions, the supply air temperature
is controlled at 55F and the return air temperature is
maintained around 75F by providing a constant heat
input to the indoor space. The system was started at
minimal OAD opening (20%) to ensure adequate
indoor air quality, and the ESC controller was turned
on at about 3000 seconds to bring the system the optimum. The optimal OAD opening in this study is
100% since the outdoor air was set to 286K (55F),
which is always lower than the return air temperature
297K (75F). Therefore, the more outdoor air intake,
the less cooling water needed to be consumed. Figure 21 shows the time histories of the optimized
chilled water flow rate and OAD opening. The obtained steady-state results are very close to the optimum since the assumed condition is mechanical
cooling with optimal OAD opening at 100%.

where  n is the undamped natural frequency and 
is the damping ratio. The damping ratio  was first
approximated by the percent overshoot suggested in
[63], then the 10% to 90% rise time Tr was estimated.
The  n can then be approximated via the following
relationship with Tr and  [63]:
2.16 + 0.60
(5)
Tr =

n
which is accurate for 0.3    0.8 .

The Modelica Association

459

Modelica 2008, March 3rd  4th , 2008

F lo w R a te (K g /s)

P. Li, Y. Li, J. Seem

25

Start of ESC

20
15

20
15
10
5

0

0.5

1

1.5

2

2.5

3

3.5

10

4
x 10

5

O A D O p e n in g (% )

W a ter F lo w R a te (K g /s)

30

0
-5
0

1000

2000

3000

4000

5000

6000

7000

4

300
200
100
Saturated Control Input
Unsaturated Control Input

0
0

0.5

1

1.5

2

2.5

3

3.5

4
4

x 10

T e m p e ra tu re (K )

100
80
60

320

300
Return Air Temperature
Outdoor Air Temperature

280
0

40

0.5

1

1.5

2

2.5

3

3.5

4
4

Time (sec)

x 10

20
1000

2000

3000

4000

Time (sec)

5000

6000

7000

Figure 21: Tuning results of ESC with standard ESC.
4.2 Anti-Windup ESC

Another simulation study was conducted to verify
the effectiveness of the proposed anti-windup ESC.
Assume that a 20% damper opening is the minimum
requirement for indoor air quality, and thus this was
set as the lower saturation limit. The upper saturation
limit was 100%. In the simulation study as shown in
Figure 21, the initial outdoor air damper opening was
set at 20%, the same as the lower saturation limit.
The initial air temperature was again set to be 286 K.
Figure 22 shows the integrator windup phenomenon
when only the general ESC scheme was applied.
Driven by the ESC, the damper opening was increased from 20% to 100% which was the corresponding achievable optimal setting. Then the outdoor air temperature was suddenly increased to 310
K (36.85 C) at 6000 seconds, the new optimal opening was supposed to be below the lower saturation
limit. However, the results show that the ESC was
unable to respond to such change with reducing the
damper opening. Rather the damper appeared
stuck at the previous position. In comparison, as
shown in Figure 23, applying the back-calculation
based anti-windup ESC starting from 3000s effectively solved this problem. Therefore, the proposed
anti-windup ESC scheme is shown to be able to handle the saturation windup problem.

The Modelica Association

20
10
0

0

0.5

1

1.5

2

2.5

3

3.5

4
x 10

OA Opening (%)

0

Flow Rate (Kg/s)

Figure 22: Standard ESC under actuator saturation

0

800
600
400
200
0
-200

4

Saturated Control Input
Unsaturated Control Input

0

0.5

1

1.5

2

2.5

3

3.5

4
x 10

Temperature (K)

O A D O p en in g (% )

120

4

320
300
Return Air Temperature

280

Outdoor Air Temperature

0

0.5

1

1.5

2
Time (sec)

2.5

3

3.5

4
x 10

4

Fig. 23: Anti-windup ESC under damper saturation

5

Conclusions

In this paper, a Modelica based dynamic simulation
model was developed for a single-duct air-side
economizer based on Dymola and AirConditioning
Library. In order to make the cooling coil modeling
more effective and computationally efficient, revision was made on the water medium model and the
associated heat exchanger modeling. An ESC algorithm was proposed as part of a three-state economizer operation, which aims to minimize mechanical
cooling load for the economizer operation in commercial buildings. The standard ESC algorithm was
enhanced by an anti-windup ESC scheme against
damper (actuator) saturation. Simulations were conducted to search for the optimal outdoor air damper
opening for standard ESC and the anti-windup ESC.
The simulations results demonstrated the effective-

460

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

ness of using ESC for tuning the outdoor air damper
position to minimize mechanical cooling load. The
proposed enhancement was also validated through
the simulation results.

References
1.
2.

3.

4.
5.
6.

7.

8.

9.
10.

11.
12.

13.

EPA, Energy Cost and IAQ Performance of
Ventilation Systems and Controls. EPA Report,
2000. EPA-4-2-S-01-001.
ASHRAE, Energy Standard for Buildings Except Low-Rise Residential Buildings. 2004,
American Society of Heating, Refrigerating and
Air-Conditiioning Engineers, Inc.: 1791 Tullie
Circle NE, Atlanta, GA 30329.
ASHRAE,
90.1
User's
Manual
ANSI/ASHRAE/IESNA Standard 90.1-2004.
2004, American Society of Heating, Refrigerating and Air-Conditioning Engineers, Inc.
Financial Times Energy, I. Design Brief
Economizers.
NBCIP, Product Testing Report: Duct-Mounted
Relative Humidity Transmitters. 2004, National
Building Controls Information Program.
NBCIP, Product Testing Report Supplement:
Duct-Mounted Relative Humidity Transmitters.
2005, National Building Controls Information
Program.
Song, L. and M. Liu, Optimal outside airflow
control of an integrated air-handling unit system for large office buildings. Journal of Solar
Energy Engineering, Transactions of the ASME,
2004. 126(1): p. 614-619.
Guo, C., Q. Song, and W. Cai, A neural network
assisted cascade control system for air handling
unit. IEEE Transactions on Industrial Electronics, 2007. 54(1): p. 620-628.
Blackman, P.F., Extremum-Seeking Regulators,
in An Exposition of Adaptive Control. 1962,
Pergamon Press.
Sternby, J., Extremum Control Systems: An Area
for Adaptive Control?, in Preprints of the Joint
American Control Conference. 1980: San Francisco, CA.
strm, K.J. and B. Wittenmark, Adaptive control. 2nd ed. 1995, Reading, Mass.: AddisonWesley. xvi, 574 p.
Krsti, M. and H.-H. Wang, Stability of extremum seeking feedback for general nonlinear
dynamic systems. Automatica, 2000. 36(4): p.
595-601.
Krsti, M., Performance improvement and limitations in extremum seeking control. Systems
and Control Letters, 2000. 39(5): p. 313-326.

The Modelica Association

14. Bendapudi, S. and J.E. Braun, A Review of Literature on Dynamic Models of Vapor Compression Equipment. 2002.
15. Bourdouxhe, J.-P., M. Grodent, and J. Lebrun,
Reference Guide for Dynamic Models of HVAC
Equipment, ed. M. Geshwiler. 1998: American
Society of Heating, Refrigerating & AirConditioning Engineers.
16. MacArthur, J.W. Analytical Representation of
the Transient Energy Interactions in Vapor
Compression Heat Pumps. 1984. ASHRAE, Atlanta, GA, USA.
17. MacArthur, J.W. and E.W. Grald, Prediction of
cyclic heat pump performance with a fully distributed model and a comparison with experimental data. ASHRAE Transactions, 1987. Vol.
93, Part 2.
18. Nyers, J. and G. Stoyan, Dynamical model adequate for controlling the evaporator of a heat
pump. International Journal of Refrigeration,
1994. 17(2): p. 101-108.
19. Willatzen, M., N.B.O.L. Pettit, and L. PlougSorensen, General dynamic simulation model
for evaporators and condensers in refrigeration.
Part I: Moving-boundary formulation of twophase flows with heat exchange. International
Journal of Refrigeration, 1998. 21(5): 398-403.
20. Rasmussen, B.P. and A.G. Alleyne, Controloriented modeling of transcritical vapor compression systems. Journal of Dynamic Systems,
Measurement and Control, Transactions of the
ASME, 2004. 126(1): 54-64.
21. Zhou, X., Dynamic modeling of chilled water
cooling coils, in School of Mechanical Engineering. 2005, Purdue University.
22. Svensson, M.C., Studies on on-line optimizing
control with application to a heat pump. 1994,
The University of Trondheim.
23. He, X., S. Liu, and H. Asada. Modeling of vapor
compression cycles for advanced controls in
HVAC systems. 1995. Seattle, WA, USA.
24. Wang, S., J. Wang, and J. Burnett, Mechanistic
model of centrifugal chillers for HVAC system
dynamics simulation. Building Services Engineering Research and Technology, 2000. 21(2):
p. 73-83.
25. Modelica.
2007
[cited; Available from:
http://www.modelica.org/.
26. Modelon.
2007
[cited; Available from:
http://www.modelon.se/.
27. Videla, J.I. and B. Lie. A New Energy Building
Simulation Library. in Proceedings of Modelica
2006. 2006.
28. Dynasim. http://www.dynasim.se/dynasim.htm.

461

Modelica 2008, March 3rd  4th , 2008

P. Li, Y. Li, J. Seem

29. Lebrun,
J.,
Variable
Speed
Fan,
http://cbs.lbl.gov/diagnostics/model_library.
2004.
30. Wagner, W., et al., The IAPWS industrial formulation 1997 for the thermodynamic properties
of water and steam. Journal of Engineering for
Gas Turbines and Power, 2000. 122(1): p. 150180.
31. Tan, H. and A. Dexter, Estimating airflow rates
in air-handling units from actuator control signals. Building and Environment, 2006. 41(10):
p. 1291-1298.
32. Limperich, D., et al. System Simulation of
Automotive Refrigeration Cycles. in Proceedings of the 4th International Modelica Conference. 2005. Hamburg.
33. Wagner, W. and A. Pru, The IAPWS Formulation 1995 for the Thermodynamic Properties of
Ordinary Water Substance for General and Scientific Use. J. Phys. Chem. Ref. Data 2002. Volume 31(Issue 2): p. 387-535.
34. Wagner, D.-I.W. and D.-I.U. Overhoff, FLUIDCAL. 2004. Basic Package Water (IAPWS95) for calculating the thermodynamic properties of H2O.
35. Hilding Elmqvist, H.T.a.M.O. Object-Oriented
Modeling of Thermo-Fluid Systems. in Proceedings of the 3rd International Modelica Conference. 2003. Linkping.
36. Bendapudi, S., Development and evaluation of
modeling approaches for transients in centrifugal chillers. 2004, Purdue University
37. Torge Pfafferott, G.S. Implementation of a
Modelica Library for Simulation of Refrigeration Systems. Proceedings of the 3rd International Modelica Conference. 2003. Linkping.
38. Tummescheit, H., Design and Implementation
of Object-Oriented Model Libraries using Modelica, in Department of Automatic control. 2002,
Lund Institute of Technology.
39. Eborn, J., On Model Libraries for Thermohydraulic Applications, Department of Automatic Control. 2001. Lund Inst. of Technology.
40. Modelon AB, AirConditioning Library Users
Mannaul Version 1.5. 2007.
41. Rotea, M.A., Analysis of multivariable Extremum Seeking Algorithms. Proceedings of the
American Control Conference, 2000. p. 433-437
42. Leblanc, M., Sur lelectrification des Chemins
de fer au Moyen de Courants Alternatifs de
Frequence Elevee. Revue Generale de
lElectricite, 1922.
43. Tsien, H.S., Engineering cybernetics. 1954,
New York,: McGraw-Hill. xii, 289p.

The Modelica Association

44. Choi, J.Y., et al., Extremum seeking control for
discrete-time systems. IEEE Transactions on
Automatic Control, 2002. 47(2): p. 318-323.
45. Wang, H.H., M. Krstic, and G. Bastin, Optimizing bioreactors by extremum seeking. International Journal of Adaptive Control and Signal
Processing, 1999. 13(8): p. 651-669.
46. Wang, H.-H., S. Yeung, and M. Krstic, Experimental application of extremum seeking on an
axial-flow compressor. IEEE Transactions on
Control Systems Technology, 2000. 8(2): p.
300-309.
47. Banaszuk, A., Y. Zhang, and C.A. Jacobson.
Adaptive control of combustion instability using
extremum-seeking. in Proceedings of the American Control Conference. 2000.
48. Binetti, P., et al., Control of formation flight via
extremum seeking. Proceedings of the American
Control Conference, 2002. 4: p. 2848-2853.
49. Wang, H.-H. and M. Krsti, Extremum seeking
for limit cycle minimization. IEEE Transactions
on Automatic Control, 2000. 45(12): p. 24322437.
50. Drakunov, S., et al., ABS control using optimum
search via sliding modes. IEEE Transactions on
Control Systems Technology, 1995. 3(1): 79-85.
51. Yu, H. and . zgner. Extremum-seeking control strategy for ABS system with time delay. in
Proceedings of the American Control Conference. 2002.
52. Yu, H. and . zgner. Extremum-seeking control via sliding mode with periodic search signals. in Proceedings of the IEEE Conference on
Decision and Control. 2002.
53. Speyer, J.L., et al. Extremum seeking loops with
assumed functions. in Proceedings of the IEEE
Conference on Decision and Control. 2000.
54. Banavar, R.N., D.F. Chichka, and J.L. Speyer.
Functional feedback in an extremum seeking
loop. in Proceedings of the IEEE Conference on
Decision and Control. 2001.
55. Banavar, R.N. Extremum seeking loops with
assumed functions: Estimation and control. in
Proceedings of the American Control Conference. 2002.
56. ASHRAE, ASHRAE standard : ventilation for
acceptable indoor air quality. 2001, Atlanta,
GA: American Society of Heating, Refrigerating
and Air-Conditioning Engineers, Inc. 34 p.
57. strm, K.J. and B. Wittenmark, ComputerControlled Systems: Theory and Design. 3rd ed.
Prentice Hall information and system sciences
series. 1997, Upper Saddle River, N.J.: Prentice
Hall. xiv, 557 p.

462

Modelica 2008, March 3rd  4th , 2008

Dynamic Modeling and Self-Optimizing Control of Air-Side Economizers

58. strm, K.J. and L. Rundqwist. Integrator
windup and how to avoid it. in Proceedings of
1989 American Control Conference. 1989.
59. Fertik, H.A. and C.W. Ross, Direct digital control algorithms with anti-windup feature. ISA
Transactions, 1967: p. 317-328.
60. strm, K.J., Advanced control methods  Survey and assessment of possibilities, in Advanced
control in computer integrated manufacturing.
Proceedings of the thirteenth annual Advanced
Control Conference H.M. Morris, E.J. Kompass,
and T.J. Williams, Editors. 1987.
61. Sanders, J.A., F. Verhulst, and J.A. Murdock,
Averaging methods in nonlinear dynamical systems. 2nd ed. 2007, New York: Springer.
62. Khalil, H.K., Nonlinear systems. 3rd ed. 2002,
Upper Saddle River, N.J.: Prentice Hall.
63. Dorf, R.C. and R.H. Bishop, Modern Control
Systems (10th Edition). 2004: Prentice Hall.
64. DOD, Heating, Ventilating, Air Conditioning,
and Dehumidfying Systems. 2005, United States
Department of Defense.
65. Hydeman, M., et al., Advanced Variable Air
Volume System Design Guide. 2003, California
Energy Commission.

Appendix: Economizer Operation
The American Society of Heating, Refrigerating
and Air Conditioning Engineers (ASHRAE) recommends using economizers based on the cooling capacity size and weather characteristics for the building location. ASHRAE [2] classifies climate data
based on temperature with a number from 1 to 7, and
the letters A, B, and C, which correspond to moist,
dry, and marine climates, respectively. Table 1 contains climate zones for 16 cities in the United States.
The fourth column (Economizer Requirement)
shows the cooling capacity for which an economizer
is required by ASHRAE [2]. No economizer is required in weather locations 1A, 1B, 2A, 3A, and 4A.
In weather locations 3B, 3C, 4B, 4C, 5B, 5C, and
6B, an economizer is required when the cooling requirement is greater than or equal to 19 kW. In all
other weather locations, an economizer is required
when the cooling requirement is greater than or equal
to 40 kW. ASHRAE [3] describes several control
strategies for transitioning between 100% outdoor air
and the minimum outdoor air required for ventilation. The control strategies are called high limit
shutoff control for air economizer. Following is a
list of strategies that can be programmed in a computer control system.

perature. If the outdoor air temperature is greater
than the transition temperature, then the dampers
are controlled for the minimum outdoor air required for ventilation. ASHRAE [3] said this is the
most reliable and simple control strategy since a
simple thermostat placed in an outdoor air intake
can be used. Table 2 shows the transition temperature for different climatic zones. The U.S. Department of Defense [64] recommends this strategy.
 Differential dry bulb temperature. This control
strategy compares the outdoor and return air temperatures. If the outdoor temperature is greater
than the return air temperature, then the dampers
are controlled for minimum outdoor air required
for ventilation. This strategy should not be used in
the following climatic zones: 1A, 2A, 3A, and
4A. Hydeman et al. [65] said, "Of all of the options, dry bulb temperature controls prove the
most robust as dry-bulb temperature sensors are
easy to calibrate and do not drift excessively over
time. Differential control is recommended
throughout California and the sensors should be
selected for a through system resolution of 0.5 F.
Dry-bulb sensors work well in all but humid climates, which are not typical in California."
 Fixed enthalpy. This control strategy measures the
outdoor air temperature and relative humidity.
Then the outdoor air enthalpy is calculated and
compared with a transition enthalpy. If the outdoor air enthalpy is greater than the transition enthalpy, then the dampers are controlled for minimum outdoor air required for ventilation. ASHRAE [2] recommends a transition enthalpy of
47kJ/kg and at locations with altitudes significantly different than sea level, the transition enthalpy should be determined for 24 C and 50%
relative humidity. This strategy should not be
used in the following climatic zones: 1B, 2B, 3B,
3C, 4B, 4C, 5B, 5C, 6B, 7, and 8, due to the problem with humidity sensors.

 Differential enthalpy. This control strategy deter-

 Fixed dry bulb temperature. This strategy compares the outdoor temperature to a transition temThe Modelica Association

463

mines the outdoor and return air enthalpy from
measurements of the outdoor and return air temperature and relative humidity. If the outdoor air
enthalpy is greater than the return air enthalpy,
then the dampers are controlled for minimum outdoor air required for ventilation. In 2003, the U.S.
General Services Administration required a differential enthalpy economizer for air-handling units
with a capacity greater than 3,000 CFM (1,416
LPS) unless the air handling system design precluded the use of an air-side economizer. Regarding the use of differential enthalpy controls, HyModelica 2008, March 3rd  4th , 2008

P. Li, Y. Li, J. Seem

ers when the hot dry outdoor air has lower enthalpy than the space(s) at cooling balance point.
What happens is that the economizer opens up and
the coil is dry, which in turn dries out the space(s)
until the return enthalpy goes below the outdoor
enthalpy. As a result, the economizer damper
closes, the space humidity increases, and the cycle
repeats.

deman et al. [65] said, Differential enthalpy controls are theoretically the most energy efficient.
The problem with them is that the sensors are very
hard to keep calibrated and should be re-calibrated
on an annual or semi-annual basis. Contrary to
common perception, enthalpy controls do not
work in all climates. In hot dry climates they can
hunt and excessively cycle the economizer damp-

Table A.1. Climate zones and economizer requirement for 16 US cities. (qcool: cooling capacity)
Climate

Description

Cities

Economizer Requirement

1A
1B
2A
2B
3A
3B
3C
4A
4B
4C
5A
5B
5C
6A
6B
7A
7B
8

Very Hot - Humid
Very Hot - Dry
Hot - Humid
Hot - Dry
Warm - Humid
Warm - Dry
Warm - Marine
Mixed - Humid
Mixed - Dry
Mixed - Marine
Cool - Humid
Cool - Dry
Cool - Marine
Cold - Humid
Cold - Dry
Very Cold - Humid
Very Cold - Dry
Arctic

Miami, FL
--Houston, TX
Phoenix, AZ
Charlotte, NC
Los Angeles, CA
San Francisco, CA
New York, NY
Albuquerque, NM
Seattle, WA
Chicago, IL
Denver, CO
--Minneapolis, MN
Cheyenne, WY
Ashland, WI
Jackson, WY
Fairbanks, AL

None
None
None
qcool  40 kW
None
qcool  19 kW
qcool  19 kW
None
qcool  19 kW
qcool  19 kW
qcool  40 kW
qcool  19 kW
qcool  19 kW
qcool  40 kW
qcool  19 kW
qcool  40 kW
qcool  40 kW
qcool  40 kW

Table A.2. Transition temperatures for fixed dry bulb economizer.
Climatic Zones

Transition Equation

1B, 2B, 3B, 4B, 4C, 5B, 5C, 6B, 7B, 8

TOA > 24D C

5A, 6A, 7A

TOA > 21D C

1A, 2A, 3A, 4A

TOA > 18D C

The Modelica Association

464

Modelica 2008, March 3rd  4th , 2008

Session 4c
Automotive Applications

The Modelica Association

465

Modelica 2008, March 3-4, 2008

The Modelica Association

466

Modelica 2008, March 3rd  4th , 2008

Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station in IFP

Using Modelica for modeling and simulation of spark ignited
engine and drilling station in IFP
Masoud Najafi and Zakia Benjelloun-Dabaghi

Abstract
Modeling and simulation are becoming more crucial
since engineers need to analyze very complex systems
composed of several components from different domains. Current tools used in IFP (French Institute
of Petroleum) are generally weak in treating multidomain models because the general tools are blockoriented and thus demand a huge amount of manual
rewriting to get the equations in explicit form. The
most popular tool used at IFP in simulation of 0D/1D
systems and control design area is Simulink. In this
paper, we present the use of the Modelica language
in modeling and simulation of two industrial applications.
Keywords: Modeling; Modelica; Scicos; SI Engine;
Drilling station

1 Introduction
Scilab1 is a free and open-source software for scientific calculation and Scicos2 is a toolbox of Scilab that
provides an environment for modeling and simulation
of hybrid dynamical systems [1, 2]. They can be compared with Matlab and Simulink, respectively. The underlying hybrid formalism in Scicos allows modeling
and simulation of very general hybrid dynamical systems, i.e., systems including continuous, discrete-time
and event based behaviors.
Scicos supports acausal modeling or modeling physical systems with components. This has been done, in
particular, by lifting the causality constraint on Scicos
blocks and by introducing the possibility of describing
block behaviors in the Modelica language. This extension allows the user to model physical systems de Masoud

de

Voluceau,

Najafi,
INRIA-Rocquencourt,
Domaine
BP 105, 78153, Le Chesnay, France

 Zakia

Benjelloun-Dabaghi, French institute of Petroleum
(IFP), 1 & 4, avenue de Bois-Prau, 92852, Rueil-Malmaison,
France
1 www.scilab.org
2 www.scicos.org

The Modelica Association

scribed by mathematical formula. Most physical components are more naturally modeled with components
simply because physical laws are expressed in terms
of mathematical equations [3].
Modelica is a modern object-oriented programing language based on equations instead of assignment statements. Modelica has a multi-domain modeling capability, e.g., electrical, mechanical, thermodynamic, hydraulic, and control systems can be described by Modelica. Modelica programs are built from classes that
contain elements, the variable declarations, and equations. In order to write a complicated model easily
and efficiently, the model is decomposed into several
components. Then, by interconnecting components
the model is constructed [4].
In the following sections, we will present two industrial applications: drilling station and spark ignited engine. These applications have been already modeled
in Simulink which is a popular tool at IFP mostly used
for simulation of 0D/1D systems and control system
design. In this paper, we will present the way these applications have been modeled with Modelica and simulated in Scicos.

2 Modeling a drilling station
Modeling in the oil and gas industry is used in several stages of operations, from exploration activity to
refining of the crude oil. The purpose of modeling is
to improve an understanding of the problems that are
usually difficult or expensive to deal with in the real
physical system. Drilling a well into a reservoir is an
expensive, risky, and time-consuming process. So the
problems and malfunctions should be detected as soon
as they appear. Most of problems in drilling industry
are due to lack of a complete knowledge about the environment and the process. Modeling and simulation
are inevitable to detect and control of such problems.
In previous works done at IFP a model of drilling station has been developed [5, 6, 7]. The particularity
of this work, inspired directly from cited works, lies
in using Modelica language and formal computing to

467

Modelica 2008, March 3rd  4th , 2008

M. Naja, Z. Benjelloun-Dabaghi

drillers encountered in rotary drilling was that of keeping their boreholes straight. The deeper drillers went,
the more the boreholes deviated from vertical. Drill
collars weigh more than drill pipe and are designed
to lower the center of gravity of the drill pipe. This
helps control drilling (e.g., making a straight hole) and
prevents the pipe from kinking and breaking. Two to
twenty drill collars are often used.
The drilling bit is the end of the drill string that actually cuts up the rock. The bit screws into the bottom of
the drill collars. The most common bit is the tricone bit
which has three rotating cones. The cones have teeth
that are designed to chip and flake away the rock as the
bit is rotated.

Derrick

Tin
Tension
control

Kelly
Rotary table
Rotary table turn engine

Dril string

Casing

2.1

Drll collar

BHA

Bit

Figure 1: A schematic diagram of a drilling well station.
model and simulate the drilling well station model.
A drilling well station is composed of several parts.
The first visible part of a drilling well is the rig which
is a structure housing equipments used to drill into underground reservoirs for water, oil, or etc. The basic
components of a rotary drilling rig are the derrick and
hoist, rotary table, kelly, drill pipe, bit, and pump as
shown in Fig. 1.
The derrick is the support structure that holds the
drilling apparatus and the drill string. The drill string
consists of rotary table, kelly, drill pipe, drill collars,
and bit. The rotary table is a circular table in the derrick floor which is rotated by the electrical or diesel engines. The kelly is a four or six-sided pipe that passes
up through the rotary table and transfers rotary motion
of the rotary table to the drill string. When rotated by
the rotary table, the kelly is free to be raised or lowered
by a cable connected to the top of the derrick down the
kelly.
Drill Pipe is always the longest component in a drill
string. Typically thousands of meters of drill pipe are
used to drill an oil well. Drill pipe is manufactured in
segments of 10 meters lengths. The top joint of the
drill pipe is connected to the kelly. Bottom joint of
the drill pipe is directly connected to larger diameter
pipes called drill collars. One of the earliest problems
The Modelica Association

Model of the drilling well

The drilling model is a set of differential equations describing behavior of components of the drilling station,
including the bit and the rock interactions. The model
should be as simple as possible to explain the desired
malfunctions. The diagram in Fig. 2 shows the model
composed of four main components: a rig, a drill pipe,
a drill collar, and a drilling bit. These component interact with each other via four main variables:
T : the torque that a component applies on another,
F: the force that a component applies on another,
: the angular velocity of a component,
V : the longitudinal velocity of a component.
A more detailed description of components model
will be given in the following sections.
Tin
Xin
Vin

bot ,Vbot

tab ,Vtab
Drill
rig

Ftop , Ttop

Drill
pipe

Fc , Tc

c ,Vc
Drill
collars

Fbit , Tbit

Drill
bit

Figure 2: Connecting variables
The model is nonlinear and one-dimensional and provides several bottom/surface transfer functions which
can be used for real-time estimation of borehole variables. Furthermore, the model can be used for stability
analysis that is extremely important in controlling the
drilling process. Another important use of the model is
the simulation of transient and steady state behaviors.
2.1.1

Drilling rig

Drilling rigs may have very complex structure varying
in form and size. From the modeling point of view
the rig imposes the boundary conditions on the drill
string structure. A first approach to model the rig is to

468

Modelica 2008, March 3rd  4th , 2008

Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station in IFP

consider its geometric structure and the elements that
constitute the rig. This may give an exact model, but
it would not be practical. Because in fact this model
would be very complex and numerically would be so
slow that it could not be used in real-time applications.
Another problem with this approach is the fact that it
cannot be used for another rig.
In [5], the model of two mass-spring-damper has been
proposed for the model of longitudinal motions of the
drilling rig, as shown in Fig. 3. Although the model
is simple, it can provide a very good low frequency
response (up to 20 Hz) which is quit enough for our
purpose. Further more, when the rig changes, unlike
the first method which needs a complete new model,
here we need just a new identification for parameters
of the model.
Xin

x1
m1

cretized to N = 15 sections, see Fig. 4. This modeling approach fulfills the precision requirements with a
minimum number of variables [6].
T f riction
Rig

i1
Ti1

i
Ti

Drill
Collar

N

Drilling
Bit

i+1
Ti+1

Applying Newtons laws for rotation, we can obtain
the model of each segment.
2.1.3

Drill collars

The drill collars are modeled in the same way as the
drill pipe. Since, the length of the drill collars are
smaller than that of the drill pipe, we do not discretize
the drill collars and we consider a single rigid rod. In
order to obtain the model of the drill collars, Newtons
laws for rotation are used.
Drill bit

The model of the Rig, drill pipe, and drill collars are
composed of two uncoupled dynamics: a longitudinal and a rotational dynamics. These two dynamics
should be coupled in the drill bit model. Thus, beside
the longitudinal and rotational dynamics in the drill
bit, a coupling dynamics is necessary. The diagram in
Fig. 5 shows these dynamics.

Vtab
Ftop

Figure 3: A mechanical model for the drilling rig
The mass m1 and m2 can be interpreted as the mass of
the hook and the kelly, respectively [5]. Ftop is the necessary force on the well surface to bore the drill string
down into borehole. Vtab is the kellys longitudinal velocity.
Rotary table is modeled as a rotating mass with inertial momentum. In Fig. 2, tab , Tin , Ttop are the angular velocity of the rotary table, the torque applied on
the rotary table, and the torque needed to turn the drill
string, respectively.

DVIR (c )

DTOB (Tbit )

DWOB (Fbit )

Rock/Bit contact
(rotational)

DVIZ (Vc )

Rock/Bit contact
(longitudinal)

Vbit
longitudinal/rotational coupling

Figure 5: Drilling bit model

Drill pipe

The drilling pipe is composed of multiple segments
which are screwed together to construct a pipe with
thousands of meters. Due its length, the drilling pipe
exhibits torsional, longitudinal, and lateral motions.
In this paper, only longitudinal and torsional motions
are considered. Precise modeling of the drilling pipe
needs complicated methods such as finite elements. In
order to simplify the model, the drilling pipe is disThe Modelica Association

i+1

u1

x2

2.1.2

i

Figure 4: Discretizing the drilling pipe

2.1.4
m2

i1

1

In Fig. 5, DVIZ, DVIR, DWOB, DTOB represent the
downhole longitudinal velocity, the downhole angular
velocity, the downhole weight-on-bit, and the downhole torque-on-bit, respectively. The DTOB (Tbit )
which is the torque resistance against the rotation due
to the rock/bit contact is computed by iso-weight tables. These tables are used to compute the necessary
torque as a function of DWOB and DVIR (c ). The

469

Modelica 2008, March 3rd  4th , 2008

M. Naja, Z. Benjelloun-Dabaghi

Torque_in

0

X_in

0

V_in

RIG

Drill Pipe
Mux

Drill Pipe

Drill Collars

Drill Bit

Figure 6: Model of the drilling rig in Scicos
model is composed of four implicit blocks and five
explicit blocks.
,
,
,
and
blocks are implicit blocks (written
with the Modelica language). There are three explicit
blocks providing input variables of the
block.
block to visualize output variables
There is a
in the model, and a
block to activate the scope
block to sample its inputs. Note that the connection
2.2 Simulation example
type between the implicit blocks is different from that
For each component of the drilling well, i.e., rig, between explicit blocks. These connections represent
drilling pipe, drill collars, and drilling bit, we have de- physical connection, i.e., there is no flow direction.
veloped a Modelica model. The model of the drilling With the the developed model, the user is able to simurig has three control inputs: the rotary table applied late the model in different situations. Unwanted vibratorque (Tin ), the longitudinal speed of the kelly (Vin ), tion/oscillation is a well known recurrent phenomenon
and initial position of the kelly (Xin ), see Fig. 2. Thus, in rotary drilling that may cause catastrophic bit failthe
block has three explicit inputs. Each Model- ures [5, 6, 7, 8, 9]. This phenomenon is the result of
ica model is considered as an implicit block in Scicos. torque fluctuations due to Coulomb frictions. These
These blocks should be connected to build the model frictions are are included in our model, so it should
of the drill well.
be possible to simulate this phenomenon which is
The Scicos diagram constructed by connecting devel- known as stick-slip. In order to demonstrate this pheoped Modelica blocks is shown in Fig. 6. This Scicos nomenon, the simulation is started at steady state anbottom end of the drilling bit is a tricone transforming
the rotational motions into longitudinal motions. c is
computed as a function of Vbit and the geometric structure of the bit. The WOB is computed as a function of
the axial speed of the tricone bit and the longitudinal
speed of the bit.

The Modelica Association

470

Modelica 2008, March 3rd  4th , 2008

Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station in IFP

of the air/fuel ratio or fuel richness are not modeled in
this work. The system including fundamental components, sensors, and actuators is illustrated in Fig. 8.

3500
3250
3000
2750
2500

+

0

30

60

90

120

150

180

210

240

270

300

EGR valve

Intake manifold

30.0
22.5

Throttle

Spark plug

15.0

AIR

7.5
0.0

+

0

30

60

90

120

150

180

210

240

270

300

Intake runner

Bypass valve

60

Exhaust valve

Inlet valve

45

Purge control valve

30

Piston

Cylinder

15
0

+

0

30

60

90

120

150

180

210

240

270

300

N
Cranckshaft

Figure 7: simulation of a drilling station exhibiting oscillations in the rotation speed
gular speed of 66 rpm. The input torque is Tin =3000
N.m., Xin =-0.03, and Vin =0. With these inputs, the system is stable. At t=100 sec, the torque is increased to
3200 N.m. which sets off the oscillation. The simulation result is given in Fig. 7. In the top subplot, the
input torque applied on the rotary table is shown. The
middle subplot shows the angular velocity of the rotary table, and the bottom subplot shows the angular
velocity of the drilling bit.

Mload

Figure 8: Principle sketch of SI-engine

3.1

Model of the SI engine components

In this subsection, a brief description of the engine
components and their corresponding Scicos block is
given, more details are given in [10]. These components are shown in Fig. 9.

3 Mean value SI engine
The model of the SI engine described in this section
is a nonlinear, low frequency model of a fuel-injected
four cylinders SI engine which is generally referred to
as a mean value model. Mean value engine models attempts to capture dynamics in a time-scale spanning
over several combustion cycles. Fast events are not of
interest other than their effects on a larger scale. Most
cyclic dynamics are modeled by their average value
over a cycle. The speed and torque output of the engine and the pressure in the inlet manifold are the aspects of most interest in mean value engine model that
we have developed. Mean value engine model generally represents a basis for the development of different
engine control strategies.
The model of the overall engine is composed of several
components. In order to develop the model of the SI
engine easier, the engine subsystems including the air
throttle, the intake manifold, exhaust gas recirculation
(EGR), the canister purge mechanism, sensor dynamics, combustion chamber, and the load are modeled.
Inherent system delays in the four-stroke engine cycle
including the induction-to-power stroke delay, effects
The Modelica Association

Throttle

Intake manifold

Crankshaft

EGR

E
Air

Canister

Combustion
chamber

Figure 9: Scicos toolbox for engine components

3.1.1

Air intake throttle

The air throttle that controls the air flow rate into the
air manifold and the combustion chamber can be modeled as a flow restriction. The model of a flow restriction highly depends on the pressure difference across
the restriction, if small enough, the gas density is considered equal on both sides, i.e., the gas is considered as an incompressible fluid. If, on the other hand,

471

Modelica 2008, March 3rd  4th , 2008

M. Naja, Z. Benjelloun-Dabaghi

large pressure differences can be expected the restriction should be modeled assuming compressible fluids.
We have assumed that there is no back flow and the
temperature is unchanged across the throttle [11, 12].
When the engine is in idle mode, the necessary air for
the maintaining the minimum power of the engine is
supplied through an air passage, called air bypass passage. The bypass area is controlled by the engine control unit (ECU).
The schematic of the throttle block in Scicos is given
in Fig. 8. The air throttle component modeled with
Modelica has two implicit ports and two explicit inputs. In Fig. 9, the square ports are implicit and triangle ones are explicit. Implicit ports represent inlet and
outlet air flows and explicit input ports represent control signals. The implicit ports are modeled with the
keyword in Modelica.
3.1.2

Exhaust gas recirculation (EGR)

In order to reduce harmful emissions resulting form
the combustion, some of the exhaust gas is diverted
back into the combustion process. In this method the
inlet and exhaust manifolds are connected with a pipe
and the recirculated gas flow rate is controlled by a
valve [12]. The EGR control valve is modeled as a
restriction [11, 12]. The schematic of the EGR block
in Scicos is given in Fig. 9. The EGR block has two
implicit ports and one explicit input port representing
the control signal of the EGR valve.
3.1.3

Canister

Most of the hydrocarbon emissions in modern cars are
from the exhaust, but a considerable part also comes
from evaporative losses in the fuel tank. Most modern
cars use an evaporative emissions management system to reduce these emissions. The basic function of
this system is to trap and store the fuel vapors from
the fuel tank in a canister until the engine is started.
Then after the trapped fuel vapors is drawn into the
engine by intake air manifold and combusted. In order
to control the flow of vapors into the engine, a purge
control valve with no back flow is used. The canister purge valve is modeled as a restriction [11, 12].
The schematic model of the Canister block in Scicos
is given in Fig. 9.

send into the combustion chamber through the intake
runner. We have assumed an isothermal manifold heat
transfer, i.e., constant manifold air temperature. The
air in the intake manifold is composed of fresh air,
fuel, and burnt gas. The concentrations can be described as functions of the partial pressures of fuel and
air in the intake manifold. Using the ideal gas law, we
can obtain the model of the intake manifold pressure.
In SI engines, the inlet manifold pressure is reduced
by the throttle in order to control the output torque.
The flow rate in the intake runner is imposed by the
pumping mechanism of the combustion chamber and
the crankshaft rotation [11, 12].
The manifold air pressure sensor (MAP sensor) response is not as fast as the variation of pressure in the
manifold, so its dynamics cannot be ignored and a first
order filter is used to estimate the manifold pressure.
The schematic of the manifold block in Scicos is given
in Fig. 9. The block has four implicit ports and one explicit output port representing the MAP sensor output.
3.1.5

Combustion chamber

The combustion chamber is the heart of the engine.
The air/fuel mixture flows into the cylinders and reacts and usable energy is extracted from the heated gas
which is then expelled. In this work, the effects of the
air/fuel ratio are not modeled. The cylinder is continuously swept by a piston which is connected to the
crankshaft via a rod. The top of the cylinder houses intake and exhaust ports and a spark-plug in SI engines.
The cylinder and the crankshaft have two important
roles: torque generation and air pumping. When gas
burns and expands, the piston is forced down. The
downward movement is then transformed into rotational movement. The applied torque on the crankshaft
depends on several parameters, such as the air/fuel
mixture ratio, spark ignition time, manifold pressure,
angular velocity of the crankshaft, etc. Since there is
no accurate and simple physical model describing the
generated torque, it is customary that a map is used.
This map gives the optimum generated torque as a
function of the manifold pressure (Pman ), and the angular velocity of the crankshaft ( ). Thus, the optimal
obtainable torque is defined as
opt
gen
= F( , Pman ).

This map gives the value of the produced torque regardless of other important effects such as the effects
The air flowing through the air throttle, the EGR, and of spark advance. Adjusting the spark advance timthe canister are mixed in the intake manifold and are ing, we can optimize engine efficiency to deliver peak
3.1.4

Intake Manifold

The Modelica Association

472

Modelica 2008, March 3rd  4th , 2008

Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station in IFP

combustion pressure when the piston reaches about
10 after top dead center angle. Incorrect spark timing
can have a significant effect on emission output and
vehicle drivability. The amount of the spark advance
needed by the engine varies as function of the number
of different operating conditions. The coolant temperature, fuel quality, and engine load are just a few of
the many factors that can significantly impact ideal ignition time [13, 14, 15]. The effects of the spark timing
on the produced torque is obtained by a using a experimentally obtained map. The map that we have used
in our simulation gives the spark advance efficiency
or the ratio of the produced torque with respect to the
optimal torque, i.e.,

=

gen
opt = H(|SA|)
gen

where |SA| is the absolute value of the spark advance
timing. Note that H(0) = 1 and |SA| < 40 .
The up/down movement of the cylinder creates a
pumping effect; when the piston moves downward, the
air is inhaled from the intake manifold and when the
piston moves upward, the burnt air is exhaled to the
exhaust manifold. In an internal combustion engine,
the pressure on the intake side will normally be lower
than on the exhaust side. Pumping gas from low to
high pressure costs energy and this energy is taken
from the crankshaft. The amount of the pumped air
depends on several variables such as the cylinder volume, the angular velocity of the crankshaft, pressure in
the intake manifold, pressure in the exhaust manifold,
and the air temperature. Again, since there is no accurate and simple physical model describing the amount
of the pumped air, a map is used to describe the total
gas flow rate as a function of manifold pressure (Pman )
and engine speed ( ). The maps used in our model
have been obtained at IFP for a four cylinders SI engine. The schematic of the combustion chamber block
in Scicos is given in Fig. 9. This block has three implicit ports for the air intake runner, the exhaust outlet,
and the connection with the crankshaft. The block has
one explicit input port representing the spark advance
signal coming from the controller.

tions represent the load applied on the engine including controllable loads such as effects of A/C or antifrost systems on the engine and uncontrollable perturbations modeled with a zero mean random noise. The
schematic of the crankshaft block in Scicos is given
in Fig. 9. This block is connected to the combustion
chamber block via an implicit port representing the
mechanical connection of the crankshaft to the combustion chamber. The block has an explicit output port
providing the angular velocity.

3.2

Simulation example: idle speed control

In this section, the engine components are assembled
to construct the model of an SI engine, see Fig. 10. The
engine model is then used to validate start-up and idle
speed control strategies. The controller can be developed with standard (explicit) Scicos blocks. Its modeling with explicit blocks in Scicos has the advantage
of using the rich control toolbox of Scilab.
In our model, the selected controller is relatively simple, i.e., a PI controller. This controller will be active as soon as the engine speed exceeds 700 RPM.
During the start-up phase, the spark advance is set to
20 and the throttle bypass area is 15%. When engine speed superseded the 700 RPM threshold, the
control is handed over to the PI controller that adjusts
the spark advance and the bypass area as a function
of the reference speed, i.e., 750 RPM, instantaneous
MAP sensor and the engine speed. The simulation results of an engine start-up and the idle speed control
is given in Fig .11. In this simulation, in order to test
the the idle speed controller, different loads (l ) are applied at instants t=20 sec and t=40 sec, see the bottom
plot of Fig. 11. In the top plot of Fig. 11, the engine
speed is shown. The engine speed is relatively regulated around 750 RPM in spite of the loads and random perturbations. The middle plot of Fig. 11 gives
the intake manifold pressure that decreases from atmosphere pressure as engine starts up and varies as load
changes.

4 Future Works
3.1.6

Crankshaft dynamics and perturbations

The Modelica compiler used in Scicos has been deThe crankshaft dynamics are modeled using the Newveloped in the SIMPA3 project with the participation
tons second law for rotating masses. All perturbations
of INRIA, IMAGINE, EDF, IFP, and Cril Technology.
due to instabilities in combustion, differences in genRecently, the ANR4 /RNTL SIMPA2 project has been
erated torque in cylinders, and variations in fuel injec3 Simulation pour le Procd et lAutomatique
tion in different cylinders are modeled with noise gen4 French National Research Agency
erator blocks (explicit Scicos blocks). This perturbaThe Modelica Association

473

Modelica 2008, March 3rd  4th , 2008

M. Naja, Z. Benjelloun-Dabaghi

Bypass air

3

Modelica
PID

800

0

EGR

Reference speed

Advance time

0

Advance time

Air

Alpha

Throttle
Throttle
Air

MScope

Speed
0

Canister
Canister
Air

Load

Figure 10: The Scicos model for a mean SI engine
els. Because it gives the possibility of several simplifications such as efficient discontinuity handling, index
reduction, and generation of the analytical Jacobian.
Another advantage of Modelica models comparing to
Simulink models is the facility in model construction
and navigation in the model. For example, the model
of the drilling station in Simulink is composed of more
that 500 blocks distributed in 116 subsystems whereas
the Scicos model is just composed of 9 blocks. The
5 Conclusion
model of the SI engine in Simulink is composed of
203 blocks distributed in 30 subsystems whereas the
In this paper, we modeled a drilling station and a mean Scicos model is composed of 20 blocks. The reduced
value SI engine with Modelica in Scicos. It should number of blocks helps the user to construct and debug
be noted that these models have been already mod- the model easier and faster.
eled and simulated in Simulink at IFP. The modeling
in Modelica was performed in order to compare two
modeling environments. Modeling in Modelica has 6 Acknowledgements
several advantages: Modelica is a declarative language
The authors gratefully acknowledge the helps and
with which very general hybrid systems can be modcomments of Isabelle Rey-Fabret5 to understand the
eled. The Modelica models are independent of the
model of drilling station and Gilles Corde1 for providsimulation tool and can be simulated in any Modeling the engine model.
ica simulator. Another important advantage of using
5 Research professor at IFP and cole des Ptroles et Moteurs
Modelica lies in the symbolic manipulation of modlaunched to develop a more complete Modelica compiler. The main objectives of this project are to extend
the SIMPA compiler to fully support inheritance and
hybrid systems, give the possibility to solve inverse
problems by model inversion for static and dynamic
systems, and enhance initialization of Modelica models.

The Modelica Association

474

Modelica 2008, March 3rd  4th , 2008

Using Modelica for Modeling and Simulation of Spark Ignited Engine and Drilling Station in IFP

[8] Dufeyte M.P., and Henneuse H., Detection and
monitoring of the stick-slip motion: field experiments, Proc. SPE/IADC Drilling conference,
Amsterdam, Netherlands, 1991.

RPM

Crankshaft speed
1000
900
800
700
600
500
400
300
200
100
0

0

10

20

30

40

50

60

70

80

t
Manifold
pressure

[9] Dawson R., and Lin Y. Q., and Spanos P.D., Drill
string oscillation, Proc. Spring. Conf. of Socienty
for experimental Mech, Houston, June, 1987.

90000

Atm

80000
70000
60000
50000
40000
30000

0

10

20

30

40

50

60

70

80

50

60

70

80

[10] Najafi M., Modeling complex systems with
Modelica in Scicos: Application to mean value
spark engine, ESM2007, Westin Dragonara Hotel, St. Julians, Malta, 2007.

load

t load
Applied
5.0
4.5
4.0
3.5
3.0
2.5
2.0
1.5
1.0
0.5
0.0

0

10

20

30

40

[11] Nakayama Y. and Boucher F., Introduction to
Fluid Mechanics, Arnold, London, Great Britain,
1999.

t

Figure 11: simulation result for start-up and idle speed
control of the engine
[12] Silverlind D., Mean Value Engine Modeling
with Modelica. M, Department of Electrical Engineering, Linkoping University, Masters thesis,
References
2001.
[1] Campbell S. L., Chancelier J.P., Nikoukhah [13] Heywood J.B., Internal Combustion Engine FunR., Modeling and simulation in Scilab/Scicos,
damentals. McGraw-Hill series in mechanical
Springer Verlag publishing, 2005.
engineering, international edition, 1988.
[2] Chancelier J. P., Delebecque C. , Gomez C., [14] Aquino C., Transient A/F control characteristics
Goursat M., Nikoukhah R., Steer S., An introof the 5 liter central fuel injection engine. In Soduction to Scilab, Springer Verlag, Le Chesnay,
ciety of Automotive Engineers technical paper,
France, 2002.
1981.
[3] Najafi M.,The Numerical Solver for the Simula- [15] Degobert P., Automobiles and Pollution. In Sotion of the Hybrid Dynamical Systems, Doctor of
ciety of Automotive Engineers, Inc. Translation
Science Thesis, Paris XII University, 2005
of Automobile et pollution, 1995.
[4] Fritzson P., Principles of Object-Oriented Modeling and Simulation with Modelica 2.1, WileyIEEE Press, 2004.
[5] Pavone D., and Desplans J.P., Analyse et Modlisation du comportement dynamique dun rig
de forage, IFP report No 42208, 1996.
[6] Pavone D., and Desplans J.P., Analyse, Modlisation et limination du stick-slip observ sur les
expriences de Norvge, IFP report No 41317,
1994.
[7] Rey-Fabret I., and Mabile C., and Oudin N., Detecting whirling behavior of the drill string from
surface measurments, Proc. SPE 72nd, annual
technical conference and exhibitions of the Society of Petroleum Engineer, San Antonio, USA,
pp 223-232, 1997.
The Modelica Association

475

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

476

Modelica 2008, March 3rd  4th , 2008

Controller Development for an Automotive Ac-system using R744 as Refrigerant

Controller Development for an Automotive Ac-system using
R744 as Refrigerant
Sanaz Karim

Hubertus Tummescheit
Modelon AB
Ideon Science Park, SE-22370 Lund, Sweden
Hubertus.Tummescheit@modelon.se, Sanaz.Karim@gmail.com

1

Abstract
Due to recent regulatory changes in Europe, CO2 or
R744 is considered a serious alternative to be the successor of R134a for the AC-system of cars for the
European market. Research into R744 as a working
fluid for automotive AC started in the early nineties
and continues even today. There are still open issues in both design and control of R744 systems, e.g.
the choice of an expansion device that satisfies both
cost and performance constraints, control in the subcritical region and controling transcritical transients.
In a Masters thesis project organized in cooperation
with Daimler AG in Sindelfingen, these issues were
investigated using a well validated model of an R744
prototype system modeled using the AirConditioning
Library by Modelon AB and Dymola from Dynasim
AB. The preferred choice for the expansion device
from a cost point of view is a two-stage orifice with
a pressure-activated bypass for high load conditions.
The solution with the two-stage valve is compared to a
reference system that uses an electronically controlled
valve that is controlled to the COP-optimal high side
pressure. Unfortunately, the two-stage valve can exhibit both limit cycling behaviour and multiple steady
states depending on the plant operation history, both
undesirable properties. For the investigated system the
drawbacks could be eliminated by proper control design. Another problem that was investigated was the
load distribution between a front- and a back seat evaporator for a two-evaporator version of the same system. Again for cost reasons, the refrigerant side of
the second evaporator is not controlled, instead flow is
split between the two evaporators using a fixed expansion device for the rear evaporator.

Introduction

Under the Kyoto protocol agreement, by the year
2012, industrialized countries have to reduce their collective emissions of greenhouse gas 5% below their
1990 levels. Since the current refrigerant used in vehicles, R134a, has a GWP (Global Warming Potential)
of 1410, R744 (CO2 ) technology has been proposed as
a natural alternative to current R134a-based systems.
The main benefits of R744 as a refrigerant are:
 Energy-efficient
 Non-toxic
 Non-flammable
 No ozone depletion potential (ODP=0)
 Low global warming potential (GWP=1)
Apart from the environmental benefits listed above, using R744 as a refrigerant for air-conditioning (A/C)
systems can decrease the fuel consumption under
some climate conditions.
Daimler AG and some of its suppliers have developed
and validated specific component and system models
for R744-cycles based on the AirConditioning Library
by Modelon. These models were used to investigate
control strategies for both the single evaporator and the
dual evaporator system prototype for an S-class Mercedes.

2

A/C Systems Optimization and
Control

The role of the HVAC-unit in the A/C system is to provide maximum cooling power in order to cool down
the air and dehumidify it before re-heating and venKeywords: air conditioning; compression cycle; simu- tilation. To increase cooling power at very high amlation; CO2; R744; control design, COP optimization bient temperature, traditionally a lower COP (more
The Modelica Association

477

Modelica 2008, March 3rd  4th , 2008

S. Karim, H. Tummescheit

fuel consumption) is accepted. The current practice
is to control the air temperature after the evaporator to
a constant, low temperature (slightly above 0 Celsius
to avoid frost) and control the actual cabin temperature by mixing in warm outside air in the HVAC box
to obtain the desired temperature in the cabin. However, most of the operating times the optimization of
the COP is the more reasonable control target from the
point of view that fuel consumption should be minimized. These two control targets can be fulfilled by
inserting two decoupled SISO control loops, one of
them controling the high pressure and the other one
controling the evaporator outlet temperature by considering the strong crosscoupling between these two
variables.

which controls the refrigerant flow, based on the ambient temperature and compressor speed is suggested
by [1]. For the purpose of simplification the effect of
speed is neglected and the controller is reduced to a
controller which works just based on the ambient or
gas cooler temperature and is designed at a low speed,
since at higher speeds of the compressor the role of the
optimum high-pressure is less significant.
An electronic expansion valve like a PWM-valve can
be used as an actuator to change the flow rate to
achieve desired the high-pressure, but to get rid of the
costs of the high-pressure controller and gas cooler
temperature measurement device, a two-stage orifice
expansion valve has been developed whose internal
control mechanism is described in section 3.1.

2.1

2.2

Optimum High-Pressure Control

To achieve maximum COP in R744 systems, a simple
SISO control strategy with two control loops has been
proposed by [1]. They consider the high- pressure as
the main variable that affects the COP and cooling
power. Since the heat rejection process of the R744
refrigeration cycle takes place in the supercritical region, where the pressure is independent of the temperature, the system efficiency is a nonlinear function of
the working pressure and the ambient temperature.
For each ambient (gas cooler air inlet) temperature,
there is an optimum high-pressure, which results in the
maximum COP. With the increase of the ambient temperature, the optimum pressure increases.
The other boundary conditions (evaporator temperature, air humidity and flow rate) have negligible effect
on the optimum high-pressure.

Figure 1: Comparison of COP and cooling power with
the change of high-pressure

Evaporator Temperature Control

Under low load conditions, it is necessary to control
the compressor power to reduce the cooling power to
the desired range for the A/C system and not let it
reach its maximum possible capacity. These conditions are low cooling load and/or high engine speed.
Since the compressor of the automotive A/C unit
draws its driving force from the engine, its power is
a function of the engine speed, which is a highly fluctuating variable. Control of the compressor capacity
is necessary to compensate engine speed disturbances,
to satisfy the comfort requirements and to avoid temperature variations. Control is particularly important
at higher speeds, which cause an undesirable power of
the compressor and too low temperature at the evaporator.
Among the various methods proposed to control the
compressor capacity, using a variable displacement
compressor is the most attractive one. The most popular variable displacement compressor for automotive
use today is the swash-plate compessor1 . Changing
the inclination of the swash plate changes the displacement of each of the many pistons of the compressor.
This causes a change of the pressure ratio, both highpressure as well as low-pressure are affected, but the
effect of the expansion valve on the high pressure is
dominant. The control of the swash plate angle and
thus the relative volume is used as a low pressure controller in spite of its influence on the high pressure.
In the sub-critical region, where the heat rejection
takes place isothermally, evaporator refrigerant and air
outlet temperature are functions of the low-pressure,

A variable swash plate controller is used as lowpressure (evaporator air outlet temperature) controller
and since any change in a angle of the swash plate
will affect the pressure ratio as well as the compressor
1 For hybrid cars with sufficient electrical power, other options
power; it is expected that it changes the optimum high- would be advantageous, because they open up the new possibility
pressure as well. Therefore a high-pressure regulator of using a speed control of the compressor.
The Modelica Association

478

Modelica 2008, March 3rd  4th , 2008

Controller Development for an Automotive Ac-system using R744 as Refrigerant

thus the swash plate control makes it possible to control the evaporator temperature and via the temperature
also the power.
Concerning the previous section, at a constant speed,
it is acceptable to neglect the cross coupling between
the first SISO loop which tries to maximize COP by
high-pressure control and the second one which aims
to control the low-pressure (evaporator air outlet temperature), but it is not satisfactory to decouple these
loops in the case of speed changes.
Assuming constant speed, control of the evaporator air
outlet temperature in the case of low cooling load can
improve the COP significantly due to a smaller pressure ratio and consequently smaller power uptake of
the compressor.

3

AirConditioning Library

The AirConditioning Library and the simulation tool
Dymola, both based on the standardized, freely available modelling language Modelica, have been selected
by the German automotive OEM as the preferred tool
for model development and exchange for the A/C system in passenger cars. The library contains a complete
range of component models and templates of typically
used and proposed A/C system architectures and all
currently used as well as new and proposed refrigerants for automotive applications. The modeling detail is appropriate for component selection, system architecture design, system integration for overall vehicle thermal management and climate control design.
Prototype systems for future technologies often contain components that differ from those needed for conventional designs, but due to the open code and the
given modeling infrastructure, it is straightforward to
add unusual components to the Library. In this case a
two-stage orifice model with a pressure operated bypass had to be added.

3.1

most linearly with the pressure difference. This results
in a very non-linear pressure  mass flow characteristic which is prone to limit-cycling behaviour. The
cycle is caused by interaction between the dynamics
if the mass storage at the high- and low pressure levels in combination with the differences between the
mass flow characteristics of the compressor (almost no
change for pressure difference above and below p)
and the valve (almost a step function at p). When
the rising pressure opens the valve for a pressure difference higher than p, the opening bypass will increase the mass flow from the high pressure side so
rapidly that the pressure difference falls below the bypass opening limit, because the compressor mass flow
does not increase in the same degree and the cycle
starts again.

Two-Stage Orifice Model

This valve has an internal mechanism to drastically
change its Kv value based on the pressure difference
between the low- and high-pressure side [6]. It consists of a standard orifice and a bypass which is closed
for small pressure differences. As shown in Figure 2,
the refrigerant flows only through the orifice at pressure differences below a pressure difference p, in this
case set to 73 bar. The bypass starts to open at a rising pressure difference of p with a very steep gradient, and for higher pressures, the Kv-value rises alThe Modelica Association

Figure 2: Two stage orifice valve
The highly nonlinear behaviour of the valves Kvvalue can under some situations give rise to limit cycling around the steep part of the characteristic where
the valve opens, and it may even lead to two steady
states with different COPs, one at a pressure difference above the opening pressure, the other one at
a pressure difference below the opening pressure, at
identical boundary conditions.

4

Single Evaporator, Two-stage Orifice Valve System Control Design

While no direct control of the high-pressure is possible
anymore when using the two-stage orifice valve, it is
still desired to keep the COP as close as possible to its
optimal value in order to reduce fuel consumption. As
previously mentioned, the first control target remains
to regulate the evaporator temperature by means of the
compressor relative volume control, the COP control
is of secondary importance. To achieve these goals, a
simplified control structure proposed by [4] was used
as a starting point for the control design. That structure
was developed for the same type of two-stage orifice
valve and used a complex feed-forward map with three

479

Modelica 2008, March 3rd  4th , 2008

S. Karim, H. Tummescheit

Temperature set point

+
-

Evaporator
temperature
controller

+

Low
pressure
controller

-

+
-

Compressor

Gas Cooler

Low pressure
Sensor

Internal Heat Exchanger

Low pressure
set point
corrector

High pressure
set point
corrector

+

Evaporator

Controllable
valve

High pressure
controller

High pressure
sensor

Gas cooler
temperature
sensor

Evaporator
temperature
sensor

Evaporator temperature control
COP control

Figure 3: Control structure for R744 AC-cycle with electronically controllable expansion device, assuming
COP-optimal control via the valve to control the high pressure side and temperature/power control via the
compressor to control the low pressure side.
inputs (engine speed, air mass flow and inlet air temperature) to mimic the optimal high pressure control
with a fully controllable valve. There are a number of
reasons why the control structure suggested in [4] uses
a high-pressure controller in place of the low-pressure
one for controlling the evaporator temperature. The
refrigerant high-pressure sensor required for controlling the high-pressure is already present for monitoring and protection functions in todays R134a circuits,
so no additional sensors are needed and this suggestion
gets rid of the cost for a low-pressure sensor. There
are a number of reasons why the control structure proposed by [4] was dropped in favour of a simpler one.
On the low pressure side the existing evaporator outlet temperature sensor can be used due to the simple temperature-pressure relationship of the saturation
curve:

valve, undesirable limit cycling behaviour occurs
at some operating points. It is not possible to remove the limit-cycling behaviour with the given
control structure.
 For engine speed disturbances, the feed forward
scheme for controling evaporator outlet temperature from with a feedback on the high side pressure did not work reliably.
 The occurence of multiple steady states, see section 4.3.

The current investigation was not done with a fully realistic sensor model for the evaporator temperature.
If a cost-effective temperature sensor would be too
slow to control engine speed variations, a low pressure
controller would still be preferrable to the high pres The feed forward is not robust to changes in sure one with feedforward due to the list of drawbacks
the environment conditions, in particular not to above.
changes in humidity, which today is not measured
due to too costly sensors. The feed forward only
works well in a limited range of operating condi- 4.1 Performance of the Valves
tions and actually decreases control performance
To compare the operation of the controllable valve in
in other situations. A feed forward based design
an optimized cycle and a two-stage valve without conthat includes humidity measurements would most
trol of the high pressure, all boundary conditions and
likely avoid the robsutness drawback.
the compressor speed are kept constant and simulation
 Using the components chosen in the given pro- were performed for three different load cases and both
totype R744 system with the two-stage orifice valves.

The Modelica Association

480

Modelica 2008, March 3rd  4th , 2008

inlet air
temperature

Engine speed

Air mass flow

Controller Development for an Automotive Ac-system using R744 as Refrigerant

Feed forward high pressure
set point
corrector

+
Temperature set point

+

Temperature
controller

-

High-pressure
characteristics
curve

High-pressure
controller

+
-

Compressor

Gas Cooler

High pressure
sensor

Internal Heat Exchanger
Tracking signal

Evaporator

Evaporator
temperature
sensor

Two-stage
orifice
valve

Figure 4: Proposed Control Structure by [4], simplified compared to the control structure in 3. In this case it is
also assumed that the temperature set-point for the evaporator is adapted at low load to improve the COP.

Figure 5: Alternative control structure for control of the low pressure side. The evaporator temperature set point
is used to improve COP, which means that a higher complexity is needed in the supervisory part of the HVAC
control that needs to determine the proper temperature set point.
1. Low cooling load and no control on evaporator for the lower ambient temperature. At higher temperoutlet air temperature (Fixed relative volume of ature losses decrease, see Figure 6.
the compressor)
2. High cooling load and no control on evaporator
outlet air temperature (Fixed relative volume of
the compressor)
3. Evaporator temperature controlled (low cooling
load)
Figure 6: Comparison of the two valves, case 1

4.1.1 Case 1

The system with two-stage valve has lower COP and The high-pressure with two-stage orifice valve is kept
higher cooling power than the optimized cycle, even fixed around 110 bars, while the variable Kv valve alThe Modelica Association

481

Modelica 2008, March 3rd  4th , 2008

S. Karim, H. Tummescheit

lows the pressure to change in a wider range. The reasons is behind the internal mechanism of the two-stage
orifice valve which does not result in a Kv-value close
to the controlled Kv for most of this range (Figure 7).

Figure 10: Comparison of the two valves, case 3
Since the pressure difference is low, at the lower ambient temperatures, the refrigerant passes through the
fixed orifice of the two-stage orifice valve and proFigure 7: Comparison of the two valves, case 1
vides the high-pressure that is needed for better COP.
Both the valve-Kv values and correspondingly the resulting high pressures are closer to one another for this
4.1.2 Case 2
load case and control scheme than for the previous two
In comparison with the previous case, at higher loads, ones.
the cycle with two-stage orifice valve has a COP near
to the optimum value but at higher ambient temperatures it does not achieve equally high cooling power as
the optimized cycle.

Figure 11: Comparison of the two valves, case 3
As has been demonstrated in this section, for lower
ambient temperatures, the COP of the cycle with twostage orifice is up to 40% less than ideal cycle, thereFigure 8: Comparison of the two valves, case 2
fore it is suggested that in this range of ambient temFor this cooling load, the Kv shows a smaller deviation peratures, the evaporator temperature is controlled to
the highest possible value to improve the COP. Assumfrom the optimized one.
ing the evaporator temperature is controlled with the
two-stage valve cycle, the differences between the solution are not as dramatic as a first look suggests. The
worst case scenario is, however, handled better with
the optimized cycle that provides the highest cooling
power at the highest load case.

4.2

Limit-Cycling Behaviour

In some operating points, which result in a higher
pressure-difference than 73 bars, as a consequence
of the rising pressure, the bypass starts to open and
decreases the high-pressure, the decrease in high4.1.3 Case 3
pressure causes the closing of the bypass and this limit
When the low-pressure is controlled via the relative cycle continues until one of the inputs alters the presdisplacement of the compressor, the COP is improved sure difference and mass flow rate. To observe the role
of flow rate and pressure change in the limit cycle phefor both cycles.
Figure 9: Comparison of the two valves, case 2

The Modelica Association

482

Modelica 2008, March 3rd  4th , 2008

Controller Development for an Automotive Ac-system using R744 as Refrigerant

nomenon directly, all the boundary conditions are kept
constant and the relative volume of the compressor is
changed manually to provide the appropriate pressure
difference and flow rate. Figure 12 illustrates above
explanations.

strate this statement: Assuming a low-pressure controlled cycle, the ambient temperature varies in the
range from 30o C to 45o C, and other operating conditions are kept constant. Figure 15 shows the phase
portrait plot of two different cases when the limit cycle takes place. One of them happens when the desired
low-pressure is 40 bar and the other one at 45 bar.

Figure 12: Limit cycle
Other output parameters, which are correlated with the
high-pressure, will also show this limit cycle. The effect on the evaporator outlet air temperature is negligible (less than 1o C in this case) and it is seen in Figure 13 that the low-pressure controller can remove the
fluctuations. Therefore passengers do not sense the oscillations of the temperature.

Figure 15: Portrait plot of the valve Kv against the
pressure-difference
Under normal driving conditions, boundary conditions
will rarely ever be constant for a sufficiently long time
such that these limit cycling conditions will be noticeable, but they are nonetheless an undesired side effect
of the valve construction.

4.3

Figure 13: Temperature and limit cycle
But the effect on the cooling capacity and COP is
quite considerable. In the temperature interval where
this phenomenon happens, the highest deviation of the
COP is about 50% less than the expected average value
(Figure 14).

Multiple Steady-States

In the case of high-pressure control and in the vicinity of 73 bar pressure-difference, when the two-stage
orifice valve changes its flow configuration, a bistability phenomenon takes place. In this case, any disturbances which leads to small variance in the pressuredifference, causes the valve to jump to the alternate
path while the high-pressure is kept constant by the
controller. Therefore the system is able to exist in either of two steady states, while the high-pressure is
fixed. Figure 16 shows that a small disturbances of the
pressure, pushes the system to another steady state and
causes a significant change in the cooling power. Although this will be compensated by the outer loop later
on, it is another situation where the high-pressure loop
in combination with the two-stage valve acts against
the main purpose of control.

5

Dual Evaporators

Today luxury cars allow passengers to control a different climate in up to four climate zones. This reFigure 14: COP and Limit cycle
quires the presence of two or even three evaporators
However, this limit cycle does only occur at few oper- to generate the cooling capacity for front and rear pasating points and its characteristic differs in different sengers. The Electronic Control Unit (ECU) controls
circumstances. The following observations demon- the position of the different temperature blend doors
The Modelica Association

483

Modelica 2008, March 3rd  4th , 2008

S. Karim, H. Tummescheit

operating conditions. Note that all other components
are the same, which means in particular that the heat
rejection capacity via the gascooler is identical for
both systems. Figure 17 illustrates that the summation
of the capacity of the front and rear evaporator is equal
to the capacity of one-evaporator system in this condition. It also shows that the outlet air temperature of the
front evaporator is same for both cases. With a perFigure 16: Bi-stable behaviour for high pressure con- fect model which includes the corresponding effects
trol
of the rear compartment on the front one, this distribution scheme may change a little and more compressor
to provide the passengers with their desired tempera- work will be needed to keep the front evaporator temture in different zones. In the cooler unit, the high- perature constant.
pressure refrigerant splits and flows from two different expansion devices to the front and rear evaporator.
The cooling capacity is divided accordingly between
both evaporators. But the amount of the division depends on the operating conditions and structure of the
valves. If a variable displacement compressor is used
to control the front evaporator outlet air temperature,
and a two-stage orifice valve to improve the COP, then
a fixed orifice can be used to pass the refrigerant to the
Figure 17: Cooling power distribution between two
rear evaporator. In this case, there is no direct control
evaporators in comparison with one-evaporator system
on the outlet air temperature of the rear evaporator. To
have full control authority on both evaporator temperaFigure 18 shows the cooling power distribution against
tures, a controllable second expansion device would be
the ambient temperature. At higher temperatures, the
needed. Alternatively, a model-based controller could
pattern of distribution will change but acceptable coolbe designed to control the compressor relative volume
ing power is still provided for both evaporators.
based on the measured value of the outlet air temperature of both evaporators. The easier way to control
the cooling capacity of the rear evaporator is to use a
variable speed fan and change the air flow around the
evaporator, while the temperature of the front evaporator is controlled with the compressor relative volume variation using the same SISO approach as for
the one-evaporator system. This will change the balance point of the rear evaporator low-pressure and this
in turn changes the front evaporator low-pressure. The Figure 18: Cooling power distribution between two
behaviour of the latter control system is investigated evaporators in comparison with one-evaporator system
in [2], where in the modeling of the dual evaporator
system, it is supposed that the front evaporator uses
fresh air for ventilation and the rear compartment has 5.2 Rear AirFlow Effect
just one zone. The outlet air of the front evaporator
enters the car cabin, it is mixed with recirculation air In order to order to manipulate the cooling power of
of the rear compartment and then enters the rear evap- the rear evaporator, it is possible to change the air mass
flow through it. The simulation was run in a limited
orator for the second phase of cooling.
range of airflow variations under two different cooling
loads. Figure 19 shows the change of the rear evapora5.1 Cooling Power Distribution
tor cooling power when the air mass flow is changed at
To compare the cooling power of the one-evaporator 5000 second. Figure 20 shows the cooling power varisystem with the two-evaporator one, both systems are ation against the air mass flow variation under a high
simulated under the same cooling load and at the same and a low cooling load.
The Modelica Association

484

Modelica 2008, March 3rd  4th , 2008

Controller Development for an Automotive Ac-system using R744 as Refrigerant

Figure 19: Rear evaporator air flow change.

sults suggest that the same approach of control for the
one-evaporator system is also applicable for the dual
evaporator system. With the given limited control authority, pressure and temperature of the rear evaporator
will always be defined by the controlled conditions for
the front evaporator and the boundary conditions. Instead of temperature control for the rear compartment,
the capacity of the rear evaporator can be controlled
using a variable speed fan, but only within certain limits.

It is seen that the rear cooling power is changed while
the front one is almost kept constant. At lower cooling References
loads, the rear evaporator capacity is more sensitive to
the air mass flow change.
[1] Yang W., Fartaj A., Ting S-K., Co2 Automative A/C System Optimum High Pressure Control,SAE International 2005-01-2022, 2005.
[2] Karim, S. Open Issues in Control of Automotive
R744 Air-Conditioning Systems: Masters Thesis
Nr E3492E, Department of Electrical Engineering, Dalarna University, 2007.

Figure 20: Cooling power over air mass flow.

[3] Tummescheit H. Design and Implementation of
Object-Oriented Model Libraries using Modelica.
Lund, Sweden: PhD thesis, Department of Automatic control, Lund Institute of Technology, 2002.

Therefore, at these conditions, using a two-stage valve [4] Lochmahr K., Baruschke W. and Britschbesides the front evaporator temperature control is
Laudwein A., Control System for R744 Refrigerpossible, while the capacity of the rear evaporator is
ant Circuits, ATZ worldwide, 2005.
controlled by means of adjusting the air mass flow.
[5] strm K. and Hgglund T., Advanced PID Control, ISA-The Instrumentation, Systems, and Au6 Conclusions
tomation Society, 2006
Various aspects of system and control design for a [6] Lemke N., Tegethoff W., Khler J., and
Horstmann, P., Expansion Devices for R744 MAC
prototype of a R744 automotive A/C system for the
Units, Vehicle Thermal Managment Systems 7
Mercedes S-class were investigated by simulation usConference and Exhibition, SAE International,
ing the AirConditioning Library and Dymola. Differ2005.
ent system designs with a controllable expansion valve
and a two-stage bypass orifice were compared and
show that the controllable valve gives up to 15 % better
COP than the two-stage valve. Several control designs
were compared and the result was that the simplest
control structure proved to be most robust and had
better performance than the more complex versions.
Furthermore it is demonstrated that the system with
the highly non-linear two-stage valve exhibits limitcycling behaviour and bistability around the part of the
valve characteristic that looks almost like a step function in the valve coefficient Kv. For the two-evaporator
system which uses a two-stage orifice valve to regulate the pressure of the front evaporator, simulation reThe Modelica Association

485

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

486

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid Powertrain

Implementation of a Modelica Online Optimization
for an Operating Strategy of a Hybrid Powertrain
Henrik Wigermo, BMW Group, Energymanagement 88077 Munchen
Johannes von Grundherr, BMW Group,Energymanagement 88077 Munchen
Thomas Christ BMW Hybrid Cooperation, Vehicle Architecture,
1960 Technology Dr., Troy, Michigan USA
January 21, 2008

Abstract
The paper presents a method of implementing an
optimization based control algorithm within the
Modelica framework. To find the optimal point
within a given objective function the golden section
search is employed. Its implementation in Modelica
is presented. The optimizer based control strategy is
applied to control a simplified electrical circuit and to
a hybrid electric vehicle.
Keywords: Modelica; Optimization; Hybrid Vehicle;
Simulation; Fuel Consumption

1

Introduction

Online optimization is increasingly being implemented for better results in controlling complex systems. It is especially helpful if the control objective
depends on several input parameters which influence
the outcome in a non intuitive way. One example is
the operational strategy of a powersplit hybrid electric
vehicle.
Compared to conventional transmissions, hybrid transmissions allow for several additional degrees of freedom: The combustion engine speed can be controlled
independently from vehicle speed and battery power
can be used for propulsion or the storage of braking
energy. Although the main control objective is the fuel
economy of the vehicle, other goals like dynamic response, driveability, acoustic impression and tailpipe
emissions have to be achieved. In many cases the definition of the control objective is given by a calibration
table or multidimensional mappings. Since a mapping
normally cannot be expressed analytically, the solution
to the optimization problem has to be computed online
for each control step.
The Modelica Association

In the development process of hybrid vehicles, simulation is a key issue. It is used to study aspects like
fuel consumption and performance and to understand
complex system interactions. Since the hybrid vehicle powertrain is composed of mechanical, electrical,
chemical and thermodynamical components, Modelica is a very useful tool for this. The control software
of the hybrid vehicle is normally implemented using
tools like Simulink or ASCET. The actual powertrain
control is only a small part of the entire controls software. A great deal of code which is interconnected to
the actual powertrain control concerns system diagnosis or remedial actions, and does not need to be simulated. To study the powertrain behavior only the relevant parts of the control code are transferred to Modelica.
In this paper, we shall present a simple optimization
algorithm and give an example on how it can be implemented in Modelica. We will also take a look on a
possible employment of such an algorithm; the powertrain control of a hybrid electric vehicle. In addition,
the following points have been investigated: How will
an algorithm that requires fixed time-steps work together with an complex vehicle model? How does the
optimization influence the simulation time? How can
standard Modelica elements like tables be integrated
in the optimization algorithm, since it doesnt allow
graphical programming?

2

Problem statement

A Plant P is controlled by its input u and disturbed by
d. y is the observed measurement. In an early control
development stage the plant can be represented by a
simulation model. The control task is to follow a given
reference yre f so that an objective function J(y, yre f ) is
minimized. For linear systems and quadratic objective

487

Modelica 2008, March 3rd  4th , 2008

H. Wigermo, J. von Grundherr, T. Christ

Controller C
Optimization code

Plant P
yref

u

n=1

x1
u

y

J(y;yref )

d

Boundary point for
next iteration step

Objective function
J(y;yref )

x4
x2

Figure 1: Control optimization problem

x3

functions the choice of controller is well understood.
A linear state feedback control can be directly derived
from the linear plant given by the system matrices A,
n=2
B, C, D and by the coefficients of the quadratic objective function.
For nonlinear objective functions the optimization can
be carried out by an optimization algorithm. In each
x4
optimization step the algorithm calls the objective
function, iterating the control signal u to generate the
x3
x1
optimal solution u .
x2
In our case the plant is a Modelica model. The control
using the optimization algorithm is also integrated in
Modelica. A tutorial example of such an optimization Figure 2: Principle of Golden Section Search Algorithm
is shown in section 3.2.

3

Online optimization

tolerance parameter. Modelica code 1 describes the
golden section search algorithm:

An optimization algorithm used for the given problem
has to be robust, i.e. it needs to come up with a solution
after a finite number of iterations. Such an algorithm function goldenSectionSearch
extends Modelica.Icons.Function;
is golden section search. In this paper its integration
parameter Real tau=0.001;
into the Modelica framework is shown.

3.1 Optimization algorithm - Golden section
search

...
constant Real C=0.5*(3 - sqrt(5));
constant Real R=1-C;
...
algorithm
x1:= xLowerLimit;
x4:= xUpperLimit;
x2:= R*x1 + C*x4;
x3:= C*x1 + R*x4;
fx2:=optFunction(x2,alpha,IbatDes,
Ri,Iload,gammaI);
fx3 :=optFunction(x3,alpha,IbatDes,
Ri,Iload,gammaI);

The golden section search derives its name from the
fact that it narrows
its search interval with the golden
p
ratio 21 (1 + (5)) in each step. The technique is effective only for unimodal functions, where a maximum
or minimum is known to exist within a given interval. As starting points the lower and upper limit of the
search interval are chosen. Using the golden section,
while abs(x4-x1)>
two new points within the interval are evaluated and
tau*(abs(x2)+abs(x3)) loop
compared. The point with the highest functional value
if (fx3<fx2) then
x1:=x2;
is chosen as a new boundary point, and points outside
x2:=x3;
of this are no longer considered. The algorithm continx3:=R*x3 + C*x4;
ues to search until the maximum number of iterations
fx2:=fx3;
is reached or the termination condition suggested in
fx3:=optFunction(x3,alpha,
IbatDes,Ri,Iload,gammaI);
[4]: | x4  x1 |> (| x2 | + | x3 |) is satisfied.  is a
The Modelica Association

488

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid Powertrain

Ri (Iopt  Iload )2 +
|
{z
}

else
x4:=x3;
x3:=x2;
x2:=R*x2 + C*x1;
fx3:=fx2;
fx2:=optFunction(x2,alpha,
IbatDes,Ri,Iload,gammaI);
end if;
end while; if
(fx2<fx3) then
xmin:=x2;
fxmin:=fx2;
else
xmin:=x3;
fxmin:=fx3;
end if;

BatteryLoss

I (t)Iopt
| {z }

(1)

CurrentCost

Iopt is our control variable; the current of the external
current source. The battery losses are assumed to be
a quadratic function of the current through the battery
internal resistance. The SOC-optimal battery current
Ibat,des is a function of the battery SOC and is chosen
to the following curve:
60

end goldenSectionSearch;
40

Modelica Code 1: Golden Section Search Algorithm

3.2

IbatDes [A]

20

Optimization example

The following example (see fig. 3) illustrates the control problem: A time varying electric load Iload (t) is
to be supplied with power from an energy storage device (e.g. a battery) in such a way that the power
losses are minimal and the State-of-Charge (SOC) is
kept at a fairly constant level (to optimize the lifetime
of the energy storage device). The system can be influenced from an external current source Iopt , which
can deliver power at all times but with losses that are
time-dependent. This means at times it can be efficient to charge the battery and to use the stored energy
at a later time when the losses of the current source are
high.  is a control variable which we choose in order
to weigh the importance of the SOC-control.

0

20

40

60
45

50

55

60
SOC [%]

65

70

75

Figure 4: Ibat,des as a function of battery state of charge
I (t) is a time-varying function that decides the loss
power of the external current source. In this example,
we have chosen it to be sinodial (see figure 6).
3.2.1

Results

We let the optimization algorithm defined in chapter
3.1 find the optimal solution to the objective function
(1). The variable Iopt is computed through a function
Ibat
Iload
call of goldenSectionSearch.
Figure
5 shows the calculated optimal current, as well
Iopt
as the load current and the resulting battery current.
We can see that high (battery discharging) peaks in the
load current have been compensated for with the current source in order to minimize the battery losses.
In figure 6, the optimized current has been compared
to a control strategy that only considers the battery
Figure 3: Example Electric Circuit
SOC (as described in figure 4). We can conclude that
From these control objectives we define the objective the optimization chooses to charge the battery at times
when the current is inexpensive, but at the same time
function to be minimized as:
manages to keep the SOC at levels similar to the SOCCost =  | Ibat,des (SOC)  Iopt | +
controlled strategy, not very far from the target value
|
{z
}
of 60%.
SOCControl
The Modelica Association

489

Modelica 2008, March 3rd  4th , 2008

H. Wigermo, J. von Grundherr, T. Christ

500

200
Iopt

Eloss [Wh]

I [A]

150
100
50
0
500

System loss without optimization
System loss with optimization

400
300
200
100

550

600

650
t [s]

700

750

0

800

0

100

200

300

400

500
t [s]

600

700

800

900

1000

400

500
t [s]

600

700

800

900

1000

600

700

800

900

1000

150
60
SOC [%]

100
50

55
50

SOC without optimization
SOC with optimization

0
I [A]

45

50
100

0

T [C]

200

300
500

200

300

Battery temperature without optimization
Battery temperature with optimization

150

250

100

50

Iload
Ibat=Iload+Iopt
550

40
30
20

600

650
t [s]

700

750

800

0

100

200

300

400

500
t [s]

Figure 5: Optimization result: Controlled current Iopt , Figure 7: Comparison optimized system with SOCcontrolled system: System losses, battery SOC and
load current Iload and resulting battery current Ibat
temperature
Cost [W/A]

200
Cost of current
100
0
500

550

600

650

700

750

800

650

700

750

800

200
I [A]

SOCControlled current
100
0
500

550

600

tive function within Modelica text algorithm sections.
In order to do this, one must initialize the table using
dymTableInit. The table/mapping can then be called
from a function using the function dymTableIpo1 or
dymTableIpo2.

200
I [A]

Optimized current
100
0
500

550

600

650

700

750

800

650
t [s]

700

750

800

SOC [%]

60
55
50
45
500

SOC without optimization
SOC with optimization
550

600

...
equation
when initial() then
Data.EngineFuelFlow=dymTableInit
(2.0, smoothness, "FuelFlowAllCyl",
engineFuelFlowTable, table, 0.0);
end when;
...

Figure 6: Optimization result: Cost of current, SOC- Modelica Code 2: Table Interpolation in Modelica
Text
Controlled current, Optimized current and SOC
As a measurement on how good the optimization has
worked, we compute the total system losses (battery
losses and losses of the external current source). By
integration of the loss power, as shown in figure 7, we
see that the energy lost in the optimized system is only
about half of the SOC-controlled strategy. The heat developed in the battery is proportional to the loss power,
and the operating temperature of the battery rises over
time. However, with the optimal control the battery
losses are kept down, and the temperature remains at a
lower level than the SOC-controlled strategy.

3.2.3

Comments on simulation time

In a simple example like the one given above, the simulation time of a model containing an optimization algorithm is good, only somewhat slower than an equal
model using a traditional control approach. However
when combined with a complex vehicle model, generating a lot of events due to system state changes, a
fixed-step optimization algorithm can slow the simulation time down considerably. In these cases, it has
been shown that time-discrete sampling of the optimization algorithm increases the computation speed.
A well considered sampled optimization algorithm de3.2.2 Implementation of tables in Modelica text
livers virtually the same result as the non-sampled,
A difficulty in the implementation of the online op- but without recomputing the optimal solution for each
timization is the use of table look-ups for the objec- event triggered by the plant. Using this method, we
The Modelica Association

490

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Online Optimization for an Operating Strategy of a Hybrid Powertrain

have achieved simulation performance comparable to
our traditional control concepts.

80
60

v [km/h]

4

100

Hybrid vehicle application

40
20
0

This section will present a simulation model of a hybrid electric vehicle using a control strategy based on
online optimization. In this case, the optimization only
governs the choice of engine torque, but it could also
be employed for the choice of gear, or in EVT-mode
(Electrically Variable Transmission) the speed of the
internal combustion engine. The advantage of such an
implementation would be that the vehicle would adapt
its gear strategy depending on the current conditions.
Figure 8: Vehicle speed (above) and combustion enHowever such a strategy also has the disadvantage that
gine torque (below) as a function of time
the gear choice is not always comprehensible to the
driver.
The following control objectives are considered in our
objective function [5]:
0

200

400

600

0

200

400

600

800

1000

1200

800

1000

1200

800

1000

1200

800

1000

1200

400

TICE [Nm]

300
200
100

0

t [s]

40

PBat [kW]

20

 Combustion engine losses

0

20

 Battery losses

40

 Electric machine losses
SOC [%]

Below simulation results from an FTP721 simulation
of a hybrid electric vehicle are shown. In figure 8 the
vehicle speed is plotted with our control signal, the
optimal combustion engine torque. TICE is available
for us to choose at all times except the phases where
the vehicle is powered electrically. It has been chosen
to minimize the listed control objectives.
Figure 9 shows the resulting power and SOC of the
battery. At a given engine speed the battery power
is proportional to the combustion engine torque, and
therefore also directly connected to our control signal. We can conclude that even albeit a high portion of
pure electrical driving in this cycle, the SOC remains
around the target SOC of 60%.

600

0

200

400

600

65

55

t [s]

Figure 9: Battery power (above) and state of charge
(below) as a function of time
algorithm has to be called at each step of the simulation, the simulation time was comparable to models
using traditional control strategies.

References

This paper shows that it is possible to implement optimization algorithms for the control of a plant, e.g.
a hybrid electric vehicle, in Modelica. Using online
optimization, a fixed-step optimization algorithm can
find a solution to a number of complex and interconnected control objectives. Although the optimization
Federal Test Procedure legislation fuel cycle

The Modelica Association

400

60

Discussion and conclusion

1 The

200

70

 Battery SOC control

5

0

491

[1] Eborn J. On Model Libraries for Thermohydraulic Applications. Lund, Sweden: PhD thesis, Department of Automatic control, Lund Institute of Technology, 2001.
[2] Tummescheit H. Design and Implementation of
Object-Oriented Model Libraries using Modelica. Lund, Sweden: PhD thesis, Department of
Automatic control, Lund Institute of Technology,
2002.
Modelica 2008, March 3rd  4th , 2008

H. Wigermo, J. von Grundherr, T. Christ

[3] Tummescheit H, Eborn J. Chemical Reaction
Modeling with ThermoFluid/MF and MultiFlash. In: Proceedings of the 2th Modelica
Conference 2002, Oberpfaffenhofen, Germany,
Modelica Association, 18-19 March 2002.
[4] Press, W. H.; Teukolsky, S. A. & Vetterling, W.
T. et al. (1999), Numerical Recipes in C, The
Art of Scientific Computing (second ed.), Cambridge University Press, Cambridge, ISBN 0521-43108-5.
[5] US 2007/0032926 A1 FORD GLOBAL TECHNOLOGIES: Optimal Engine Operating Power
Management Strategy for a Hybrid Electric Vehicle Powertrain. 8.2.2007.

The Modelica Association

492

Modelica 2008, March 3rd  4th , 2008

Model Embedded Control: A Method to Rapidly Synthesize Controllers in a Modeling Environment

Model Embedded Control: A Method to Rapidly Synthesize Controllers in a Modeling Environment
E. D. Tate

Michael Sasena

Jesse Gohl

Michael Tiller

Hybrid Powertrain Engineering, General Motors Corp.
1870 Troy Tech Park, Troy, Michigan, 48009

Emmeskay, Inc, 47119 Five Mile Road
Plymouth, Michigan, 48170

ed.d.tate@gm.com msasena@emmeskay.com jbgohl@emmeskay.com mtiller@emmeskay.com

Abstract
One of the challenges in modeling complex
systems is the creation of quality controllers. In some
projects, the effort to develop even a reasonable prototype controller dwarfs the effort required to develop a physical model. For a limited class of problems, it is possible and tractable to directly synthesize a controller from a mathematical statement of
control objectives and a model of the plant. To do
this, a system model is decomposed into a controls
model and a plant model. The controls model is further decomposed into an optimization problem and a
zero-time plant model. The zero-time plant model
in the controller is a copy or a reasonable representation of the real plant model. It is used to evaluate the
future impact of possible control actions. This type
of controller is referred to as a Model Embedded
Controller (MEC) and can be used to realize controllers designed using Dynamic Programming (DP).
To illustrate this approach, an approximation
to the problem of starting an engine is considered. In
this problem, an electric machine with a flywheel is
connected to crank and slider with a spring attached
to the slider. The machine torque is constrained to a
value which is insufficient to statically overcome the
force of the spring. This constraint prevents the motor from achieving the desired speed from some initial conditions if it only supplies maximal torque in
the desired direction of rotation. By using DP, a control strategy that achieves the desired speed from any
initial condition is generated. This controller is realized in the model using MEC.
The Modelica Association

The controller for this example is created by
forming an optimization problem and calling an embedded copy of the plant model. Furthermore, this
controller is calibrated by conducting a large scale
Design of Experiments (DOE). The experiments are
processed to generate the calibrations for the controller such that it achieves its design objectives when
used for closed loop control of the plant model.
It is well understood that Modelica includes
many language features that allow plant models to be
developed quickly. As discussed previously, the development of quality control strategies generally remains a bottleneck. In this paper we show how existing features along with appropriate tool support
and potential language changes can make a significant impact on the model development process by
supporting an automated control synthesis process.
Keywords: Control, Dynamic Programming, Model
Embedded Control, Model Based Control, Optimal
Control

1

Introduction

The use of modeling is well established in
the development of complex products. Modern tools
have significantly reduced the effort required to
model and tune physical systems. Acausal or topological modeling reduces the effort required to model
a systems physics. The use of optimization allows
systematic tuning of parameters to improve a design.
The combination of parameter optimization and

493

Modelica 2008, March 3rd  4th , 2008
1

E. Tate, M. Sasena, J. Gohl, M. Tiller

rapid modeling allows a large set of potential designs
to be quickly evaluated. However for systems which
include controls, the development is, in general, a
man-power intensive process subject to large uncertainty in development time and optimality. The optimization of both controls and design must be
solved in many problems [1-3]. One way to address
this problem is to use numerical techniques to construct controllers. For certain classes of problems,
tractable numerical techniques can be used to develop an approximately minimizing controller [4]. A
minimizing controller is a controller which achieves
the best possible performance from a system as
measured against an objective. There may exist more
than one controller able to achieve this minimum,
but no controller can perform better than a minimizing controller. For this work, the terms minimizing
controller and optimal controller are used interchangeably.
To construct a minimizing controller, an object cost, J , is defined. This is a function which
maps the state and input trajectory of the system to a
scalar:

J

C x, u .

(1)

Consider the special case of a plant described by ordinary differential equations with inputs that are
piecewise constant. These piecewise constant inputs
are updated periodically at the decision instances
by a controller at intervals of t . The total operating
cost is calculated as a sum over an infinite time horizon. Furthermore, the sum of costs is discounted by
the term
which is greater than zero and less than
or equal to one. The total cost is calculated by an
additive function that operates on the instantaneous
state and the control inputs. This cost may take a
form similar to
tk

1

k

J x 0

ccont x

k 0

, uk

d

. (2)

t tk

The total cost in (2) is a function of the initial state
of the system. To simplify notation, let the state at
the decision instances be represented by

xk

x tk .

(3)

Let the discrete time samples occur at

tk

k

t.

(4)

Furthermore, let the continuous-time instantaneous
cost, ccont , in (2) be represented in discrete time notation as an additive cost over an interval,
tk

1

c xk , uk

ccont x

, uk

d .

(5)

Using the notation developed in (2) through (5), the
continuous-time systems total cost is expressed in
discrete time notation as
k

J x0

c xk , uk .

(6)

k 0

To simplify the continuous-time dynamics, let
t

f d x, u

f

,u d ,

0

x .

(7)

0

Hence,

xk

1

f d xk , uk .

(8)

An optimal control choice for each time step can be
found using the dynamic programming equations,

u* x

arg min c x, u
u U x

V f d x, u

. (9)

The function V x is known as the value function.
By using the dynamic programming (DP) equations
to find the value function, a minimizing controller is
obtained. The DP equations are

V x

min c x, u

u U x

V f d x, u

, (10)

where

U x

u g x, u

0

(11)

defines the set of feasible actions, U x . For the
case where the total cost is considered over an infinite horizon and uk u * xk (see eq (9)), the value
function is the same as the total cost function,
J x V x . Equation (10) can be solved through
value iteration, policy iteration, or linear programming. See [5-23] for discussion of solution methods.
For discussion of using DP to find value functions
for automotive control application, see [24-29]. The
formulation of equation (11) is chosen to simplify
management of constraints throughout the model and
to conform to a standard form used in the optimization community, the negative null form [30].
One problem with solving (10) is that when
the state space consists of continuous states, V x
is a function from one infinite set to another. Except
in special cases, this requires approximation to solve.
One common approach is to use linear bases to approximate the value function. Possible linear bases
include the bases for multi-linear interpolation, the
bases for barycentric interpolation, b-splines, and
polynomials. See the appendices in [25] for a discussion of linear bases for dynamic programming. In the
case where V x is approximated by a linear basis,

t tk

The Modelica Association

494

Modelica 2008, March 3rd  4th , 2008
2

Model Embedded Control: A Method to Rapidly Synthesize Controllers in a Modeling Environment

T

V x

x w,

(12)

where
x

f1 x

f2 x

fN x

.

(13)

An approximate solution to (10) is found by finding
the weights, w , which solve
T

x w

min c x, u

u U x

T

f d x, u

w

Controller Development

To use equations (2) through (14) to develop
a controller, it is necessary to have a plant model
which includes the dynamics ( f ), cost function ( c ),
and constraints ( g ) all coupled to an integrator
which can be invoked as a function call by a Control
Design Algorithm (CDA). In addition, the set of
states for the plant model and the set of controller
actions must be specified to the CDA. For this work,
a custom wrapper was developed that allowed
batches of states and actions to be efficiently evaluated. Each evaluation returned the state at the next
interval, the cost of operation for the interval, and the
constraint activity over the interval.
To understand the structure of the equations
involved in this work, consider a system consisting
of a plant and a controller. Without loss of generality, assume the plant dynamics are described by ordinary differential equations

x

f x, u ,

(15)

where f is a function that describes the plant dynamics. For notational simplicity consider a continuous time controller. Let the controller be a full state
feedback controller implemented as a static mapping,
M , from the state, x , to the action set, u :

The Modelica Association

M x .

(16)

Assuming only a single global minimum exists, the
dynamic programming equations in (9) can be directly used for the static mapping (16). The autonomous dynamics of this system are then described by
the following equation

. (14)

See [5-7] for a discussion of using linear bases to
form the value function.
It is important to understand that this controller is an optimal controller for the discrete time
case only, when the controller updates every t
seconds. In other uses, the controller will generally
be suboptimal. Additionally, any development algorithm based on this methodology will suffer from the
curse of dimensionality [31]. In other words, the
time to find an optimal controller will increase geometrically with the size of the plant state space. As a
point of reference, using a single commercially
available PC from 2005, a five state controller was
found in less than twenty four hours.

2

u

x

f x,arg min c x, u

(17)

V f d x, u

u U x

This equation is then integrated to solve for x t ,
x t
c x s ,u

t

f x s , arg min

V fd x s , u

u U x

0

ds

(18)

where

x 0

x0

(19)

defines the initial conditions. To evaluate f d from
(7), a nested integrator, which is independent of the
primary simulation integrator, is required. This
nested integrator executes in zero-time from the
perspective of the primary integrator. We refer to
this as an embedded or nested simulation. Because
the nested integrator is used inside a numeric optimization, it will potentially be called multiple times at
each primary integrator evaluation. If f d in (18) is
expanded using (7), the plant dynamics function, f ,
from (15) occurs in two locations in
x t

(20)

c x s ,u

t

f x s , arg min
0

u U x

t

V

f

,u d ,

0

x s

ds

0

where

x 0

x0

(21)
The nested copy of the plant dynamics equations, f ,
is referred to as the embedded or nested model. In
the case where the controller is modeled as updating
periodically, rather than continuously, the solution to
the optimization problem is held constant between
controller updates.
The equation structure in (20) and the reuse
of the plant dynamics function, f , offer the ability
to quickly synthesize controllers using numerical
techniques. However, existing tools make the implementation of this type of model problematic.
There are two primary issues in implementation. The
first is execution efficiency. Few commercial tools
have been developed with the goal of efficiently
solving this class of equations. Secondly, several

495

Modelica 2008, March 3rd  4th , 2008
3

E. Tate, M. Sasena, J. Gohl, M. Tiller

commercial modeling environments make the definition and reuse of the plant model cumbersome, requiring significant efforts during development and
maintenance. Fortunately, the features of Modelica
make the definition and reuse of a plant model manageable. The examples that follow have been developed in Dymola , however this general approach
has also been used with Simulink and AMESim.
To systematically generate a system with an
optimal controller, a model of the plant is generated.
This plant model is wrapped with an application
programming interface (API) so a control design algorithm can determine the state space, the action
space, the state at the next time step, the constraint
activity, and the cost for a given state and action.
This interaction between the plant model, the API
and the control design algorithm is illustrated in
Figure 1. The CDA queries the API to determine the
structure of the state and action space. Given this
structure and the configuration of the CDA, a sequence of DOEs is executed. The DOE data are used
to find a solution to (10). For this work, the value
function was modeled using multi-linear interpolation and a solution to (14) was found. To simplify
coding, value iteration was used [5, 6] to find V x .
State Space
Action Space

x, u
Control Design Algorithm

API to expose functions

f d x, u

Plant
Model

g x, u
(CDA)

c x, u

V x

Figure 1 - Plant Model API

Once the value function is generated, the
system model is formed by one of two methods. The
first method is by generating a lookup table that
maps the state variables to an action as in (16). The
process of generating a value function, finding a
mapping equivalent to (9), and realizing a controller
as a mapping (or lookup table) is referred to as Indirect Model Embedded Control (IMEC). This method
is appropriate for some systems. Another approach,
which is more computationally expensive, is referred
to as Direct Model Embedded Control (DMEC). For
DMEC, the controller is realized by forming an optimization statement around an embedded copy of
The Modelica Association

the plant model. This structure is illustrated in Figure
2.

Controller
Optimizer
x, u

x

f d x, u

g x, u

c x, u

API to expose functions

u*

Plant
Model

Embedded
Plant
Model

Figure 2 - Direct Model Embedded Controller Structure

To realize a Direct Model Embedded Controller (DMEC), two pieces are added to the system
model. The first piece is an optimizer which solves
(9). This optimizer can be as simple as a Design of
Experiments (DOEs) which considers a fixed set of
actions, and selects one which minimizes (9). For
more sophistication, if the nature of the problem
permits it, a gradient-based optimizer can be employed [30, 32, 33]. If the nature of the problem does
not allow solution using these types of approaches,
global solvers can be used [34-36]. Ideally, an optimization library should support both gradient and
non-gradient methods for constrained optimization
problems. As part of this project, libraries for performing both DOEs and gradient-based optimizations were implemented entirely in Modelica. However, there are currently no comparable commercial
or public domain libraries available. The second
piece required to implement a DMEC is the ability to
invoke a function which efficiently initializes and
simulates, over a short time horizon, a set of models which are copies of the plant model with modified parameters. Because of the structure of the problem, each time the controller executes, multiple embedded simulations will execute. Depending on the
nature of the action set, the number of embedded
simulations may vary from as few as two embedded
simulations to several thousand embedded simulations.

3

Example  Simple Engine Start

To illustrate how these concepts are used to
build a controller, consider the problem of starting an
internal combustion engine using an electric machine

496

Modelica 2008, March 3rd  4th , 2008
4

Model Embedded Control: A Method to Rapidly Synthesize Controllers in a Modeling Environment

with insufficient torque to guarantee the engine
completes a revolution from all possible stationary
starting points. If the initial position of the engine is
in a range of angles, the electric machine will stall.
To simplify the modeling, let us assume the engine
can be approximated using a crank slider connected
to a spring. The system model, shown in Figure 3,
consists of an electrical motor connected to the crank
which connects through the crank slider mechanism
to a piston which is subject to damping from friction.
Inertia is present in the motor rotor, crankshaft and
piston. The electric machine is subject to constraints
on minimum and maximum torque.

is visible in (2) is assigned a value of one and omitted from the expression.
While it is clear that the system has exactly
two states, they can be selected somewhat arbitrarily.
For this example, the engine angle and engine speed
were selected. With these variables as the states, the
controller is represented as a static map from the engine angle and engine speed to the electric machine
torque.

u

The objective of the control system is to ensure the engine will overcome the initial compression torque from any initial state and minimize engine start time. The total cost of operation (what is
being minimized) is expressed mathematically as the
total time taken to achieve a speed greater than or
equal to five hundred RPM. Once this speed is
achieved, the controller is deactivated and another
scheme is used to manage the engine. The total cost
of operation for this system is considered over an
infinite time horizon and is computed as

J x 0
0

0 , t 500 rpm
1 ,otherwise

u

100 u 100,
.
10000 u
10000

c x

Value function

0
50
100

0.4

150

0.2

200

0

dt . (22)

250

1000
500

The Modelica Association

300

0
-500
Engine Speed [rpm]

(23)

This type of cost generates a shortest-path controller. The controller will minimize the total time to
achieve 500 rpm. The total cost in (22) is undiscounted. Therefore the discounting factor, , which

(25)

The value function was represented using multilinear interpolation, see equation (12).
The plant model was implemented in Modelica. The Controller Design Algorithm (CDA) was
implemented in MATLAB. The CDA invoked
function calls to a custom API, similar to Figure 1,
applied to the plant model in Dymola. The CDA
solved for the weights, w , in the value function
(equation (12)). This value function was used to generate an Indirect Model Embedded Controller
(IMEC) and a Direct Model Embedded Controller
(DMEC). The value function generated by the CDA
is shown in Figure 4.

The instantaneous cost for this system is

0 ,
500 rpm
.
1 ,otherwise

(24)

,

The feasible action set is a single real number, the
motor torque, bounded by the constraints on motor
torque and power. The set of feasible actions is defined by

U x

Figure 3 - Engine Starting Model

M

-1000

Engine Angle [deg]

350

Figure 4 - Value function

The IMEC was realized as a two input
lookup table with multi-linear interpolation on a
regular grid. The grid points in the table were found
by solving (9) using the value function generated by
the CDA. This controller was implemented using

497

Modelica 2008, March 3rd  4th , 2008
5

E. Tate, M. Sasena, J. Gohl, M. Tiller

standard Modelica components. The actuator commands for the IMEC controller are shown in Figure 5
as a function of engine speed and angle.
Best Control Choice - u*

0
50
100

100

150

0

200

-100

250

1000
500

300

0
-500
Engine Speed [rpm]

-1000

Engine Angle [deg]

350

Figure 5 - IMEC control table

The DMEC was realized by wrapping a copy
of the plant model with an API similar to the one
used for the CDA. A DOE was used to search feasible actions. The resulting code structure is identical
to Figure 2. The optimal action was chosen to minimize (9).
For both of these controllers, the problem of
starting the engine from any initial condition was
solved. The solution involved the counter-intuitive
approach of spinning the engine backwards, then
reversing direction to allow enough energy to be
stored in the inertia to overcome the spring force.
From a model and a control objective, an optimal
controller with very complex behaviors was numerically generated in less than 10 minutes on a single
PC (3GHz, 2Gb RAM). Furthermore, a similar
problem with four states was solved in less than
three hours. Of course the power of this approach
can only be realized once a sufficient level of tool
support is available so that the time required to set
up the analysis is on the same order as the solution
time.
3.1

Control Design Algorithm (CDA). The IMEC controller was designed by solving for the best electric
machine torque for a set of engine angles and speeds
on a regular grid. For engine states which occur off
this grid, multi-linear interpolation was used to calculate the control action. When the IMEC was used
in an engine start simulation, if the optimal torque
transitioned between positive and negative, the interpolation caused a smooth change in the torque because of the continuity imposed by interpolation.
Alternatively, consider a Direct MEC. Because of the characteristics of the dynamic programming equations and the value function, the optimal choices are either full positive or full negative
torque. This results in an instantaneous, noncontinuous change in torque. When plotted as in
Figure 6, the difference between the control inputs
and the state evolution of the system can be seen.
The interpolation due to the approximation in the
IMEC results in artifacts in the control actions and a
slight loss of performance in the system. Mathematically this means that more detail is required to
resolve u * x , the function that we are ultimately
trying to formulate, than to resolve V x .
There are cases where an IMEC is superior
to a DMEC approach (e.g. [26] illustrates just such a
case). In general, an IMEC implementation is superior when both the action set is continuous and the
optimal actions are continuous. The DMEC approach
is superior when either the action set is discrete or
the optimal actions are not continuous with respect
to the state. One example where DMEC is clearly
superior is where the motor is controlled by selecting
the state of a switch inverter. In this case, the action
set consists of a finite set of choices for switch configuration and the optimal actions are not continuous
with respect to the state.

Direct vs Indirect MEC

Ideally, both an IMEC and DMEC will result in identical behaviors. However, differences in
approximation schemes and interpolation can results
in appreciable differences. In many cases, while Indirect MEC is simpler to realize in a model, there are
good reasons to implement a controller with the
complexity and computational cost of a Direct MEC.
As an example, consider the previous problem. The value function, V(x), was found using the
The Modelica Association

498

Figure 6 - Comparison of IMEC and DMEC results

Modelica 2008, March 3rd  4th , 2008
6

Model Embedded Control: A Method to Rapidly Synthesize Controllers in a Modeling Environment

4

Implementation of optimization algorithms

One of the challenges in Direct Model Embedded Control is the implementation of an optimizer. While this work was performed using a Design of Experiments (DOE) to select optimal actions,
this approach becomes intractable when equality
constraints and larger dimensional actions sets are
considered. Towards the goal of supporting these
classes of problems, a gradient-based optimizer was
developed. One of the goals in developing this optimizer was to fully implement the optimizer in Modelica. By fully implementing in Modelica, all of the
information used by the optimizer would be accessible for speed improvements by the compiler. Should
native support for model embedding become available, all equations associated with a Direct MEC
would be accessible to the compiler for speed improvement. Additionally, since the embedded simulations in a DMEC can be completely decoupled
from each other, simulation tools could easily exploit
the coarse grained parallelism on multi-core CPUs
by running several embedded simulations concurrently when conducting searches in the optimizer
(e.g. line searches and numerical gradients).
The optimizer was developed in Modelica to
solve a constrained optimization problem which is
generally stated in negative null form [30] as

min f objective
s.t.
g inequalities
hequalities

0

.

(26)

0

To implement a gradient optimizer, the optimizer
functionality was separated from the objective function ( f objective ), the inequality constraint functions
( g inequalities ), and the equality constraint functions
( hequalities ). The optimizer was designed under the
assumption that the inequality constraint functions
are all in negative null form: feasible inequality constraints are less than or equal to zero. The objective
function was assumed to be a minimization objective. Since Modelica does not (yet) support the concept of methods or passing of functions as arguments, the optimizer was designed to use static inheritance. For this reason, the objective and constraint functions are replaceable functions within an
optimizer package.
One feature of this library, that is not commonly available, is the ability to handle functions
The Modelica Association

which are undefined over some region. The domain
of the objective and constraints may not be known a
priori. This occurs with MEC applications because
the objective (e.g. equation (9)) and constraint functions (e.g. equation (11)) are typically evaluated using a solver. The solver may not find a solution.
Hence, classical algorithms must be modified to recover from undefined evaluations.
Implementation of this capability was problematic because of the lack of numeric support for a
real value which represents the concept of an undefined quantity. Either a native capability similar to
Matlabs  NaN, or operator overloading with the
ability to extend a class from real numbers would
have simplified implementation.
In this library, Modelica.Constants.inf was
used to indicate that a function call was undefined.
However, the language specification does not define
behavior for operations (e.g. addition, subtraction,
multiplication, division) on Modelica.Constants.inf.
Therefore, all functions and statements which operated on variables that might be assigned a value of
Modelica.Constants.inf required conditional expressions to ensure expected behavior.
While this optimization library will not be
publicly released, it is available for further development. Contact the lead author for a copy.

5

Recommendations

While it is possible to realize both IMEC
and DMEC controllers using Modelica 2.2, the addition of a standard optimization library and native
support for embedded model simulation would
vastly simplify implementation and maintenance.
Towards the goal of simplifying implementation of MEC, a recommended language improvement is the addition of a model simulate function.
The function would accept arguments that specify
the model to simulate, the parameter values to use in
each simulation, the outputs to return, and any solver
specific settings. The solver should be able to be
configured to solve both initialization problems and
simulation problems. For efficiency in evaluation,
the function should support both a scalar and vector
lists of parameters. In addition to results which are
associated with the model, there should be results
associated with the solver. These results should be
sufficient to diagnose solver failures. At a minimum, these should include the final time in the
evaluation and an indication of whether the simulation successfully completed. A sample function defi-

499

Modelica 2008, March 3rd  4th , 2008
7

E. Tate, M. Sasena, J. Gohl, M. Tiller

nition along with an example invocation are shown
in Figure 7.
function simulateModel
input String modelName;
input String paramNames[:];
input String resultNames[:];
input Real
paramValues[:,size(paramNames,1)];
input SettingsRecord solverSettings;
output Real
results[size(paramValues,1),
size(resultNames,1)];

end simulateModel;
// example call
[angle, speed, exitCondition, exitTime] =
simulateModel(
modelName=Library.PlantModel,
paramNames{w0, theta0,u},
resultNames=
{w, theta,
exitCondition, exitTime },
paramValues=
[0, 0, -100;
1, 0, -100;
;
2, 2*pi, 100],
solverSettings =
SettingsRecord(
stopTime=1.0,
fixedStep=0.1)
);

Figure 7 - Model evaluation

It is important to point out that the goal is to
be able to invoke such a function from within a running model and not simply as a command line analysis option. As previously mentioned, the ability to
directly express such nested simulation relationships
makes posing MEC problems much easier. If the
MEC problem could also directly express the optimization problem associated with MEC then tools
could also bring the underlying symbolic information to bear on efficient gradient evaluation as well.
One remaining issue for DMEC problems is
the initialization of state variables in the embedded
model. For DMEC problems we typically want the
embedded model to start at the current state of the
parent simulation. Said another way, the current values of the states in the parent simulation should be

The Modelica Association

used as initial conditions in the nested simulation.
Of course, it is possible using the function in Figure
7 to establish such a mapping but hopefully the language design group will consider alternatives that
would be less tedious and error prone.

6

Conclusions

It is tractable to numerically synthesize near
optimal (or approximately minimal) controllers for
many systems. While in most cases the state feedback required for the controllers may make them
impractical to deploy, they can certainly be used as
prototype controllers that establish performance limits for a given design as well as provide insights into
control laws for production controllers. Furthermore, this approach can easily integrate into a combined plant-controller optimization process. This can
be done by making the optimal controller a function
of the plant parameters. These optimal controllers
can be realized as lookup tables (IMEC) or through
the use of optimization and embedded models
(DMEC). An algorithmic approach to controls synthesis was presented. For this paper, the IMEC and
DMEC approaches were applied to an engine starting problem to generate an optimal controller in an
automated fashion.
As this work has shown, Modelica is a
promising technology for rapid prototyping of subsystem designs and prototype controllers. However,
lack of support for model embedding makes development and long term maintenance problematic because considerable work must be done to implement
this embedding. Lacking any language standard, this
work will always be tool specific. Furthermore, implementation of controllers which rely on optimization suffer from the lack of a standard optimization
library. While an optimization library was developed
for this work, it isnt practical for most users to make
such an investment. By adding both language support to express the essential aspects of model embedding and optimization discussed in this paper,
Modelica can evolve into a powerful technology for
system development and optimization.

References
[1]

500

H. K. Fathy,"Combined Plant and Control
Optimation: Theory, Strategies, and Applications," Mechanical Engineering, University of Michigan, Ann Arbor, 2003.

Modelica 2008, March 3rd  4th , 2008
8

Model Embedded Control: A Method to Rapidly Synthesize Controllers in a Modeling Environment

[2]

[3]

[4]

[5]
[6]
[7]
[8]

[9]

[10]

[11]
[12]

[13]

[14]

H. K. Fathy, P. Y. Papalambros, A. G. Ulsoy, and D. Hrovat, "Nested Plant/Controller
Optimization with Application to Combined
Passive/Active Automotive Suspensions."
H. K. Fathy, J. A. Reyer, P. Y. Papalambros,
and A. G. Ulsoy, "On the Coupling between
the Plant and Controller Optimization Problems," in American Control Conference, Arlington, Va, 2001.
P. R. Kumar and P. Variaya, Stochastic Systems: Estimation, Identification and Adaption. Englewood Cliffs, New Jersey: Prentice
Hall, 1986.
D. Bertsekas, Dynamic Programming and
Optimal Control: Vol 2. Belmont, Mass:
Athena Scientific, 1995.
D. P. Bertsekas, Dynamic Programming and
Optimal Control: Vol 1. Belmont, Mass:
Athena Scientific, 1995.
D. P. Bertsekas and J. N. Tsitsiklis, NeuroDynamic Programming. Belmont, Mass:
Athena Scientific, 1996.
M. A. Trick and S. E. Zin, "A Linear Programming Approach to Solving Stochastic
Dynamic Programs," Carnegie Mellon University 1993.
M. A. Trick and S. E. Zin, "Spline Approximations to Value Functions: A Linear
Programming Approach," Macroeconomic
Dynamics, pp. 255-277, 1997.
D. P. de Farias and B. Van Roy, "The Linear
Programming Approach to Approximate
Dynamic Programming," Operations Research, vol. 51, pp. 850-865, NovemberDecember 2003.
V. F. Farias and B. Van Roy, "Tetris: Experiments with the LP Approach to Approximate DP," 2004.
D. P. de Farias,"The Linear Programming
Approach to Approximate Dynamic Programming: Theory and Application," Ph.D.
Dissertation, Department of Management
Science and Engineering, Stanford University, Palo Alto, Ca, 2002.
D. Dolgov and K. Laberteaux, "Efficient
Linear Approximations to Stochastic Vehicular Collision-Avoidance Problems," in
Proceedings of the Second International
Conference on Informatics in Control,
Automation, and Robotics (ICINCO-05),
2005.
G. J. Gordon, "Stable Function Approximation in Dynamic Programming," January
1995.

The Modelica Association

[15]
[16]

[17]
[18]

[19]

[20]

[21]

[22]

[23]

[24]

[25]

[26]

501

R. S. Sutton and A. G. Barto, Reinforcement
Learning: An Introduction. Cambridge,
Mass: MIT Press, 1999.
R. Munos and A. Moore, "Barycentric Interpolators for Continuous Space and Time Reinforcement Learning," Advances in Neural
Information Processing Systems, vol. 11, pp.
1024-1030, 1998.
R. Munos and A. Moore, "Variable Resolution Discretization in Optimal Control," Machine Learning, vol. 1, pp. 1-24, 1999.
J. M. Lee and J. H. Lee, "Approximate Dynamic Programming Strategies and Their
Applicability for Process Control: A Review
and Future Directions," International Journal of Control, Automation, and Systems,
vol. 2, pp. 263-278, September 2004.
D. P. de Farias and B. Van Roy, "Approximate Value Iteration with Randomized Policies," in 39th IEEE Conference on Decision
and Control Sudney, Australia, 2000.
D. P. de Farias and B. Van Roy, "Approximate Value Iteration and TemporalDifference Learning," in IEEE 2000 Adaptive Systems for Signal Processing, Communications and Control Symposium, 2000, pp.
48-51.
B. Van Roy and J. N. Tsitsiklis, "Stable Linear Approximations to Dynamic Programming for Stochastic Control Problems with
Local Transitions," Advances in Neural Information Processing Systems, vol. 8, 1996.
P. W. Keller, S. Mannor, and D. Precup,
"Automatic Basis Function Construction for
Approximate Dynamic Programming and
Reinforcement Learning."
V. C. P. Chen, D. Ruppert, and C. A. Shoemaker, "Applying Experimental Design and
Regression Splines to High Dimensional
Continuous State Stochastic Dynamic Programming," Operations Research, vol. 47,
pp. 38-53, January-February 1999.
C.-C. Lin, H. Peng, and J. W. Grizzle, "A
Stochastic Control Strategy for Hybrid Electric Vehicles," in Proceedings of the 2004
American Control Conference, 2004, pp.
4710-4715 vol. 5.
E. D. Tate,"Techniques of Hybrid Electic
Vehicle Controller Synthesis," Electrical
Engineering: Systems, University of Michigan, Ann Arbor, Michigan, 2007.
E. Tate, J. Grizzle, and H. Peng, "Shortest
Path Stochastic Control for Hybrid Electric
Vehicles," Internation Journal of Robust and
Nonlinear Control, 2006.
Modelica 2008, March 3rd  4th , 2008
9

E. Tate, M. Sasena, J. Gohl, M. Tiller

[27]

[28]

[29]

[30]

[31]
[32]
[33]
[34]

[35]

[36]

I. Kolmanovsky, I. Siverguina, and B. Lygoe, "Optimization of Powertrain Operating
Policy for Feasibility Assessment and Calibration: Stochastic Dynamic Programming
Approach," in Proceedings of the American
Control Conference, Anchorage, AK, 2002,
pp. 1425-1430.
J.-M. Kang, I. Kolmanovsky, and J. W.
Grizzle, "Approximate Dynamic Programming Solutions for Lean Burn Engine Aftertreatment," in Proceedings of the 38th Conference on Decision & Control, Phoenix,
Arizona, 1999, pp. 1703-1708.
C.-C. Lin, H. Peng, J. W. Grizzle, and J.-M.
Kang, "Power Management Strategy for a
Parallel Hybrid Electric Truck," IEEE
Transactions on Control Systems Technology, vol. 11, pp. 839-849, November 2003.
P. Y. Papalambros and D. J. Wilde, Principles of Optimal Design: Models and Computation, 2 ed. New York, New York: Cambridge University Press, 2000.
J. Rust, "Using Randomization to Break the
Curse of Dimensionality," 1996.
S. Boyd and L. Vendenberghe, Convex Optimization. New York, N.Y.: Cambridge
University Press, 2004.
P. E. Gill, W. Murray, and M. H. Wright,
Practical Optimization. New York, N.Y.:
Academic Press, 1981.
D. R. Jones, C. D. Peritunen, and B. E.
Stuckman, "Lipschitzian Optimization without the Lipschitz Constant," Journal of Optimization Theory and Applications, vol. 79,
pp. 157-181, 1993.
A. J. Booker, J. Dennis, J. E. , P. D. Frank,
D. B. Serafini, V. Torczon, and M. W. Trosset, "A Rigorous Framework for Optimization of Expensive Functions by Surrogates."
M. J. Sasena,"Flexibility and Efficiency Enhancements for Constrained Global Design
Optimization with Kriging Approximations,"
Mechanical Engineering, University of
Michigan, Ann Arbor, 2002.

The Modelica Association

502

Modelica 2008, March 3rd  4th , 2008
10

Session 4d
Mechanical Systems & Applications

The Modelica Association

503

Modelica 2008, March 3-4, 2008

The Modelica Association

504

Modelica 2008, March 3rd  4th , 2008

High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters

High-Accuracy Orbital Dynamics Simulation through Keplerian
and Equinoctial Parameters
Francesco Casella Marco Lovera
Dipartimento di Elettronica e Informazione
Politecnico di Milano
Piazza Leonardo da Vinci 32, 20133 Milano, Italy

Abstract
In the last few years a Modelica library for spacecraft
modelling and simulation has been developed, on the
basis of the Modelica Multibody Library. The aim of
this paper is to demonstrate improvements in terms of
simulation accuracy and efficiency which can be obtained by using Keplerian or Equinoctial parameters
instead of Cartesian coordinates as state variables in
the spacecraft model. The rigid body model of the
standard MultiBody library is extended by adding the
equations defining a transformation of the body centerof-mass coodinates from Keplerian and Equinoctial
parameters to Cartesian coordinates, and by setting the
former as preferred states, instead of the latter. The remaining parts of the model, including the model of the
gravitational field, are left untouched, thus ensuring
maximum re-usability of third-party code. The results
shown in the paper demonstrate the superior accuracy
and speed of computation in the reference case of a
point-mass gravity field.
Keywords: Spacecraft dynamics; Orbit dynamics; Numerical integration; State selection.

1

Introduction

The Modelica Spacecraft Dynamics Library ([6, 7,
10]) is a set of models (based on the already existing
and well known Multibody Library, see [9]) which is
currently being developed with the aim of providing
an advanced modelling and simulation tool capable of
supporting control system analysis and design activities for both spacecraft attitude and orbit dynamics.
The main motivation for the development of the library
is given by the significant benefits that the adoption
of a systematic approach to modelling and simulation,
based on modern a-causal object-oriented languages
such as Modelica, can give to the design process of
such advanced control systems.
The Modelica Association

At the present stage, the library encompasses all the
necessary utilities in order to ready a reliable and
quick-to-use scenario for a generic space mission, providing a wide choice of most commonly used models for AOCS sensors, actuators and controls. The
librarys model reusability is such that, as new missions are conceived, the library can be used as a base
upon which readily and easily build a simulator. This
goal can be achieved simply by interconnecting the
standard library objects, possibly with new components purposely designed to cope with specific mission requirements, regardless of space mission scenario in terms of either mission environment (e.g.,
planet Earth, Mars, solar system), spacecraft configuration or embarked on-board systems (e.g., sensors,
actuators, control algorithms).
More precisely, the generic spacecraft simulator consists of an Extended World model and one or more
Spacecraft models. The Extended World model is an
extension of Modelica.MultiBody.World which provides all the functions needed for a complete representation of the space environment as seen by a spacecraft: gravitational and geomagnetic field models, atmospheric models, solar radiation models. Such an
extension to the basic World model as originally provided in the MultiBody library plays a major role in
the realistic simulation of the dynamics of a spacecraft as the linear and angular motion of a satellite
are significantly influenced by its interaction with the
space environment. The Spacecraft model, on the
other hand, is a completely reconfigurable spacecraft
including components to describe the actual spacecraft dynamics, the attitude/orbit control sensors and
actuators and the relevant control laws. In this paper we are specifically concerned with the Spacecraft model; this component has been defined by extending the already available standard model Modelica.Mechanics.MultiBody.Parts.Body. The main modifications reside in the selectable evaluation of the in-

505

Modelica 2008, March 3rd  4th , 2008

F. Casella, M. Lovera

teractions between the spacecraft and the space environment and on the additional initialization option for
the simulation via selection of a specific orbit for the
spacecraft. The main drawback associated with the
adoption of the standard Body model as the core of
the Spacecraft model is related to the intrinsic use this
component makes of the Cartesian coordinates in the
World reference frame for the state variables associated with the motion of the Bodys center of mass. Indeed, for spacecraft work it is well known that significant benefits, both in terms of simulation accuracy and
computational performance, can be obtained by using
different choices of state variables, such as Keplerian
and Equinoctial parameters (see, e.g., [11, 8]).
Therefore, the aims of this paper, which extends preliminary results presented in [2] are the following:

completely specifies the two-body orbit from a complete set of initial conditions for solving an initial value
problem class of differential equations.
In the following subsections, we will deal with spacecraft subject only to the gravitational attraction of the
Earth considered as a point mass (unperturbed Keplerian conditions) and we will refer mainly to the Earth
Centered Inertial reference axes (ECI), defined as follows. The origin of these axes is in the Earths centre.
The X-axis is parallel to the line of nodes. The Z-axis
is parallel to the Earths geographic north-south axis
and pointing north. The Y-axis completes the righthanded orthogonal triad.

2.1

Position and Velocity Coordinates

In the ECI reference frame, the position and velocity
 to demonstrate improvements in terms of simu- vectors of a spacecraft influenced only by the gravitalation accuracy and efficiency which can be ob- tional attraction of the Earth considered with punctitained by using Keplerian and Equinoctial pa- form mass will be denotated as follows
rameters instead of Cartesian coordinates as state

T
r= x y z ,
(1)
variables in the spacecraft model;

T dr
v = vx vy vz = .
(2)
 to illustrate how Keplerian and Equinoctial padt
rameters can be included in the existing multibody spacecraft model by exploiting the object- The acceleration of such a spacecraft satisfies the
oriented features of the Modelica language and equation of two-body motion
the symbolic manipulation capability of Modelica tools.

The paper is organised as follows: first an overview
of the available choices for the state representation of
satellite orbits is given in Section 2; subsequently, the
use of Keplerian and Equinoctial orbital elements for
the simulation of orbit dynamics will be described in
Section 3, while the corresponding Modelica implementation will be outlined in Section 4 and the results obtained in the implementation and application
of the proposed approach to the simulation of a Low
Earth and Geostationary orbits will be presented and
discussed in Section 5.

d2r
r
= GM
2
dt
krk3

(3)

where  = GM is the gravitational coefficient of the
Earth. A particular solution of this second order vector
differential equation is called an orbit that can be elliptic or parabolic or hyperbolic, depending on the initial
values of the spacecraft position and velocity vectors
r(t0 ) and v(t0 ). Only circular and elliptic trajectories
are considered in this study.
The state representation by position and velocity of a
spacecraft in unperturbed Keplerian conditions is

T
(4)
xECI = rT vT

at a given time t. Time t is always associated with a
state vector and it is often considered as a seventh component. A time used as reference for the state vector
The state of the center of mass of a satellite in space or orbital elements is called the epoch.
needs six quantities to be defined. These quantities
may take on many equivalent forms. Whatever the
2.2 Classical Orbital Elements
form, we call the collection of these quantities either a
state vector (usually associated with position and ve- The most common element set used to describe elliplocity vectors) or a set of elements called orbital ele- tical orbits (including circular orbits) are the classical
ments (typically used with scalar magnitude and angu- orbital elements (COEs), also called the Keplerian palar representations of the orbit). Either set of quanti- rameters, which are described in the sequel of this Secties is referenced to a particular reference frame and tion. The COEs are defined as follows:

2

Satellite State Representations

The Modelica Association

506

Modelica 2008, March 3rd  4th , 2008

High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters



a

: semi-major axis, [m];



n

: mean motion, [rad/s]



e

: eccentricity, [dimensionless];



i

: inclination, [rad];



with the implicit choice of adopting M as a parameter to represent the spacecraft anomaly; the advantages
and disadvantages of this choice will be discussed in
the following.

 : right ascension of the ascending node,
2.3
[rad];





: argument of perigee, [rad];





: true anomaly, [rad];

Equinoctial Orbital Elements

COEs suffer from two main singularities. The first is
when the orbit is circular, i.e., when the eccentricity is
zero (e = 0). In this case the line of apsis is undefined
 E : eccentric anomaly, [rad];
and also the argument of perigee . The second occurs
when the orbit is equatorial, i.e., when the inclination
 M : mean anomaly, [rad];
is zero (i = 0). In this case the ascending node is un(see Figures 1 and 2). The definitions of the COEs are defined and also the right ascension of the ascending
referenced to the ECI frame. The semi-major axis a node . See Figure 1.
specifies the size of the orbit. Alternatively, the mean It is nevertheless possible to define the true, eccentric
motion
r
and mean longitude (L, K and l, respectively) as
GM
n=
(5)
a3
can be used to specify the size.
L =  +  + ,
(8)
The eccentricity e specifies the shape of the ellipse.
K =  +  + E,
(9)
It is the magnitude of the eccentricity vector, which
l =  +  + M;
(10)
points toward the perigee along the line of apsis.
The inclination i specifies the tilt of the orbit plane. It
is defined as the angle between the angular momentum
these quantities remain well-defined also in the singuvector h = r  v and the unit vector Z.
lar cases of circular and/or equatorial orbits.
The right ascension of the ascending node  is the angle from the positive X axis to the node vector n point- The equinoctial orbital elements (EOEs) avoid the sining toward the ascending node, that is the point on the gularities encountered when using the classical orbital
equatorial plane where the orbit crosses from south to elements. EOEs were originally developed by Lanorth. The argument of perigee  is measured from grange in 1774. Their definitions in terms of Kepthe ascending node to the perigee, i.e., to the eccen- lerian elements are given by the following equations
tricity vector e pointing towards the perigee.
The eccentric anomaly E is defined on the auxiliary
circle of radius a, that can be drawn around the ellipZ
tical orbit, as shown in Figure 2. Finally, the mean
i
h
anomaly M is defined as M = n(t  t p ), where t p dee
notes the time of perigee passage, i.e., the instant at

which the eccentric anomaly vanishes. As is apparent
from its definition, the mean anomaly for an ideal Ke
i
plerian orbit increases uniformly over time. E and M
n
X
are related by the well known Kepler equation

LINE
OF APSIS

NORTH

SATELLITE

PERIGEE

EQUATORIAL
PLANE

E  e sin(E) = M.

(6)

In this work, satellite state representation in terms of
classical orbital elements (Keplerian parameters) will
be denoted as

T
xCOE = a e i   M
(7)
The Modelica Association

ASCENDING
NODE

507

ORBITAL
PLANE

Y
LINE
OF NODES

intersection between
equatorial plane
and orbital plane

Figure 1: Classical Orbital Elements (COEs).
Modelica 2008, March 3rd  4th , 2008

F. Casella, M. Lovera

the same direction as the h vector). In the equinoctial frame the elements P1 and P2 represent the projection of the eccentricity vector onto the Q and E directions, respectively (see Figure 3). The elements Q1
and Q2 represent the projection of the vector oriented
in the direction of the ascending node with magnitude
tan(i/2), onto the Q and E directions, respectively.
Note that in the singular cases of circular (or equatorial) orbits, the vector P (or Q) becomes zero; the
indetermination in the two components of each vector
is thus not a problem.

AUXILIARY
CIRCLE

ELLIPTIC
ORBIT

SATELLITE

a

r


E
a

a cos(E)
ae

LINE
OF APSIS

Figure 2: True and eccentric anomalies for elliptic motion.

P1

i = tan(i/2) n /n


E

(11)

P1 = e sin( + I),

(12)

P2 = e cos( + I),

(13)

Q1 = tan(i/2) sin ,

(14)

Q2 = tan(i/2) cos ,

(15)

l =  +  + M.

(16)

True retrograde equatorial orbits (i = 180 ) cause
problems because Q1 and Q2 are undefined. This
problem is solved by introducing a retrograde factor
I which is +1 for direct orbits and 1 for retrograde
orbits. In this work, dealing with geostationary satellites, I is equal to +1 and the mean longitude net of
the Greenwich Hour Angle (t)

E

P2

L



Q



Q

(see, e.g., [1, 5, 8] for details)

l = l  (t)

Q1

LINE
OF NODES

e

a,

LINE
OF APSIS


Q2

r

ORBITAL
PLANE

SPACECRAFT

ORBITAL
PLANE

Figure 3: Eccentricity and inclination equinoctial
components and true longitude.

2.4

Conversion formulae: COEs to Cartesian

The position coordinates in the orbital plane, centered
in the Earth (Figure 2) are related to the COEs by the
following equations

 

a cos(E)
 ae
xorb

=
.
(19)
yorb
a sin(E) 1  e2

(17) while the corresponding velocities can be computed as
#
2

 "
 a|r|n sin(E)
vx,orb
will be used instead of the mean longitude l given by
= a2 n 
,
(20)
vy,orb
equation (16). GEO satellite state representation in
1  e2 cos(E)
|r|
terms of equinoctial orbital elements will be denoted
q

2 + y2 = r T r. As depicted in Figas follows
with |r| = xorb
orb

T
ure 1, the orthogonal basis RT N of the Gaussian coxEOE = a P1 P2 Q1 Q2 l .
(18) ordinate system can be obtained from the orthogonal
basis XY Z of the ECI frame by means of three succesThe definitions of the EOEs are referenced to the
sive rotations
equinoctial reference frame, which can be obtained


 
xorb
x
from the ECI reference frame by a rotation through



y
y ,
=
R
(x
)
(21)
ZXZ COE
orb
the angle  about the Z axis, followed by a rotation
0
z
through the angle i about the new X axis (which points
in the same direction as the node vector n pointing with
the ascending node), followed by a rotation through
R ZXZ (xCOE ) = R Z ()R X (i)R Z ()
(22)
the angle I about the new Z axis (which points in
The Modelica Association

508

Modelica 2008, March 3rd  4th , 2008

High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters


h
i
x d|r|
2  Q2 ) dcos(L) + 2Q Q dsin(L)
 
+

(1
+
Q
1 2 dK
2
1
dK
vx
 |r| dl
h
i



dsin(L)
dcos(L) 
d|r|
y
2
2
 vy  = n 
cos  sin  0
+

(1
+
Q

Q
)
+
2Q
Q
,
1 2 dK
1
2
dK
h
i
 |r| dl

R Z () =  sin  cos  0
(23)
vz
dsin(L)
dcos(L)
z d|r|
+
2
Q

Q
2 dK
1 dK
|r| dl
0
0
1
(30)
describes the first rotation around the Z axis of an an- where
gle , matrix
|r| = a(1  P1 sin(K)  P2 cos(K)),


1
0
0
|r|
,
=
R X () = 0 cos i sin i 
(24)
1 + Q21 + Q22
0  sin i cos i
a
=
,
2 + Q2
1
+
Q
describes the second rotation around the X of an angle
1
2
q
i, matrix
 = 1 + 1  P12  P22



a 
cos() sin() 0
2
sin(L)
=
(

P
)
sin(K)
+
P
P
cos(K)

P
1
2
1
2
|r|
R Z () =  sin() cos() 0
(25)

a 
0
0
1
cos(L) =
(  P12 ) cos(K) + P1 P2 sin(K)  P2 .
|r|
describes the third rotation around the Z axis of an angle . Thanks to the orthonormal property of rotation
matrices, equation (21) can be easily inverted, giving 3 COEs and EOEs for simulation of
orbit dynamics
 


x
xorb
y = R TZ ()R TX (i)R TZ () yorb  ;
(26) When orbital control problems are studied, it is usually
z
0
necessary to integrate the equations of motion of the
following the same reasoning, the Cartesian velocity satellite under the action of gravity (due to the Earth or
any other celestial body), of the space environment and
vector can be expressed as
of the actuators thrust. The usual approach, known as


 
Cowells method (see [3]), is to integrate the equations
vx,orb
vx
vy  = R TZ ()R TX (i)R TZ () vy,orb  .
(27) of motion in cartesian coordinates
0
vz
r = v
(31)
Further details can be found, e.g., in [11]. SummarizF
ing, it is possible to compute xCOE , given xECI , by first
v = ag (r) +
(32)
m
solving the scalar implicit equation (6) for E, and then

where matrix

the explicit vector equations (19)-(20), (26)-(27).

where ag is the acceleration of gravity, F is the sum of
all the other forces, and m is the satellite mass. applied
2.5 Conversion formulae: EOEs to Cartesian by the actuators. First-cut models assume a point-mass
model
The conversion formulae from EOEs to Cartesian coag = GMr/krk3 ,
(33)
ordinates in ECI are slightly more involved. The
results are summarised here; for further details, the while accurate simulations require more detailed modreader is referred to, e.g., [1, 5, 8].
els of the gravitational field, usually in the form of a
The eccentric longitude K can be computed by solving series expansion (see, e.g., [12]). In both cases, the
the implicit equation
differential equations are strongly non-linear; therefore, despite the use of high-order integration algoltheta + (t) = K + P1 cos(K)  P2 sin(K).
(28) rithm, tight tolerances end up in a fairly high number
of simulation steps per orbit.
The ECI coordinates are then given by
If the satellite motion is described in terms of COEs
 


or EOEs, it is easy to observe that the variability of
x
(1 + Q22  Q21 ) cos(L) + 2Q1 Q2 sin(L)
y =  (1 + Q21  Q22 ) sin(L) + 2Q1 Q2 cos(L) ,
the six orbit elements is much smaller than that of the
Cartesian coordinates. In particular, it is well-known
2Q2 sin(L)  2Q1 cos(L)
z
(29) that in case of a point-mass gravity field with no other
The Modelica Association

509

Modelica 2008, March 3rd  4th , 2008

F. Casella, M. Lovera

applied forces, the first five parameters are constant,
while the mean anomaly and the mean longitude increase linearly with time. All existing high-order integration methods have error bounds which depend on
Taylor expansions of the state trajectory. One can then
conjecture that if the COEs/EOEs are used as state
variables, instead of the Cartesian vectors r and v, the
state trajectories will be smoother, and therefore the integration algorithm will be able to estimate them with
with a higher relative precision using much larger time
steps, compared to the Cartesian coordinates case.
Recalling the definition of vector xECI in (4), letting
z = xCOE or z = xEOE depending on the choice for
the new state variables and denoting by g() the transformation relating z and x, equations (31)-(32) can be
written in compact form as
x = f (x)

(34)

x = g(z).

(35)

If a state variable change from x to z is now performed,
the following equations are obtained
 g(z)
z = f (g(z))
z

(36)

which can be solved for z provided that the new state
variables z are uniquely defined


 g(z)
z
x = g(z).
z =

1

f (g(z))

(37)
(38)

The Jacobian for gCOE is generically well defined and
becomes singular only in the case of a circular and/or
equatorial orbit. In this case the EOEs are needed, as
the Jacobian for gEOE is well defined in this case.
The model (37)-(38), which is now in standard statespace form, has two very important features:
 the right-hand side of (37) is much less variable
than the right-hand side of (34), so it will be easier to integrate the equations with a higher accuracy;

for decades. In particular, the so-called class of symplectic integration methods (see, e.g., [4] and the references therein) provides an effective and reliable solution to the problem. In the framework of the present
study, however, the aim is to improve accuracy in the
computation of orbital motion while retaining the advantages associated with the use of a general-purpose
object-oriented modelling environment, in which not
only orbital dynamics can be simulated, but also the
coupled attitude motion, as well as the associated
mathematical models of sensors, actuators and controllers for orbital and attitude control. This more general framework requires the use of general-purpose integration algorithms for ODEs/DAEs.

4

Modelica implementation

The concepts outlined in Section 3 are easily implemented with the Modelica language. The starting point is the Body model of the standard Modelica.Mechanics.MultiBody library [9]: this is a 6
degrees-of-freedom model of a rigid body, which can
be connected to other components to form a multibody system model. The original model has six degrees of freedom, corresponding to 12 state variables:
the three cartesian coordinates and the three velocity
components of the center of mass, plus three suitable
variables describing the body orientation and the three
components of the angular velocity vector. Assuming
that the gravitational field is applied exactly at the center of mass (the gravity gradient effect is computed in a
separate model and thus not included here), the translational and rotational equations are completely decoupled, so it is possible to focus on the former ones,
leaving the latter ones untouched.
First of all, the equations to compute the gravity acceleration as a function of the cartesian coordinates
using accurate field models are added by inheritance
to the standard World model of the MultiBody library,
which only offers the most basic options of no gravity,
constant gravity and point mass gravity (see [7, 10]).
Then, the standard Body model must be enhanced by:
1. adding the COEs a, e, i, , , M or the EOEs a,
P1 , P2 , Q1 , Q2 , l as new model variables;

 in case an accurate model of the gravity field is
used, it is not necessary to reformulate it in terms
of the COEs/EOEs, as the right-hand side of (37)
uses the compound function f (g(z)).

2. adding the equations relating COEs/EOEs to the
cartesian coordinates;

Remark 1 The accurate computation of long-term solutions for dynamical problems associated with pure
orbital motion has been a subject of extensive research

3. switching the stateSelect attribute for the r and v
vectors of the Body model to StateSelect.avoid,
and for the COEs/EOEs to StateSelect.prefer.

The Modelica Association

510

Modelica 2008, March 3rd  4th , 2008

High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters

The Modelica compiler tool will then perform the 5 Simulation examples
transformation from (34)-(35) to (37)-(38) automatiIn this Section, the results obtained in comparing the
cally, using symbolic manipulation algorithms.
accuracy obtained by simulating the orbit dynamics
A first implementation option is to extend the Body for two Low Earth orbiting (LEO) spacecraft and a
model by inheritance, adding the above-mentioned GEO one will be presented. As previously mentioned,
features, and thus deriving two enhanced models for the purpose of the present study we focus on the
BodyKepler and BodyEquinoctial; this approach is simulation of the unperturbed dynamics, i.e., only the
gravitational acceleration computed from a point-mass
documented in [2].
model for the Earth is considered. In this case, the
orbit is an ellipse (closed curve), having well-defined
A second option is to put the additional variables and
features. Therefore, this assumption allows us to inequations in a separate model with a multibody flange
troduce two simple criteria in order to evaluate the acinterface, and then connect it to the unmodified Body
curacy of the performed simulations, namely:
model within a wrapper model that also sets the preferred state variables. This option perfectly fits the ar The period of an unperturbed elliptical orbitqcan
chitecture of the Spacecraft Dynamics library, where
3
be computed a priori and is given by T = 2 a ,
such a structure was already used in order to include
the models of the interaction of the satellite with the
so a first measure of simulation accuracy can be
space environment: gravity gradient torque, aerodygiven by the precision with which the orbit actunamic drag, solar radiation, etc. (see [10], Fig. 3). In
ally closes during the simulation. To this purpose,
fact, the library described in [10] already contained a
the following stopping criterion has been defined
similar model to compute the orbital parmeters; that
for the simulation: the integration is stopped
model, however, contained explicit inverse conversion
when the position vector crosses a plane orthogoformulae (from cartesian coordinates to COEs), and
nal to the initial velocity and passing through the
was designed to be used with cartesian coordinates as
initial position. Then, the final time is compared
states. Since either the COEs or the EOEs can be used,
with the orbit period and the final position is comthe wrapper model must actually contain two condipared with the initial one.
tionally declared, mutually exclusive models (one for
 Furthermore, for an unperturbed orbit the angular
each choice of coordinates), which are both connected
momentum h = r  v should remain constant, so
to the standard Body model; a flag in the wrapper
a second measure of accuracy for the simulation
model decides which of the two will actually be acis given by the relative error in the value of h, i.e.,
tivated in the simulation model.
the quantity
The Modelica code defining the new models is very
kh  h(0)k
compact and easy to check, which is an important feaeh =
.
(39)
kh(0)k
ture to ensure the correctness of the resulting model.
As already noted, the accurate models of the gravity
field, previously implemented in [7, 10], can still use The considered orbits have been simulated usthe Cartesian coordinates as inputs, and are thus left ing the Dymola tool, using Cartesian and Keplerian/Equinoctial coordinates, in order to evaluate the
unchanged.
above-defined precision indicators. The DASSL inteAs to the computational efficiency, the workload at gration algorithm has been used, with the smallest fea12
each time step is increased, compared to the standard sible relative tolerance 10 . The RADAU algorithm
ECI formulation, by the conversion formulae, the Ja- has also been tried with the same relative tolerance,
cobian computation and the solution of the linear sys- yielding similar results which are not reported here for
tem (37). However, as will be demonstrated in the next the sake of conciseness.
section, this additional overhead is more than compensated by the fact that the differential equations are 5.1 A near-circular, LEO orbit
much easier to integrate in the new state variables, resulting in a faster simulation time and in a much tighter The first considered orbit is a LEO, near circular one
accuracy.
(see Figure 4), characterised by the following initial
The Modelica Association

511

Modelica 2008, March 3rd  4th , 2008

F. Casella, M. Lovera

state, in Cartesian coordinates:


6828.140  103
,
0
r(0) = 
0


0
v(0) = 5.40258602956241  103 
5.40258602956241  103

The results obtained in the comparison of Cartesian
and Keplerian coordinates are summarised in Table 1.
As can be seen from the Table, the precision achieved
in the actual closure of the orbit improves significantly
when using Keplerian coordinates as states: the simulated period is very close to the actual one and both
the period error and the position error are significantly Figure 5: Relative errors on the orbit angular momensmaller.
tum - near circular orbit: Cartesian (top) and Keplerian
(bottom) coordinates.

(see Figure 6, where it is also compared with the circular orbit considered in the previous case) and by the
following initial state, in Cartesian coordinates:


6828.140  103
,
0
r(0) = 
0


0
v(0) = 5.40258602956241  103 
7.29349113990925  103

Figure 4: The considered LEO, near circular orbit.
Similarly, in Figure 5 the time histories of the relative
error on the value of the orbital angular momentum
are illustrated, for a simulation of about one day: the
results are clearly very satisfactory in both cases, however while in the case of Cartesian states the relative
error is significantly larger than machine precision and
is slowly increasing, in the case of Keplerian states the
relative error is much smaller and appears to be more
stable as a function of time (see also the mean value of
the relative angular momentum error, given in Table
1). Finally, note that the use of Keplerian parameters
also gives significant benefits in terms of simulation
efficiency, as can be seen from the last column of Table 1.

5.2

A highly elliptical, LEO orbit

As in the previous case, Table 2 shows the precision
achieved in the actual closure of the orbit: as can be
seen, the errors on the simulated period are of the same
order of magnitude for both choices of state variables.
The position errors, on the other hand are significantly
smaller when simulating the orbital motion using Keplerian rather than Cartesian states.
Similarly, in Figure 7 the time histories of the relative
error on the value of the orbital angular momentum are
illustrated, for a simulation of about one day. In this
case, the results show that using Cartesian states the
relative error is again significantly larger than machine
precision and is slowly increasing, while using Keplerian states the relative error is of the order of machine
precision.

The second considered orbit is again a LEO one, but Finally, the gain in terms of simulation efficiency can
it is characterised by a high value of the eccentricity be verified from the last column of Table 2.
The Modelica Association

512

Modelica 2008, March 3rd  4th , 2008

High-Accuracy Orbital Dynamics Simulation through Keplerian and Equinoctial Parameters

Table 1: Orbit closure errors, relative angular momentum error and number of steps using Cartesian and Keplerian coordinates - near circular orbit.
States
Cartesian
Keplerian

T [s]
1.00332  106
2.38369  108

krk [m]
1.69711  103
2.17863  105

Mean eh
1.5373  109
4.7528  1013

Number of steps
959
376

Table 2: Orbit closure errors, relative angular momentum error and number of steps using Cartesian and Keplerian coordinates - highly elliptical orbit.
States
Cartesian
Keplerian

T [s]
1.17226  105
1.48665  105

krk [m]
4.39241  103
2.67799  107

Mean eh
1.2927  1010
2.5223  1016

Number of steps
3650
1120

Figure 6: The considered LEO, highly elliptical orbit,
compared with the circular one considered in Section
5.1.
Figure 7: Relative errors on the orbit angular momentum - highly elliptical orbit: Cartesian (top) and Keplerian (bottom) coordinates.
5.3 A GEO orbit
The last considered orbit is a GEO one, characterised
8) that in the case of Cartesian states the relative erby the following initial state, in Cartesian coordinates:
ror is slowly increasing over time, while in the case of


Equinoctial states the relative error appears to be more
7
4.21641  10
stable (see also Table 3).
,
0
r(0) = 
Finally, the advantages provided by the use of
0


Equinoctial parameters in terms of simulation effi0
ciency are confirmed by the data provided in the last
v(0) = 3074.66
column of Table 3.
0

Table 3 shows the accuracy improvement achieved
when simulating the orbital motion using Equinoctial
rather than Cartesian states. As in the previous case,
also for the simulation of GEO orbits it appears from
the inspection of the time histories of the relative error
on the orbital angular momentum (depicted in Figure
The Modelica Association

6

Concluding remarks

A method for the accurate simulation of satellite orbit dynamics on the basis of the Modelica MultiBody
library has been presented. The proposed approach is
based on the use of Keplerian and Equinoctial parame-

513

Modelica 2008, March 3rd  4th , 2008

F. Casella, M. Lovera

Table 3: Orbit closure errors, relative angular momentum error and number of steps using Cartesian and
Equinoctial coordinates - GEO orbit.
States
Cartesian
Equinoctial

T [s]
2.79186  105
2.92057  108

krk [m]
1.88208  102
8.91065  105

Mean eh
1.0323  1010
6.8574  1016

Number of steps
793
20

proach. In Proceedings of the 6th EUROSIM
Congress, Lubiana, Slovenia, 2007.
[3] V. Chobotov. Orbital Mechanics. AIAA Education Series, Second edition, 1996.
[4] V.V. Emelyanenko. A method of symplectic integrations with adaptive time-steps for individual
Hamiltonians in the planetary N-body problem.
Celestial Mechanics and Dynamical Astronomy,
98(3):191202, 2007.
[5] D. Losa. High vs low thrust station keeping maneuver planning for geostationary satellites. PhD thesis, Ecole Nationale Superieure des
Mines de Paris, 2007.
Figure 8: Relative errors on the orbit angular momentum - GEO orbit: Cartesian (top) and Equinoctial (bottom) coordinates.

[6] M. Lovera. Object-oriented modelling of spacecraft attitude and orbit dynamics. In 54th International Astronautical Congress, Bremen, Germany, 2003.

ters instead of Cartesian coordinates as state variables
in the spacecraft model. This is achieved by adding to
the standard Body model the equations for the transformation from Keplerian and Equinoctial parameters
to Cartesian coordinates and exploiting automatic differentiation. The resulting model ensures a significant
improvement in numerical accuracy and a reduction in
the overall simulation time, while keeping the same
interface and multibody structure of the standard component. Simulation results with a point-mass gravity
field show the good performance of the proposed approach. The validation with higher order gravity field
models is currently being performed.

[7] M. Lovera. Control-oriented modelling and simulation of spacecraft attitude and orbit dynamics. Journal of Mathematical and Computer
Modelling of Dynamical Systems, Special issue
on Modular Physical Modelling, 12(1):7388,
2006.
[8] O. Montenbruck and E. Gill. Satellite orbits:
models, methods, applications. Springer, 2000.
[9] M. Otter, H. Elmqvist, and S. E. Mattsson. The
new Modelica multibody library. In Proceedings
of the 3nd International Modelica Conference,
Linkping, Sweden, 2003.
[10] T. Pulecchi, F. Casella, and M. Lovera. A Modelica library for Space Flight Dynamics. In Proceedings of the 5th International Modelica Conference, Vienna, Austria, 2006.

References

[1] R.A. Broucke and P.J. Cefola. On the equinoctial
orbit elements. Celestial Mechanics and Dynam- [11] M. Sidi. Spacecraft dynamics and control. Cambridge University Press, 1997.
ical Astronomy, 5(3):303310, 1972.
[2] F. Casella and M. Lovera. High accuracy simulation of orbit dynamics: an object-oriented apThe Modelica Association

[12] J. Wertz. Spacecraft attitude determination and
control. D. Reidel Publishing Company, 1978.

514

Modelica 2008, March 3rd  4th , 2008

Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics

Rotational3D 
Efficient modelling of 3D effects in rotational mechanics
Johan Andreasson
Magnus Gfvert
Modelon AB
Ideon Science Park
SE223 70 Lund, Sweden
E-mail: {johan.andreasson,magnus.gafvert}@modelon.se

Abstract
In this work, it is described how effects of rotational
mechanics represented in three dimensions can be described in an efficient way. The ideas have been implemented in the Rotational3D library which is introduced in this paper. Special attention is payed to the
influence of joints and how 1D rotational and multibody representations can be combined. Comparison
of accuracy and efficiency with MultiBody is shown
as well as typical application examples.
Keywords: Rotational mechanics, Rotational3D,
Multi-Body, Driveline, Shaft

1

Introduction

component. Gyroscopic effect may be included by using the Rotor1D component instead of the normal rotational inertia. These composite Rotational and MultiBody models in the Modelica Standard Library were
introduced in [5]. They were designed for modeling
of automatic transmissions, and are useful in contexts
where the complete rotational mechanism is mounted
on one multi-body part. In more general cases they
have the limitations of not describing all interaction
effects. Other drawbacks are the lack of information
on mechanism geometry and the very rudimentary visualization.
Using MSL, a full model that includes all interaction
effects requires that also the spin motion is described
with MultiBody models. This results in overly complex and inefficient models where the 1-dimensional
rotation is hidden in transformation matrices. The rotation angle is difficult and computationally expensive
to extract. It is also only available in the range [, ]
and it is therefore tricky to track revolutions. Components such as shafts introduces a lot of constraint equations when defined with standard multi-body joints.
The Rotational3D library was designed to combine
the advantages of the Rotational and MultiBody approaches. In particular, this means:

There is large class of rotational mechanical systems
where 1-dimensional revolution, or spin, is the dominating motion. Examples of such systems are automotive drivelines, transmissions, and steering mechanisms [1, 2]. These rotational systems are often part of
general 3-dimensional multi-body systems with which
they interact. This may be reaction forces and torques
from brakes or motors, or gyroscopic moments resulting from motion orthogonal to the spin direction.
It can also be kinematic effects on the spin motion
 Efficient description of the spin motion
from universal joints with bending angle coupled to
3-dimensional motion of multi-body parts.
 Reaction torques and forces
Systems of this class may in parts be described with
 Geometry and kinematic effects
the Modelica Standard Library (MSL) [3] by using
the the 1-dimensional formalism of the Rotational li Visualization
brary, or by the full multi-body formalism of the
MultiBody library [4]. The 1-dimensional approach
 Interfacing to both MultiBody and Rotational
gives a low-complexity representation that allows for
fairly straightforward modeling of components such As a result, Rotational3D is very suitable for e.g. autoas clutches and gears. Simple reaction torques can be motive applications and it is an established part of the
applied to multi-body parts by using the Mounting1D VehicleDynamics Library [6].
The Modelica Association

515

Modelica 2008, March 3rd  4th , 2008

J. Andreasson, M. Gafvert

2 Modelling principles
The main idea is to describe the spin motion similarly
as in the Rotational library, and provide references that
are coupled to MultiBody frames.
Figure 1: Animation view of an axle in a bearing with
a connector reference shown. Axis-of-rotation (n), refTo represent the reference and the shaft motion, the erence rotation (q), actual rotation (red arrow) and the
following information must be communicated in a angle .
connector.

2.1 Connector definition

1. The rotation angle around the axis of rotation

and the torque at the frame,  f rame is defined by

2. The torque around the axis of rotation
3. The forces and torques acting on the reference
frame
4. A reference frame with position and orientation
5. The direction of the axis of rotation, n
6. The axis that defines zero rotation, q
Items 1 and 2 can be described by a Rotational flange
and items 3 and 4 by a MultiBody frame. In addition, the reference axes n and q are required. The n
and q axes were explicitly defined in the connector in
early versions of Rotational3D. Now they are instead
implicitly defined as the x and y axes of the reference
frame, resulting in the following connector definition1 :
connector Flange
MB.Interfaces.Frame frame
"Reference frame";
Rt.Interfaces.Flange flange
"Rotation around frame x-axis relative y-axis";
end Flange;

In Figure 1, the representation of the connector is seen.

2.2

Coupling 1D and 3D effects

Consider the fundamentals of an inertia, the angular
acceleration of the inertia is a sum of the contributions
of the flange and the frame so that the resulting torque
at the flange,  f lange is defined2 as

 f lange = J  f lange + n   f rame
(1)

1 A similar connector definition is also used in [7] and has been
introduced in the Modelica Standard Library as "FlangeWithBearing". The scope of this is different as it essentially is intended as a
Rotational connector with an optional "bearingFrame" that allow
for reaction torques to be applied.
2 This can also be found in [5].

The Modelica Association


 f rame + n f lange = J n f lange +  f rame  n f lange .
(2)
Here  f lange ,  f rame , n, and J refer to the angular velocity of flange and frame, spin axis, and inertia, respectively. As a result, the torque at the flange, depends on the motion of the frame and vice versa.
Another example of how information from both connectors are required to formulate a model is a tyre
model. Typically, the longitudinal force generated by
the tyre is dependent on the wheels spin velocity. Unlike for example a wheel speed sensor that measures
the speed relative to the hub, the total rotational velocity around the spin axis, tot , is required.
tot =  f lange + n   f rame

2.3

(3)

Avoiding over- and under-determined
systems

Consider Figure 2: With two mounted bearings (1),
each bearing is mounted to a MultiBody frame and
by supplying parameters for n and q, the rotation axis
and reference is defined in the Rotational3D connector. This model is over-determined since two connectors, both specifying the reference is connected.
Correspondingly, if none of the connectors in a set
would have the reference specified, the model would
be under-determined (2).
This is avoided by a connection rule using two connectors with different colours, the grey is unconstrained
and the white is constrained: Each connection set must
have one and only one white connector and there must
never be a loop containing only white connectors.
This rule is somewhat simplified, consider for example the under-determined example from Figure 2 (3).
Here, both ends of the shaft are attached to white
connectors and there is no loop consisting on only
white connectors. Still, the model is over-constrained

516

Modelica 2008, March 3rd  4th , 2008

Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics

1

2

3

Figure 2: Example of under- and over-determined systems: Loop consisting on only white connectors (1).
The right-hand flange of the shaft is un-connected and under-determined (2). A model that is over-constrained
through the Rotational part (3).

since the Rotational part is forming a loop. This of
course could be handled by the rule above. It would
require that there were four Rotational3D connectors
to cover the combinations of constrained and unconstrained connectors.
Still, however, this would not be sufficient for the
general case since there are cases where some of
the MultiBody variables are constrained and some
not, which ultimately would lead to an unreasonable
amount of connectors.

3

1

2

3

4

5

6

7

8

9

Library contents

Unlike for many other libraries, Rotational3D components are not intended to be used entirely on its own,
but together with Rotational and MultiBody components. Only parts that cannot be modelled in Rotational are implemented. This includes shafts, inertias,
visualizers, and other models where either the geometry or inertial effects are considered. In addition, there
are models that allow both Rotational and MultiBody
models to be used with the library, especially mounts
and housings.
Figure 3 shows some highlighted components: The
MultiBodyMount (1) translates a Rotational3D connector to a rotating MultiBody frame and the RotationalMount (2) allow Rotational models with action
and reaction torques to be connected. The SupportedRotationalMount (3) is a version of (2) including a
bearing and thus has an additional MultiBody connector to define the orientation of the flange. The Flange
visualization (4) visualizes the vectors n and q as well
as the rotation angle  as seen in Figure 1 which is useful both for debugging and comprehension. The Shaft
component (5) defines the motion between two flanges
without reference. It imposes no constraints between
The Modelica Association

Figure 3: A selection of components from Rotational3D.

the flanges since it is assumed to be flexible also in the
length direction. The twist characteristics is defined by
connecting components to the Rotational connectors
and additionally, inertial effects can be added via the
MultiBody connectors. The rotation angle is defined
based on the choice of joint type made, either universal and constant velocity. The Inertia (6) corresponds
to the Rotor component but additionally contains geometric information as well as mass properties and the
corresponding visualization.
As an extension to the basic mounts (1-3), there
are also housings suitable for components such as
gear boxes. The SupportedHousing (7) allow for
ideal gears to be directly connected to the Rotational
flanges. The SupportedHousing2 (8) is an adaption to
handle gearboxes from e.g. the PowerTrain library [8]
requiring a MultiBody support frame for internal in-

517

Modelica 2008, March 3rd  4th , 2008

J. Andreasson, M. Gafvert

ertias and animation. There are also sensors, such as
the AbsoluteRotationalVelocity (9), described in Section 2.2.
SupportedBevelGear

6

4 Examples
As explained earlier, Rotational3D is intended to be
used together with both Rotational and MultiBody
components. This section explains and exemplifies
when Rotational3D is suitable and how component
and subsystem models can be designed.

5

5
3

2

2

4

4

4.1 Bevel gear
The first example shows two bevel gear components.
Consider first the upper diagram layer in Figure 4,
showing a bevel gear with an external support frame
(1). To this frame, two SupportedRotationalMount
components (2) are connected, each containing a bearing that specifies the orientations of the two axles.
These mounts are connected to a Rotational.GearR2R
component (3) that contains the 1D gear characteristics. Each mount is also connected to a connector (4)
and visualization for gear wheel and axle (5). Both
connectors are white since their orientation is fully
specified and as seen in the animation view (6), there
are two bearings except for the axles and gear wheels.

1

BevelGear

Figure 4: Diagram layer and visualization of two bevel
Now consider the lower diagram, showing the same gear models.
bevel gear but without the support frame. Instead,
the left connector is grey, indicating that this component has to be connected to an outside bearing. The
left mount is here a RotationalMount, and as a consequence, no bearing is present in the visualization.

4.2 Steering system



Steering systems for passenger cars are typically designed as illustrated in Figure 5. The steering wheel
is attached to the steering column (1) which in turn is
connected to a shaft that is connected to the pinion of
4
1
the rack-and-pinion mechanism (3). Each connection
requires a joint (4) with two degrees of freedom to al2
low the shaft to rotate around its length axis. The uni4
versal joint is the most common type, consisting of two
3
revolute joints in series forming a cross. Unlike more
advanced joints, the universal joint has a varying ratio
over a revolution, depending on the bend angle (). Figure 5: Typical steering system layout (right) and
This require careful design of the geometric layout universal joint geometry (left).
as well as the rotation of the cross and depending on
these two factors, the resulting gear ratio of the mechanism will vary. Figure 6 shows the difference in rack
The Modelica Association

518

Modelica 2008, March 3rd  4th , 2008

Rotational3D - Efficient Modelling of 3D Effects in Rotational Mechanics

0.8

Difference: universal  constant velocity

Table 1: Translation and simulation results from Dymola [9].
MB
Rt3D
linear systems {10, 3, 3, 2} {3, 3}
non-linear systems
{10}
{1}
simulation time
1.91
0.047

[mm]

0.4

0

- 0.4

4.4

Comparison with MultiBody

Two implementations of a drive shaft are compared. A
-200
0
200
400
drive shaft is typically used to transfer axial rotational
steering wheel angle [deg]
motion between two moving bodies. Using MultiBody
primitives to define a non-elastic shaft with universal
Figure 6: Difference in rack position as function of joints yields the series R-U-P-U-R. R denotes a revosteering wheel angle.
lute joint, here representing the bearings, P is a prismatic and U is a universal (two orthogonal revolute
joints).
Figure 9, shows an animation screen shot of the per1
formed simulation where both the MultiBody (MB)
2
and the Rotational3D (Rt3D) representations are included on top of each other. The trajectory of the first
universal joint is shown as well as vectors for the re5
sulting forces and torques. The first shaft end is driven
4
with a constant speed relative to its bearing while the
required drive torque as well as the speed at the other
shaft end is shown, Figure 9.
Table 1 shows the number of linear and non-linear sys3
tems of equations and the simulation time for the two
cases described above. By avoiding the constraints
imposed by the MultiBody primitives, the number of
Figure 7: Transmission model for the VehicleDynam- non-linear equations are drastically decreased which
makes the Rotational3D implementation about a factor
ics library using PowerTrain library components.
40 faster and less sensitive to the specified accuracy of
the integrator.
- 0.8
-400

position for the steering system in Figure 5, compared
to the same system but with constant velocity joints.

4.3

Automatic Transmission

5

Limitations

Although the library concept is proven to be efficient,
it requires that some fundamental rules are followed.
As already stated, there is a connection rule to avoid
over- and under-constrained models. Additional, relating to the problems with the representation of multiple
revolution in MultiBody, it is required that the relative
rotation between two reference frames is less than one
revolution.

Another advantage of Rotational3D is its compatibility with other Modelica libraries. Figure 7 shows
an example of a seamless integration of two libraries
for an automatic transmission. It is defined from a
standard interface in the VehicleDynamics library and
completed with shift mechanism (1), shift controller
(2) and a housing (3). The torque converter (4) and the 6 Conclusions
gear box (5) are from the PowerTrain library [8]. Note
that the PowerTrain components use a MultiBody sup- This work presents a new library that combines the advantage with Rotational and MultiBody representation
port frame as discussed in Section 3.
The Modelica Association

519

Modelica 2008, March 3rd  4th , 2008

J. Andreasson, M. Gafvert

of rotational mechanics. It gives the same simulation
results as MultiBody representations, often at a fraction of the cost. An example shows a factor of around
40. More complex mechanisms such as drivelines are
often difficult/impossible to get to work in MultiBody.
These are built seamlessly in Rotational3D.

References

Figure 8: Animation view of the comparison and validation example with motion, forces and torques indicated. The MultiBody and the Rotational3D models
are overlayed.
shaft velocity MB

[rad/s]

10

Shaft velocity Rt3D

[4] Otter, M. et al. The New Modelica MultiBody Library. In: Proceedings of the 3rd Modelica Conference 2003, Linkping, Sweden, Modelica Association, October 2003.

-5
0
1E-4

5
Difference in shaft velocity MB-Rt3D

10

[rad/s]

5E-5

[5] Schweiger, C., Otter, M., Modelling 3D
Mechancisl Effects of 1D Powertrains. In: Proceedings of the 3rd Modelica Conference 2003,
Linkping, Sweden, Modelica Association, October 2003.

0E0
-5E-5
0

5

shaft torque MB

100

10

[6] Modelon AB, Lund, Sweden. The VehicleDynamics library, Users Guide, Version 1.2, 2007.

Shaft torque Rt3D

50
[Nm]

[2] Andreasson, J., On Generic Vehicle Motion
Modelling and Control, Ph.D. thesis, ISBN 917178-527-2, 2006.
[3] Modelica Association. The Modelica Standard
Library, http://www.modelica.org

5
0

[7] Dempsey M. et al. Coordinated automotive libraries for vehicle system modelling. In: Proceedings of the 5th Modelica Conference 2006,
Vienna, Austria, Modelica Association, September 2006.

0
-50

-100
0
0.010

5
Difference in shaft torque MB-Rt3D

10

[8] Schweiger, C. et al. The PowerTrain Library:
New Concepts and New Fields of Application.
In: Proceedings of the 4th Modelica Conference
2005, Hamburg, Germany, Modelica Association, March 2005.

0.005
[Nm]

[1] Andreasson, J., Gvert, M., The VehicleDynamics Library - Overview and Applications.
In: Proceedings of the 5th Modelica Conference, Vienna, Austria, Modelica Association, 4-5
September 2006.

0.000
-0.005

[9] Dymola - Dynamic Modelica Laboratory,
http://www.dynasim.se

-0.010
0

5

10

Figure 9: Comparison of the MultiBody and the Rotational3D implementations. Speed at the second shaft
end (upper two plots) and required drive torque at first
shaft end (lower two plots).
The Modelica Association

520

Modelica 2008, March 3rd  4th , 2008

Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer Bushings

Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig
for Elastomer Bushings
Susann Wolf
Joachim Haase
Christoph Clau
Fraunhofer-Institute for Integrated Circuits, Design Automation Division (IIS/EAS)
Zeunerstrae 38, 01069 Dresden, Germany
{Susann.Wolf, Joachim.Haase, Christoph.Clauss}@eas.iis.fraunhofer.de
Michael Jckel
Jrgen Lsch
Fraunhofer-Institute for Structural Durability and System Reliability (LBF)
Bartningstrae 47, 64289 Darmstadt, Germany
{Michael.Joeckel, Juergen.Loesch}@lbf.fraunhofer.de

Abstract
This paper presents methods of sensitivity calculation applied to a multi-axial test rig for elastomer
bushings. In this context, the effect of parameter
variations on system variables is analysed by using
different tools. Aspects like modelling, modelling
effort, computing time and accuracy are discussed.
This paper is based on results, which were developed
in the Fraunhofer collaborative project Computer
Aided Robust Design (CAROD).
Keywords: parameter sensitivity; Monte-Carlo simulation; elastomer test rig; DAE; Dymola; DASPK;
MATLAB

1

Introduction

Tolerances of material quality, manufacturing processes and assembly operations lead to scattering
product properties. In mass production therefore
more or less significant deviations of the desired
ideal properties occur. Resulting from wear and
degradation, also during product life cycle continuous changes of component and system characteristics
take place.
The named uncertainties are only covered insufficiently in traditional development workflows of
mechatronical products. In most cases, simulations
without any parameter scatter are performed to optimise mechanical and mechatronical systems and to
analyse their durability and reliability.
The objective of Robust Design is to analyse the effects of scattering component behaviour in early de-

The Modelica Association

velopment phases and to optimize products. This
presentation will focus on sensitivity analysis, which
typically is an initial task in robust design studies.
The prior objective is to determine parameters,
which highly affect the product behaviour.
The paper starts with a short description of the chosen technical example: A 3 DOF test rig for elastomer bushings. Subsequently, two multi-bodysimulation models of the test rig using MATLAB
and Modelica are presented, including a crosscomparison of the particular simulation results. In
the following, the method of sensitivity calculation
is introduced, which has conceivable potentials to
lower the effort for sensitivity analyses. To validate
the results, the implementation of a Monte-Carlo
(MC) analysis is treated, which is based on repeated
calls of the Dymola simulator. The results of this MC
analysis are again compared with an MC analysis
performed with MATLAB. Finally, based on the
analysis results, the application and performance of
the methods for sensitivity evaluation are discussed.

2
2.1

Technical Example: Test Rig for
Elastomer Bushings
Application and Technical Description

The methods described in this paper are presented by
example of a multi-axial test rig (figures 1 and 2),
which is owned by Fraunhofer LBF. The test rig is
mainly used for sign-off tests of automotive elastomer bushings considering service loads. Further
on, the bushings dynamic transmission behaviour
can be characterised.

521

Modelica 2008, March 3rd  4th , 2008

S. Wolf, J. Haase, C. Clau, M. Jockel, J. Losch

-

-

Fig. 1: Multi-axial test rig for characterisation and testing of elastomer
bushings at Fraunhofer LBF and CAD model of a typical elastomer
bushing (right)

Using servo-hydraulic actuation, variable cyclic
loading of more than 100 Hz is feasible. Based on a
transmission design with pre-stressed cardan joints,
the load directions axial (x), lateral (y) and torsion () at the bolt can be realised isolated or in
combination, respectively. To minimise wear and
friction, hydrostatic linear guides between bolt and
bail as well as bail and base plate are used. The
movement of the bolt  and therefore the displacement of the elastomer bushing  is measured by sensors, which are positioned near the bushings clamping device. The reaction forces are measured by a
piezoelectric measurement platform.

Fig.2: CAD model of the test rig, declaration of bodies and degrees of
freedom (absolute)

2.2

Multi-Body-Simulation Model of the Test
Rig and Simulation Tools

To analyse the dynamic behaviour of test rig mechanics, multi-body-simulations (MBS) are used (cp.
[1]). In this context, the models typically include
rigid bodies, which are linked by joints and force
elements.
Corresponding, the MBS model of the elastomer test
rig includes the rigid bodies bolt, bail, piston
and shaft, while following joints and force elements are applied between the bodies (cp. figures 2
and 3):

The Modelica Association

Bolt-bail: cylindrical joint x/, damping x/
(hydrostatic bearings)
Bail-base plate: prismatic joint y, damping y
(hydrostatic bearing and friction of hydraulic
cylinder)
Bolt-base plate: 6 DOF, stiffness x//y and
damping x//y (elastomer bushing)
Bolt-shaft: cardan joint, no force element
Shaft-piston: cardan joint, no force element
Piston-base plate: cylindrical joint x/,
damping x/ (friction of hydraulic cylinder)

The transmission characteristic of the elastomer
bushing is modelled by using the approaches
FE,x=cEx3x+cEx1x+dEx1dx/dt,
FE,y=cEy3y+cEy1y+dEy1dy/dt and
ME,=cE3+cE1+dE1d/dt,
which describe nonlinear stiffness and linear damping behaviour for each load component. The parameter settings are based on measurement data derived
by tests with a commercial elastomer bushing.
Comparable to the physical test rig, the MBS model
is actuated by axial forces Fx, torsion M (piston) and
lateral forces Fy (bail).

Fig.3: Multi-body simulation model of the test rig (top view)

The MBS model was set up in MATLAB/SimMechanics as well as in Modelica (using a
Dymola solver).
2.3

Comparison of Modelica and MATLAB
Model

To compare the MBS models built in the MATLAB
and Modelica environment, two test cases were defined. The first test case is characterised by sinusoidal forces and moments:

522

Modelica 2008, March 3rd  4th , 2008

Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer Bushings

-

Fx=3.0106sin(314t) [N]
Fy=3.4108sin(t) [N]

MATLAB
Modelica
x [mm]

-

4

M=10 sin(150t) [Nm]

0.05
0.025
0
-0.025 0.3

0.31

0.32

0.33

0.34

0.3

0.31

0.32

0.33

0.34

0.3

0.31

0.32

0.33

-0.05

0.12

[

 [rad]

Forces Fx ,F y [N] and moment Ma [Nm]

]

0.1
1
0.5
0
-0.5

0.34

time [s]

-1

Fig. 7: Comparison of results from Modelica and MATLAB model
(case 1)

Time t [s]

2.4

Fig. 4: Applied noise signals in test case 2

Figures 5 and 6 show the calculated displacements x
and y [mm] as well as the torsion  [rad] of the body
bolt for the two test cases.
y



Displacements x, y [mm] and torsion  [rad]

x

Treated Scenario

The investigations target a virtual scenario, which
describes the production of a small series of (only)
theoretically identical test rigs. Due to manufacturing
tolerances the test rig components will differ more or
less, leading to scatter of the test rigs behaviour.
To examine the scenario, prior parameters of the
MBS model have to be defined, which are affected
by assumable manufacturing tolerances. In this context, 13 parameters have been identified:
- Masses of all rigid bodies
- Inertias   of bodies piston, shaft and
bolt
Inertia   of body shaft
Damping coefficients concerning hydrostatic
linear guides bail-base plate (y) and bailbolt (x,)
- Damping coefficients concerning friction of
hydraulic cylinders (piston: x/, bail: y)
In the following, the sensitivity of the test rig dynamics on variations of these parameters is examined by
sensitivity calculation and MC analyses.
-

Time t [s]

Fig. 5: Test case 1 - Solution (Dymola)
Displacements x, y [mm] and torsion a [rad]

0.14

[

y [mm]

]

In contrast, the second test case includes the application of noise signals (figure 4). These signals were
generated with a MATLAB script, which contains
the rand command.

Time t [s]

Fig. 6: Test case 2  Solution (Dymola)

To compare the MBS models created in Modelica
and MATLAB, the displacements x and y as well as
the torsion  of the body bolt were analysed in the
time domain. Figure 7 shows the calculated displacements and torsion for test case 1, exemplarily. It
is obvious, that both models lead to nearly identical
results. This conclusion is affirmed by the results
concerning case 2.
The Modelica Association

3

Sensitivity Calculation

3.1

Method of Sensitivity Calculation

The main idea is to pre-evaluate the sensitivity of the
test rig performance due to variations of single parameters. Beside information concerning the performance scatter to be expected, promising adjusting screws for system optimisation can be derived.

523

Modelica 2008, March 3rd  4th , 2008

S. Wolf, J. Haase, C. Clau, M. Jockel, J. Losch

The performance and dynamics of the test rig are
analysed using multi-body-simulation. To perform
sensitivity calculation, the analytical equations of
motion have been set up explicitly using the Lagrange approach. Thus, the system equations are
available in symbolic form. The DAE/ODE system
of the elastomer test rig is described by 3 equations
of motion (1) to (3) with 3 state variables x(t), y(t)
and (t) as well as 23 system parameters (13 parameters to be varied, 10 fixed parameters). The system is excitated by sinusoidal forces and moments
(compare (1) to (3), case 1) as well as noise signals
(case 2).
3

2

of the interesting influence. Sensitivities are functions of time t. Also these functions can be used as a
basis for the determination of derived functions.
By differentiation of the system (4) according to all
pi the following system can be set up for the computation of first-order parameter sensitivities:

F x F x
F
+
=x pi x pi
pi

(i=1,...,m)

(5)

(4) together with (5) can currently be solved by Dymola, if (5) is added explicitly. The code DASPK [2]
can directly solve the DAE (4) and (5), where (5) is
generated within the code automatically.

2

3.0e6 Sin(314 t) = cEx1 lW + 4 cEx3 lW + cEx1 X(t) + 6 cEx3 lW X(t) + 3 cEx3 lW X(t) +

2

3 cEx3 lW X(t)
2

lW -Y(t)

2

2

2

3 cEx3 X(t) Y(t)
2

lW -Y(t)

2

cEx1 Y(t)

+

2

lW -Y(t)

2

2

2

-Y(t) 2 )

3

2

+

4

lW -Y(t)

lW (2 mD+mW) Y (t)

( lW

2

2

cEx3 Y(t)

-

2

2

2

2

2

lW -Y(t)

5 cEx3 lW Y(t)
2

lW -Y(t)

2

2

+

2

-

4 cEx3 lW

4

2

2

lW -Y(t)

6 cEx3 lW X(t) Y(t)
2

lW -Y(t)

2

3

-

2

lW -Y(t)

2

2

-

(1)
3.2

2

+

(dDx+dEx1) Y(t) Y (t)

+ (dDx+dEx1+dKx) X (t) +

lW -Y(t)

+ (mD+mK+mW) X (t) +

6 cEx3 lW X(t)

2

+

(2 mD+mW) Y(t) Y (t)
2

2

lW -Y(t)

2

3.4e8 Sin(t) = cEy1 Y(t) + ... +

mW
jWz

 mB+mD+ 4 + lW 2 -Y(t) 2 +






jWx lW 2 Tan(AL(t)) 2
2  4 mD+mW
Y
(t)

2
 4 lW 2 - 4 Y(t) 2 +


-lW 2

2

+Y(t) 2 
( lW -Y(t)2 )  Cos(AL
2


)
(t)





jWx lW 2 Tan(AL(t)) Y(t) Y (t)

2

1.0e4 Sin(150 t) = (cEa1+cEa3 AL(t) ) AL(t) + ... +





  Y(t)








-lW 2
Cos(AL(t)) 2 
+Y(t) 2 
2
 Cos(AL(t))


2

(2)

(3)

The performance and dynamics of the test rig are
evaluated by analysing the resulting displacements x
and y as well as the resulting torsion  of the body
bolt, which directly loads the elastomer bushing.
Sensitivity calculation examines the effects of minor
parameter deviations from their nominal values for
the behaviour of the dynamic systems.
In this case systems are regarded, which are described by differential-algebraic equations (DAEs) of
the form

 p, t) = 0
F(x, x,

Results of Sensitivity Calculations

Dymola and DASPK were used to calculate both
solution and sensitivities of the elastomer test rig.
For the equations of motion the results for x, y and 
were calculated. The solutions from Dymola and
DASPK are in accordance. In the following, the influence of parameters on the axial displacement x
and the torsion  of the bolt are illustrated.
The first-order sensitivities for case 1 are computed
using DASPK (figures 8 to 15). The solutions are
shown in 8 and 10 (see also figure 5 using Dymola).
The figure 9 shows first-order parameter sensitivities
of x regarding parameters of mass. The timeline corresponds to figure 8. Figure 11 where the timeline
corresponds to figure 10 shows the first-order parameter sensitivities regarding parameters of inertia.
12,0

mK

X
Y
AL

0,8

mW

0,3

-0,2

0,0

0,2

0,4

0,6

0,8

1,0

-0,7

Sensitivities of x regarding
parameters of mass mK , mW, mD

cEx3 X(t) - 3 cEx3 lW Y(t) - 3 cEx3 X(t) Y(t) -

2

-1,2

mD
6,0

0,0
0,0

0,1

0,2

0,3

0,4

0,5

0,6

0,7

0,8

0,9

1,0

-6,0

-12,0

Time t [s]

Time t [s]

Fig.8: Detail of solution (DASPK)

Fig.9: Detail of first-order parameter sensitivities of x (DASPK)

(4)

0,08

, the equations of motion of the system, whereas
x(t)  \ n are state variables and p  \ m summarises parameters of all types, which mean diverse
determining factors on developing of the variables.
The factor of interest is the influence, which changes
of parameters cause of developing of the variables,

1,2

0,8

0,4

0
0

0,005

0,01

0,015

0,02

0,025

0,03

0,035

0,04

0,045

-0,4

X
Y
AL

-0,8

0,05

Sensitivities of x regarding parameters of
inertia jKx , jWx , jWz , jDx

cEx1 lW

2

Displacements x , y [mm] and torsion  [rad]

2

Displacements x , y [mm] and torsion  [rad]

3

0,06
0,04
0,02
0,00
0

0,005

0,01

0,015

0,02

0,025

0,03

0,035

0,04

0,045

0,05

-0,02
-0,04
-0,06
-0,08
-0,10

jKx
jWx
jWz
jDx

-0,12

-1,2

Time t [s]

Time t [s]

Fig.10: Detail of solution (DASPK) Fig.11: Detail of first-order
parameter sensitivities of x (DASPK)

x(t )
the so-called sensitivities of parameter
(the
pi
By classifying the amplitudes of the time-depending
sensitivity of variable x concerning parameter pi ). sensitivity functions (e.g. figures, 9, 11, 12, 13, 14,
These sensitivities are computed for the evaluation

The Modelica Association

17 and 18) it can be evaluated, which parameters
have a large, a marginal or no influence on the solu-

524

Modelica 2008, March 3rd  4th , 2008

Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer Bushings

0,3

time the range of tolerance band is increasing. That
is why parameter changing causes not only different
amplitudes but also variations in the time behaviour.
0,08
0,06

Displacement x [mm]

tion of the system. Parameters with a significant influence to solution x are the parameters of mass mK,
mW, mD and the parameters of inertia jKx, jWz and
jDx, see as an example figure 12 and 13. Concerning
sensitivities of y, also parameters of inertia and mass
have an influence. Parameters with a significant influence to solution  are the inertias jKx, jWz and
jDx.
mK
mW
mD

0,2

mB
jKx

Sensitivities of x

jWx

0,1

jWz

0,04
0,02
0
0

0,005

0,01

0,015

0,02

0,025

0,03

0,035

0,04

dDx
dDa

0

0,005

0,01

0,015

0,02

0,025

0,03

0,035

0,04

0,045

0,05

-0,08

dKx

0,05

X(t)
X(t) / + 0,5 %
X(t) / - 0,5 %
X(t) / + 1 %
X(t) / - 1 %

-0,04
-0,06

jDx

0,0

0,045

-0,02

Time t [s]

dKa
dBy

-0,1

Fig.15: Detail of range of tolerance of solution x regarding variation of
all parameters (DASPK)

lW
cEx1
cEx3

-0,2

cEy1
cEy3
cEa1

-0,3

cEa3
dEx1
dEy1

-0,4

dEa1

Time t [s]

Fig.12: Detail of first-order parameter sensitivities of x regarding all
parameters (DASPK)
300

200

mK

Sensitivities of x

mW
mD

100

mB
jKx
jWx

0

In case 2 (figures 17 and 18), sensitivity calculations
are carried out by means of Dymola. The resulting
first-order parameter sensitivities are approximations
by method of difference quotient. This method is
explained by a scheme which is illustrated in figure
16. The original model was parallel instantiated with
different parameter values, which are necessary for
difference quotient calculation.

jWz

0,0

0,1

0,2

0,3

0,4

0,5

0,6

0,7

0,8

0,9

1,0

jDx
dDx

p nom

dDa

-100

dKx

x nom (t)

dKa
dBy

-200

p1 var
-300

Time t [s]

8

mK / X

6

mK / AL

x1 var(t )  x nom(t )
p1 var(t )  p nom(t )



x
p1

Fig.16: Method of difference quotient using Dymola

Figure 17 shows that all considered parameters have
nearly no influence on the solution x of the system,
whereas parameters of mass mK, mW and mD are
dominating parameters.

4
2
0
0,00
-2

0,02

0,04

0,06

0,08

0,10

0,12

0,14

0,16

0,18

Sensitivities of x

Sensitivity of x and  regarding mK

10

..
.

..
.

Fig.13: Detail of first-order parameter sensitivities of x regarding 13
specified parameters) (DASPK)

Again figure 14 illustrates the described results exemplarily of parameter of mass mK regarding x and
.

x1 var (t)

0,20

-4
-6
-8
-10

Time t [s]

Time t [s]

Fig.14: Comparison of influence of parameter of mass mK on x and 

Fig.17: First-order parameter sensitivities of x for 13 specified parameters (difference quotient)

Solutions of the original system using different parameter values confirm the sensitivity calculations.
Figure 15 illustrates the range of tolerance of solution x regarding variation of all parameters ( 0,5%
and  1%). The graphic shows that by increasing

The Modelica Association

Parameter with a significant influence on solution 
are parameter of inertia jKx, jWx and jDx, see figure
18. Regarding case 2, first-order parameter sensitivities will also be carried out by means of DASPK.

525

Modelica 2008, March 3rd  4th , 2008

S. Wolf, J. Haase, C. Clau, M. Jockel, J. Losch

Sensitivities of a

Sensitivity calculation described in section 3 yielded
an evaluation of system parameters. Then MC analyses for located dominating parameters were determined.
The results of MC analyses for case 1 are illustrated
by figures 19 to 23.
Time t [s]

4

Time t [s]

Fig.19: Tolerance band of x, y and  regarding parameters of mass

Displacements x, y [mm] and torsion a [rad]

The results show, that sensitivity calculation leads to
comparable results for test case 1 and test case 2.
Related to these sensitivity computations it can be
summarised that additionally to the determination of
the solution of a concrete DAE system also sensitivity computations are possible. As noted above, the
results from Dymola and DASPK are in accordance.
Concerning the results of sensitivity calculations, the
evaluation of influence of the parameters on the targeted result values is feasible.

Displacements x, y [mm] and torsion a [rad]

Fig.18: First-order parameter sensitivities of  for 13 specified parameters (difference quotient)

Monte-Carlo Analysis

To evaluate the results of sensitivity calculation MC
analyses [3] were performed by usage of both Modelica and MATLAB models.

Modelica Model

Within the Dymola simulator MC simulation is offered as a tool-specific feature. In this paper, another
possibility was used which will also be presented as
a poster on the Modelica2008 conference.
In the Modelica model the parameters which are to
be varied randomly get their values via a function
call. This function, which can be coded as a Modelica function or a C-Function, is parametrised by the
user with parameters of the desired random distribution. Repeated Dymola calls (via the scripting language) cause the randomly choice of the value of the
chosen parameter. The results of each simulator run
have to be collected.
In this case, a uniform distribution with the nominal
value 6.0 and the tolerance 10% was used as an
example, which is specified in the model in this way:

Time t [s]

Fig.20: Detail of tolerance band of x, y and  regarding parameters of
mass

Figure 21 shows that parameters of mass have only a
marginal influence on solution . These result verified the small tolerance band of  regarding parameters of mass.
0,15

0,10

Sensitivities of 

4.1

0,05

0,00
0

0,02

0,04

0,06

0,08

0,1

0,12

0,14

0,16

0,18

0,2

-0,05

-0,10

-0,15

mK
mW
mD
mB

-0,20

model elast
// parameter of the system
parameter Real mK = uniform(6,0.10)
"mass of piston";
...

The Modelica Association

Time t [s]

Fig.21: Sensitivity of  regarding parameters of mass (DASPK)

526

Modelica 2008, March 3rd  4th , 2008

Displacements x, y [mm] and torsion a [rad]

Displacements x, y [mm] and torsion a [rad]

Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer Bushings

Time t [s]

Time t [s]

Fig.22: Tolerance band of x, y and  regarding parameters of inertia
Displacements x, y [mm] and torsion a [rad]

Fig.26: Detail of tolerance band of x, y and  regarding parameters of
inertia

MC analyses verified the results of sensitivity calculation, see section 3.
4.2

Time t [s]

Fig.23: Detail of tolerance band of x, y and  regarding parameters of
inertia

Displacements x, y [mm] and torsion a [rad]

The results for case 2 are shown by figures 24 to 26.

Time t [s]

Displacements x, y [mm] and torsion a [rad]

Fig.24: Tolerance band of x, y and  regarding parameters of mass

MATLAB Model

The sensitivity analysis of the MATLAB model was
performed with the Fraunhofer LBF inhouse software MASIMO. The software creates sample sets of
user-defined parameters based on Latin-HypercubeSampling methods and automatically performs the
needed simulations in MATLAB. MASIMO was,
among other things, applied during the EC funded
project MODBOGIE [4] to perform sensitivity
analysis of a complex locomotive model.
The MC analyses each contained 100 simulations for
test case 1 and test case 2. All 13 parameters (cp. ch.
2.2) were set to vary in a range of 10% of their
nominal value, while an equal distribution of parameter values was defined, respectively.
To analyse the resulting time series of the simulations, scalar evaluation quantities xm, ym and m were
defined, taking the arithmetic mean value of the
amount of displacements and torsions x(t), y(t) and
(t). Following, the parameter xm is examined, exemplarily.
Figure 27 shows an qualitative Anthill plot of xm as a
function of the piston mass for test case 1. Each
point represents the (converted) result of one single
simulation of the MC analysis. The diagram shows
the trend, that an increasing piston mass leads to decreasing values of xm. In general, Anthill plots can be
used to get a first impression of sensitivities and
trends.

Time t [s]

Fig.25: Tolerance band of x, y and  regarding parameters of inertia

The Modelica Association

527

Modelica 2008, March 3rd  4th , 2008

Scalar evaluation parameter xm

S. Wolf, J. Haase, C. Clau, M. Jockel, J. Losch

T re
nd

Piston mass

Figure 27: Anthill-plot of xm as a function of piston mass

0.1

-0.3
-0.4

Bolt mass

-0.2

Shaft mass

0
-0.1

Piston mass

Correlation coefficient [-]

To derive further information, correlation coefficients between the result values xm, ym and m and
the varied input parameters can be applied. Figure 28
exemplary shows the correlation between xm and the
input parameters. In this context, negative correlation
coefficients point out, that an increasing parameter
value leads to decreasing result quantities. It is obvious, that the masses of piston, shaft and bolt affect xm
dominantly.

-0.5
-0.6

1

Parameter No.

13

Figure 28: Correlation of xm with the varied parameters (113), case 1

Similar investigations were performed for the result
values xm and m. The analysis of m showed prior
sensitivities on the inertias of piston, shaft and bolt,
while ym is dominantly affected by the masses of all 4
bodies.
The analysis of test case 2 led to comparable results.
Again, the body masses of piston, shaft and bolt affect xm, while the torsion m is dominantly influenced by the inertias of these bodies. ym again is
dominantly affected by the masses of all 4 bodies.

5

Conclusions

In this paper, the application of sensitivity calculation was presented by example of a multi-body simulation model of an elastomer test rig. The results
show, that sensitivity calculation has the potential to
pre-evaluate prior parameters of a model, which exThe Modelica Association

emplarily can be deeper analysed by a following MC
analyses. An indispensable precondition for applying
sensitivity calculation is the provision of the equations of motion in a symbolic representation.
Especially for complex models with a high number
of DOF or long periods to be computed, the preselection of parameters can lead to a significant reduction
of computational effort. Even in case of the test rig
example, which only comprises 4 DOF and rather
small time series to be computed (< 2 seconds), each
simulation of the MC analysis took approximately 2
minutes (Pentium 4, 3 GHz). Resulting, a complete
analysis with 100 simulations and 13 parameters
took more than 3 hours.
A sensitivity calculation using DASPK respectively
13 parameters (until tend 1 s) took approximately 10
minutes. Using Dymola a sensitivity calculation (as
shown in figure 16) took maximal approximately 40
minutes and a MC analysis with 50 simulations and
4 varied parameters maximal approximately 12 minutes. Resulting, a complete MC analysis using Dymola with 100 simulations and 13 parameters (2 seconds) would take approximately 2.5 hours. These
computation times point out, that sensitivity calculation is able to reduce effort considerably.
Within the Dymola simulator, MC simulation is offered as a tool-specific feature. In this paper a more
common possibility was presented, which describes
the MC method on the Modelica language totally.
Both methods are very time consuming. Using Dymola the effects of parameter tolerances can be calculated by MC simulation (with a high computational effort), using the sensitivity system (5), which
has to be added manually or using the finite difference approximation (see figure 16).
Using the code DASPK, system (5) is generated
within the code automatically. It would be desirable,
if this possibility (and also regarding a similar system for second-order parameter sensitivity) would be
existant also in Dymola. So far, an operator of sensitivities like the existing operator der (), the derivation with respect to time, is absent.
Note, that the solver DASPK allows the computation
of first-order parameter sensitivities. The interpretation of these results leads to a classification of the
importance of the system parameters regarding the
effect to the variables.

6

Outlook

The next steps will cover following topics:

528

Modelica 2008, March 3rd  4th , 2008

Methods of Sensitivity Calculation Applied to a Multi-Axial Test Rig for Elastomer Bushings

Parameter Sensitivities of Second-Order using
DASPK

References

In this section a short description is given to determine second-order parameter sensitivities by means
of DASPK. By means of differentiation of the system (5) according to all pi second-order parameter
sensitivities are computed. As mentioned before, the
code DASPK can solve the DAE (4) and (5). By differentiation of the system (4) according to all pi and
using of this system as a new system (4) in the
source code, the second-order parameter sensitivities
are generated automatically.
Another way to determine the second-order parameter sensitivities is the modification of source code of
DASPK. Therefore, an aim is to extend the source
code of DASPK to generate the system of secondorder parameter sensitivities automatically by differentiation of system (5). Then DASPK could solve
(4), (5) and also the system of second-order, where
(5) and the system of second-order could be generated within the code automatically.

[1] Jckel, M.; Wallmichrath, M.; Bruder, M.;
Lsch, J.; Landersheim, V.: Virtual Test Lab 
Simulation Based Testing of Components and
Systems. Proceedings of NAFEMS-Seminar
2006 Virtual Testing  Simulation Methods
as Integrated part of an Efficient Product Development, ISBN 1-874376-14-x, 2006
[2] Petzold, L.; Cao, Y.; Li, S.; Serban, R.: Sensitivity analysis of differential-algebraic equations and partial differential equations. Computers and Chemical Engineering 30, 2006, pp.
1553-1559.
[3] Robert, C. P.; Casella, G.: Monte Carlo Statistical Methods, Springer, 2004 (2nd ed.)
[4] Jckel, M.; Bruder, T.; Lsch, J.; Kieninger,
M.; Schmidt, H.: European research projects of
LBF: HEMBOT / MODBOGIE. Proceedings
of 4th Fraunhofer LBF Meeting on Structural
Durability in Railway Engineering, May 16
and 17 2006, Fraunhofer LBF Darmstadt, 2006

Introduction of scalar evaluation quantities
In continuative work, analyses concerning scalar
evaluation quantities, which are derived from the
results in the time domain, are planned. Examples for
these scalar evaluation result quantities are the first
eigenfrequency or the mean value of the amplitude
spectrum in a defined frequency range. The first eigenfrequency can be computed in MATLAB directly
from the condition matrix of the elastomer test rig
model. Using Dymola, the condition matrix can be
generated and denoted by linearisation of the original
model. Within Modelica there are also matrix functions, which are useful for this context. The first eigenfrequency can be derived from simulations in the
time domain and a following Fourier transformation.
For each DOF x, y and , then a scalar quantity can
be calculated.
Regarding sensitivity calculation, problems can occur in this context, because scalar evaluation quantities are not directly available in the DAE system. If
the evaluation quantity can be calculated during the
simulation, sensitivities are automatically present.
Otherwise, derived evaluation variables have to be
calculated by post-processing. This challenge will be
discussed in further publications.

The Modelica Association

529

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

530

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Library for Simulation of High-Lift Drive Systems

Implementation of a Modelica Library
for Simulation of High-Lift Drive Systems
Dipl.-Ing. Malte Pfennig Prof. Dr.-Ing. Frank Thielecke
Hamburg University of Technology, Institute of Aircraft Systems Engineering
Nesspriel 5, 21129 Hamburg

Abstract
The development and design of new high-lift drive
systems is a complex and iterative process, which is
often depending on experience. Especially results determined in the predevelopment phase and based on
uncertain assumptions have decisive influence on the
system specification and thus on the system design.
In order to reduce development time and optimize the
development process, a rapid generation and adaptation of simulation models for analysis of transient system behaviour is essential. This article presents an
computer-integrated approach for further reduction of
the high-lift development process. An interface to
Modelia should enable an automated system model
generation. A suitable component library is introduced
and verified by simulation of the Airbus A380 flap actuation system.
The purpose of this article is to present the project of
a computer-aided development process as well as an
adequate component library for assembling simulation
models of high-lift drive systems.
Keywords: high-lift system; power drive system; system development

1 Introduction
In order to reduce take-off and landing airspeed, modern transport aircraft are equipped with high-lift systems. The extension of slats and flaps at the wings
leading and trailing edges augments the effective wing
area and also allows for higher angles of attack thus increasing the lift coefficient. Figure 1 depicts the highlift surfaces, as well as the corresponding drive and
actuation system.
A central power drive unit (PDU), mounted in the center fuselage, provides energy for driving a shaft transmission, which ensures mechanical synchronisation of
the left and right actuation systems. The shaft transmission is routed across the wingspan by numerous
The Modelica Association

bearings, while universal joints and gearboxes compensate changes in direction. Branch gears transmit
the mechanical energy to rotary or ballscrew actuators
which are coupled with the flap traverse mechanism.
High actuator gear ratios reduce fast turning transmission inputs to slow panel movement.
As part of the secondary flight control, the high-lift
drive system has to be fault-tolerant and fulfill high requirements regarding the reliability. While the power
drive unit and the slat flap control computer are of redundant design, the shaft transmission system offers a
single load path only. Sufficient mechanical strength
of all elements in the actuation system is required for
all possible system states. Peak loads occurring as a
result of a system failure are often a design case for the
mechanical components of the drive system. Thus, the
analysis of transient system behaviour is of uttermost
importance for the determination of strength requirements for the drive trains mechanical elements. As
aerospace applications require certified components,
no standard but custom-build components and assemblies have to be installed. In consequence, component
parameters characterising their dynamical behaviour,
e.g. the mass moment of inertia or the friction characteristics, are unknown in the early design phase. Thus,
these parameters have to be estimated based on the
knowledge of existing similar products.
Owing to numerous changes of the system architecture, requirements, constraints or parameters, the effort for installing and maintaining a complete simulation model in the early design and specification
phase is not justified. For this reason, simplified models are used for a rough evaluation of peak loads,
while adequate safety margins compensate uncertainties. However, increasing mechanical strength normally involves an increasing mass. Thus, considerable
potentials in system weight reduction might be wasted.
In this report an integrated approach is presented that
aims at an optimisation of the high-lift drive system,
as well as its development process. Moreover, an au-

531

Modelica 2008, March 3rd  4th , 2008

M. Pfennig, F. Thielecke

Figure 1: High-lift segments and power drive train at leading and trailing edge
tomated generation and easier maintenance of a complex simulation model for analysis of transient system
behaviour should be realised in order to make simulation results available in the predevelopment phase. A
software tool combining knowledge based methods for
high-lift design and steady state calculations is to be
extended to transfer available system information into
a simulation model for analysis of transient behaviour.
Modelicas characteristic of being object-oriented and
providing a simple way to generate simulation models by combining library components makes it predestined for this task. In order to facilitate modelling a
complex high-lift drive train, a library containing all
required components has been created.

2 System description and modelling
The basic elements of a high-lift drive system, namely
the power drive unit, the actuators and the shaft transmission connecting actuators and drive unit, were introduced in chapter 1. Besides gearboxes, shafts, joints
and bearings that are essential for the shaft routing,
there are further components required to react to mechanical failures. A shaft rupture leading to a separation of flap segments might result either in an asymmetric flap setting or even the complete transmission
system might be decoupled from the PDU so that the
aircraft looses its high-lift function in a critical situaThe Modelica Association

tion. Furthermore, jamming in the flap tracks might
cause an asymmetric flap setting as well as an overload in actuation system and wing structure. In order
to avoid an unacceptable flap asymmetry that cannot
be compensated by the rudders, safety brakes are installed at the spanwise ends of the shaft transmission.
These wing tip brakes (WTB) are activated if the monitoring systems identifies a failure by comparing the
position at the transmission ends, the drive units output angle and the commanded position.
Moreover, the installation of torque limiting devices
reduces loads in the drive system and structure in case
of jamming in one of the drive stations. High loads
and load gradients result from rapid deceleration of the
system by either jamming or brake activation.
The analysis of such transient behaviour requires a
nonlinear model. Figure 2 exemplifies a flap drive
system architecture and its elements. For the purpose
of an acceptable simulation time, modelling each mechanical element separately is not practicable. Thus,
adjacent parts are merged into a lumped model. The
total inertia and torsional stiffness can easily be calculated from the elements connected in series. Other
variables like friction coefficients or backlash can be
determined accordingly.
While the system model in contrast to the real drive
system posesses concentrated parameters, an appropriate discretisation must not change the dynamic behaviour of the system. Different approaches have

532

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Library for Simulation of High-Lift Drive Systems

Figure 2: Schematic representation of a flap drive system and its model according to [4]
proven their value. In [2], Neumann proposes to substitute all transmission elements between the downdrives by at least two systems made up of spring,
damper and mass. Adapting the distribution of the torsional stiffnesses, the relevant natural modes can be
preserved.
A closer look at the distribution of drive system element masses and torsional stiffnesses reveals that installed gearboxes make up a major share of the total
mass moment of inertia, while the torsional stiffness is
mainly influenced by long shaft elements. Another approach, reducing the model order by summing up the
mass moments of inertia around those areas that already show an accumulated inertia, like gearboxes, is
presented in [4]. On the other hand, a single torsional
spring represents the torsional stiffness of the elements
between those inertias.
Both methods show a good correlation between simulation and measured data.

3 Development of high-lift actuation
systems
The design and construction process of a new highlift actuation system starts early in the overall development process of a new aircraft. Thus, only few and
uncertain information is available at the beginning. Especially in the concept and preliminary design phase,
the requirements, system constraints and component
data often change. The data becomes more reliable
and more detailed while the development process proceeds. However, mandatory inputs for the design process of the high-lift drive systems that have to be availThe Modelica Association

able from the start are:
 the number and type of actuators. The application
of either a geared rotary actuator or a ballscrew
actuator depends on the planned flap kinematics.
 effective airloads at the actuators.
 wing geometry and available installation space in
the wing area.
 maximum travel of the actuators and required
time for their adjustment.
The development and design of the mechanical transmission system, the hydraulic and/or electric power
drive unit and the monitoring and failure detection system is complex and highly interdependent. The focus
in this article is on the actuation system.
With the listed inputs, a first drive system architecture
can be designed schematically. To guarantee a uniform motion of the actuators, gear ratios have to be
determined accordingly. Mechanical properties of the
components have to be estimated at first. Experience
from the development of former drive systems is of
tremendous value for this parameter estimation.
If gear ratios, characteristic friction coefficients and
the architecture are known, steady state calculations,
e.g. for determination of the drive torque required by
the PDU and torque limiter settings, are possible.
For a rough evaluation of maximum loads resulting
from transient changes in consequence of wing tip
brake activation or torque limiter lock out, simple
models seem practicable. As proposed in [4], the part
of the transmission that is in focus of the analysis can

533

Modelica 2008, March 3rd  4th , 2008

M. Pfennig, F. Thielecke

Figure 3: Concept for an computer-aided development process of high-lift drive systems
be transformed to a torsional oscillator with a single
inertia J  . For dynamic similarity, the torsional stiffness c of the vibrator is adjusted, such that the first
eigen mode of the complete transmission system and
the reduced model are identical. Presuming a sudden
deadlock in the transmission and neglecting nonlinear
influences, the kinetic energy Ekin of the transmission
converts to potential energy E pot in the spring, allowing the calculation of the peak load:
Ekin = E pot


1 
1 2
1  2
J  =
 c   2 =  s
2
2
2 c



 s,max = max  c  J .

(1)

Thus, the possibility to do rough system evaluations
and trade-offs is provided. For example, the system
dependency on the chosen gear ratio could be analysed.
Regarding equation (1), another problem seems obvious. The maximum transmission speed, especially
after a mechanical disconnect, depends on nonlinear
friction characteristics. While the effort of generating
a complex simulation model and the time for running
these simulations is not justified as long as most parameters are uncertain and many changes are necessary, the need for more detailed system analysis when
The Modelica Association

the system specification reaches a mature level and reliable data are available is obvious.
In order to reduce development time, the Institute of
Aircraft-Systems Technology at Hamburg University
of Technology is working on a tool called WissBaSys
to support the design process. Particularly, the efforts
in early design and specification phases, that are in
focus, could be reduced by numerous computer-aided
features, which are introduced hereafter.
While the architecture of high-lift transmission systems may change, they generally consist of a relatively small number of different mechanical components. Thus, a library of generic, parameterised components has been created. A graphical user interface
(GUI) offers the possibility to connect these generic
elements to a complete transmission system. The resulting system layout can easily be changed by adding
or removing components.
In order to support the difficult task of parameter estimation when reliable data are not available, not only
default values are provided, but also functions describing an interdependence between variables are supported. Furthermore, the user has access to an external
database containing extensive information about many
existing aircraft components.
Another characteristic of the preliminary design phase
is the handling of uncertain knowledge and checking

534

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Library for Simulation of High-Lift Drive Systems

the system requirements after every change. For this
reason, continuous domains are attached to all variables. This is the basis for an interval constraint satisfaction problem (ICSP). Constraint propagation as it
is presented in [5] enables the evaluation of nondirectional equations and inequalities containing variables
with interval domains.
Establishing an ICSP brings further useful advantages.
Enabling nondirectional evaluation, trade-off studies
are encouraged. Furthermore, violations of system requirements or constraints are detected automatically
within the constraint propagation process.
The concept of a computer-aided development process is illustrated in figure 3. The system architecture is assembled utilising generic library components.
System and component parameters are estimated with
help of data base information, default values and empirical estimation functions. An automated generation
of simplified models enables approximation of maximum load result from transient behaviour. The system
analysis is completed by steady state calculations. The
ICSP automatically checks all system requirements so
that the basis for a system synthesis is available. While
synthesis methods allow for an evaluation and optimisation of slat and flap traverse mechanisms [1] an allincluding high-lift optimisation on aircraft level is not
available up to now.
Containing all relevant component data, the transfer
to a complex nonlinear simulation model would complete the development process. The way Modelica
uses for modelling by combining generic library components offers ideal possibilities for an interaction in
this context.
WissBaSys supports design studies in early development phases and generates lumped models of reduced
order. An appropriate Modelica model has to be
named for general concentrated transmission sections.
Presuming the allocation of available and model parameters is existent, model instances corresponding to
the concentrated parameters can be generated. With
the knowledge that some parts execute special function, e.g. the wing tip brake, additional models have
to be inserted. If an allocation of simulation models
for the mechanical elements in the transmission system is existent, the generation of the complete simulation model can be realised.

4 HighLift library for drive systems

control and fault detection system. Here, the actuation system and the power drive unit are considered in
more detail. For a determination of maximum transmission loads, the mechanical components of the drive
train can be modelled as one-dimensional rotational elements. These are characterised by their mass moment
of inertia, a torsional stiffness, structural damping, mechanical backlash, gear ratio and the friction characteristic. While the models Inertia, ElastoBacklash and
IdealGear of Modelicas standard library cover most
of these attributes a new friction model is needed and
introduced in this chapter.
Besides models representing a nonlinear torsional oscillator, some components fulfill additional tasks that
have to be taken into account. These components are
the safety brakes and mechanical torque limiters. The
HighLift library contains models for a shaft brake, an
ideal torque limiter, the general mechanical rotational
part and a geared rotary actuator. Moreover, hydraulic
components necessary for modelling hydraulic power
drive units are available.
The focus is on the mechanical drive train and its relevant models are discussed in the following. All models
are designed such that they need only the information
that is relevant for a specification.

This model represents the brake function of the wing
tip brake, which is mounted in the wing structure.
If the brake is activated, the compression of friction
packages causes a friction torque that stops the transmission. Essential parameters describing the brake behaviour are the maximum dynamic brake torque, maximum static brake torque and the time for reaching the
maximum dynamic torque. Thus these are the only input variables of the model which extends the interfaces
Rigid and FrictionBase.
In order to allow different approaches for describing
the transient change of the friction torque when the
brake is activated, the models input u is the normalized maximum dynamic brake torque tauB_max. After reaching a halt, the static friction torque might
increase up to the brakes maximum limit load
tauB_lim. In contrast to the models available in
the standard library, friction coefficients are no longer
needed here.

The high-lift drive system consists of the mechanical
actuation system, hydraulic drive units, as well as a
The Modelica Association

535

Modelica 2008, March 3rd  4th , 2008

M. Pfennig, F. Thielecke

figure 5 shows, an ideal mechanical torque limiter is
modelled.

A coupling consisting of balls embedded along the circumferece of two flanges guarantees a positive connection in normal operation mode. In case a torque
limit is passed, the balls start to move along a ramp
thus pushing one of the flanges against a friction device. The increasing relative angle between the flanges
results in an increasing brake torque.
The torque limiting function has two characteristics.
First of all, a brake torque depending on the relative
angle of the flanges is induced. Moreover, the torsional
stiffness changes within the lock out process. While
the balls are in motion, the stiffness decreases significantly compared to the normal operation mode. When
the balls reach their end stop, the device is grounded
and the torsional stiffness changes again.

Figure 5: Ideal torque limiter model

As shown in its symbol the general rotational mechanical element consists of an ElastoBacklash model
and a modified Inertia as well as of an IdealGear.
The LossyInerta model takes friction losses into account. Most elements of the transmission system like
bearings show friction behaviour corresponding to the
Stribeck Friction Law:

 f ric,S = Coulomb + dvis   + Stribeck  e fexp | |
Figure 4: Nonlinear torsional stiffness characteristic of
a mechanical torque limiter

(3)

However, the detailed analysis of single state gearboxes shows additional friction losses that highly depend on the transmitted loads [6]. This phenomenon
is valid only when the unit is in motion and the breakout has occurred. Based on the results of sophisticated
analyse of gearbox friction behaviour, a combined approach appears feasible. As discussed in [3] bearing
losses and load dependent gear stage losses differ. For
representation of a total drag torque, the friction torque
is made up of the bearing friction according to the
Stribeck law which is depending on ambient conditions and gearbox losses characterised by a gearbox
efficiency GE :

For modelling these characteristics, a torsional spring
with nonlinear stiffness, according to figure 4, is
needed. Furthermore, the dynamic brake torque increases after lock out and reaches its maximum when
the balls reach their end stop.
A new spring model has been created. Required inputs are the lock out torque 1 and the end stop torque
2 as well as the different torsional stiffnesses for all
three states. Compared to the standard spring, this
model has an additional output y describing a normal(4)
 f ric =  f ric,S + (1  GE )  load .
ized brake torque:

While GE varies between 0 and 1, it represents the
0
: rel < 1


1
: |rel |  2
y=
(2) dependence on the transmitted torque and is easily de
termined by measurement.
 |rel |  1 :   | | < 
1
2
rel
 
2

1

Combining the nonlinear spring with a shaft brake as

The Modelica Association

536

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Library for Simulation of High-Lift Drive Systems

phenomenon can be represented by the gearbox efficiency GE as a function of the input angle in . If the
unit stops, GE increases linearly to 1 after a speed
threshold is crossed. Consequently, load-dependent
friction diminishes according to equation (4). When
the unit starts to move again, GE is a function of in ,
while its final value depends on the sign of the transmitted power. Figure 7 shows this characteristic.

Most Airbus aircraft use planetary gears with high gear
reduction for flap and slat actuation. Their dynamic
behaviour has essential effects on the complete highlift actuation system. Exact modelling of these components is of vital importance for the reliability of simulation results. Analysis of the friction behaviour of
these actuator types also shows remarkable influence
of the transmitted loads on the friction torque [2].
Furthermore, the load-dependent friction changes with
the energy flow direction. Generally, driving against
opposing load has better efficiency than in the case of
aiding loads. The load-dependent friction does not occur stepwise as soon as the unit begins to move, but
increases smoothly after a change in direction.
Figure 7: Gearbox efficiency for deceleration (a) and
acceleration (b)

Further Models
The models presented in detail here are of vital importance for modelling a complete high-lift actuation system. Furthermore, the HighLift library contains models for inducing mechanical failures in the drive train.
For this purpose, an element that can be used for a mechanical disconnection and another model that causes
jamming at a specified time are included. Besides the
transmission system, the power drive unit is of major
interest. Hydraulic component models for turbulent
resistances, servo valves, a differential cylinder as well
as an example that uses these components for modelling a PDUs drive train with a variable displacement
hydraulic motor (VDHM) are included.
Figure 6: Normalised input torque of a geared rotary
actuator with constant load
For validation a geared rotary actuator has been tested
and its friction behaviour determined [2]. Simulation
results using the model described above show good resemblance to test data as presented in figure 6. For
validation of the actuation system measured data of
the actuator loads as well as the power drive units
speed is an inputs to the model. The contact of the gear
wheel teeth is the reason for the load-dependent friction torque [3]. When a turnaround occurs, the wheels
do not turn simultaneous but consecutively. Thus, the
contact between the gear wheels establishes smoothly.
Since the geared rotary actuator is modelled as a single
stage gearbox in order to reduce the model order, this
The Modelica Association

5 Transient simulation of Airbus
A380 flap actuation system
For a verification of the presented models the Airbus A380 flap actuation system is taken into account.
The number of actuators and mechanical elements in
total outnumbers that of all other flap actuation systems of Airbus aircraft. The actuation system utilises
geared rotary actuators, a wing tip brake and a system torque limiter that is installed between the power
drive unit and the first downdrive. A test rig replicating the A380 high-lift drive system of one wing only,
has been installed at the Airbus facilities in Bremen
in order to run certification tests. Utilising the models

537

Modelica 2008, March 3rd  4th , 2008

M. Pfennig, F. Thielecke

Figure 8: Airbus A380 flap actuation system and model
of the HighLift library the actuation system is modelled and verified by means of measured data. Figure
8 presents a schematic view of the transmission system and a lumped model of reduced order in Modelica.
Furthermore, sensor positions are marked in figure 8.
For modelling the approach presented in [4] and discussed in 2 is used.
For validation test data of the actuator loads and the
PDU speed are used as input. The drive systems starts
to operate against increasing opposing actuator loads.
After an acceleration phase the system speed is almost
constant until a position threshold is reached and the
speed is reduced before the system stopps at its determined position.
Figure 9 shows that the speed within the shaft trans-

Figure 9: Transmission speed
The Modelica Association

mission system varies only slightly. Comparing simulation and test data for the input torque at the system
torque limiter (STL) that depends on the exact modelling of the complete actuation system, the data show
good conformability. While the simulated break out
occurs 0.5 seconds earlier than in the test the simulation results are very accurate afterwards. Figure 10
compares simulation and test results for the specified
sensor positions.
Now the introduced model is used to analyse a failure
case scenario. At t1 the disconnector model is used to
simulate a shaft rupture between system torque limiter
and first downdrive while the transmission system

Figure 10: Simulated and measured actuation system
input torque
538

Modelica 2008, March 3rd  4th , 2008

Implementation of a Modelica Library for Simulation of High-Lift Drive Systems

Figure 11: Transmission speed and torque at the wing tip brake after shaft rupture and brake activation
drives against opposing loads. After the mechanical
disconnection the complete system is accelerated by
the applied actuator loads. The failure is detected and
the wing tip brakes are applied at t2 and cause a system
stop. In consequence of the rapid deceleration,
load peaks occur within the shaft transmission. The
maximum is to be found at the safety brake.
Figure 11 compares test rig data and simulation results for transmission speed and torque at the wing tip
brake. Although simulated and measured speed have
different gradients during the acceleration phase, their
oscillatory behaviour is similar and their value at t2 is
almost identical. The simulated deceleration phase is
shorter as it was in the test. Nonetheless, the maximum
transmission loads differ only slightly.

tool WissBaSys and the Modelica environment has
been established by the implementation of the presented HighLift library, its execution is still outstanding. Furthermore a simulation of the complete system
including the power drive unit as well as the slat flap
control computer is necessary.

Acknowledgment
The authors thank the Airbus Deutschland GmbH for
sponsoring and supporting this project.

References

6 Conclusion and future work
This article presents the development and design of
high-lift actuation systems and its implied challenges.
For further reduction of development time for new
high-lift systems a computer-aided approached is aspired. In order to enable an automated generation of
nonlinear models for simulation of the complete drive
train, a library containing all essential elements of the
described drive system is introduced. With the help of
the modelled components the Airbus A380 flap actuation system has been modelled. Simulating a normal
extension cycle, the simulation model provides results
that are close to measured data. The verified model is
used for analysis of maximum loads when the safety
brakes are applied after a shaft rupture.
While the basis for an interface between the design
The Modelica Association

539

[1] Holert, B.: Eine Methode zum mehrkriteriellen Entwurf der Fhrungsmechanismen
in Hochauftriebssystemen von Transportflugzeugen. Hamburg: Dissertation, Institut
fr Flugzeug-Systemtechnik, TU HamburgHarburg, 2005.
[2] Neumann, U.; Holert, B.; Carl, U.B.: Fr eine
sichere Landung - Simulation von Landeklappenantriebssystemen. Antriebstechnik, 4/2004.
[3] Pelchen, C.;Schweiter, C.; Otter, M.: Modeling
and Simulating the Efficiency of Gearboxed and
of Planetary Gearboxes. 2nd International Modelica Conference, Oberpfaffenhofen 2002.
[4] Rechter, H.; Richter, M.: Die Simulation
als Hilfsmittel bei der Entwicklung und Integration der A330/340-Hochauftriebssysteme.
DGLR-Jahrestagung, Band 1, Gttingen 1993.
Modelica 2008, March 3rd  4th , 2008

M. Pfennig, F. Thielecke

[5] Runte, W.: YACS: Ein hybrides Framework
fr Constraint-Solver zur Untersttzung wissensbasierter Konfigurierung. Diplomarbeit, Fachbereich Mathematik / Informatik, Universitt
Bremen, 2006.
[6] Ruprecht, T.; Thielecke, F; Recksiek, M: SIVA
- A testrig for the validation of high lift component models. AST Workshop on Aircraft System
Technologies, Hamburg 2007.

The Modelica Association

540

Modelica 2008, March 3rd  4th , 2008

Session 5
Poster Session

The Modelica Association

541

Modelica 2008, March 3-4, 2008

The Modelica Association

542

Modelica 2008, March 3rd  4th , 2008

4-Dimensional Table Interpolation with Modelica

4-DIMENSIONAL TABLE INTERPOLATION WITH MODELICA
Tobias Hirsch
Markus Eck
German Aerospace Center (DLR)
Pfaffenwaldring 38-40, 70569 Stuttgart, Germany
tobias.hirsch@dlr.de, markus.eck@dlr.de

Abstract
The steady-state model for a solar field contains a
large number of equations including conditional
statements. For a yearly energy yield analysis the
operational state (on duty, off duty) of the solar field
may change from one time instant to the other. Due
to the strongly varying boundary conditions a simulation run without convergence problems is not
likely. For this reason a lookup-table model is designed to calculate the five output variables of the
solar field depending on the four input variables. The
interpolation model is based on the existing MODELICA model for 2D-interpolation and can be used
for table interpolation tasks independent of the technical application. The structure of the model and a
method for the automatic generation of the required
interpolation data from the complex solar field
model is described.
Keywords: solar power plant; look-up table; interpolation

1

Introduction

Solar thermal power plants are one of the most interesting options for renewable electricity production.
For the calculation of the annual energy yield of
these plants steady-state models are used. The calculation method which is based on mass and energy
balances is called for every hour of the year with the
corresponding weather data input and delivers an
output of electric energy. This approach works well
as long as transient effects in the plant can be neglected. When a thermal storage has to be considered
an additional transient model has to be implemented.
Since the solar field and the power block can still be
represented as a steady-state block, the final plant
model is composed of very complex steady-state
models for the solar field and the power block and a
rather simple transient model of the storage system.
For an annual calculation on an hourly basis, the
model is called 8760 times with input data that might

The Modelica Association

be strongly varying from hour to hour. First tests
with the complex steady-state models show that robustness of the simulation is not satisfying. Due to
the large changes in input parameters and model dependencies it is very likely that an annual calculation
might terminate before reaching the end time.
The reason for the complexity of the solar field
model is the aspect that the model has to describe the
operation in full load, part load and stand-by mode.
While mass and energy balances are derived for
regular field operation this is not the case for the
stand-by mode. In order to determine the time instant
with irradiation conditions sufficient for a switch
from stand-by into part-load operation the set of balance equations has to be solved with a modified set
of input parameters even if the field is shut-down.
Implementing the equations within the MODELICA
language yields a number of conditional statements
that have to be operated by the solver. Robustness of
the resulting system is hard to check and may differ
from one field layout to the other.
A way to couple the complex steady-state field
model with the simple transient thermal storage
model is developed by replacing the equation-based
solar field model by a table-based interpolation.
When analyzing the system it is found that the solar
field output is determined by just four independent
inputs. Unfortunately, the existing interpolation
model in MODELICA is limited to two independent
variables. Within this paper, a MODELICA model is
presented that allows a three dimensional interpolation using the MODELICA 2D-interpolation model.
By an additional interpolation level the capability
can easily be extended to an interpolation in four
dimensions.

2

Solar field model characteristics

The solar field is composed of a large number of
parabolic trough collector rows arranged in parallel.
The water fed into the field at high pressure is preheated, evaporated and superheated by the solar irra-

543

Modelica 2008, March 3rd  4th , 2008

T. Hirsch, M. Eck

diation. This kind of system is called a Direct Steam
Generation parabolic trough power plant [1]. Apart
from general parameters of the field, the output of
the solar field is determined by the following input
variables:
- Direct normal irradiation, DNI
- Ambient temperature, T_amb
- Feed water specific enthalpy, h_in
- Operating pressure of the field, p_out
All of these are a function of time with the first two
taken from the weather data file and the last two being determined by the whole plant model. In addition
to the generated mass flow, four more outputs have
to be provided by the model, so the list of output
variables reads:
- Steam mass flow, m_out
- Field inlet pressure, p_in
- Field outlet temperature, T_out
- Recirculation pump power, P_rec
- Field in operation-indicator, FIO
A MODELICA solar field model is available that
describes the relation between input- and output parameters based on the physical equations. The model
allows changes in the solar field configuration in an
easy way by simply changing some parameters that
e.g. determine the number or arrangement of collector rows. It is therefore suited for the design of a solar field but is not suited for annual energy yield
analysis.

3

General approach

solar field are stored in MATLAB .mat files and can
directly be read by the MOCELICA interpolation
model. Within the following sections the automatic
generation of the interpolation data and the structure
of the interpolation model will be described.

4

Generation of interpolation data

Since a large number of solar field configurations,
each described by one set of interpolation data, is to
be analysed for the yearly output, an efficient
method is needed to generate the interpolation data.
For the interpolation routines in MODELICA one
look-up table in three dimensions (variation of input
variables p_out, h_in, DNI) has to be provided for
each of the five output variables (m_out, p_in, T_out,
P_rec, FIO).
This is realized by a MATLB script file that calls the
MODELICA executable for all combinations of input variables. By use of the DYMOLA-MATLAB
interface the output variables are then stored by the
MATLAB script in a .mat-file. For each output
variable a separate file is generated that stores the
three vectors of parameter variations
p_steps =[p_start : dp_: p_end]
h_steps =[h_start : dh_: h_end] ;
I_steps =[I_start : dI_: I_end] ;

and the three-dimensional result matrix containing
the results at the nodes defined by the vectors above.
The procedure is illustrated in figure 1.
Due to the complexity of the solar field model it is
initialized with a fixed set of parameters. The desired
operating point for each input parameter combination

The physically based solar field
Complex MODELICA model
model is replaced by a table interpolation model that calculates
compile: dymosim.exe, dsin.txt
one output variable (e.g. m_out) MATLAB script file
based on a set of interpolation
define variation in 3 parameters
data and the three input variables
(h_in, p_out, DNI). Extension to
store parameter ramps as .mat file
the forth input variable is done by
loop over all
linear interpolation in the ambivariations
call dymosim from MATLAB interface
ent temperature (T_amb). For
each of the five output variables
store relevant output data in result files
the same interpolation model can
be used with an individual set of
interpolation data. The interpola.mat files containing interpolation nodes
tion data are automatically generated by calling the physical solar
Interpolation based MODELICA model
field model from a MATLAB
script for all nodes of the interpolation data. The outputs of the Figure 1: Procedure for generation of interpolation data
The Modelica Association

544

Modelica 2008, March 3rd  4th , 2008

4-Dimensional Table Interpolation with Modelica

is then reached by a ramp in the three input variables. The final state of the ramp (values of the input
variables for the actual combination) is stored by the
MATLAB script in a .mat file before the executable
is called. The data are then read by the executable to
define ramps in the input variables that lead from the
fixed initialization state to the desired final state.
This approach has the advantage that no problems
with the initialization occur during the parameter
variations due to the stable initialization state. One
separate call of the executable for each parameter
variation is chosen, although the ramps might have
been defined to generate a number of results points
in one simulation run. The advantages for the implementation chosen are:
- only one data point is lost if the simulation
does not converge
- high flexibility in the definition of the parameter variations (e.g. no need for equidistant grids) .
The output variable FIO is very important for the
following interpretation of the interpolated data since
it determines if a data point calculated by interpolation is valid. The value is set to false if the solar field
can not be operated for the combination of input
variables or if the simulation has not converged. In
both cases, the data points obtained from the interpolation do not represent a physical state of the solar
field.
In order to allow direct access to the interpolation
data from the MODELICA 2D-interpolation model
CombiTable2D the data a stored in the following
way. For each value of input variable x3, e.g. 70 bar,
80 bar, 90 bar, 100 bar, 110 bar, a set of 2Dinterpolation data are stored in one separate matrix.
In our example, these matrices are named data1 to
data5. The matrix contains in the first row the vector
of nodes in variable x2 and in the first column the
vector of nodes in variable x1. The matrix is then
filled with the output data at the corresponding
nodes:
x2(2)

...

x2(ih)

output variable that has to be described by 3Dinterpolation a separate file is generated. This allows,
in principle, an arbitrary number of output variables.
In our example, five output variables are used with
the data stored in the files FIO.mat, m_flow.mat,
p_in.mat, P_rec.mat, T_out.mat.

5

3D interpolation model

The three-dimensional table interpolation used in the
yearly analyzer is based on the two-dimensional table interpolation model available in the MODELICA
standard library. This model is very efficient since
the search for the interpolation interval starts at the
result found in the last time instant. The two dimensional interpolation model is used to interpolate in
the variables x1 (DNI) and x2 (h_in) for a fixed value
of variable x3 (p_out). For each value of the variable
x3 defined in the vector p_steps one value ui (i=1:n)
for the output variable is calculated. The final output
value is then generated by a 1-D interpolation in the
n results ui. The procedure is illustrated in figure 2.
The model that holds the following equations is
named Kennlinie3D (german word for Characteristic3D). In the following, the code of this model is
described. The model contains three inputs
Modelica.Blocks.Interfaces.RealInput x1;
Modelica.Blocks.Interfaces.RealInput x2;
Modelica.Blocks.Interfaces.RealInput x3;

for variables x1, x2 and x3. In the solar field example
these inputs correspond to h_in, DNI, p_out. The
result is delivered via output
Modelica.Blocks.Interfaces.RealOutput y;

A data structure is defined to provide information on
the upper and lower limits of x1 and x2 as well as the
matrix name in the interpolation file that holds the
interpolation data.
encapsulated record interpolation_source
Real
x3;
Real
min_x1;
Real
max_x1;
Real
min_x2;
Real
max_x2;
String table_name;
end interpolation_source;

0

x2(1)

x1(1)

dat(1,1) dat(1,2)...

dat(1,4)

x1(2)

dat(2,1) dat(2,2)...

dat(2,4)

...

...

...

...

...

In the model n instances of this data structure are
created as parameters by:

x1(iI) ...

...

...

dat(iI,ih)

parameter interpolation_source[:]
IP_source;

All data matrices together are stored in one single .mat-file. This file holds all data necessary for the
3D-interpolation in variables x1, x2 and x3. For each
The Modelica Association

In Dymola, the data can be entered via the graphical
user interface which is shown in figure 3. In this example, 2-D-interpolation in x1 and x2 data have been
generated for five pressure levels from 70 bar up to

545

Modelica 2008, March 3rd  4th , 2008

T. Hirsch, M. Eck
x3

x1
x1

x1

x1

x1

x2

x2
x2
x3 x2
x3 x2
x3
x3

n 2D-table interpolations

The final result is calculated by weighting the n outputs of the 2D-interpolation blocks
y = sum(

IP_table[i].y*weight[i]
for i in 1:n );

x3

The weighting factors are calculated from a linear
interpolation in the variable x3. For example, a value
of x3=82e5 Pa would lead to a vector of weighting
factors weight =[0 0.8 0.2 0 0]. The Dymola routine dymTableIpo1 is used for the interpolation. This
routine has to be initialized by

y

ui

weighting of n signals

Figure 2: Structure of the 3D interpolation model

110 bar. The interpolation data are found in matrices
data1 to data5 in the interpolation data file defined
by parameter String SourceFile= "p_in".
The variable x1 (h_in) may vary between 500 kJ/kg
and 1100 kJ/kg and the variable x2 (DNI) between 0
and 1000 W/m2. The 2-dimensional interpolation is
done in n MODELICA interpolation blocks which
are instantiated by

and called with the command

Modelica.Blocks.Tables.CombiTable2D
IP_table[n](
each tableOnFile=true,
each fileName=SourceFile,
tableName={IP_source[i].table_name
for i in 1:n}
);

The inputs x1 and x2 and connected to the corresponding inputs u1 and u2 of the n interpolation
blocks, taking into account the variable range limitations defined in IP_source.
for i in 1:n loop
IP_table[i].u1=
max(IP_source[i].min_x1,
min( IP_source[i].max_x1, x1 )
);
IP_table[i].u2=
max(IP_source[i].min_x2,
min( IP_source[i].max_x2, x2 )
);
end for;

when initial() then
Weight_tableID=dymTableInit(
1.0,
smoothness,
"NoName",
"NoName",
Weight_matrix,
0.0);
end when;

for i in 1:n loop
weight[i] =
min(1.0,
max(0.0,dymTableIpo1(
Weight_tableID,
Weight_columns[i],
x3)) );
end for;

with the corresponding declarations
parameter Real[:,:]
Weight_matrix =
[IP_source.x3, diagonal(ones(n))];
parameter Integer
Weight_columns[:]=
2:size(Weight_matrix, 2);
Real
Weight_tableID;
Real[n] weight;
parameter
Modelica.Blocks.Types.Smoothness.
Temp
smoothness =
Modelica.Blocks.Types.Smoothness.
LinearSegments;

Figure 3: Screenshot of the Dymola graphical user interface for IP_source with five pressure levels

The Modelica Association

546

Modelica 2008, March 3rd  4th , 2008

4-Dimensional Table Interpolation with Modelica

6

Solar field model with 3 inputs

The solar field model SolarField_Characteristic
based on the interpolation is assembled from five
3D-interpolation blocks of type Kennlinie3D as
shown in figure 4. The three input connectors for
h_in (red lines), DNI (blue lines) and p_out (green
lines) are connected to the corresponding inputs of
the 3D-interpolation blocks. Based on the interpolation data provided in files FIO.mat, m_flow.mat,
p_in.mat, P_rec.mat, T_out.mat the outputs FIO,
m_flow, p_in, P_rec and T_out are calculated. The
values are only valid if the indicator FIO is 1. In case
this value is smaller than 1, a default value, e.g.
70 bar for p_in, is used instead of the calculated
value.

7

approach as in the 3D-interpolation model using the
Dymola function dymTableIpo1. For reusability a
model called WeightedSignals is defined. Figure 5
shows a screenshot of the final solar field model with
the three SolarField_Characteristic models each
representing one level of ambient temperature and
five WeightedSignals models that are responsible
for weighting obtained from the three interpolation
models.

Weighting blocks
0 C

20 C

Extension to four dimensions

As mentioned in the beginning of this text the solar
field output depends on one more variable namely
the ambient temperature. Since the dependence on
this variable is nearly linear three nodes in ambient
temperature (0 C, 20 C, 40 C) are sufficient for
the model. For each of the three temperature levels a
separate set of interpolation data is generated. Three
instances of the solar field model SolarField_Characteristic are created with the outputs
linearly weighted with the actual ambient temperature T_amb. The weighting is realized by the same

40 C

Figure 5: Solar field model with three instances of the
SolarField_Characteristic model representing three
levels of ambient temperatures

2D

>

FIO

0.999

DNI

Sw itch_p_in

2D

p_in

Constant_p_in
70e5

h_in

Sw itch_T_out

2D

T_out

Constant_T_...
400

Sw itch_m_flow

2D

p_out

m_flow

Constant_m_...
0

Sw itch_P_rec

2D

P_rec

Constant_P_r...
0

Figure 4: The SolarField_Characteristic model composed of five 3D-interpolation blocks of type Kennlinie3D

The Modelica Association

547

Modelica 2008, March 3rd  4th , 2008

T. Hirsch, M. Eck

8

Conclusions

Acknowledgements

A MODELICA model Kennlinie3D for table interpolation in three dimensions is developed. The
model is based on the MODELICA 2D-interpolation
model CombiTable2D which gives access to an efficient interpolation routine provided by Dymola. Interpolation to four dimensions is possible with an
additional interpolation level supported by the developed model WeightedSignals. In order to allow a
large number of parameter studies a method is developed that automatically generates the required
interpolation data from a complex solar field model.
Due to the universal design of the models they can
also be used apart from the solar field application.

The authors would like to thank the German Ministry
for the Environment, Nature Conservation and Nuclear Safety for the financial support given to the
ITES project under contract No. 16UM0064.

References
[1]

Eck M., Zarza E., Eickhoff M., Rheinlnder
J., Valenzuela L. Applied research concerning the direct steam generation in parabolic
troughs. Solar Energy, Vol. 74, 2003,
pp. 341-351

Apendix: Source code of model WeightedSignals
model WeightedSignals
Modelica.Blocks.Interfaces.RealInput x
Modelica.Blocks.Interfaces.RealInput u[n]
Modelica.Blocks.Interfaces.RealOutput y

actual value of x;
values at nodes x_param;
interpolation result;

parameter Real

x_param[:] "interpolation nodes
// (here [0C, 20C, 40C] )
parameter Integer n=size(x_param,1) "Dimension of signal vector";
parameter Modelica.Blocks.Types.Smoothness.Temp
smoothness=Modelica.Blocks.Types.Smoothness.LinearSegments
"smoothness of table interpolation;
parameter Real[:,:] Weight_matrix
= [x_param, diagonal(ones(n))];
parameter Integer
Weight_columns[:] = 2:size(Weight_matrix, 2);
Real
Weight_tableID;
Real[n]
weight
weights of the values u[i];

equation
for i in 1:n loop
weight[i] = dymTableIpo1( Weight_tableID, Weight_columns[i], x);
end for;
y = sum( u[i] * weight[i]
for i in 1:n);
when initial() then
// Initialize Weighting functionality
Weight_tableID=dymTableInit(1.0,smoothness,"NoName","NoName",Weight_matrix, 0.0);
end when;
end WeightedSignals;

The Modelica Association

548

Modelica 2008, March 3rd  4th , 2008

PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems

PlanarMultiBody
A Modelica Library for Planar Multi-Body Systems
Mathias Hbinger1, Martin Otter2
1
Vienna University of Technology, Austria
2
German Aerospace Center (DLR), Institute of Robotics and Mechatronics, Germany
mathias.hoebinger@gmx.at, martin.otter@dlr.de

Abstract
A new Modelica library for the modeling and simulation of 2-dimensional mechanical systems has been
developed. It is based on the existing Modelica.Mechanics.MultiBody library and implements a
number of simplifications and optimizations for 2dimensional environments, which bring the advantages of a reduced complexity of the modeling process as well as a reduced computational effort. Additionally, new components are present for joints with
curve-curve contact (e.g. cam follower joints). The
basic approach is, to have a 1:1 mapping of packages, models and functions, if this makes sense, and
specialising them to 2 dimensions.
Keywords:
Modelica, planar multi-body, contact mechanics.

1

Introduction

The PlanarMultiBody library is a Modelica package
providing 2-dimensional mechanical components to
model in a convenient way planar mechanical systems. The main design goal of the library was to utilize the fact that in such systems coordinates, directions and rotations can be expressed and computed in
a much simpler way than in 3-dimensional systems.
A typical example of this library is a mechanism
with 2 kinematic loops as shown in the Figure 1.

Figure 1: A planar mechanical system containing
2 coupled kinematic loops

The Modelica Association

The PlananMultiBody library,
see screenshot to the right, has
the following main features:
 In 2-dimensional systems, the
orientation of any object with
respect to another one can be
described by a single angle.
This simplifies the notation for
orientation of objects considerably. The use of the orientation objects from the Modelica.Mechanics.MultiBody library can be dropped completely, as well as the special
handling of the orientation object with Connections.Root
(..), Connections.Branch(..) operators to define the
connected network of coordinate systems in order
to handle over-determined DAEs. The requirements for a Modelica translator to process models
of this library are therefore much less as for the 3dim. Modelica.Mechanics.MultiBody library.
 The visualizer objects used in the MultiBody library for the animation of objects have been altered to achieve two aims: Firstly, all animation
objects can be addressed as 2D objects, e.g., the
bars used to animate a fixed translation have a
length and a width, no height. The Visualizers.Advanced.Shape object, as well as the objects
used for animating all kinds of arrows, includes
input values for length, width and position. Secondly, because the actual animated shapes are still
3D-objects, the height is automatically set to a
very low value which gives the animation a
pseudo-planar look.
 The possibility to model joints based on two
curves sliding along each other. In model PlanarMultibody.Joints.CurveCurveJoint,
different
curve objects can be selected. They all contain
functions used to compute three vectors depending on a curve parameter s: the curvePosition,, the
curveTangent and the curveNormal. The Planar-

549

Modelica 2008, March 3rd  4th , 2008

M. Hobinger, M. Otter

MultiBody.Joints.CurveCurveJoint object includes two instances of arbitrary curve objects,
each connected to a frame. This joint constrains
the movement of its two frames by requiring
proper contact conditions for the two curves.
These are computed using the two curve parameters s1 and s2. Additional curves needed by a user
can easily be added by just providing the necessary equations of the curve and its normal and
tangent vectors.

2

Describing Orientation

The simplified way of describing absolute and relative orientation of objects is the most significant improvement for modeling planar systems compared to
model the same system using the 3-dimensional
MultiBody library. For notational convenience the
word frame is used in the sequel as a synonym for
coordinate system. Instead of using three orthogonal unit vectors to define a specific frame we can do
that with a single angle  that describes the rotation
of that frame with respect to the global coordinate
system around the only possible axis of rotation, the
z-axis. To define the position and rotation of a second frame relative to the first one is equally simple: a
two-dimensional vector r_rel and a relative angle
_rel are everything that is needed. Given the absolute angles _a and _b of two different frames, the
relative angle can be computed by simply stating
_rel= _b  _a .

the world-frame. The resultant cut torque is a scalar
along the z-axis of the world-frame. To summarize,
the connector is defined as:
connector Frame
import SI = Modelica.SIunits;
SI.Position r[2]
"Absolute position vector";
SI.Angle phi
"Angle from x-axis world to frame";
flow SI.Force f[2]
"Constraint force in world frame";
flow SI.Torque t
"Constraint torque in world frame";
end Frame;

As usual, if velocities or accelerations are needed,
they can be obtained by applying the derivative operator der(...). This also holds for the angular velocity which is simply der(phi), where as in the Modelica.Mechanics.MultiBody library the computation of
the angular velocity is complicated and is performed
with a function.

4

Using the Frame connector and the utility functions in PlanarMultiBody.Frames, it is straightforward to implement the elementary components that
are usually available in multi-body programs. The
PlanarMultiBody library has about 40 components.
The most important ones are shown in Table 1. Exactly like in the Modelica.Mechanics.MultiBody library, equations are only defined on position level.
4.1

3

PlanarMultiBody
Frame Connector

The Frame connector is used to connect planar
multibody components together. It is rigidly fixed at
an attachment point of a mechanical part. A frame
frame a is described with respect to the world
frame using the
 2-element vector r that is directed from the origin of the world frame to the origin of frame a
and is resolved in the world frame and by the
 angle  between the x-axis of the frame and the
x-axis of the world-frame.
It is assumed that a free body diagram is constructed,
i.e. that a cut is performed between mechanical parts
that shall be connected together at frame a. In the cut
plane a resultant cut force fa and resultant cut torque
a act on frame a. Since in planar multi-body systems
there are no advantages to express vectors in local
frames, all vectors, and especially fa, are expressed in
The Modelica Association

Elementary Components

PlanarMultiBody.World

This model represents a global coordinate system
fixed in ground. It is used as inertial system in which
the equations of all elements of the PlanarMultiBody
library are defined and is the world frame of an animation window in which all elements of the PlanarMultiBody library are visualized. Furthermore, the
gravity field of the multi-body model is defined here.
Default is a uniform gravity field; a point gravity
field can also be selected. The world object is also
used to define default settings of animation properties (e.g. the width of the rectangles representing a
revolute joint). The world object itself is animated as
a coordinate system with 2 axes and labels.

550

Modelica 2008, March 3rd  4th , 2008

PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems

and torque balance of this massless part is present in
the Modelica model.

Abbreviations:
ra,a,fa,a := frame_a.r, .phi, .f, .t
rb,b,fb,b := frame_b.r, .phi, .f, .t

4.3

resolve1(..) := Frames.resolve1(..)

In planar systems, the only possible axis of rotation
is the z-axis, so this component always defines such
a rotation using a vector rel. When rel = 0, frame_a
and frame_b coincide. Unlike in the Modelica.Mechanics.MultiBody library, the absolute orientation vector of frame_b, frame_b.phi, can easily
be obtained by stating
frame_b.phi = frame_a.phi + _rel.
As with most other joints, the generalized coordinates (here: _rel and its derivative _rel) have the
attribute stateSelect = StateSelect.prefer in order that
they are selected as states if possible. The position
vectors of the two frames are identical and there is a
force and torque balance present. Instead of implementing an additional model ActuatedRevolute, a
conditional 1-dim. flange connector is present onto
which a drive train can be attached driving the revolute joint, e.g, with components from the Modelica.Mechanics.Rotational library. There is a Boolean
parameter drivenFlange present to activate or deactivate the additional flange.

grav := world.gravityAcceleration(..)
World

rb = 0
b = 0

Parts.Fixed
Translation

rb = ra + resolve1(a, rrel)
b =  a
0 = fa + fb
0 = a + b + rrel  fb

Joints.Revolute rb = ra

Joints.JointRR

PlanarMultiBody.Joints.Revolute

b = a + rel
0 = fa + fb
0 = a + b
rrel0 = rb - ra
L*L = rrel0* rrel0
0 = fa + fb
fa = frod * rrel0 / L
0 = a
0 = b

4.4

PlanarMultiBody.Parts.Body

Table 1: Elementary components of PlanarMultiBody.

This component defines the mass and inertia properties of a body. They are defined using the following
parameters: m for the mass, the position vector r_CM
from the origin of frame_a to the center of mass (resolved in frame_a) and the inertia value I. There is a
Boolean parameter enforceStates present which defines if the positon vector r and orientation angle 
of frame_a should be use as states. These variables
have the attribute stateSelect = if enforceStates then
StateSelect.always else StateSelect.avoid. The feature to have potential states both in joints and in bodies makes it easier to model systems with bodies
which are connected to the environment without using a joint or freely moving bodies.

4.2

4.5

Parts.Body

w = der(a)
z = der(w)
rCM0 = resolve1(a, rCM)
rabsCM0 = ra + rCM0
g = grav(rabsCM0)
v = der(rabsCM0)
a = der(v)
fa = m * (a  g)
I * z = a  rCM0  fa

PlanarMultiBody.Parts.FixedTranslation

This component defines a fixed translation of a
frame. It is, e.g., used to define frames for several
attachment points on a body. The equations state that
the position vector of frame_b is defined from the
position vector of frame_a and the relative position
vector rrel from frame_a to frame_b (rrel is defined as
parameter r). Since frames are translated, the angles in the two frames are set equal. Finally, a force

The Modelica Association

PlanarMultiBody.Joints.JointRR

This component fixes the distance between its two
frames to parameter L, but does not constrain the
orientation angles of any of them. Therefore it can be
used as a replacement for two revolute joints connected by a fixed translation. Using this component
reduces the order of the nonlinear equation system
and helps avoiding problems with non-linear equation systems caused by kinematic loops. The cut
force is constrained to act only along the vector be-

551

Modelica 2008, March 3rd  4th , 2008

M. Hobinger, M. Otter

tween the origins of the two frames. Finally, a force
and torque balance is present in this component.
There is an additional object called PlanarMultiBody.Joints.JointRRWithMass present which includes a mass fixed relative to the two frames of the
joint.

Figure 2: The diagram level of the model animated in
Figure 1 using two instances of JointRRWithMass

5

Force Elements

Force elements exert forces and torques between two
frames. Because these elements, although they have
obviously been altered to fit into the different orientation setup of this new library, are virtually identical
in their functionality and structure to the ones in the
MultiBody library, we will not discuss them here in
great detail. For a more detailed description of the
most important force elements, see [1].

6

utilizes a single model to realize virtually of all its
animations, MultiBody.Visualizers.Advanced.Shape.
The following features were implemented into the
PlanarMultiBody animation engine:
 Having a user-interface with purely 2dimensional animation parameters gives the user
the convenience of not having to deal with a zcoordinate that only exists in the animation and
has nothing to do with the planar system being
modeled.
 To provide users with a maximum of freedom of
design, either side of a 3d-object displayed by
the FixedFrame component of the library can
be used as a pseudo-2d object. E.g. a cylinder
can be used as a circle or a rectangle. For this
purpose, a boolean parameter zDirection was
added to the Shape object which rotates the
animated object by 90 around the y-axis.
 To avoid overlapping of objects in the pseudo2D animation, it is possible to shift an object
along the z-axis of the animation using the
parameter heigthShift.
 The heigth of all objects is automatically set to a
low value which results in the desired pseudo2D look of the animation.
Table 2 shows all the parameters of the
PlanarMultiBody.Visualizers.Advanced.Shape object
with their default values and a short description of
their functionality.

Animation

The animation environment in Dymola [2] is natively a 3-dimensional one, and all animated objects
therefore have to be programmed in that way. However, the Modelica.Mechanics.MultiBody library

Table 2: Parameters of the PlanarMultiBody.Visualizers.Advanced.Shape object

The Modelica Association

552

Modelica 2008, March 3rd  4th , 2008

PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems

7

connected to the respective variables in the curve
objects.

Curve-Curve Contact

With Joints.CurveCurveJoint, the PlanarMultiBody
library includes a new joint making it possible to
simulate two surfaces having to remain in contact
with each other. In every instance of this joint, the
user can choose two out of a library of curves used to
simulate the connected surfaces. Each curve is fixed
to one frame of the joint, in the sequel we will use
the name curve_1 for the curve object connected to
frame_a and curve_2 for the one connected to
frame_b. The main idea is to have two variables s1
and s2, one for each curve, in the CurveCurveJoint
model, which stand for the path parameter of the respective curve, describing the current contact point
on the curve with respect to a fixed starting point.
Usually sis the arc-length along the curve, but this
need not to be the case in general. For a given value
of their respective curve-variables, curve_1 returns a
relative position vector from frame_a to the point of
contact as well as the normal and tangent vector at
that point on the curve.
tangent1
tangent2
normal2

normal1

curve_1
curve_2

Figure 3: Normal and tangent definition of
curve-curve contact

7.1

Joints.CurveCurveJoint

As mentioned above, this model includes two frames as well
as two instances of a curve
object. The possibility of
choosing the curves inside the
actual instance of the joint is realized by including
them as replaceable objects:
replaceable Joints.Internal.Circle
curve1(phi=frame_a.phi,r_0=frame_a.r)
extends
PlanarMultiBody.Interfaces.BaseCurve
(phi=frame_a.phi, r_0=frame_a.r)

r1_rel = curve1.position(s1);
r2_rel = curve2.position(s2);
r1 = Frames.resolve1(frame_a.phi,r1_rel);
r2 = Frames.resolve1(frame_b.phi,r2_rel);
normal1 = Frames.resolve1(frame_a.phi,
curve1.normal(s1));
normal2 = Frames.resolve1(frame_b.phi,
curve2.normal(s2));
tangent2 = Frames.resolve1(frame_b.phi,
curve2.tangent(s2));

More importantly, the kinematic constraint equations
as well as the force and torque balances of the joint
and the curves are defined here:
First, the distance between the contact point on
curve_1 and the one on curve_2 is set to zero:
{0,} = frame_b.r + r2 - (frame_a.r + r1);

Then, additional equations ensure that the contact
point is actually an osculation point of the two
curves, meaning that their standard normal vectors
point in the same direction with different signs:
0 = Modelica.Math.atan2(
normal1*tangent2, -normal1*normal2);

The formulation of this condition is from Hans Olsson [3] and requires some explanation: The contact
conditions on the normal could be formulated as
normal1*normal2=0. However, this equation has a
singular Jacobian and therefore every solver would
have severe difficulties. The condition could also be
formulated as normal1*tangent2 = 0, as often suggested in literature. Here, we have the problem that a
contact where normal1 and normal2 are directed in
the same direction, will also fulfill this equation and
therefore it can happen that during simulation suddenly a wrong contact appears. The formulation used
in the CurveCurveJoint is basically using the normal1*tangent2 = 0 formulation, but uses this as the
first argument to the atan2(..) function. As second
argument -normal1*normal2 is used. The
atan2(..) function has the property that the signs of
the two arguments determine the quadrant of the solution. Especially, only if the second argument is
positive, -/2 <= atan2(x,y) <= /2. Therefore, in the
solution point 0 = atan2(x,y), the second argument
-normal1*normal2 must be positive which means
that the two normals have to be directed in opposite
direction.
Finally, force and torque balances are included:

In the equation section of the CurveCurveJoint
model, position, normal and tangent variables are

The Modelica Association

553

Modelica 2008, March 3rd  4th , 2008

M. Hobinger, M. Otter

// Force and torque balance of joint
zeros(2) = frame_a.f + frame_b.f;
0 = frame_a.t + frame_b.t +
Frames.cross(frame_b.r - frame_a.r,
frame_b.f)
// Force and torque balance of curve1
f_contact1 = -normal1*f_N;
zeros(2) = frame_a.f + f_contact1;
0 = frame_a.t +
Frames.cross(r1, f_contact1);

7.2

Predefined Contact Curves

The package PlanarMultiBody.-Joints.Internal
includes the models which are
predefined
in
the
CurveCurveJoint object. Additional curves can easily be
added by a user. We will use
the Ellipse model to explain
the functionality of these
objects. All curve-definition
models extend a model
called PlanarMultiBody.Interfaces.BaseCurve which
defines the basic input variables r_0 and phi which
are the absolute position vector and orientation angle
of the frame to which the curve is attached.
The BaseCurve model also establishes the three
functions position, normal and tangent and their basic input and output variables. The input variable s is
the curve parameter; the 2-dimensional output vector
is called r, n or t depending on the function. To enable the different curve-definition models to have
different versions of these functions, they are defined
as replaceable encapsulated partial functions in
BaseCurve.
replaceable encapsulated partial
function normal
input Real s
"Curve parameter";
output Real n[2] "Normal to curve";
end normal;

Every curve model has its own set of parameters
used to adjust the actual curve surface In case of the
ellipse there are two of them: a and b, defining the
length of the two ellipse-axis.
Furthermore, there is always at least one parameter
defining the path parameter of the animated curve. In
case of the ellipse, the final parameter C is the approximated circumference of the Ellipse computed
from the given parameters a and b. In the models
which define non-closed curves, e.g. StraightLine,
there is an input parameter instead of this final parameter allowing the user to define how long a part
of the curve should be animated.
The Modelica Association

Additionally, there are the usual animationconcerned parameters animation, switching the animation of the curve on or off, and color, defining the
color of the animated curve. Finally, the parameter
ns defines how many points should be used to interpolate the animated curve and the SwitchSide parameter defines on which side of the curve the contact should occur.
The most important part of a curve-definition model
are of course the three functions actually defining the
shape of the curve: curvePosition, curveNormal and
curveTangent. They extend the respective functions
in the BaseCurve model by including the necessary
additional parameters and adding an algorithm
section with the statement computing their output
variable. Here we present the CurvePosition function
from the Ellipse model as an example:
model Ellipse "Ellipse contact curve"
extends
PlanarMultiBody.Interfaces.BaseCurve(
redeclare final function position =
curvePosition(a=a,b=b,C=C),
redeclare final function normal =
curveNormal(a=a,b=b,C=C,sw=sw),
redeclare final function tangent =
curveTangent(a=a,b=b,C=C));
protected
function curvePosition
extends PlanarMultiBody.Interfaces.
BaseCurve.position;
input Modelica.SIunits.Length a
"Length of a-axis of ellipse";
input Modelica.SIunits.Length b
"Length of b-axis of ellipse";
input Modelica.SIunits.Length C
"Approximated circumference";
algorithm
r := { a*sin(s*2*pi/C),
-b*cos(s*2*pi/C)};
end curvePosition;
...
end Ellipse;

Finally, the model includes an algorithm computing
the points used to animate the curve in its current
position defined through the curve parameter. This is
done by filling three coordinate vectors with length
ns. These vectors are actually realized as ns*2 matrices, the second columns being filled with slightly
shifted values to ensure better visibility of the animated curve. The animation is performed with Dymolas built-in support for parameterized surfaces.

554

Modelica 2008, March 3rd  4th , 2008

PlanarMultiBody - A Modelica Library for Planar Multi-Body Systems

joint. Then the appropriate curves have to be selected
by double clicking on the joint and selecting them
from a dropdown menu (see next Figure 5).

final parameter Real s_min=0
"Minimum value of s";
final parameter Real s_max=C
"Maximum value of s";
algorithm
for i in 1:ns loop
s := s_min + (i - 1)*
(s_max - s_min)/(ns - 1);
r := Frames.resolve1(phi,
position(s));
x[i,1] := r_0[1] + r[1];
x[i,2] := r_0[1] + r[1] + 0.01;
y[i,1] := r_0[2] + r[2];
y[i,2] := r_0[2] + r[2] + 0.01;
z[i,1] := 0;
z[i,2] := 0.01;
end for;

7.3

Figure 5: Selecting a curve in the
CurveCurveJoint menu

Examples

Package PlanarMultiBody.Examples.CurveCurveJoint includes a number of examples demonstrating
the use of this new joint. The most obvious example
is probably the classic Cam-Follower setup. In this
model, an elliptic object driven by gravity acting
upon a body attached to it turns on a revolute joint
fixed to the ground. It is connected to an object with
a straight surface being attached to a prismatic joint
and forced into movement by the ellipsoid (see
model schematic und animation in next Figure 4).

Finally, a body is attached to frame_a of the joint
and the start value of the ellipses curve parameter is
set to an appropriate value to ensure that the system
is not in an idle position at time 0.
Another example from this package demonstrates the
effect of the switchSide parameter, see Figure 6. Two
CurveCurveJoint objects are present, both describing
the contact between two circles. In the upper circlecircle contact, switchSide = true, whereas in the
lower circle-circle contact, the default switchSide =
false is used. The effect can be seen in Figure 6.

Figure 6: Example CurveCurveJointSwitchSides
demonstrating the switchSide parameter

Figure 4: Model and animation of CamFollower

It it realized by connecting frame_a of a CurveCurveJoint to the world frame through a revolute joint
and doing the same with frame_b using a prismatic
The Modelica Association

The third example, see Figure 7, shows the possibility of more complex curves by using an ellipse distorted by a sinus wave. This curve has amplitude and
frequency of the wave as additional parameters.
Here, a very small circle attached to a small body
runs along the distorted ellipse. It is connected to the
world frame using a prismatic joint.

555

Modelica 2008, March 3rd  4th , 2008

M. Hobinger, M. Otter

Figure 7: Example SinusEllipse demonstrating more
complicated curve-curve contacts

8

Conclusions

The PlanarMultiBody library is a mechanical library
to model planar mechanical systems. The main advantage is its simplicity and that no special symbolic
manipulation features of the Modelica simulation
environment is needed, contrary to the Modelica.Mechanics.MultiBody library that describes 3dim. mechanical systems. Therefore, the PlanarMultiBody library is well suited for teaching, but also for
a quite large class of technical problems that are 2dim. in nature. Besides standard joints, the PlanarMultiBody library allows the definition of curvecurve contacts, especially to describe cam-follower
types of contact. The non-standard formulation [3] of
the contact condition with the atan2(..) function has
proven to result in reliable solutions of the occurring
non-linear algebraic equation systems.
It is planned to include this library as free package in
the Modelica Standard Library after an evaluation
phase. Currently, there is also an Interpolation package under development. Once available, it is planned
that the curve descriptions in the curve-curve contact
description can be optionally described by splines of
this package.

References
[1]

Otter M., Elmqvist H., Mattson S.E. The new
Modelica Multibody Library. Proc. of the 3rd
International Modelica Conference, pp. 311-330,
2003.
http://www.modelica.org/Conference2003/papers/
h37_Otter_multibody.pdf

[2]

Dynasim. Dymola Users Guide, Version 6.0,
http://www.dynasim.se.

[3]

Olsson H.: Formulation of contact conditions.
Personal communication to M. Otter, Sept. 2007.

The Modelica Association

556

Modelica 2008, March 3rd  4th , 2008

Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the SmartElectricDrives Libraries

Implementation of Hybrid Electric Vehicles using the
VehicleInterfaces and the SmartElectricDrives Libraries
Dragan Simic Thomas Buml
Arsenal Research
Giefinggasse 2, 1210 Vienna, Austria

Abstract
In this paper different configurations of hybrid electric
vehicles summarized in the SmartHybridElectricVehicles library were examined and simulated. The
presented simulation models and results were created
and achieved with Modelica using Dymola. The
models represent different kinds of electric and
hybrid electric vehicle configurations. Furthermore,
different strategies for operating the hybrid electric
vehicles energy sources are provided. The parameters
needed for parameterization of the vehicle models
were, in case of the electric vehicle, taken from real
measurements on the vehicle and vehicle components.
For all other models parameters were assumed due
to a lack of measurement data. In the library three
Modelica packages specifically designed for modeling
systems including mechanical components, electrical
components and control components have been used.
These are the SmartElectricDrives library, the VehicleInterfaces library and the PowerTrain library. Due
to the object oriented architecture of these libraries all
necessary components needed for the implementation
and simulation of electric and hybrid electric vehicle
configurations are provided and can be reused. Hence,
the efficiency optimization of such configurations gets
eased by these libraries.
Keywords: simulation, modeling, hybrid electric vehicles, optimization, fuel consumption, operating strategy

1

Introduction

In this contribution a simulation library, the SmartHybridElectricVehicles (SHEV) library, will be presented. This library is developed by arsenal research
with focus on automotive applications, such as electric
and hybrid electric vehicles (HEV). The SHEV library
The Modelica Association

is written in Modelica language [1] and simulated using the Dymola simulation environment. The library
is implemented on the basis of the VehicleInterfaces
(VI) library [2]. Therefore compatibility with all other
libraries based on the VI library is ensured. For simulations of the electrical components the SmartElectricDrives (SED) library [3] is used. The StateGraph
library, included in the Modelica Standard Library
(MSL), has been chosen for modeling the operating
strategies of the included vehicles. All mechanical
components, such as the power train including transmissions, differentials, axles, etc. are provided by the
PowerTrain library.

2

Electric Vehicle

An electric vehicle using the above mentioned libraries was modeled as depicted in figure 1. This
configuration consists of a front axle modeled in the
driveline model, a transmission (trans.) with
one gear and an electric machine (MG2). Attention
is paid to the energy consumption during a simulated
drive cycle. Therefore the quasi stationary model of
an electrical excited DC machine with integrated converter and control system, including voltage and current limitation as well as flux weakening from the SED
library is used here. For powering the vehicle, an energy source (battery) is modeled using a simple
idealized battery model included in the SED. This battery model consists of a constant capacitor and a constant internal resistor only. All mechanical components, such as brakes, chassis and driveline
are taken from the PowerTrain library. They are provided there as ready to use models. For controlling the
vehicle velocity (acceleration pedal and brake pedal
position) a virtual driver model taken from the PowerTrain library was adapted. In the controller model
(control.), different operating strategies are implemented.

557

Modelica 2008, March 3rd  4th , 2008

D. Simic, T. Bauml

Figure 1: The Modelica simulation model of the electric vehicle

2.1

Operating strategies

Three different operating strategies are implemented
in the controller of the electric vehicle. These strategies are modeled using the StateGraph library of the
MSL. All operating strategies control the reference
torque of the electric machine. In the first case reference torque of the electric machine is limited between maximum machine torque and zero. The reference torque is restricted to be positive only. In this first
operating strategy, only the drive mode of the electric
machine is active, no recuperation occurs.
The second operating strategy includes the basic functionality of the first operating strategy with an additional recuperation mode. When the virtual driver actuates the brake pedal, the electric machine is driven in
generator mode and the battery is recharged. The reference torque of the electric machine is directly proportional to the brake pedal position. Additionally, vehicle deceleration occurs by mechanical braking.
The third operating strategy is split into two braking
mode levels. During the first stage, vehicle deceleration occurs by electrical braking and recuperation
only. The battery is charged. If the demanded reference braking torque exceeds the electric machines
maximum torque, additional mechanical braking occurs.
In the last two strategies electrical braking and hence
electrical recuperation only occurs if the battery state
of charge decreases beneath a certain limit. By reaching the upper set limit, electrical braking is switched
off to prevent overloading and damaging the battery.
The model of the electric vehicle in figure 1 was simulated with all three operating modes in the New European Drive Cycle (NEDC). The state of charge (SOC)
The Modelica Association

Figure 2: Simulated state of charge of the battery during different operating strategies
of the battery was compared and is shown in figure
2. mode1 represents the first operating strategy without recuperation, mode2 the second operating strategy
with proportional recuperation and mechanical braking and mode3 the third implemented operating strategy. Due to a high recuperation ratio mode3 is the
strategy with the lowest energy consumption and the
highest recuperation potential, respectively. Mainly
electrical braking occurs and therefore the battery is
recharged more than in any other implemented strategy.

3

Series Vehicle

The series hybrid electric vehicle depicted in figure 3
is modeled based on the electric vehicle model. It contains an additional internal combustion engine (ICE),

558

Modelica 2008, March 3rd  4th , 2008

Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the SmartElectricDrives Libraries

Figure 3: The Modelica simulation model of the series hybrid electric vehicle
engine, and an electric machine acting as generator, MG1. The generator is driven by the ICE and is
used to charge the battery. The operating maps and
the fuel consumption of the ICE are taken from a Toyota Prius, according to [4]. The basic drive modes for
the MG2 are taken from the electric vehicle. Additionally, different operating strategies for the ICE and the
MG1 have been implemented. With the disabled recuperation mode of the MG2 and a disabled generator
MG1, the behaviour of the series vehicle is the same
as the electric vehicle. For operating the MG1 a shift
of the ICE operating point is implemented. It is dependent on the demanded electrical power and, hence,
the required torque and speed of the generator. The
input value for this operating strategies are the measured motor power and the current generator power,
respectively. During a change of the demanded generator power the strategy calculates the most efficient
operating point of the ICE regarding fuel consumption. In figure 4 the shifting between two operating
points with different demanded generator power is
depicted. max is the maximum torque and min is the
drag torque of the ICE. These two operating points
of the ICE are those with the highest efficiency and
the lowest fuel consumption, respectively. The operating strategy is modeled in the controller (control.)
block and based on different control algorithms that
will not be described here in detail. The control is independent of size and type of the electric machine as
well as of the size of the ICE, which means, that any
kind of ICE or machine can be included in the model.
Currently the user can choose between two engines
and various transient and quasi stationary electric machines in different power classes.

The Modelica Association

Figure 4: Operating point shift of the internal combustion engine

4

Parallel Vehicle

The parallel HEV, figure 5, contains an ICE, engine,
and an electric machine acting as starter/generator,
MG1 with two shaft ends. This electric machine is
used for starting the ICE, for boosting during driving
mode and for recharging the battery. The electric machine, MG1, is coupled on one side with the ICE by a
mechanical clutch, C1, and on the other side with the
transmission by a mechanical clutch, C2. The mechnical clutch, C2, is embedded in the transmission model
(trans. + C2). Using this kind of power train
configuration, it is possible to switch between more
driving modes. Potential driving modes are driving
with the electric machine only, driving with engine and
electric machine (ICE and boosting electric machine),
start/stop operation of the ICE, load point shifting of

559

Modelica 2008, March 3rd  4th , 2008

D. Simic, T. Bauml

Figure 5: The Modelica simulation model of the parallel hybrid electric vehicle
the ICE and recuperation during vehicle deceleration.
Exemplarily, two operating strategies for the ICE and
the starter/generator are simulated and shown here.
The first operating strategy demonstrates the basic
operating strategy of a conventional vehicle, only
driven by the ICE without recuperation or start/stop
operation. The second operating strategy manages
the start/stop driving operation of the ICE and the
starter/generator. The comparison of the fuel consumption of the ICE is depicted in figure 6, where
conventional is the fuel consumtion of conventional
driving and start/stop is the fuel consumption during
start/stop operation, respectively. Both vehicle models are simulated in an NEDC operating cycle. The
SOC of the battery is balanced in both models at start
Figure 6: Comparison of the fuel consumption of conand end of the simulation, figure 7. One can see, that
ventional and parallel hybrid electric vehicle
the state of charge of the conventional vehicle remains
unchanged, because no electrical driving or boosting
occurs. By contrast the SOC during start/stop operation shows slight changes. During standstill the engine
is switched off. By activating the acceleration pedal,
the engine is started by the electric machine. While
accelerating the engine, the SOC decreases until the
engine has reached idle speed. Then the electric machine switches to recuperation mode and the battery is
recharged to the upper set limit. Due to a fuel saving
during standstill, the vehicle with start/stop operating
mode shows a slightly lower fuel consumption as the
conventional vehicle.

5

Electric Vehicle Validation

Figure 7: Comparison of the battery SOC of convenFor validation of the HEV models and the SHEV li- tional and parallel hybrid electric vehicle
brary the electric vehicle was used in a first step, beThe Modelica Association

560

Modelica 2008, March 3rd  4th , 2008

Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the SmartElectricDrives Libraries

description
vehicle mass
front area
wheel radius
inertia of electric machine
final gear ratio
aerodynamic resistance
coefficient
rolling resistance coefficient

value
1625
2.653
0.285
0.2
7.35
0.407

unit
kg
m
m
kgm
-

0.0144

-

description
nominal armature voltage
nominal armature current
nominal excitation current
nominal rotor speed
maximum rotor speed
warm armature resistance
armature circuit inductance
warm excitation resistance
excitation circuit inductance

value
162
110
12.5
1340
6500
0.069
0.00169
9.47
0.0947

unit
V
A
A
rev/min
rev/min

H

H

Table 1: Parameters of the chassis model and driving
resistances derived from measurements
Table 2: Parameters of the electric machine according
to the Peugeot Partner data sheet
cause measurements on and electric vehicle could be
accomplished easily. A Citron Belingo electrique vehicle was chosen for validation, according to [5]. After
determination of the component parameters, all single
components and the entire electric vehicle model were
parameterized. Afterwards simulation results were
gathered and compared with measurement results of
the real vehicle.

5.1

Parameterization

Every component of the electric vehicle model needs
a set of parameters which have to be determined prior
to the simulation. They have been derived from numerous measurements on all mechanical and electrical components and data sheets. The data sheet for
the electric machine is taken from a Peugeot Partner
Electric vehicle which has the same as the Citron
Berlingo Electrique, according to [6]. For the parameterization of the chassis model and the driving resistances, freewheeling curves of the electric vehicle
were determined. Out of these measurements parameters listed in table 1 were calculated and used for the
simulation.
For a detailed battery simulation a dynamic battery
model was developed at arsenal research, whereas for
the simulation and validation of the entire electric vehicle power consumption the more simplified idealized
model was used. The parameterization of both battery
models, linearized and dynamic, is based on measurements on the real vehicle battery using a standardized
charging/discharging test cycle. Throughout this investigation it was possible to determine the parameters
of the battery.
The electric machine as described in the data sheet according to [6] was parameterized with the values listed
table 2.

The Modelica Association

Figure 8: Comparison of the measured and simulated
freewheeling curve of the electric vehicle

5.2

Model Validation

The validation of the electric vehicle model was executed first on component level and then regarding
the complete vehicle. All mechanical and geometrical parameters, the electrical parameters of the electric
machine and the battery as well as the overall power
consumption of the entire electric vehicle were determined. The vehicles driving resistances such as aerodynamic and rolling resistances have been calculated
based on the measured freewheeling curve. For validating the electric vehicle resistance model the simulated freewheeling curve is compared with the measured one in figure 8. The very small difference between the real measured and the simulated freewheeling curve allows the assumption, that the driving resistances have been chosen in an accurate way.
For validation of the vehicles power train, the electrical excited DC machine, the DCDC converter and
the battery model are validated. For modeling the
electric machine a torque controlled quasi stationary

561

Modelica 2008, March 3rd  4th , 2008

D. Simic, T. Bauml

Figure 9: Power and torque curves of electric machine

Figure 10: Mesured and simulated battery voltage

model, taken from the SED library, was used. The
electric machine is driven by a reference torque and
the simulation covers the entire admissible electric machine speed range. The maximum feasible inner electric torque and the mechanical output power in dependence on the electric machine speed is depicted in
figure 9. This parameterization is based on the electric machine manufacturers data sheet and shows good
congruence with the measured values.
Using measurement results of the voltage, current and
temperature gathered during road test procedures, the
complex battery model was parameterized. The measurement results were recorded during a ride through
the city of Vienna, Austria. For the battery model
and the entire electric vehicle validation the measured
curents were used as reference signals. The measured,
Vmeasured , and simulated, Vsimulated , battery voltages are
depicted in figure 10. The deviation of the voltages is
assigned to the fact that some cells of the real battery
were slightly damaged. Though, the overall voltage error of less then 5% is still in an acceptable bandwidth
and shows the applicability of the used models.

ios. A significant acceleration of the development process of HEV drive train concepts and technologies can
be achieved and effort can be reduced. The achievable improvements of a HEV concept highly depend
on the specific driving cycle and the boundary conditions, e.g. driving time without recharging possibilities, recharging time during standstill periods, recharging during recuperation, recharging during load point
shifting of the ICE operating point, etc. Therefore,
these boundary conditions should be defined prior to
the simulations to assure simulation results that can
match the real system behaviour in a satisfying way.
Furthermore, already small changes in the control
strategy can have big influence on the overall energy
consumption. Also these steps of development can be
simulated by means of this library in a rather easy way.

6

References
[1] Peter Fritzson, Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1,
IEEE Press, Piscataway, NJ, 2004.

Conclusions

[2] M. Dempsey, H. Elmqvis, M. Gaefvert, P. Harman, C. Kral, M. Otter, and P. Treffinger, Coordinated automotive library for vehicle system modThe presented vehicle simulations allow the determielling, 5th International Modelica Conference
nation of the energy and fuel consumption as well as
2006, 2006.
the identification of the economic savings potential
by integrating alternative vehicle drive train concepts.
Using the developed SHEV library different HEV con- [3] J.V. Gragger, H. Giuliani, C. Kral, T. Buml,
cepts and operating strategies can be analyzed and
H. Kapeller, and F. Pirker, The SmartElectrictested very quickly . Based on the developed vehicle
Drives Library  powerful models for fast simulamodels different potential concepts have been identitions of electric drives, 5th International Modelfied and analyzed under different application scenarica Conference 2006, Vienna, Austria, 2006.
The Modelica Association

562

Modelica 2008, March 3rd  4th , 2008

Implementation of Hybrid Electric Vehicles using the VehicleInterfaces and the SmartElectricDrives Libraries

[4] National Renewable Energy Labaratory (NREL),
ADVISOR documentation, ADVISOR data file
fc prius jpn, www.ctts.nrel.gov, 2002.
[5] M. Noll, H. Giuliani, D. Simic, V. Conte,
H. Lacher, and P. Gollob, Simulation and optimisation of a full electric hybrid vehicle, International Battery, Hybrid and Fuel Cell Electric
Vehicle Symposium & Exposition, 22nd, EVS23,
Anaheim, USA, 2008.
[6] Peugeot,
Partner Electric Motor, Beschreibung Technischer Daten, Organummer 7725, Ref:
1238-D-04/98, Partner Electric Motor, 1998.

Definitions, Acronyms and Abbreviations
SHEV

SmartHybridElectricVehicles

HEV

hybrid electric vehicle

VI

VehicleInterfaces

PT

PowerTrain

SED

SmartElectricDrives

MSL

ModelicaStandardLibrary

NEDC

New European Drive Cycle

SOC

state of charge

ICE

internal combustion engine

The Modelica Association

563

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

564

Modelica 2008, March 3rd  4th , 2008

Modeling of CO2 Reduction Impacts on Energy Prices with Modelica

Modeling of CO2 Reduction Impacts on Energy Prices with Modelica
Philip Machanick1, Ariel Liebman1, Peter Fritzson1,2
1
School ITEE, University of Queensland, Australia
2
PELAB, Department of Computer and Information Science
Linkping University, SE-581 83 Linkping, Sweden
aliebman@itee.uq.edu.au, philip.machanick@gmail.com, petfr@ida.liu.se

Abstract
There is growing evidence that anthropogenic carbon
dioxide (CO2) emissions as a by-product of the combustion of fossil fuels for energy use is raising the
earths temperatures and potentially leading to irreversible climate change. Additionally the growth in
global emissions is likely to rise at an increasing rate
due economic growth, especially in developing
countries. Leading climate change mitigation strategies require a global CO2 emission permit trading
regime which is postulated to facilitate the lowest
cost emission reduction options and technologies.
However, given the technologies are still maturing
the economic considerations appear to dictate slow
initial reductions which will then grow at an increasing rate as technologies such as wind, solar and carbon capture and storage mature. These economic
considerations however may be in conflict with
longer-term optimization of costs and benefits,
which may be better addressed by earlier intervention. In this paper we present a Modelica model designed to allow exploration of the tradeoffs between
least cost emission cuts and early stabilization of
atmospheric carbon dioxide.

1

Introduction

The energy and climate systems are now intimately
bound through human activity. The evidence that
anthropogenic carbon dioxide (CO2) emissions as a
by-product of the combustion of fossil fuels for energy use is raising the earths temperatures and potentially leading to irreversible climate change [6].
Additionally the growth in global emissions is forecast to rise rapidly due to economic growth, especially in developing countries. In order to minimize
the impacts of rising emissions on global temperatures and potentially catastrophic events such as
multi-metre sea level rises deep cuts are required
early [5,16].

The Modelica Association

The leading climate change mitigation strategies
require a global CO2 emission permit trading regime
which is postulated to facilitate the lowest cost emission reduction options and technologies. However,
given the technologies are still maturing the economic considerations appear to dictate slow initial
reductions which will then grow at an increasing rate
as technologies such as wind, solar and carbon capture and storage mature.
A significant question in the politics of climate
change has been the trade-off between the costs of
mitigation versus the costs of doing nothing. What is
missing is a model quantifying the costs and benefits
of the rate of of mitigation, taking into account that
early strategies may be less efficient than later ones,
yet have more value for mitigation if it is accepted
that early mitigation is better than late mitigation,
since effects accumulate.
The leading climate change mitigation strategies
require a global CO2 emission permit trading regime
which is postulated to facilitate the lowest cost emission reduction options and technologies. This kind of
scheme has its origin in earlier approaches to emissions reduction, such as the US Acid Rain Program,
initiated by the Clean Air Act of 1990 [17], with the
underlying theory of artificial markets being created
to correct for market failures dating back to the late
1960s [18].
Given that the technologies are still maturing, the
economic considerations appear to dictate slow initial reductions which will then grow at an increasing
rate as technologies such as wind, solar and carbon
capture and storage mature  hence the need not only
to create an artificial market, but to explore how to
use price as an instrument to drive change at the appropriate rate.
In this paper we present a Modelica model which
explores the tradeoffs between least cost emission
cuts and early stabilization of atmospheric carbon
dioxide.

565

Modelica 2008, March 3rd  4th , 2008

P. Machanick, A. Liebman, P. Fritzson

1.3

1.1 Model assumptions

1.2

The climate system

The climate model allows for either linear or exponential growth in emissions and in atmospheric carbon dioxide; current trends look linear but exponential growth may occur in the worst case if growth in
energy use tracks population growth. As a first approximation, although there are indications that environmental sinks may saturate [7], we assume a fixed
ratio of natural CO2 sinks (plants, land, ocean) to
emissions. This assumption is reasonable if abatement measures are effective (changes in the ocean in
particular can be rapid [8]), i.e., this is a conservative
assumption for the benefits of early abatement.
Our climate model assumes the following parameters:
 We assume all variation in greenhouse cases, at a
first approximation, is in CO2 (reasonable since
methane outputs have stabilized since 1990, and
CO2 output is the largest single anthropogenic
contributor to greenhouse gases [10]) and therefore work with gigatonnes CO2-equivalent
(GtCO2-eq)
 We base our scenarios on the IPCCs, which vary
total emissions increases from 2000 to 2030 from
9.7 GtCO2-eq to 36.7 GtCO2-eq off a baseline of
39.8 GtCO2-eq, prior to mitigation [11]
 Total sinks including oceans and land-based consumers of CO2: 50% of anthropogenic CO2 production (30% oceans, 20% land) [9]
Our starting point is the scenarios defined by the Intergovernmental Panel on Climate Change (IPCC)
[12]. These scenarios are intended to illustrate a
range of possibilities, without attempting to predict
the likelihood of any one outcome [13]. Any of these
scenarios could equally well be modeled and for
completeness all should be modeled. However, for
purposes of illustrating the use of Modelica, we focus here on using only one base scenario, and vary
mitigation strategy assuming a given trend in energy
demand. Specifically, we choose the A1C scenario,
because that represents high growth with maximal
convergence of developing economies with developed economies. This scenario combination is relevant because of the debate as to whether mitigation
implies forcing unremitting poverty on developing
countries [14,15].

The Modelica Association

Structure of Paper

The remainder of this paper is structured as follows.
In Section 2, we develop a model, based on plausible
parameters, In Section 3, we present examine outputs
of the model, and discuss future applications. Finally, Section 4 concludes with an overall discussion
of findings and proposals for future work.

2

The Model
2.1






2.2

Methodology and assumptions
We assume that the system is continuous
since all physical process are continuous and
the abatement and economic changes happen
slowly
Assume that the influence of abatement
paths impacts only the cost of abatement
represented by the carbon price. We dont
model the feedback in the other direction
Assume that 50% of emissions are absorbed
environmentally

The economics of abatement

We develop a simple model based on the technology
assessments of McKinsey and Co.s climate change
mitigation team in Sweden [19,20]. This model includes a cost curve for marginal abatement integrated with a mean reverting model for global energy
prices.
 Assume that costs reduce over time as
learning occurs
o constant learning rates for efficiency of energy production and
use
 There are two ways to reduce emissions:
o efficiency-based which reduces
total energy produce to meet
same virtual demand
o increase proportion of zero-CO2
energy
 Underlying energy price remains constant
and is increased only through carbon
pricing (likely to be incorrect as supply
fails to keep up with demand, e.g., as appears to be happening at time of writing
with oil).

566

Modelica 2008, March 3rd  4th , 2008

Modeling of CO2 Reduction Impacts on Energy Prices with Modelica

2.3

Model design

The continuous assumption allows use to use ordinary coupled differential equations (ODEs).
Data from IPCC converted to rates of emission
change and energy production/efficiency change and
are incorporated as growth parameters in ODEs.
The most significant equations are:
(a) No mitigation, high Carbon growth

1) U' (t) = E(t) x U(t) + L
2) PE' (t) = PE-MRR x (PLT + PC x CBI  PE)
3) PC ' (t) = PC-MRR x (PA  PC)
Equation (1) allows us to express energy use U as an
exponential component E and a linear component L. U
represents virtual energy as explained above: it is the
trend in energy demand, not taking into account that
actual energy use may be less owing to efficiency
gains. In our examples in this paper, we hold E to zero.
Equation (2) captures the variation in energy
price (PE) in terms of the energy price mean reversion rate (PE-MRR) which captures the tendency for
price spikes to smooth out, long term energy price
(PLT), the modeled carbon price (PC), the carbon intensity at the start of the modeled time (CB).
Equation (3) models the trend in carbon price in
terms of the carbon price mean reversion rate (PCMRR) and abatement cost (PA).
This is a closed form model for the interaction between energy costs under a carbon pricing regime
and the concentration of carbon dioxide in the atmosphere.
These equations can be expressed in Modelica as
follows:
der(energyUse) = // (1)
energyGrowthExp * energyUse +
energyGrowthLinear;
der(energyPrice) = // (2)
energyPriceMRR *
(longTermEnergyPrice +
carbonPrice * baseCarbonIntensity 
energyPrice);
der(carbonPrice) = // (3)
carbonPriceMRR * (abatementCost 
carbonPrice);

(b) With mitigation
Figure 1. CO2 concentration
becomes clearer which scenarios are most likely.

3

We have run some variations on parameters through
the model, to illustrate how scenarios can be explored.
The A1C scenario explored here in its worst case
with no mitigation results in rapid growth in carbon
emissions, resulting in atmospheric CO2 of the order
of 800 parts per million (ppm), as illustrated in Figure 1(a). In this scenario, most energy by 2100 is
carbon-based, as we have assumed zero mitigation:
no increase in efficiency, no increase in non-emitting
energy sources. With mitigation CO2, peaks at
around 450ppm (Figure 1(b) illustrates the early
mitigation strategy; the late mitigation strategy is
similar with a slightly higher, later peak).
Our mitigation strategy is based on reducing
emissions to those of the B1T IPCC scenario. The
early mitigation and late mitigation strategies are
based on assuming the same cumulative reduction in
emissions, but reversing the order, with faster change
earlier in the more aggressive scenario.

This model is provided as a starting point, so the parameters should be taken as examples. Given that the
IPCC has deliberately not provided probabilities for
their scenarios [12], in the same spirit we do not claim
that our specific examples are predictions, but rather
case studies on which predictions can be built, once it

The Modelica Association

Results

567

Figure 2. Energy Pattern (late mitigation)

Modelica 2008, March 3rd  4th , 2008

P. Machanick, A. Liebman, P. Fritzson

energy costs in the interim. However, the following
limitations in the model favour the late mitigation
strategy and therefore make it appear the better strategy in terms of cost:
 The constant learning rate assumption biases the simulation towards lower costs
for late mitigation, as new technologies
are more efficient, later
o in practice, an aggressive mitigation strategy is likely to increase
the learning rate e.g. if carbon
taxes are passed through to low
emission R&D
 Extra costs of late mitigation to the environment are not factored in, especially if
environmental sequestration becomes less
efficient as CO2 levels rise
 Extra costs of early decommissioning of
polluting plant would be higher in a late
mitigation strategy, as a higher fraction of
such plant would be built later in the
strategy
We should however note that even where the
faster mitigation strategy is more expensive, the gap
is not large (at most 2%), owing to the fact that efficiency strategies are included in the mix.

(a) Less aggressive strategy

(b) More aggressive strategy.
Figure 3. Real Energy Pattern

Figure 4. Energy cost relative to no mitigation

4

Figure 2 illustrates the change in energy pattern
with our late mitigation (less aggressive) strategy. In
this scenario, an abatement strategy has already
started in 2000, and increases up to 2060, when new
measures start to ease off. In the meantime efficiency
measures increase up to 2050. In graphs, energyUse
means virtual energy demand (energy demand not
taking into account reductions caused by efficiency),
energyReal is actual energy demand, allowing for
efficiency measures, energyBlack is energy resulting
in carbon emissions, and energyZeroCO2 is emission-free energy.
Figure 3 contrasts the less aggressive (a) and
more aggressive (b) strategies, this time leaving out
the virtual energy line, since it is the same in all
cases. Required non-emitting energy goes below
zero in (b) because we are more than meeting the
emission target in early years without adding more
zero-emission energy, by aggressive efficiency
measures. This is a flaw in the model, since we
should not force abatement costs to be higher for
more mitigation than is actually needed.
When we compare costs, the two mitigation
strategies come out approximately equal  in the end.
As illustrated in Figure 4 (cost scaled to no mitigation = 1), the fast mitigation strategy results in higher
The Modelica Association

Conclusions

This model provides a starting point for evaluating
abatement paths for bringing CO2 levels into line
with requirements for stabilizing climate change.
We have modeled a limited range of scenarios to
illustrate the techniques. Once it becomes clearer
which scenarios are more probable, it will be a simple matter to rerun the model with different parameters.
In our future work we will investigate a wider
range of scenarios, and fine-tune the model for a better fit to the real world, for example, changes in environmental sequestration as CO2 levels rise. We will
also fine-tune economic assumptions, to allow for a
range of policy options such as more aggressive support for R&D for low-emissions technologies, and
carbon taxes.

5

Acknowledgements

This work was supported by ARC Centre for Complex Systems Univ. Queensland, by Vinnova in the
Safe and Secure Modeling and Simulation project,
and by the Swedish Science Council (VR). Philip
Machanick has been hosted by the School of ITEE,
University of Queensland as a Visiting Fellow.

568

Modelica 2008, March 3rd  4th , 2008

Modeling of CO2 Reduction Impacts on Energy Prices with Modelica

References
[1] Peter Fritzson, Peter Aronsson, Hkan Lundvall,
Kaj Nystrm, Adrian Pop, Levon Saldamli, David Broman. The OpenModelica Modeling,
Simulation, and Development Environment. In
Proceedings of the 46th Conference on Simulation and Modelling of the Scandinavian Simulation Society (SIMS2005), Trondheim, Norway, [11]
October 13-14, 2005.
http://www.ida.liu.se/projects/OpenModelica
[2] Peter Fritzson. Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1, 940
pp., ISBN 0-471-471631, Wiley-IEEE Press,
2004.
[3] The Modelica Association. The Modelica Lan[12]
guage Specification Version 3.0, Sept 2007.
http://www.modelica.org.
[4] Peter Fritzson et al. The OpenModelica Users
Guide, July 2007.
http://www.ida.liu.se/projects/OpenModelica.
[5] JE Hansen. Scientific reticence and sea level rise,
Environ. Res. Lett., vol. 2 no. 2 April-June 2007
[6] GC Hegerl and FW Zwiers and P Braconnot and
NP Gillett and Y Luo and JA Marengo Orsini and
N Nicholls and JE Penner and PA Stott, Chapter
9: Understanding and Attributing Climate
Change. In Climate Change 2007: The Physical
Science Basis. Contribution of Working Group I
to the Fourth Assessment Report of the Intergovernmental Panel on Climate Change (ed. S
Solomon and D Qin and M Manning and Z Chen
and M Marquis and KB Avery and M Tignor and [13]
HL Miller, pages 663-745, Cambridge University
Press 2007
[7] Peter M. Cox, Richard A. Betts, Chris D. Jones,
Steven A. Spall and Ian J. Totterdel. Acceleration
of global warming due to carbon-cycle feedbacks
in a coupled climate model, Nature vol. 408, 9
November 2000, pp 184-187
[8] John E. Dore, Roger Lukas, Daniel W. Sadler and [14]
David M. Karl. Climate-driven changes to the
atmospheric CO2 sink in the subtropical North
Pacific Ocean, Nature vol. 424, 14 August 2003
pp 754-757
[15]
[9] Richard A. Feely, Christopher L. Sabine, Kitack
Lee, Will Berelson, Joanie Kleypas, Victoria J.
Fabry and Frank J. Millero. Impact of Anthropogenic CO2 on the CaCO3 System in the Oceans,
Science 16 July 2004: Vol. 305. no. 5682, pp.
362  366
[16]
[10] IPCC, 2007: Summary for Policymakers. In: Climate Change 2007: The Physical Science Basis.

The Modelica Association

569

Contribution of Working Group I to the Fourth
Assessment Report of the Intergovernmental
Panel on Climate Change [Solomon, S., D. Qin,
M. Manning, Z. Chen, M. Marquis, K.B. Averyt,
M.Tignor and H.L. Miller (eds.)]. Cambridge
University Press, Cambridge, United Kingdomand New York, NY, USA.
IPCC, 2007: Summary for Policymakers. In: Climate Change 2007: Mitigation. Contribution of
Working Group III to the Fourth Assessment Report of the Intergovernmental Panel on Climate
Change [B. Metz, O.R. Davidson, P.R. Bosch, R.
Dave, L.A. Meyer (eds)], Cambridge University
Press, Cambridge, United Kingdom and New
York, NY, USA.
Nebojsa Nakicenovic, Joseph Alcamo, Gerald
Davis, Bert de Vries, Joergen Fenhann, Stuart
Gaffin, Kenneth Gregory, Arnulf Grbler, Tae
Yong Jung, Tom Kram, Emilio Lebre La Rovere,
Laurie Michaelis, Shunsuke Mori, Tsuneyuki
Morita, William Pepper, Hugh Pitcher, Lynn
Price, Keywan Riahi, Alexander Roehrl, HansHolger Rogner, Alexei Sankovski, Michael
Schlesinger, Priyadarshi Shukla, Steven Smith,
Robert Swart, Sascha van Rooijen, Nadejda Victor, Zhou Dadi. IPCC Special Report on Emissions Scenarios (SRES),: Special Report on Emissions Scenarios, Working Group III, Intergovernmental Panel on Climate Change (IPCC),
Cambridge University Press, Cambridge, 2000.
http://www.grida.no/climate/ipcc/emission/index.
htm
Nebojsa Nakicenovic, Arnulf Grbler, Stuard
Gaffin, Tae Tong Jung, Tom Kram, Tsuneyuki
Morita, Hugh Pitcher, Keywan Riahi, Michael
Schlesinger, P. R. Shukla, Detlef van Vuuren,
Ged Davis, Laurie Michaelis, Rob Swart and
Nadja Victor. IPCC SRES Revisited: A Response, Energy & Environment, vol. 14, nos. 2 &
3, 2003, pp 187-214.
Olive Heffernan. A push for political will, Nature
Reports Climate Change, vol. 6 Nov 2007 p 79.
http://www.nature.com/climate/2007/0711/pdf/cli
mate.2007.60.pdf
Up in smoke? Threats from, and responses to, the
impact of global warming on human development, New Economics Foundation, London,
2004,
http://www.neweconomics.org/gen/uploads/igeeb
que0l3nvy455whn42vs19102004202736.pdf
J. Hansen, Mki. Sato, P. Kharecha, G. Russell,
D.W. Lea, and M. Siddall. Climate change and

Modelica 2008, March 3rd  4th , 2008

P. Machanick, A. Liebman, P. Fritzson

[17]
[18]

[19]

[20]

trace gases. Phil. Trans. Royal. Soc. A, vol. 365,
2007, pp 1925-1954, doi:10.1098/rsta.2007.2052
Clean Air Act, US Government, 1990
W.D. Montgomery, Markets in Licenses and Efficient Pollution Control Programs, Journal of
Economic Theory 5 (Dec 1972):395-418
Per-Anders Enkvist, Tomas Nauclr and Jerker
Rosander. A cost curve for greenhouse gas reduction, The McKinsey Quarterly, no. 1 2007, pp 3545
Diana Farrell, Scott S. Nyquist and Matthew C.
Rogers. Curbing the growth of global energy
demand, The McKinsey Quarterly Web exclusive, 12 pp, July 2007

Appendix  The Complete Model

parameter Real abatementCatchupRate=1 "From
final abatementPlan to end of sim";

class CarbonWorldXIIa
parameter Integer scenario=1 "1 for faster
early abatement, to 2 for slow early
abatement or 3 for 0 abatement";
parameter Real gamma = 0.006725 "Correction
factor which can be used to account for
concentration dependent sequestration such as
sea and bio-";
parameter Real absorptionFactor = 0.5;
Real emission(start = baseEmission);
Real carbConc(start=384)
"Carbon Concentration";
Real abatementCO2(start =
startAbatementCO2);
Real abatementEfficiencyCO2 (start=0);
Real abatementCO2Imputed;
Real energyZeroCO2 (start = 0 );
Real energyEfficiency (start = 0 );
Real energyReal (start = 0);
Real abatementCost;
Real energyPrice(start =
longTermEnergyPrice);
Real carbonPrice(start =
longTermCarbonPrice);
Real energyUse (start = baseEnergyUse);
Real energyBlack;
Real totalCarbonIntensity;
Real totalCarbonIntensity100;
Real efficiencyValue(start =
startEfficiencyValue);
parameter Integer abateCO2 = 1,
efficiencyEnergy = 2, abateEffciency = 3;
Real abatementStepsCO2(start =
plans[1, scenario, abateCO2]);
Real efficiencyStepsEnergy (start =
plans[1, scenario, efficiencyEnergy]),
Real abatementStepsEffciency(start =
plans[1, scenario, abateEffciency]);
parameter Real plans [:,:,:] = {
{{0.22, 0.69, 0.2},{0, 0, 0.76},{0, 0,
0}},

The Modelica Association

{{0.22, 0.69, 0.2},{0, 0, 0.76},{0, 0,
0}},
{{0.57, 5.33, 0.56},{0.72, 15.23, 1.11},
{0, 0, 0}},
{{1.07, 10.64, 0.58},{1.01, 17.76, 0.86},
{0, 0, 0}},
{{1.16, 14.02, 0.65},{0.99, 19.04, 0.83},
{0, 0, 0}},
{{1.69, 23.47, 0.72},{1.52, 25.11, 0.78},
{0, 0, 0}},
{{1.84, 28.18, 0.76},{1.84, 28.18, 0.76},
{0, 0, 0}},
{{1.52, 25.11, 0.78},{1.69, 23.47, 0.72},
{0, 0, 0}},
{{0.99, 19.04, 0.83},{1.16, 14.02,
0.65},{0, 0, 0}},
{{1.01, 17.76, 0.86},{1.07, 10.64,
0.58},{0, 0, 0}},
{{0.72, 15.23, 1.11},{0.57, 5.33,
0.56},{0, 0, 0}},
{{0, 0, 0.76},{0.22, 0.69, 0.2},{0, 0,
0}}
};

570

parameter Real energyGrowthExp=0.0,
energyGrowthLinear=20.0/(GJ_MWh/energyConvFac
tor);
parameter Real tonnesToPPM =0.127365 "from
H:-aliebman-My Research-Energy-Climate
Change-Emissions trading-AL - Carbon Trading
Research-Modelica ModelsCalibrationData.xls";
parameter Real carbonToCO2 = 3.664
"Conversion between mass Carbon and Carbon
Dioxide";
parameter Real startEfficiencyValue= 31.06
"150 $/tCO2e";
parameter Real startAbatementCO2=5 "tCO2e";
parameter Real learningRate=0.02;
parameter Real GJ_MWh=3.6,
energyConvFactor=GJ_MWh "GJ_MWh or 1.0";
parameter Real baseEmission=40 "40 GtCO2e
from energy sector - McKinsey", baseEnergyUse
= 411*energyConvFactor/GJ_MWh "IPCC Special
Report on Emission Scenario (SRES) 2000 linear fit and interpolation between 19902050 ";
parameter Real baseCarbonIntensity =
baseEmission /baseEnergyUse "0.7
/energyConvFactor - tonnes/MWh converted to
tonnes/GJ";
parameter Real carbonPassThrough = 1;
parameter Real longTermEnergyPrice = 80
/energyConvFactor; //"$100/MWh long term
energy price" // Will need to be a dynamic
quantity later
parameter Real longTermCarbonPrice = 0.0;
// "$20/tCO2 long term abatement /carbon
cost" // Need to check this actually makes
sense!
parameter Real energyPriceMRR = 1.0 "Energy
price mean reversion rate";
parameter Real carbonPriceMRR = 1.0 "Carbon
Price mean reversion rate" ;
Real relEnergyPrice (start = 1);
Real energyCostTrend (start = 1);
Real scaledEnergyPrice (start=0);

Modelica 2008, March 3rd  4th , 2008

Modeling of CO2 Reduction Impacts on Energy Prices with Modelica

Integer which (start = 2); // used which =
1 to initialize abatements

baseCarbonIntensity - energyPrice);
der(carbonPrice) =
carbonPriceMRR*(abatementCost carbonPrice);
totalCarbonIntensity100=
100*totalCarbonIntensity;
energyReal = energyBlack + energyZeroCO2;
end CarbonWorldXIIa;

function nextStep
input Real data[:,:,:];
input Integer i,j,k;
output Real step;
algorithm
step := data[i,j,k];
end nextStep;
equation
energyCostTrend = relEnergyPrice *
energyUse / baseEnergyUse;
// useful to compare strategies on cost
relEnergyPrice = energyPrice /
longTermEnergyPrice;
// useful to compare energy cost across
strategies that vary total use
scaledEnergyPrice = relEnergyPrice *
energyReal / energyUse;
abatementCost =
efficiencyValue*(sqrt(abatementCO2/startAbate
mentCO2) - 1);
der(efficiencyValue) = learningRate*efficiencyValue " longTernmEnergyPrice *
someKindOfCarbonIntensity)";
when sample(0, 10) then //StartTime
which = if pre(which) < size(plans,1)
then
pre(which) + 1 else pre(which);
end when;
abatementStepsCO2 = nextStep (plans, which,
scenario, abateCO2);
efficiencyStepsEnergy = nextStep(plans,
which, scenario, efficiencyEnergy);
abatementStepsEffciency = nextStep(plans,
which, scenario, abateEffciency);
der(abatementCO2) = abatementStepsCO2; //
This is a carbon dioxide quantity
der(energyEfficiency) =
efficiencyStepsEnergy*energyConvFactor/GJ_MWh
; // This is an energy quantity
der(abatementEfficiencyCO2) =
abatementStepsEffciency; // This is a
carbon dioxide quantity
energyZeroCO2=(abatementCO2abatementEfficiencyCO2)/baseCarbonIntensity;
energyBlack = energyUse - energyEfficiencyenergyZeroCO2;
emission = energyBlack*baseCarbonIntensity;
abatementCO2Imputed=energyZeroCO2*baseCarbonI
ntensity;
totalCarbonIntensity = emission/energyUse;
der(carbConc) =
tonnesToPPM*(emission*absorptionFactor)gamma*carbConc;
der(energyUse) =
energyGrowthExp*energyUse+energyGrowthLinear;
der(energyPrice) = energyPriceMRR*(
longTermEnergyPrice +
carbonPrice*carbonPassThrough*

The Modelica Association

571

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

572

Modelica 2008, March 3rd  4th , 2008

Modelling of an Adsorption Chiller with Modelica

Modelling of an adsorption chiller with Modelica
Matthias Schicktanz
Fraunhofer Institute Solar Energy Systems
Heidenhofstr. 2, 79110 Freiburg
matthias.schicktanz@ise.fraunhofer.de

Abstract
This paper describes the model of an adsorption
chiller. The model follows a component modeling
approach based on the Modelica Media and Modelica Fluid Library. New models describe the phenomenon of condensing, evaporation and adsorption.
A new library has been created to describe the physical properties of adsorption materials. First simulations were performed and are compared to measured
data of an existing machine. The simulated curves
show good accordance to measured data.
Keywords: thermally driven chiller, adsorption
chiller

1

Fig. 1 shows the working principle of a thermally
driven chiller. It pumps heat from a low temperature
heat source at TC to a middle temperature heat source
at TM powered by heat at a temperature level TH
(TC<TM<TH ).

Introduction

Facing a globally increasing cold demand to cover
the need of comfort in hot areas and at the same time
facing the problem of global warming, the market for
thermally driven chillers is increasing. Thermally
driven chillers produce cold but are powered by heat
instead of mechanical work (electricity). Depending
on the application, heat sources with temperatures
above 70C such as solar heat, waste heat or heat of
a cogeneration unit can be used.

Fig. 1: Thermally driven chiller (TDCs) pump heat
from a low temperature heat source at TC to a middle
temperature heat source at TM and are powered by
heat at a temperature level TH (TC<TM<TH ).

The Modelica Association

Fig. 2: Scheme of an adsorption chiller with two adsorbers. Cited from [3].

Fig 2 shows the technical implementation of an adsorption chiller. It shows four vacuum vessels for the
four main components evaporator, condenser and
two adsorbers. Each component contains a heat exchanger that is connected to one of the three heat
reservoirs TC, TM and TH as mentioned in Fig 1. The
water in the loops is called chilled water, cooling
water and hot water, respectively. The components
are separated by four flaps that control the vapor
flow in the machine. An expansion valve connects
the condenser to the evaporator.
At a low pressure and low temperature level refrigerant (here: water) evaporates in the evaporator and
passes the flap to the left adsorber (2). Thereby it
takes up heat from the chilled water. The left adsorber adsorbs the water vapor at the surface of the
adsorbent coating (here: silica gel). The energy released during this exothermal process is passed to the
cooling water.

573

Modelica 2008, March 3rd  4th , 2008

M. Schicktanz

In the meantime the second adsorber (1) at the right
side gets desorbed powered by energy of the hot water loop. This occurs at a higher pressure level by
heating the adsorbent. The released water vapor
passes the flap to the condenser where it condenses
and releases energy to the cooling loop. The condensate afterwards passes an expansion valve before
reaching the evaporator.

2

Structure of the adsorption chiller
model

mal conductor taken from the Modelica Standard
Library connects the heat exchanger to a condensing
model. In the condensing model simple heat and
mass conservation equations are taken into account.
Within this model, no mass and energy storage takes
place. All condensate is released to the water outlet
connector which is a causal output connector and
was especially designed for this purpose. Opposed to
the standard Modelica Fluid connector it only transmits flow variables (m_flow, H_flow) but no state
variables (p, h), since the later change during the expansion process in the expansion valve.
hydrauli...

hydrauli...

A...
A...

G=k_cond...

k_value_Con...

Fig. 3 shows the Modelica representation of the
process described above. The four main components
condenser, evaporator and two adsorbers are separated by four flaps. All models are connected via the
fluid port of the Modelica Fluid Library [1]. A causal
connector represents the expansion valve between
condenser and evaporator.

C...

A...
A...

WaterOutlet

SteamPin2

SteamPin1

V

C...

Fig. 4: Graphical Modelica representation of the condenser.

C...

E_in
E...

Fig. 3: Modelica representation of the adsorption
chiller main components.

2.1

Functional Component Models

All main components used in the model have a similar design. Fig. 4 shows the graphical representation
of the condenser.
The model mainly uses components from the Modelica Fluid Library. The ports at the top lead to the
hydraulic connections (here cold water). The golden
box in the middle represents a finned heat exchanger
which is described below. As a first approximation,
the heat transfer coefficient describing the condensation of water vapor at the heat exchangers surface is
assumed to be constant. Therefore, a constant therThe Modelica Association

The models for the evaporator and the adsorber have
the same structure as the condenser but the condensing model is replaced by an evaporation model and
an adsorption model, respectively.
The evaporation model in the evaporator contains
basically the same heat and mass conservation equations as the condensing model, but additionally heat
and mass is stored to describe the refrigerant pool
that covers the heat exchanger. Moreover, the connector for the condensate is defined as input as a
counterpart to the condenser.
The adsorption model contains fundamental heat and
mass conservation equations with internal storage to
describe the adsorption process. The load
x = f ( p, T ) describes the amount of refrigerant
that is adsorbed by the adsorbent

574

x=

mrefrigerant
madsorbent

Modelica 2008, March 3rd  4th , 2008

Modelling of an Adsorption Chiller with Modelica

In equilibrium the load only depends on temperature
and pressure at the adsorbent surface. The specific
adsorption enthalpy had as well as the equilibrium
relation x = f ( p, T ) are defined in the adsorption
material package described below. However, the
speed of adsorption is described as a simple linear
relation between driving pressure and mass flow

m& =  ( p sat  p )

controls the distribution of the cooling water between condenser and cooled adsorber. From a hydraulic point of view both vessels are arranged in
parallel.
A...
Temp_A1_out
A...
H...
T
H...

where psat is the saturation pressure for the refrigerant in the adsorbent, p is the vapor pressure in the
vessel and m& is the mass flow of refrigerant into or
out of the adsorbent.  is an effective diffusion coefficient that describes the kinetics and so for is a fit
parameter [2].

A...
Temp_A2_out
A...
T
M...
M...
const
k=0....

2.2

Finned Heat Exchanger Model

C...
C...

C...

hydrauli...

cp_Fi...

G=k_Tube...

CapacityFins

HTC_Medium...

pipe

CapacityTu...
cp_T...

heatPort

Fig. 5: Modelica representation of a simple finned heat
exchanger.

2.3

Adsorption chiller piping model

Fig. 6 shows a graphical representation of the adsorption chiller piping. The purpose of the piping is
to distribute the flow of the three loops for hot water,
cooling water and chilled water to the four main
components.
The connections to the hot water, cooling water and
chilled water loops are shown on the left side. The
connections to the four vessels from Fig. 3 are on
the right side. The single valve in the lower right

The Modelica Association

E_in

SignalVal...

SignalVal...

E...

Temp_A2

hydrauli...

C...

Temp_A1

Fig. 5 shows a graphical representation of a finned
heat exchanger model. It is a simple model consisting of different heat capacities for fins and tubes and
a constant heat transfer coefficient model that represents the heat transfer from the hydraulic medium in
the pipe to the pipes wall. The pipe model from the
Modelica Fluid Library is applied.

Fig. 6: Modelica representation of the piping of the
adsorption chiller.

The two three-way-valves in the upper left of Fig. 6
control the forward flow of hot water and cooling
water. Either the one or the other adsorber is connected to the hot water loop and cold water loop,
respectively. Similarly, the two three-way-valves in
the middle control the reverse flow. An external controller connected via the control connector at the bottom controls the valves. In order to improve the efficiency of the chiller the reverse flow valves are
switched according to the temperatures in the reverse
flow of the adsorbers. The warmer outlet flow is
connected to the hot water and the colder outlet flow
to the cooling water. Therefore, temperatures at the
adsorber outlets are delivered to the controller.
Switching of the valves in reverse flow occurs at a
later time than switching of the valves in forward
flow.

3

Adsorption Material Properties

At Fraunhofer ISE different adsorption materials are
measure and characterized. The material package in
the adsorber model is therefore defined as replaceable and simulation can be performed with different
materials.

575

Modelica 2008, March 3rd  4th , 2008

M. Schicktanz

3.1

Description of the adsorption physics

According to Dubinins theory [4] the physical equilibrium between temperature, pressure and load in
the adsorber can be described by knowing only one
function

W = f ( A)
in which [W ] = m kg is the adsorption volume onto
the adsorbent surface that describes how much vapor
can be adsorbed. Therefore, it is proportional to the
load
3

x =  W
where  is the density of the refrigerant in the liquid adsorbed state. The adsorption potential
[ A] = J kg describes the conditions of pressure and
temperature charactering adsorption process and is
defined as

A = R  T  ln

p refrigerant
p

with specific gas constant R , saturation pressure of
the pure refrigerant prefrigerant and saturation pressure p of the refrigerant in the adsorbed state. Also
the adsorption enthalpy had is derived from the
characteristic material equation:

 A 
had = hv + A  T   

  ln W  T
Here hv is the specific evaporation enthalpy of the
refrigerant and  is the linear thermal expansion
coefficient of refrigerant in the adsorbed state.
3.2

Each material package is then extended by a partial
base class package. In this partial package all physical adsorption properties as described above are calculated.
So far, all implemented adsorption materials work
with water as refrigerant but in principle it is possible to extend the package to the physical properties
of other adsorption pairs like methanol/activated carbon.

4

Preliminary results and discussion

Simulations with real measured data as input have
been performed in order to compare the model with a
real machine. As working water according to the
IAPWS-formulation from the Modelica Media Library and pair silica gel from the adsorption materials package are used. Measurement data come from
the SorTech SKA PT 402 chiller. Data for temperature and mass flow at the inlets of the adsorption machine are given as inputs for the simulation from the
measurement. Weight of adsorbent and heat capacities are given as parameters. Moreover, switching
times for forward valves in the adsorption chiller
piping are set manually, whereas reverse flow valves
are switched by the controller as described above.
Fig. 7 compares measured data with the simulated
results. It shows the measured temperatures at the
inlet and outlet of the hot water, cooling water and
chilled water loops versus time. Moreover, simulated
results at the outlets are shown.

Implementation of adsorption data in Modelica

The implementation of the adsorption material properties in Modelica follows Dubinins theory to describe all parameters with the W = f ( A) relation. In
practice, for the specific adsorption enthalpy also the
derivative W

A

is needed since Modelica cannot

perform this transformation. Therefore, three functions are needed to describe the properties of a material:
The first function describes the relation between W
and A (which may contain piecewise-defined functions), the second function gives the according derivative and the third function contains the needed
coefficients. The first two functions therefore are
extended by the coefficient function.

The Modelica Association

Fig. 7: Comparison between measured and simulated
data.
Temp_HW_in.T,
Temp_MW_in.T
and
Temp_E_in.T are input data for the inlets of the adsorption chiller. Temp_HW_out.T, Temp_MW_out.T
and Temp_E_out.T are simulated temperature values
at the chillers outlets. HW_out_Measured.y,
MW_out_Measured.y and CW_out_Measured.y are
measured outlet temperatures.

A half cycle needs approximately about 500s. After
this time adsorption or desorption, respectively, stops
and the valves in the piping model are switched to
change operation mode. Therefore, a complete ad-

576

Modelica 2008, March 3rd  4th , 2008

Modelling of an Adsorption Chiller with Modelica

sorption/desorption cycle needs about 1000s. The
peaks especially in the hot and cooling water loop
are caused by this switching process.
The simulated curves show good accordance to the
measured data. After the switching process the simulated output temperature from the hot water loop
(Temp_HW_out.T)
and
measured
data
(HW_out_measured.y) start from a similar temperature and converge against the same final desorption
temperature.
The same is true for the simulated and measured values (Temp_MW_out.T) and (MW_out_measured.y),
respectively, in the cooling water loop.
In both loops the simulated temperature differences
after the switching process are smaller than the
measured values. This might indicate that the switching in the reverse flow valves of the SKA PT 402
happens to soon.
Inlet temperatures actually were supposed to be constant temperatures but the test bench for the chiller
was not able to handle the high power requirement
which resulted in oscillating inlet temperatures. For
example
the
middle
temperature
level
Temp_MW_in.T shows a double overshoot in the
time interval 5800s-5900s. The model can handle
this fluctuation. At the outlet Temp_MW_out.T and
MW_out_measured.y both show a reaction to the
fluctuation. But since the model does not include the
length of the pipes between adsorber and thermometer the simulated reaction happens before the real
measured events.

5

Acknowledgment
I would like to thank SorTech AG for appropriating
measured data.

References
[1]

[2]

[3]
[4]

Casella F., Otter M., Proelss K., Richter C.,
Tummescheit H., The Modelica Fluid and
Media library for modeling of incompressible and compressible thermo-fluid pipe networks. Modelica Conference 2006
Nez, T. Charakterisiserung und Bewertung
von Adsorbentien fr Wrmetransformationsanwendungen. Freiburg im Breisgau,
Germany: PhD thesis, Department for physics, Albert-Ludwigs-Universitt, 2001.
Henning H-M, Solar cooling. Presentation
ISES Beijing, China 2007.
Dubinin M. Physical Adsorption of Gases
and Vapors in Micropores, volume 9, pages
1-70. Academic Press, 1975.

Conclusion

A simulation model for an adsorption chiller on a
component approach has been implemented in Modelica. Even though it consists of simple equations for
heat and mass transfer it already shows good accordance to measured data. It demonstrates the principle
functions of the adsorption chiller and shows reaction to dynamic changes.
Moreover a package for different adsorption materials has been designed according to Dubinin's Theory.
New measurements will also contain pressure data in
the adsorption machine, with this data it will be possible to calibrate the free parameters in the model
which are currently only first approximations.

The Modelica Association

577

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

578

Modelica 2008, March 3rd  4th , 2008

An External Model Interface for Modelica

An External Model Interface for Modelica
Torsten Blochwitz Gerd Kurzbach Thomas Neidhold
ITI GmbH, Webergasse 1, 01067 Dresden, Germany

Abstract
The paper describes the integration of non-Modelica
submodels to a complete Modelica model. We show,
that the Modelica standard interfaces to external
code (external function and external object) are not
suited to integrate the behavior of non-trivial models.
The necessary enhancements of the external object
interface are worked out and the usage is demonstrated.
Keywords: External Function, External Object,
C-Interface

1

Introduction

With ITI-SIM and SimulationX [1] the company ITI
develops and distributes software for system simulation since 1991. SimulationX provides full support
for Modelica since release 3.0. The steadily growing
acceptance of these programs is based on a modern
user interface, which enables engineers an easy
access to modeling, simulation and optimization
techniques by using efficient calculation methods
associated with a wide range of libraries and tools. A
large contribution to this success is the availability of
interfaces to other CAE tools like MATLAB/Simulink, MSC.ADAMS or SIMPACK. In
addition to various forms of co-simulation the C
code based exchange of models between different
tools is also supported. This enables the user to cooperate across team boundaries independent of the
finally used simulation tools. The encapsulation of
the model functionality, which will be achieved by
the compilation of the code generated from the original model, also allows an effective protection against
unwanted insight into the parameters and behavior.
With the description of this interface, as well as our
proposal for its integration into the Modelica language we want to make available the described advantages to the whole Modelica community.

The Modelica Association

2

Motivation

There are different motivations to integrate nonModelica submodels into Modelica models:
1. Sometimes a component is modeled using a specialized simulator for a specific physical domain
(e.g., SIMPACK for complex multi body systems or GT-POWER [2] for combustion engines). For system simulation within a Modelica
simulator the component should be integrated into a Modelica model. Often the model functionality of the special simulator can be exported as
C-code.
2. A supplier has developed a model of a component in Modelica. He wants to supply this model
to the OEM but wants to protect his know how,
contained in the physical model. The safest way
to do that is to provide the model in binary form
as a compiled library with a well defined interface.

Figure 1: Modelica model with embedded external
components

579

Modelica 2008, March 3rd  4th , 2008

T. Blochwitz, G. Kurzbach, T. Neidhold

Modelica currently supports the following interfaces
to external functionality [3]:
 external function interface
 external object interface
According to the Modelica Language Specification
results of external functions may only depend from
their arguments, i.e., the functions have no internal
memory. Complex models do have a memory.
External objects as an improvement of external functions provide a memory context which is reported
between the function calls.
Beside the more or less complex function for the
right hand side of an ODE or DAE, external models
may contain discrete states, state- or time-dependent
events, or delay buffers. To integrate those into the
simulation, information about the objects have to be
exchanged between the external model and the simulation environment. The Modelica external object
interface does not provide the functionality to exchange this information. It must be extended to an
"External Model Interface." The following chapter
describes the requirements to the external model interface resulting from the features of complex
models.
The inclusion of controller code (e.g. ECU code generated by the Real Time Workshop from The MathWorks) is not subject of this article. Such components must be called with a constant sample rate during the simulation. This can be done utilizing the
existing Modelica interfaces (external function or
external object). No extensions are necessary.

3

Requirements for External Model
Interface

3.1 Requirements Resulting from Model Features
At first we consider external models, which are
represented by ordinary differential equations
(ODE). The equations may contain discontinuities.
Such systems are represented by following equations:
(1)
x  f ( x, u, p, z, r, t )
y  g( x, u, p, z, r, t )

(2)

z  h1( x,u,p,r, s, t )

(3)

r  h2 ( x,u,p, z, t )

(4)

The Modelica Association

with:
x ....... Continuous states
u ....... Inputs
y ....... Outputs
p ....... Parameters
z ....... Discrete states
r ........ Root functions
s ....... Sample variables
t ........ Time.
Equation (1) represents the right hand side (RHS) of
the ODE. Equation (2) represents the calculation of
the outputs. Both calculations should be separated in
different functions to enable an optimum arrangement of the external model in the calculation sequence of the enclosing model.
The other equations deal with event handling and
discontinuities.
Events:
Two kinds of events must be handled: time events
and state-dependent events. Time events are produced by timers or the Modelica sample keyword.
They are signaled from the solver to the model by
setting corresponding sample variable s.
State events are signaled from the model to the solver by zero crossings of the root functions r. Discrete
variables z can change its values only at events.
According to our experience a reliable event handling is crucial for a robust and fast calculation.
Reinitialization of States:
At event instants state values may be reinitialized by
the external model. The solver should be informed
about such an operation.
Additional Model Information:
External models of specific domains may provide
further information which eases a robust and fast
solution. Examples are minimum and maximum
permissible values for states (e.g. absolute temperatures and pressures have to be positive).
Other models could provide the Jacobian matrix directly.
It depends on the simulator, if this data is used.
Special Features:
Some special features demand actions on valid
model data. For example, the buffers of delay blocks
must be updated with valid data once after a successful time step. For that reason, the external model
must be called once after successful steps with valid
data and must be informed about that.

580

Modelica 2008, March 3rd  4th , 2008

An External Model Interface for Modelica

Other model features may require the allocation and
freeing of memory or data is to be read from files
once. For that reason special functions must be
called once at the beginning and the end of the simulation run.
3.2 Requirements Resulting from the Integration
into the Enclosing Model
For integration of the external model into the enclosing Modelica model the external model calls must be
correctly positioned in the calculation sequence.
If the outputs of the external model depend only
from states, the arrangement is simple: the external
model must be called before one of the outputs is
needed.
If the external model has direct feed through (outputs
depend directly from inputs) the situation is more
complex. The external model must be called before
the outputs are needed and after the inputs are calculated. If the enclosing model defines dependencies of
the inputs from the outputs of the external model, we
have algebraic loops. The simulator must treat them
in an appropriate manner.
For this reason it is essential for the external model
to provide the information, which output depends on
which input(s). If the model creator is not able to
offer this structural information, the worst case (each
output depends from each input) has to be assumed.
3.3

Technical Requirements

The external model interface for Modelica should be
similar to the Simulink S-function interface from
The MathWorks [4]. This interface is quite well
adopted and widely used.
The realization of the data transfer should be simulator-specific. The external model accesses the data via
functions or macros. These functions or macros are
provided by the target simulator.
The external model interface should be usable by
non-Modelica simulators too. These simulators
should be able to use and/or to create models using
the interface.
We will assume that at least the interface part of external models is written in C. How the external model is linked to the simulator is tool specific and depends on the capabilities of the operating system.

4

The External Model Interface

The external model interface can be seen from the
following three perspectives:
 Specification of the functions and data provided
by the external model.
 Specification of the calling sequence by the
solver.
 Specification of the interface to Modelica.
These three views to the external model interface are
shown in Figure 2.

Modelica
Simulator

EMI
Solver

EM

em.dll

Figure 2: Three views to the external model interface
On the other hand the interface provides a set of
utility functions which can be called from external
model code.
According to the requirements we get the following
data flow between the components (Figure 3).

GUI
p

Enclosing Model

u

x  f ( x,u,p, z,r, t )

z  h1 ( x,u, p, r, s, t )

y  g( x,u,p, z,r, t )

r  h 2 ( x, u, p, z, t )

y

External Model

x

x , z,r

t,s

Solver
Figure 3: Data flow

The Modelica Association

581

Modelica 2008, March 3rd  4th , 2008

T. Blochwitz, G. Kurzbach, T. Neidhold

The details, i.e. which data is to be provided by
which function, are part of the complete specification, which will be published by the authors.
4.1

emcSetNumContStates(emc *C, int_T n)

 Sets the number of continous states.
emcGetContStates(emc *C)

 Returns a pointer to the state array.

External Model View

emcSetSolverNeedsReset(emc *C)

 Informs the solver about a reinitialization of
states.

The data transfer is realized via the external model
context, the structure emc. The external model must
implement the following functions:
void emiInitializeSizes(emc *C)

 Defines the dimensions of the model.
 Transfers additional information (input  output
dependencies)
 Is called multiple times before the calculation.
void emiStart(emc *C)

 Is called once at the beginning of the simulation
run.
 Can be used, e.g., to allocate memory.

The implementation of the emc and the access functions are target tool specific and must be provided by
the simulator manufacturer.
4.2

Solver View

Figure 4 shows a simplified flow chart of the solution process for a Modelica model. It demonstrates
which functions are called at each stage.

void emiInitializeSampleTimes(emc *C)

 Transfers constant sample times.
 Is called once at the beginning of the simulation
run.
void emiInitializeConditions(emc *C)

 Sets the initial conditions for continuous and discrete states.
 Is called once at the beginning of the simulation
run.
void emiTerminate(emc *C)

 Is called once after the simulation run.
 Allocated memory can be freed here.
The following functions are called multiple times
during one calculation step:
void emiDerivatives(emc *C)

 Computes the RHS of the ODE (1), and (3) during event iteration.
void emiOutputs(emc *C)

 Computes the outputs (2).
void emiZeroCrossings(emc *C)

 Computes the root functions (4).
The next function is called once after a successful
calculation step:
void emiUpdate(emc *C);

 Called after a successful calculation step with valid data.
It is not allowed to access the data in the external
model context emc directly. Instead, a set of function or macros is to be used, e.g.:
The Modelica Association

Figure 4: Solution process flow chart
If the integrator works iteratively, the functions
emiOutputs and emiDerivatives may b
called several times at the same time be instant with
temporary data. These functions are to be implemented as reentrant and must not store any data.

582

Modelica 2008, March 3rd  4th , 2008

An External Model Interface for Modelica

For these purposes emiUpdate is called with valid
data once after a successful time step.
The method for robust handling of discrete variables
during event iteration is an open issue at the moment.
There are several possibilities, which should be discussed with other simulator vendors.
4.3

Modelica View

This section describes the enhancements of the external object call interface to the external model interface. The information to be exchanged between
the external model and the Modelica simulator are of
two types:
 Data for the model (parameters, inputs, outputs).
These are exchanged via usual function arguments and appear inside the Modelica model.
 Data for the solver (states, derivatives, residuals,
discrete states, root functions). These are handled implicitly by the simulator using the external
model context.
We suggest the new Modelica built in type "external
model" as an extension of the external object interface. The implicit declaration of the type could be:
class ExternalModelInterface
extends ExternalObject;
function constructor
input String emName;
output ExternalModelInterface emi;
external "C" emi=initEM(emName);
end constructor;
function destructor
input ExternalModelInterface emi;
external "C" terminateEM(emi);
end destructor;
end ExternalModelInterface;

be mapped to the appropriate function calls of the
external model.
The dimensions (nu, np, ny) and the dependencies
of the outputs from the inputs must be known during
the symbolic analyses. This information should be
provided by the external model. To get this information, the external model must be called already during the analyses. This is another difference to the
external object interface.
The usage of the external model interface in a Modelica model is:

model Block "Block with External Model"
input SignalBlocks.InputPin u1;
input SignalBlocks.InputPin u2;
input SignalBlocks.InputPin u3;
output SignalBlocks.OutputPin y1;
output SignalBlocks.OutputPin y2;
ExternalModelInterface emi=
ExternalModelInterface("c:\test.dll");
equation
{y1,y2}=calcEMI(emi,{u1,u2,u3},{1,2,3});
end Block;

As denoted before, the Modelica model handles only
the inputs, outputs, and parameters of the external
model. The other information is exchanged implicitly between the solver and the external model. If the
user wants to access such internal data for debugging
purposes, special functions could be provided.
Access to the states could be given by:
function getEMStates
input ExternalModelInterface emi;
output Real x[nx];
//states
external "C" x=getEMStates(emi);
end getEMStates;

The calculation function is declared implicitly as
follows:
function calcEM
input ExternalModelInterface emi;
input Real u[nu];
//inputs
input Parameter Real p[np]; //parameters
output Real y[ny];
//outputs
external "C" y=calcEM(emi, u, p);
end calcEM;

5
5.1

Differing from the external object interface, the functions initEM, terminateEM and the calculation
function calcEM do not correspond one to one to
the functions of the external model. During the symbolic analyses of the model these functions have to
The Modelica Association

Application Scenarios
Hand-Written External Models

External models can be developed by any programmer. The complete API with all necessary data structures and functions is described in a programmers
manual. Normally it should be the exception to implement an external model completely by hand. Instead, the adaption and integration of existing source

583

Modelica 2008, March 3rd  4th , 2008

T. Blochwitz, G. Kurzbach, T. Neidhold

code according to the external model interface requirements will be the typical task. This way is practicable for single solutions and non-commercial applications. The necessary work can be simplified by
using precast templates.
Model specific code

Target tool specific code

model.c
model.h


emi.c
emi.h

6

Compiler / Linker

em.dll

Figure 5: Work flow for hand-written external
models
5.2

Among S-functions for MATLAB/Simulink and
UFORCE-routines for SIMPACK [5] also real time
targets like ProSys-RT from Cosateq [6] are supported. For the automatic generation of EMIconform model code a new target project type was
added to the SimulationX Code Export Wizard. The
wizard assists the user in the selection of inputs, outputs, and parameters. If a supported compiler is installed, SimulationX is able to build the External
Model DLL immediately. The resulting model library does not need any additional runtime modules
and can be distributed without limitations.

Tool-Generated External Models

For commercial CAE tools the automatic generation
of external models is feasible. The Code Export
Wizard integrated in SimulationX is already able to
generate source code for various target platforms.

Conclusions and Outlook

We have shown how the interface to an external
model in SimulationX is structured.
In one of the next Modelica Design meetings, we
will make a proposal for the new predefined partial
class ExternalModel which represents the model
context inside the Modelica language.
The external model interface will be open for other
software vendors. The interface itself does not contain Modelica specific parts. In this way external
model components could be created and used by
non-Modelica simulators too.
The authors explicitly invite interested colleagues for
discussions about the interface proposal. A detailed
specification is available on requested.

model.mo

7

SimulationX

[1]
[2]
[3]

Code Export Wizard

Model specific code

References

Target tool specific code

[4]

model.c
model.h


emi.c
emi.h

[5]
[6]

http://www.simulationx.com
http://www.gtisoft.com
Modelica Association: Modelica A Unified
Object-Oriented Language for Physical Systems Modeling. Language Specification,
Version3.0, September 5th 2007.
The MathWorks: Writing S-Functions
(Manual), 2002.
http://www.simpack.com
http://www.cosateq.de

Compiler / Linker

em.dll

Figure 6: Work flow for tool-generated external
models
The Modelica Association

584

Modelica 2008, March 3rd  4th , 2008

Two Steady State CHP Models with Modelica : Mirafiori overall Model and Multi-configuration Biomass
Model

Two Steady State CHP Models with Modelica : Mirafiori overall
Model and Multi-configuration Biomass Model
Baligh EL HEFNI

Benot BRIDE

Bruno PECHINE

baligh.el-hefni@edf.fr

benoit.bride@edf.fr

bruno.pechine@edf.fr

EDF R&D
6 Quai Watier
F-78401 CHATOU CEDEX
FRANCE

Keywords : Power Plant, CHP Models, Biomass Model Steady State Modelling, Combined Cycle,
Inverse Problems

Abstract

1 Introduction

Steady state 0D/1D models are useful to check,
validate and improve through simulation the energy
performances of existing heat and/or power plants.
They are also used to find the best design that meets
required economical criteria.
A library of fully static 0D thermal-hydraulics
component models was built. It contains the models of
a grid furnace, gas combustion chamber, electrical
boiler, steam boiler, multifunctional heater, waterwall
gas/water steam exchangers, tubular air heater, steam
turbine, condenser, aero-condenser, pump, drum,
valves, pipes, gas turbine, compressor, kettle boiler,
mixer and splitter etc...
This library now enables us to build models of any
CHP plant. A 0D steady state model of the MiraFiori
heat and power plant was built in order to check,
validate and improve the energy performances of the
plant. A multi configurations steady state model of a
combined heat and power biomass plant was built, the
plant satisfies the steam demand during all the year
and produces electricity with its remaining energy.
Models were built by connecting the component
models in a technological way, so that its topology
reflects the process flow diagram of the plant.
A preliminary calibration of the Mirafiori model was
made based on measurement data obtained from onsite sensors and using inverse calculations. The best
steam cycle configuration for the Biomass CHP plant
was chosen computing various normal conditions
points. The models were then able to compute
precisely the distribution of the steam/water mass flow
rates, pressure and temperature across the network, the
exchangers thermal power, and the performance
parameters of all the equipments. They converge very
quickly, provided that the iteration variables are
properly fed in by the user (approx. 5% of the total
number of variables).
The Modelica Association

585

Modelling and simulation play a key role in the
design phase and performance optimization of
complex energy processes.
Steady state 0D/1D models are useful to check,
validate and improve through simulation the
energy performances of existing heat and/or power
plants. They are also used to find the best design
that meets required economical criteria.
The modelling and simulation of the plant was
originally carried out with LEDA. LEDA is a tool
developed and maintained by EDF since 1982 for
the modelling and simulation of the normal or
incidental operation of nuclear and conventional
thermal plants.
For present and future models, we are using
MODELICA modelling tool. New blocks and
models are being developed with Modelica and
standard guidelines have been adopted for power
plants modelling. It is now used at EDF-R&D as
well as in Engineering Departments.
Modelica models are used by EDF to improve its
knowledge about existing or future types of power
plants, check the design performances and
understand important transients situations.
Besides technical benefits of Modelica, it is likely
that using a free and non proprietary language will
promote partnerships around joint R&D and
engineering projects, thus giving the opportunities
to share development costs between participants.
Two Steady State CHP models with Modelica Mirafiori overall model and Multi-configuration
Biomass model - were built in 2007.
The modelling and simulation were carried out
with the commercial tool Dymola, as it is the most
advanced Modelica based tool up to now.

Modelica 2008, March 3rd  4th , 2008

B. El Hefni, B. Bride, B. Pechine

2 Modelling practices at EDF
Modelling and simulation play a key role in the design
phase and performance optimization of complex
energy processes. At EDF, modelling and simulation
of the plant was originally carried out with LEDA.
LEDA is a tool developed and maintained by EDF for
the modelling and simulation of normal or incidental
operation in nuclear and fossil-fuel power plants.
LEDA models are used by researchers and engineers
in order to improve their knowledge of existing or
future types of power plants, to check the design
performances and to understand important transient
situations.
EDF traditionally used steady state models in order to
check precisely the performances and the design given
by manufacturers. EDF used dynamic models to check
automation and operating procedures and to optimise
design for a specific operation.
In order to improve the performance of its simulation
tools while reducing their cost, EDF R&D made the
decision to replace LEDA with Modelica and the
commercial tool Dymola.
Application fields
 Nuclear power plants.
 Thermal fossil fuel fired power plants
(pulverized coal, fluidized bed, ...).
 Combined heat and power plants.
 Waste to energy.
Utilization fields
 Operation and maintenance.
 Design and analysis.
 Innovative technologies.

3 EDF Modelica Library
3.1

Component models

A library of fully static 0D thermal-hydraulics
component models was built. It contains the models of
a grid furnace, gas combustion chamber, boiler,
electrical boiler, steam boiler, multifunctional heater,
waterwall gas/water steam exchangers, tubular air
heater, steam turbine, condenser, aero-condenser,
pump, drum, valves, pipes, gas turbine, compressor,
kettle boiler, mixer and splitter etc...
The model equations take into account the non-linear
and the state-of-the-art physical behaviour of each
important phenomenon.

3.2

The thermodynamic properties

Properties of flue gases

The Modelica Association

586

The thermo-physical properties of the flue gases
(for the exchangers, gas turbines, compressors, gas
combustions chambers, ..) were computed using
Fortran subroutines called MONOMELD.
Properties of water and steam
The properties for water and steam were computed
from polynomials defined by the international
standard IAPWS-IF97. The efficient original
Modelica implementation of H. Tummescheit was
used.

4 The Mirafiori model
Steady state model of the MiraFiori heat and power
plant was built in order to check, validate and
improve the energy performances of the plant. The
model contains six units (systems) of production :
HP water/steam cycles with 3 gas boiler,
IP water/steam cycles with 4 gas boiler,
2 combined cycles,
2 GT.
As it has already been mentioned, MiraFiori is a
fully static model.
The full model is built by connecting the
component models in a technological way, so that
its topology reflects the functional schema of the
plant (see Figure 7 in the appendix). It is composed
of 420 elementary models, generating 9560
variables and 1950 non-trivial equations.
The model is composed of : 7 gas boilers,14
exchangers, 10 steam turbine stages, 15 pumps, 28
pressure drops, 4 gas turbines, 4 compressors, 4
kettles boilers, 4 gas combustions chambers,
several mixers, several collectors and several
boundary conditions.
It is very important to provide an efficient way to
handle the iteration variables, as the task of setting
them properly is time consuming. It is by no way
automatic, since it requires a good expertise of the
problem to be solved (the number of iteration
variables represent roughly 5% of the total number
of variables).

4.1

Model calibration

The calibration phase consists in setting the
maximum number of thermodynamic variables to
known measurement values (enthalpy, pressure,
mass flow rates), taken from on-site sensors during
performance tests. This method ensures that all
needed
performance
parameters,
size
characteristics and output data can be computed.

Modelica 2008, March 3rd  4th , 2008

Two Steady State CHP Models with Modelica : Mirafiori overall Model and Multi-configuration Biomass
Model

Figure 1 shows the evolution of the efficiencies of
the boilers as a function of the ambient air
temperature calculated through Dymola, the
variation of the efficiencies of the boilers is +/-1%
compared to the nominal value.

The main computed performance parameters are :
 the ellipse law coefficients of the turbines,
 the isentropic efficiencies of the turbines,
 the pressure drop correction coefficients of the
exchangers and of the pipes between pieces of
equipment.
 the compression ratio of the GTs.
Etc.



Air mass flow rate of gas boilers,



thermal power of exchangers,



temperatures and pressures in places where no
sensor are installed.

93.0
92.5
92.0
-10

0

10

20

30

40

50

Ambient air temperature (C)

Figure 2 shows the efficiencies of the boilers as a
function of the excess air, the boilers efficiencies
vary from 94,4% down to 92% when the excess of
air passes from 10% (nominal value) to 90%
(maximum value recorded on the operating data).

Simulation results



The global efficiencies of the water/steam cycles,



The gains or extra costs associated with the
varying operating conditions of the unit
(condenser pressure, exhaust temperature, excess
air, fouling coefficients),
The best operating point with respect to the
various operating conditions of the unit.

Sensitivity analysis

Then, the model allowed us to make a sensitivity
analysis of the effect of air mass flow rate (excess air),
ambient air temperature (combustive), temperature of
the exhaust flue gases and the condenser vacuum on
the thermo-hydraulic behaviour of the power plant
and the efficiencies of boilers.

The Modelica Association

587

Efficiencie of the boiler (%)

96%

After calibration, the model allowed us to make whatif simulation and provide to the plant operators :
 The performances of the equipments (for example
boiler performances),

4.3

94.0
93.5

-20

Etc.



95.0
94.5

Figure 1 - Efficiencies of the boilers as a
function of the ambient air temperature

The main computed outputs are :
 fuel mass flow rate of gas boilers,

4.2

96.0
95.5

Efficiencie of the boiler (%)

A preliminary calibration of the model was made
based on measurement data obtained from on-site
sensors. The model was then able to compute
precisely the distribution of water and steam mass
flow rates, pressure and temperature across the
network, the exchangers thermal power, and the
performance parameters of all the equipments. It
converges very quickly, provided that the iteration
variables (approx. 5 % of the total number of
variables) are properly fed in by the user.

95%
94%
93%
92%
91%
90%
0

20

40
60
Excess air (%)

80

100

Figure 2 - Efficiencies of the boilers as a
function of excess air
Figure 3 shows the efficiencies of the boilers as a
function of temperature of the exhaust flue gases,
the boilers efficiencies decreases by 2% when the
temperature of the exhaust flue gases passes from
110 C (nominal value) to 150 C (maximum value
recorded on the operating data).

Modelica 2008, March 3rd  4th , 2008

96%
96%

Steam turbine power (MW)

Efficiencie of the boiler (%)

B. El Hefni, B. Bride, B. Pechine

95%
95%
94%
94%
93%
93%
92%
100

110

120

130

140

150

160

48.0
47.0
46.0
45.0
44.0
43.0
42.0
41.0
40.0
39.0
0

0.05

0.1

Temperature of the exhaust flue gases (C)

Figure 4 shows the evolution of the power of gas
turbines of the combined cycles as a function of
ambient air temperature. The nominal value of power
of gas turbines is 80.5 MW for ambient air
temperature at 20 C.

0.25

0.3

Figure 5 - Evolution of the steam turbine power
of GT as a function of the condenser vacuum

4.4

Correction curves

The correction curves used to forecast the behavior
of the pieces of equipment. These correction
curves represent a simplified physical model of the
plant, which is fed into a mathematical model used
to compute on a six-week period the cheapest
operating scenario which meets environmental and
technical requirements.
The different correction curves create with the
model are:
 Gas boiler : (Boiler Power / Fuel Power) ,

0

10

20

30

40

50

Ambient air temperature (C)

Figure 4 - Power of gas turbines of the combined
cycles as a function of the ambient air temperature
Figure 5 shows the evolution of the steam turbine
power of the combined cycles as a function of the
condenser vacuum, the loss of the steam turbine
power is about 7,5 MW, between a condenser vacuum
of 50 mbar and a vacuum of 250 mbar.



Steam turbine : (Mechanical Power / Boiler
Power) ,



Gas turbine : (Mechanical Power / Fuel
Power) ,



Combined cycle : (Total mechanical Power /
Fuel Power).
70.0

Boiler power (MW)

Power of gas turbines (MW)

85
84
83
82
81
80
79
78
77
76
75
-10

0.2

Condenser vacuum(bar)

Figure 3 - Efficiencies of the boilers as a function of
the temperature of the exhaust flue gases

-20

0.15

65.0
60.0
55.0
50.0
60

65

70

75

80

Fuel power (MW)

Figure 6 - Example of correction curve :
Evolution of the boiler power as a function of
the fuel power

The Modelica Association

588

Modelica 2008, March 3rd  4th , 2008

Two Steady State CHP Models with Modelica : Mirafiori overall Model and Multi-configuration Biomass
Model

5.3

5 Biomass
model

CHP

steady

state

Recent developments of environmental concerns
drove states to promote renewable energies and
energy efficient solutions. Some invitation to tender
often are proposed so as to create new biomass CHP
plants at the best operating cost.

5.1

Need

Companies answering to these invitations to tender for
biomass CHP plants shall be able to choose the best
configurations for the plants in order to reach the
following criteria:


The yearly average efficiency (steam +
electricity) is greater than 50%;



The plant is able to satisfy the steam demand
of the customer (usually an industry) at all
time;



The yearly biomass consumption is fixed;



The return on investment time is as low as
possible.
Usual studies for this type of issue only give an
efficiency at nominal point for one or two plant
configuration. Models are able to provide various
configurations and what-if studies in order to broaden
the range of efficiency calculations and help the
company to choose the best investment.
One of these companies asked us to assist them by
creating and using a MODELICA Biomass CHP
plant.

5.2

Building the model

This model uses the same library as the Mirafiori one.
It is a fully static model. It also needs to use the same
physical properties as Mirafiori.
The full model is built by connecting the component
models in a technological way, so that its initial
topology reflects the functional schema of the more
complex plant (see Figure 7C in the appendix).
In order to be able to answer to many different
situations, we created some variables in some of the
component model enabling to switch itself on or off.
This multi configurations steady state model of a
combined heat and power biomass plant contains 96
elementary models, generating 2162 variables and 460
non-trivial equations.

The Modelica Association

589

Multi  configuration calculations
at normal operating condition

First the model is able to give figures at nominal
point for various situations.
The same model can simulate 16 different plant
configurations:


w/wo air heater



w/wo reheaters



w/wo water heating

 w/wo condenser
NB: any fuel can be set into the grid furnace, but
its physical equations are ideal for solid fuels (coal,
waste, biomass etc.).
The plant works with a fixed biomass flow rate, it
satisfies the steam demand during all the year and
produces electricity with its remaining energy.
We make an inverse calculation (such as the
calibration phase for Mirafiori model) with
DYMOLA setting the nominal parameter to their
expected value in the plant projects.
The results given by the model are :


The efficiency at nominal point (steady
state calibration),



The electric power produced

These results at nominal point are a first step to
choose the best configuration regarding the
investment cost of each type of plant.

5.4

What-if steam demand varies?

Of course, the results given at nominal point are
not consistent to know precisely the average
performance on a one-year operation.
Consequently, we use what-if ability of
DYMOLA/MODELICA model in order to realize
the following computations :


What-if simulation varying any parameter:
e.g. steam flow rate,



Economic study on a one-year typical
steam demand (what-if quasi-static
simulation).
The forecast of steam demand is defined as a load
curve with 365 values of flow rate (one per day). It
is based on measurements made by the customer
on a past year considered as normal. The variation
of the steam flow rate makes the global efficiency
vary and changes the electric power produced.

Modelica 2008, March 3rd  4th , 2008

B. El Hefni, B. Bride, B. Pechine

Hence the best yearly average figures (global
efficiency, electric power) are given by the model.
It gives a much better forecast of the incomes that will
be generated by the plant.

5.5

Creation of a tool for non-modeller

The executable file of the model has been integrated
in an easy-to-use Excel sheet for non-modelers, and it
was given to our customer.
With this tool, one who is not used to models can
make calculations on any plant configuration and
launch what-if calculation varying steam demand.

5.6

References
[1] El Hefni B., Bouskela D. Modelling of a
water/steam cycle of the combined cycle
power plant Rio Bravo 2 with Modelica
Modelica 2006 conference
[2] Souyri A., Bouskela D. Pressurized Water
Reactor
Modelling
with
Modelica
Modelica 2006 conference
[3] Avenas C. et al. Quasi-2D steam generator
modelling with Modelica. ISC2004,
Malaga, Spain.

Trigeneration issues

An absorption chiller model is being created in the
static library. This could represent one-stage or two
stage Water/LiBr systems on hot water or hot flue gas.
This will give us the ability to model trigeneration
systems in order to compute performance figures for
existing and projected plants and to simulate various
behavior.
The optimal point, harder to find for a trigeneration
than for a CHP, will easily be found with a
DYMOLA/MODELICA model.

Conclusion
Two Steady State CHP Models were built with
Modelica to evaluate the capacity of Modelica based
tools to perform steady state direct and inverse
computations for the sizing of power plants.
To even further reduce the effort required to do
Modelica modelling and simulation for such systems,
it is necessary to provide more advanced tool
functionalities to handle efficiently the iterations
variables, and trace the automatically generated
numerical system back to its original mathematical
equations, as declared by the user with the Modelica
language.
Nevertheless, this work shows that the Modelica
technology is mature enough to replace proprietary
solutions such as LEDA for the steady state modelling
and simulation of power plants.

The Modelica Association

590

Modelica 2008, March 3rd  4th , 2008

Two Steady State CHP Models with Modelica : Mirafiori overall Model and Multi-configuration Biomass
Model

Appendix
IP Water/steam cycles

HP Water/steam cycles

Figure 7A - Parts of the Dymola model of Mira-Fiori

Gas turbines

Combined cycles

Figure 7B - Parts of the Dymola model of Mira-Fiori

The Modelica Association

591

Modelica 2008, March 3rd  4th , 2008

B. El Hefni, B. Bride, B. Pechine

w/wo air heater

w/wo condenser

w/wo reheater

w/wo water heating

Figure 7C Dymola steady state model of a biomass CHP plant

The Modelica Association

592

Modelica 2008, March 3rd  4th , 2008

Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives with Modelica

Efficient Analysis of Harmonic Losses in PWM Voltage Source
Induction Machine Drives with Modelica
Johannes V. Gragger

Anton Haumer Christian Kral Franz Pirker
Arsenal Research
Giefinggasse 2, 1210 Vienna, Austria

Abstract
This paper presents an approach to calculate the copper and core losses caused by harmonics of the PWM
of a voltage source inverter. For the analysis some
models of the Smart Electric Drives (SED) library,
and additionally, a Modelica library for modeling
AC circuits by means of electric time phasors, are
used. With the proposed analysis the influence of
space phasor PWM signals on the machine efficiency
is investigated. A Modelica model of a speed controlled induction machine drive working at different
load points and different switching frequencies is
presented. The results of the simulation are compared
and discussed.
Keywords: induction machine, inverter, speed controlled drive, efficiency, copper losses, core losses,
space phasor PWM, SED library

1

Introduction

In most variable speed drives pulse width modulation
(PWM) voltage source inverters are used. Usually
machine design tools only consider the fundamental
harmonic of the stator voltage when calculating the
losses. The major aim of the presented work is to investigate the negative impact of PWM switching on
additional losses in the machine windings and the iron
cores. These additional losses are caused by harmonics of the voltage and the current due to the PWM. The
harmonic losses of the induction machine are modeled
using the AC library, which is based on the stationary
analysis with complex time phasors [1].
A number of algorithms for PWM voltage generation
are available. Some well known techniques are unipolar voltage switching and bipolar voltage switching
[2], harmonic elimination [3] and space vector PWM
[4]. In fact there are many more techniques in which
The Modelica Association

the basic principles of the ones mentioned are used
with some modifications. Different PWM algorithms
cause different voltage harmonics. These voltage harmonics give rise to current harmonics due to the machine impedance. The voltage harmonics cause additional core losses whereas the current harmonics cause
additional losses in the stator and rotor winding of the
machine. Moreover, the frequency of the carrier signal has a significant influence on the voltage and current spectra and consequently increases the losses arising in the machine. It is widely accepted that PWM
switching has a negative impact on the efficiency of
the drive and some efforts had been undergone to calculate the amount of losses caused by PWM switching.
In [5, 6, 7, 8, 9] finite element analysis (FEA) techniques are implemented, which require high computational expenses for calculating the additional losses. In
an FEA model the ohmic heat losses due to the PWM
switching are inherently covered. The additional core
losses are computed by a frequency and flux dependent model, which is evaluated locally throughout the
machine volume.
Alternatively, the harmonic losses can be assessed
keeping the processing efforts low by defining specific
loss factors [10]. In this case it is crucial to keep the
energy balance between the electric terminals and the
shaft of the machine consistent.
In this paper the energy balance is implemented
straight forward by defining an equivalent circuit [11,
12, 13, 14]. The presented work is based solely on
analytical equations using data from conventional induction machine calculation programs without FEA.
An equivalent circuit with elements taking deep bar
effects and the influence of the stator voltage and the
stator frequency on iron losses into account is used to
calculate the harmonic losses with the principle of superposition. The proposed models are designed such
way that it takes only little effort to replace the PWM
algorithm by an alternative one and to change machine

593

Modelica 2008, March 3rd  4th , 2008

J. V. Gragger, A. Haumer, C. Kral, F. Pirker

Figure 1: Three phase full bridge.

Figure 3: Reference signals and resulting PWM signals, vPW M , of the investigated space vector PWM algorithm.

Figure 2: Possible voltage space vectors of a three
phase space vector PWM.
data in order to benchmark different variable speed
drive setups.

2

PWM voltage generation

The PWM waveform depends on the control unit and
the converter topology. In this work one of the most
commonly used PWM waveforms is analyzed, the
space vector PWM. Space vector PWM can be implemented if a three phase converter of the topology
shown in fig. 1 is used. The states of the six switches
(S1 to S6 ) must be chosen such way that the switches
of one leg of the converter switch complementary. Neglecting dead times, it must hold that whenever one
switch of a leg is ON the other one must be OFF. By
no means both can be ON at the same time.
There are eight possible combinations for the switch
commands, which result in seven elementary output
voltage space vectors as shown in fig. 2. By using
PWM for switching between these seven elementary
space vectors any space vector position can be realized. The output phase voltages of a space phasor
PWM controlled three phase full bridge are shown in
fig. 3.
Using the models of ideal switching converters and the respective PWM control blocks from
the SED library [15, 16], it is possible to compare the
quality of PWM signals with different switching freThe Modelica Association

quencies (and with different switching algorithms). In
fig. 4 the spectra of space vector PWM with two different frequency ratios are shown where vre f is the
phase voltage amplitude of the reference space vector rotating with constant angular speed and magnitude and fre f is the frequency of the phase voltage.
The frequency per unit (p.u.) is fref f and the voltage
p.u. is vrev f . It appears that space vector PWM with
high switching frequency, fSwitch , causes considerably
lower harmonics with low order numbers than space
vector PWM with low switching frequency. If the
spectrum of the PWM voltage signal and the frequency
dependent impedances of the machine are known the
harmonic copper losses and the harmonic core losses
can be calculated. It can be shown that high switching frequencies help decreasing the iron losses and the
copper losses in voltage source inverter drives.

3 Model of the copper losses
The copper losses in an induction machine can be determined by using the well known single phase equivalent circuit [17]. Figure 5 shows the Modelica model
of the investigated induction machine. This equivalent
circuit represents the machine behavior in steady state
operation. The connectors used in the equivalent circuit model contain complex current time phasors as
flow variables and complex voltage time phasors as
potential variables. Furthermore, the reference frame
of the time phasors is defined by a reference angle  in
the connectors. For the calculation of the copper losses
the deep bar effects of the rotor stray inductance and

594

Modelica 2008, March 3rd  4th , 2008

Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives with Modelica

with
Rmech = Rr

1  s
.
s

(7)

For each harmonic order, the power dissipated by Rr
represents the copper losses in the rotor and the power
dissipated by Rmech represents the mechanical power
of the machine distributed to the shaft (without considering stray load losses) [17].
According to [21] the deep bar effects in rotor bars
with rectangular profile can be considered by a resistance factor
KR =  

Figure 4: Spectra of space vector PWM voltages with
low and with high switching frequency.

sinh(2 ) + sin(2 )
cosh(2 )  cos(2 )

(8)

and an inductance factor
the rotor resistance are considered. Skin effects in the
stator resistance and stator inductance are neglected
because they can be mostly avoided through wires with
small radial length in the stator winding [18]. Saturation effects are neglected as well.
The slip with respect to a certain harmonic depends
on the orders of this harmonic. It can be shown that
the rotational directions of the spatial harmonic waves
of the stator field are dependent on the order number
[19]. Therefore the slip related to the different voltage
harmonics,
  m
(1)
s =

where m is the shaft speed of an equivalent two pole
machine and the angular velocities of the harmonic
waves of the stator quantities,
 = 1  .
Using (1) and (2) the slip can be written as
s = 1 

1  s1
.


KI =

3 sinh(2 )  sin(2 )
,

2 cosh(2 )  cos(2 )

(9)

with
 = h 

s

0  2 f b
 .
2
bs

(10)

The subsidiary quantity  is a function of the bar
height, h, the frequency of the voltage harmonic, f ,
the specific resistance of the rotor bars, , the width
of the rotor bar, b, and the width of the rotor slot, bs .
Hence, the rotor resistance,
0

0

0

Rr = KR  Rr,var + Rr,const .

(11)

0

In (11) the constant resistance, Rr,const , represents the
(2) end rings and the parts of the rotor bars that are not
embedded in the slots whereas the variable resistance,
0
KR  Rr,var , represents the parts of the rotor bars that
are embedded in the slot.
(3) The rotor stray inductance is modeled the same way:

0
0
0
In a symmetric induction machine with m phases fed
Lr = KI  Lr,var + Lr,const
(12)
by PWM voltages the order numbers of the harmonics
By calculating the stator current, I s , and the rotor curof the stator field [20] are
rent, I r , of the single phase equivalent circuit for all
 = 2  m  k + 1,
(4) harmonics, the stator and rotor copper loss increase
due to the harmonics can be expressed by
where

k = {0, 1, 2, 3, ...} .
It is well known that
Rr
= Rr + Rmech
Rr =
s
0

The Modelica Association

pCu,s   =

(5)
and
(6)
595

(|I s |2 )
1
|I s1 |2

(13)

0

(Rr  |I r |2 )
1
pCu,r   =
0
Rr1  |I r1 |2

(14)

Modelica 2008, March 3rd  4th , 2008

J. V. Gragger, A. Haumer, C. Kral, F. Pirker

pFe,h = [(

f1 Vs2
f1 Vs 2 f
)  ]=
f Vs1
f1
f Vs12

(19)

pFe,e = [(

f1 Vs 2 f 2
V2
)  ( ) ] = s2 .
f Vs1
f1
Vs1

(20)

In the equivalent circuit shown in fig. 5 the hysteresis
and the eddy current losses are both considered in one
conductor GFe . Using the hysteresis losses, PFe,h1 ,
and the eddy current losses, PFe,e1 , of the fundamental
together with (19) and (20),
GFe =

PFe,h1
PFe,e1
 pFe,h +
 pFe,e .
2
3 Vs
3 Vs2

(21)

Hence, the total harmonic core losses
PFe   = 3  (GFe Vs2 )

(22)

which can also be written as
Figure 5: Equivalent circuit of an induction machine
implemented with Modelica.
Consequently, the total harmonic copper losses are
PCu   = PCu,s1  pCu,s   + PCu,r1  pCu,r  

(15)

Model of the core losses

The core losses, PFe , in an induction machine can be
divided into two parts: the hysteresis losses and the
eddy current losses [22, 23, 24, 25]. Hysteresis losses,
PFe,h , and eddy current losses, PFe,e , can both be expressed as functions of the magnetic flux linkage, ,
and the stator frequency, f :
PFe,h = Fh {2 , f }

(16)

PFe,e = Fe {2 , f 2 }.

(17)

Considering that the voltage is directly proportional to
the flux linkage and the frequency according to
V =   

(18)

the hysteresis losses and eddy current losses caused by
the harmonics of the stator voltage can be calculated
per unit to
The Modelica Association



	

(23)

5 Simulation setup

where PCu,s1 and PCu,r1 are the stator and rotor copper
losses with respect to the fundamental wave.

4

+



pFe,h  1 +

	
 
PFe,e1   pFe,e  1 .

PFe   = PFe,h1 

In mining, chemical, waste water, gas or oil industries
there are high-power medium-voltage variable speed
drives used that work with IGCT or IGBT converters. Such IGCT converters have switching frequency
ranges around 1 kHz and IGBT converters work with
frequencies up to 10 kHz [26].
In this paper a high-power medium-voltage water
pump drive is simulated. The specifications of the
investigated induction machine are shown in table 1.
The spectra of the voltage waveforms generated by
space vector PWM are calculated using the SED library and the Modelica Standard library in a Dymola
simulation environment. In fig. 6 the model calculating the harmonic components from the inverter voltage
is shown. The model contains three ideal reference
voltage signals, a block generating the PWM switching commands, and a model representing a three phase
full bridge with integrated DC-link voltage source as
well as a Fourier analysis block. In the Fourier analysis block the Fourier coefficients, ak and bk , get calculated according to the Euler-Fourier formulas [27] with
two integrators and a sine and a cosine signal source.
The spectral components are computed by converting
the Cartesian coordinates, ak and bk , to polar coordinates, dk and k . From the generated spectral components the harmonic losses are processed through a

596

Modelica 2008, March 3rd  4th , 2008

Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives with Modelica

Table 1: Parameters of the high-power mediumvoltage induction machine.
Induction Machine
Pole Pairs
Nominal Power
Nominal Frequency
Nominal Voltage
Nominal PF
Nominal Slip

[kW]
[Hz]
[V]
[%]

2
1600
50
6000
0.873
0.25

Fourier synthesis in the model shown in fig. 7. The encapsulated induction machine model applied for loss
calculation is depicted in fig. 5. It is fed with an array
of stator voltage time phasors.
In the induction machine model the inner torque components, Tinner , with respect to a harmonic, , are
computed by
Tinner = p 

Pinput  (PCu,s + PFe )
,
(2    f )

Figure 6: Model used for the PWM signal analysis.

(24)

where p is the number of pole pairs, Pinput are the
electrical input power components of the machine,
PCu,s are the stator copper loss components, PFe are
the iron loss components, and f are the harmonic sta- Figure 7: Model of the PWM voltage source induction
tor frequencies. The shaft speed of the induction ma- machine drive.
chine is controlled by an integral action controller such
way that the fundamental component of the mechaniwith mechanical loads such as pumps or fans. Many
cal power
of these loads have an approximately quadratic speed
Pairgap1 = Tinner1  (2    f1 ),
(25) dependent load torque characteristic.
Besides the variation of the operation point also the
matches the reference power, Pre f . Since the friction converter switching frequency is varied. The harmonic
losses, Pf r , are not considered in the equivalent cir- spectra of the PWM voltages with switching frequencuit, the reference power with respect to the shaft of cies of 1950 Hz, 1050 Hz and 450 Hz are calculated
the machine model is determined by
and fed to the machine model.
Pre f = Pm,re f + Pf r ,

(26)

6 Simulation Results

where Pm,re f is the desired mechanical power of the
induction machine. If the actual power, Preal , at the
shaft of the machine model matches Pre f , the desired
operation point is reached.
The harmonic losses of the inverter drive are computed for two different operation points of the machine. In case A the machine is operated at nominal
supply frequency, fNominal , and nominal mechanical
power, PNominal . In case B the machine is simulated
and PNominal
at fNominal
3
27 . The reason for assessing case B
is to investigate the influence of the harmonic losses
specifically in variable speed drives that are connected
The Modelica Association

In table 2 the simulation results of the machine fed
with space vector PWM are presented. The investigations show that increasing the PWM switching frequency decreases the total harmonic core losses. The
total harmonic core losses at a switching frequency of
450 Hz are about 60% higher than at a switching frequency of 1950 Hz. It can also be seen that the total
harmonic copper losses rise much more than the total
harmonic core losses. In case A, for instance, the total
harmonic copper losses become more than ten times
higher if the switching frequency gets decreased from

597

Modelica 2008, March 3rd  4th , 2008

J. V. Gragger, A. Haumer, C. Kral, F. Pirker

Table 2: Modelica simulation results of the high-power medium-voltage induction machine drive.
Case A:
f = fNominal
P = PNominal

Case B:
f = fNominal
3
P = PNominal
27

Switching Frequency = 1950 Hz
Machine Output Power (Fundamental)
Shaft Speed
Stator Current (Fundamental)
Power Factor (Fundamental)
Friction Losses
Core Losses (Fundamental)
Stator Copper Losses (Fundamental)
Rotor Copper Losses (Fundamental)
Core Losses (Harmonics)
Stator Copper Losses (Harmonics)
Rotor Copper Losses (Harmonics)
Efficiency (Fundamental)
Efficiency considering Harmonics

[W]
[rpm]
[A]
[W]
[W]
[W]
[W]
[W]
[W]
[W]

1600000.00
1496.34
179.85
0.87
5566.00
10706.50
8453.70
3928.22
582.59
20.84
436.41

59259.30
499.62
49.19
0.38
1996.00
3039.31
630.36
47.19
377.65
5.46
152.45

[%]
[%]

98.24
98.18

91.21
90.46

[W]
[W]
[W]
[W]
[W]
[W]
[W]

1600000.00
1496.32
180.33
0.87
5566.00
10651.60
8499.40
3952.34
678.37
73.31
1115.07

59259.30
499.62
49.18
0.38
1996.00
3037.93
630.16
47.21
561.57
21.81
463.48

[%]
[%]

98.24
98.13

91.21
89.76

[W]
[W]
[W]
[W]
[W]
[W]
[W]

1600000.00
1496.17
183.42
0.87
5566.00
10312.80
8796.23
4108.64
917.97
461.05
4429.64

59259.30
499.61
49.14
0.38
1996.00
3029.27
628.91
47.35
763.86
125.53
1780.97

[%]
[%]

98.23
97.88

91.22
87.62

Switching Frequency = 1050 Hz
Machine Output Power (Fundamental)
Shaft Speed
Stator Current (Fundamental)
Power Factor (Fundamental)
Friction Losses
Core Losses (Fundamental)
Stator Copper Losses (Fundamental)
Rotor Copper Losses (Fundamental)
Core Losses (Harmonics)
Stator Copper Losses (Harmonics)
Rotor Copper Losses (Harmonics)
Efficiency (Fundamental)
Efficiency considering Harmonics

[W]
[rpm]
[A]

Switching Frequency = 450 Hz
Machine Output Power (Fundamental)
Shaft Speed
Stator Current (Fundamental)
Power Factor (Fundamental)
Friction Losses
Core Losses (Fundamental)
Stator Copper Losses (Fundamental)
Rotor Copper Losses (Fundamental)
Core Losses (Harmonics)
Stator Copper Losses (Harmonics)
Rotor Copper Losses (Harmonics)
Efficiency (Fundamental)
Efficiency considering Harmonics

The Modelica Association

[W]
[rpm]
[A]

598

Modelica 2008, March 3rd  4th , 2008

Efficient Analysis of Harmonic Losses in PWM Voltage Source Induction Machine Drives with Modelica

1950 Hz to 450 Hz. The results also show that the harmonic stator copper losses only make up for a small
share of the entire losses caused by the PWM harmonics. The biggest parts of the PWM harmonic losses
are the harmonic rotor copper losses, especially when
the drive is operated at low switching frequencies. The
overall machine efficiency without stray load losses is
also presented in table 2.

References

It appears that the consideration of harmonic losses
only causes an efficiency decrease from 98.24 % to
98.18 % in case A with fswitch = 1950 Hz. The efficiency decreases from 98.23 % to 97.88 % for fswitch =
450 Hz. For case B the impact of the harmonics is
much higher on the efficiency. At fswitch = 1950 Hz
the efficiency decreases from 91.21 % to 90.46 %. The
largest impact on the efficiency is due to a switching
frequency fswitch = 450 Hz.
From this comparison one can conclude that when designing a machine for variable speed drives the PWM
harmonic losses should be taken into account, especially if PWM frequencies below 1 kHz are used. Furthermore, the overall efficiency values show that as
long as the machine is operated close to the nominal operation point (case A) with switching frequencies above 1 kHz the PWM harmonic losses can be neglected.

7

[2] Mohan and Robbins, Power Electronics, J. Wiley
Verlag, New York, 2 edition, 1989.
[3] H. S. Patel and R. G. Hoft, Generalized techniques of harmonic elimination and voltage control in thyristor inverters: Part I-harmonic elimination, IEEE Transactions on Industry Applications, vol. IA-9, Issue 3, pp. 310317, 1973.
[4] H.W. van der Broeck, H. C. Skudelny, and G.V.
Stanke, Analysis and realization of a pulsewidth
modulator based on voltage space vectors, IEEE
Transactions on Industry Applications, vol. 24,
No. 1, pp. 142150, 1988.
[5] T.C. Green, C.A. Hernandez-Aramburo, and
A.C. Smith, Losses in grid and inverter supplied induction machine drives, IEE Proceedings - Electric Power Applications, vol. 150, no.
6, pp. 712724, 11 2003.
[6] Y. Wu, R.A. McMahon, Y. Zhan, and A.M.
Knight, Impact of PWM schemes on induction motor losses, 41st IAS Annual Meeting,
IEEE Industry Applications Conference, vol. 2,
pp. 813818, 8-12 Oct. 2006.

Conclusions

An analytical approach to calculate the copper and
core losses caused by the harmonics of PWM voltages in variable speed induction machine drives is presented. The derived equations are implemented in
Modelica language applying the AC library for modeling electric circuits by means of time phasors. By using the proposed models the PWM harmonic losses of
a high-power medium-voltage induction machine with
1600 kW are calculated. Furthermore, the influence of
reduced load and changes in the switching frequency
are investigated. The results show that if the switching frequency is low and the machine is likely to be
operated at low load points the PWM harmonic losses
can decrease the overall efficiency of the machine considerably. Still, as long as the switching frequencies
of the PWM are above 1 kHz and the load point does
not vary significantly from the nominal load point the
PWM harmonic losses can be neglected.
The Modelica Association

[1] A. Haumer, C. Kral, J. V. Gragger, and
H. Kapeller, Quasi-stationary modeling and
simulation of electrical circuits using complex
phasors, International Modelica Conference,
6th, Bielefeld, Germany, 2008.

599

[7] C.A. Hernandez-Aramburo, T.C. Green, and
S. Smith, Assessment of power losses of an
inverter-driven induction machine with its experimental validation, IEEE Transactions on Industry Applications, vol. 39, Issue 4, pp. 994
1004, 2003.
[8] S. Mukherjee, G.E. Adams, and R.G. Hoft,
FEM analysis of inverter-induction motor rotor
conduction losses, IEEE Transactions on Energy Conversion, vol. 4, no. 4, pp. 671680, Dec.
1989.
[9] A.M. Knight, P.D. Malliband, C.Y. Leong, and
R.A. McMahon, Power losses in small inverterfed induction motors, IEEE International Conference on Electric Machines and Drives, pp.
601607, 15-18 May 2005.
Modelica 2008, March 3rd  4th , 2008

J. V. Gragger, A. Haumer, C. Kral, F. Pirker

[10] A. Boglietti, G. Griva, M. Pastorelli, F. Profumo, [21] W. Schuisky, Berechnung elektrischer Maschiand T. Adam, Different PWM modulation technen, Springer Verlag, Wien, 1960.
niques indexes performance evaluation, IEEE
International Symposium on Industrial Electron- [22] Th. Bdenfeld and H. Sequenz, Elektrische
Maschinen, Springer Verlag, Wien, 7 edition,
ics, ISIE93 - Budapest., pp. 193199, 1993.
1965.
[11] V. Kinnares, S. Potivejkul, and B. Sawetsaku[23] G. Mller, Elektrische Maschinen - Grundlagen,
lanond, Modified harmonic loss model in PWM
Aufbau und Wirkungsweise, VEB Verlag Techfed induction machines, IEEE Asia-Pacific
nik, Berlin, 4 edition, 1977.
Conference on Circuits and Systems, IEEE APCCAS, pp. 535538, 24-27 Nov. 1998.
[24] V. Del Toro, Electric Machines and Power Systems, Prentice-Hall, Englewood Cliffs, NJ, 1985.
[12] Isao Takahashi and Hiroshi Mochikawa, A new
control of PWM inverter waveform for mini- [25] I. Boldea and A. Nasar, The Induction Machine
mum loss operation of an induction motor drive,
Handbook, CRC Press, London, 2002.
IEEE Transactions on Industry Applications, vol.
[26] B. Bose, Power Electronics and Motor Drives,
21, no. 3, pp. 580587, May 1985.
Elsevier, 2006.
[13] H.W. van der Broeck and H. Skudelny, Analytical analysis of the harmonic effects of a pwm ac [27] Bronstein and Semendjajew, Taschenbuch der
Mathematik, B.G. Teubner Verlag, Leipzig, 19
drive, IEEE Transactions on Power Electronics,
edition, 1979.
vol. 3,2, pp. 216223, 1988.
[14] E. N. Hildebrand and H. Roehrdanz, Losses
in three-phase induction machines fed by PWM
converter, IEEE Transactions on Energy Conversion, vol. 16, no. 3, pp. 228233, Sept. 2001.
[15] H. Giuliani, D. Simic, J. V. Gragger, C. Kral, and
F. Pirker, Optimization of a four wheel drive hybrid vehicle by means of the SmartElectricDrives
and the SmartPowerTrains library, The 22nd International Battery, Hybrid and Fuel Cell Electric Vehicle Symposium & Exposition, EVS22,
2006.
[16] J.V. Gragger, H. Giuliani, C. Kral, T. Buml,
H. Kapeller, and F. Pirker, The SmartElectricDrives Library  powerful models for fast simulations of electric drives, 5th International Modelica Conference 2006, Vienna, Austria, 2006.
[17] R. Fischer, Elektrische Maschinen, Carl Hanser,
Mnchen, 9 edition, 1995.
[18] H. Sequenz,
Die Wicklungen elektrischer
Maschinen, vol. 3, Springer Verlag, Wien, 1954.
[19] G. Mller, Elektrische Maschinen - Theorie
rotierender elektrischer Maschinen, VEB Verlag
Technik, Berlin, 2 edition, 1967.
[20] H. Kleinrath, Stromrichtergespeiste Drehfeldmaschinen, Springer Verlag, Wien, 1980.
The Modelica Association

600

Modelica 2008, March 3rd  4th , 2008

Monte Carlo Simulation with Modelica

Monte Carlo Simulation with Modelica
Joachim Haase
Susann Wolf
Christoph Clau
Fraunhofer-Institute for Integrated Circuits, Design Automation Division
Zeunerstrae 38, 01069 Dresden, Germany
{Joachim.Haase, Susann.Wolf, Christoph.Clauss}@eas.iis.fraunhofer.de

Keywords: Statistical analysis, SAE 2748, Monte
Carlo simulation

consisting of analog and digital components often
belong to this class of systems.
The objective of this paper is to make a proposal
how to handle the description of random parameters
in Modelica in a tool-independent way. Furthermore
a way is presented how to carry out a Monte Carlo
simulation within an existing simulation engine. It is
only required that the simulator supports multiple
runs of a simulation task.
The approach is close to the standard J 2748 prepared by the Electronic Design Automation Standards Committee of the Society of Automotive Engineers (SAE) that describes random parameter handling in a VHDL-AMS simulation problem [2, 3].
Describing parameter variations in nearly the same
way in VHDL-AMS and Modelica offers the opportunity to reduce the effort to provide random parameter data in the design process and to avoid misunderstandings.

1

2

Abstract
Monte Carlo simulation allows to obtain statistical
information derived from estimates of the random
variability of component parameters. The paper
demonstrates how to describe the random characteristic of parameters in a tool-independent manner in
Modelica. Using the multi-run facilities of a simulation engine statistical analysis can be carried out
without any code intervention concerning the tool.
The approach is based on the SAE 2748 standard.
Solutions of implementation problems with respect
to Modelica are discussed. This paper is based on
results, which were developed in the Fraunhofer collaborative project Computer Aided Robust Design
(CAROD).

Introduction

It is more and more required within industrial applications to consider the influence of the variability of
design parameters on the behaviour of systems. For
instance yield and reliability often depend on the
statistical characteristics of such parameters [1].
Monte Carlo methods are widely used to analyze the
effects of parameter tolerances. In a Monte Carlo
simulation, a mathematical model of a system is repeatedly evaluated. Each run uses different values of
design parameters. The selection of the parameter
values is made randomly with respect to given distribution functions. Monte Carlo simulation is very
time consuming. A lot of simulation runs are required to investigate the behavior of a system subject
to the statistical distribution of parameters. Nevertheless, Monte Carlo simulation is very favored in various application areas where an analytical relation
between design and system parameters is difficult to
find. For example mixed-signal electrical systems

The Modelica Association

SAE-Standard J 2748

Some basic requirements that are supported by the
SAE J 2748 standard are summarized in the following. The basic idea is to add information to characterize the parameters. Thus, it should be possible to
use existing models also for statistical analysis. In
detail it is required
 Usage of the same model for nominal and
Monte Carlo analysis
 Possibility to assign different statistical distributions to each constant or parameter
 Support of continuous and discrete distributions
 Permission of user-defined distributions
 Possibility to specify correlation between constants
From a practical point of view the following points
should also be mentioned
 Independent random number generation for any
constant

601

Modelica 2008, March 3rd  4th , 2008

J. Haase, S. Wolf, C. Clau



Reproducibility of Monte Carlo simulation
within the same simulation tool
Statistical distributions are characterized from an
engineering point of view. That means the mathematical parameters as for instance the moments are
derived from engineering parameters as nominal
value, tolerances, minimum and maximum values.
The standard provides implementations of basic
regular distribution functions. Futhermore, standard
functions are provided that allow to declare userdefined distributions. Also truncated distributions
are supported that limit the random numbers to a
given interval.
Table 1: Regular distribution functions [3]
UNIFORM

Uniform distributed values

NORMAL

Gaussian distributed values

PWL_CDF

Piecewise-linear description of a cumulative distribution function

PWL_PDF

Piecewise-linear description of a probability density function

BERNOULLI

Bernoulli distribution

DISCRETE_CDF
DISCRETE_PDF

Tabular description of the probability of
discrete values

4

Realization with Modelica

Using Modelica the idea of a tool independent random number generation is realized in the following
way. As an example the uniform distribution is used
which produces uniformly distributed values within
the interval (nominal  tolerance*nominal, nominal
+ tolerance* nominal). For better reading some details compared to the final solution are simplified.

The VHDL-AMS implementation details are online
available [4].

3

function and its modifications for truncated distributions. The Box-Muller algorithm can be applied for
normal distributed numbers [5].Thus, the main problem during parameter initialization for Monte Carlo
Simulation is to generate independent (0,1) distributed values. [2] describes the requirements to a builtin random number generator provided by a tool.
The basic idea of a tool-independent random number
generator is shown in Fig. 1. The seed values that
are needed to generate a sequence of random numbers are immediately saved in a file.
With the help of global parameters it is possible to
switch between nominal and statistical analysis either w.r.t. parts of a description or the entire simulation task.

4.1

Randomly changed parameters

To supply a parameter (or a constant) with randomly
generated values it is necessary to specify random
distribution in the Modelica source code. Instead of

Method

Methods to create random numbers are in general
based on a (0,1) uniform distributed values.

parameter Real p = nominal;

which specifies a fixed parameter, the specification
of the uniform distribution function call is:

Save seed
values

parameter Real p = uniform(nominal,
tolerance);

4.2
RND
generator

The Modelica function uniform is an interface to a C
function. It is defined like this:
(0,1) uniform
distributed values

Fig. 1. (0,1) uniform random number generator
Widely used methods to generate random number
with a given distribution are the inverse transformation approach based on the cumulative distribution

The Modelica Association

Random number generation

602

function uniform
input Real Mean;
input Real Tol;
output Real random_value;
external "C" uniform(Mean, Tol,
random_value);
end uniform;

Modelica 2008, March 3rd  4th , 2008

Monte Carlo Simulation with Modelica

Within the C function the randomly distributed values have to be calculated. An example is the following function:
void uniform (double M, double Tol,
double *aus)
{ double xMin = M * (1.0 - Tol);
double xMax = M * (1.0 + Tol);
if (xMin > xMax)
{ xMax = xMin;
xMin = M * (1.0 + Tol);
}
*aus = xMin + (xMax - xMin)*RND();
}

Furthermore, the RND function above could be replaced by the random number generator incorporated
in a Modelica simulator by a tool provider. In this
way the file access to seed.dat can be avoided.
4.3

The random function is a (0,1) uniformly distributed
random value generator for instance according to
Schrages method [8]:
double RND()
{ FILE
*read_fp, *write_fp;
long
seed = 2, M = 2147483647;
long
A = 16807, Q = 127773;
long
R = 2836, k;
double F = 1.0/ M;
read_fp = fopen ("seed.dat","r");
fscanf (read_fp, "%ld",&seed);
fclose(read_fp);

After having specified the parameter to be changed
in the Modelica source code, the Modelica function
with the foreign function interface to the C domain,
and the C function random, the following steps are
necessary:
A file seed.dat has to be generated, which contains
an integer starting number for the sequence of random values. If a sequence shall be repeated, the same
seed number must be chosen.
Then the model under investigation (which contains
the parameter specification mentioned above) has to
be simulated by a Modelica simulator repeatedly.
The number of repetitions depends on the wanted
number of trials for the Monte Carlo simulation. After each single simulation the interesting results must
be saved. The results can be visualized or used in
posteriori calculations.
4.4

assert( seed != 0 );
k = seed / Q;
seed = (seed - k * Q) * A - k * R;
if ( seed < 0 ) seed += M;

Remarks

The method allows easily to define both correlated
and dependent random values of parameters. A simple example might explain the procedure:
parameter Real p1 = uniform(1, 0.1);
parameter Real p2 = uniform(p1, 0.01);

write_fp = fopen ("seed.dat","w");
fprintf (write_fp, "%ld", seed);
fclose(write_fp);
return seed * F;
}

By access to the file seed.dat , which has a fixed
name, the seed value is saved between two calls of
the random function.
In the final solution a global change of the seed file
name is possible. In case of a nominal analysis the
final function uniform would deliver the Mean value.
A more convenient way would be to provide the random number generator RND by a Modelica function.
This would allow to formulate the random distribution functions using Modelica language constructs
only. This approach could not be realized in the used
tool environment. From the language point of view it
must be possible that a Modelica function called with
the same arguments may deliver different results. For
this reason, for instance VHDL(-AMS) distinguishes
between pure and impure functions.

The Modelica Association

Application

If the same sequence of randomly generated values is
desired (e.g. to investigate a special effect) the same
seed number and the same seed file name have to be
used at the beginning.

5

Example

Fig. 2. Monte-Carlo-Plot for variables

603

Modelica 2008, March 3rd  4th , 2008

J. Haase, S. Wolf, C. Clau

In the DifferenceAmplifier of Modelica.Electrical.
Analog.Examples [9]. the resistance R of the resistor
R2 is randomly generated by the following formulation:
...
Basic.Resistor R1(R=0.0001);
Basic.Resistor R2(R=uniform(100,0.05));
Basic.Resistor R3(R=0.0001;
...

Repeated simulations using Dymola show that
R2.n.v (the thick line pencil) is sensitive with respect
to R2.R. The voltage R4.n.v (thin line) is not sensitive to that parameter. Basing on the Monte Carlo
results further calculations (density distribution )
are possible.
Furthermore, the randomly chosen parameter values
can also be visualized or used for further calculations. The following figure shows the above specified parameter R2.R which is uniformly distributed
in the interval (95, 105) (=100  100 * 5%, 100 +
100 * 5%).



The user is free to define its own distribution
based on the RND function.
 Correlations can be defined easily.
 For documentation purposes the distribution
specification is part of the model files.
The approach in [7] is also simulator independent,
but is uses a (firm-)specific nested toolkit. Our way
is defined only using the Modelica language.
Whether a language construct like ours is used in [7]
is not documented.

7

Conclusions

An approach to handle statistical analysis problems
within Modelica is presented. It is based on the SAE
J 2748 standard. The current version allows Monte
Carol simulations if the used simulation engine supports multiple runs in a simple way. If the approach
is accepted it could also be the basis of efficient implementation in Modelica simulators. In this case the
generation of the sequences of (0,1) distributed uniform random numbers must be supported without
file access.
The applicability of the approach is demonstrated
with the help of a simple example from the existing
Modelica standard library. Only existing tool and
language features are used. This and the orientation
to the SAE standard are the main advantages of the
approach compared to [7].

Fig. 3. Randomly chosen parameter R2.R

References
6

Discussion

The proposed approach realizes a simple Monte
Carlo simulation based on behavioral descriptions in
Modelica. Beyond the focus of this paper is the usage of the results of the Monte Carlo simulation for
other purposes. For example the data could be used
to create Response Surface Models. This would require to save the randomly generated parameters of
any simulation run. Also improved techniques to
create the random numbers and reduce the simulation effort could be applied. For instance possibilities
of so-called importance sampling [6] could be applied using user defined functions.
The Monte-Carlo-Simulation is also possible using
the Dymola Monte-Carlo feature. The advantage of
the suggested way is:
 It is a more general, tool independent approach.

[1] OConnor, P.D.: Practical Reliability Engineering. John
Wiley & Sons, 2003 (5th ed.)
[2] J2748, VHDL-AMS Statistical Analysis Packages, The SAE
Electronic Design Automation Standards Committee, Troy,
MI, October 2006
[3] Christen, E.; Bedrosian, D.; Haase, J.: Statistical Modeling
with VHDL-AMS. Proc. Forum on Specification and Design
Laguages FDL 07, Barcelona, September 18-20, 2007.
[4] http://links.sae.org/j2748
http://fat-ak30.eas.iis.fraunhofer.de
[5] Saucier, R. Computer Generation of Statistical Distributions. US Army Research Lab ARL-TR-2168, available at
http://ftp.arl.mil/random/random.pdf
[6] Robert, C. P.; Casella, G.: Monte Carlo Statistical Methods.
Springer, 2004 (2nd ed.)
[7] Batteh, J.; Tiller, M.; Goodman, A.: Monte Carlo Simulations for Evaluating Engine NVH Robustness. 4th International Modelica Conference, Hamburg, March 7-8, 2005,
385-392
[8] www.physics.rutgers.edu/grad/509/random.pdf
[9] www.modelica.org/libraries/Modelica

The Modelica Association

604

Modelica 2008, March 3rd  4th , 2008

Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks

Comparisons of Different Modelica-Based
Simulators Using Benchmark Tasks
Olaf Enge-Rosenblatt1), Christoph Clau1), Peter Schwarz1),
Felix Breitenecker2), Christoph Nytsch-Geusen3)
1) Fraunhofer Institute for Integrated Circuits, Branch Lab Design Automation,
Zeunerstrae 38, 01069 Dresden, Germany
olaf.enge@eas.iis.fraunhofer.de
2) Vienna University of Technology, Wiedner Hauptstrasse 8-10, 1040 Vienna, Austria
3) Fraunhofer Institute for Computer Architecture and Software Technology,
Kekulstrae 7, 12489 Berlin, Germany



Abstract
A benchmark library is presented which collects
models for testing and comparing different analog
and hybrid simulators as well as their numerical
simulation algorithms. Many of these models are
described with Modelica and simulated with Dymola
and the Modelica-related simulator Mosilab. But
VHDL-AMS descriptions are also used to compare
simulation results of Modelica simulators with those
of other types of simulators. The motivation of the
selection of benchmark problems, the modeling and
documentation style guide, and some small examples from electronics and mechanics are described.

1

Motivation

2

The development of new simulators and model libraries has to be accompanied by intensive simulations of test examples and their comparison. The first
reason for collecting a new benchmark library was
the development of a Modelica-based simulator
Mosilab [1] and accompanying test examples to ensure the Mosilab functionality. But, there are some
other objectives:
 comparison of Mosilab with commercial
Modelica simulators: Dymola, SimulationX;
 potential extension to comparisons with
other analog simulators (e.g. VHDL-AMS,
Verilog-AMS, SystemC-AMS);
 getting experiences with the numerical properties of the implemented solvers and their
robustness (e.g., influenced by simulator
control parameters);
 testing extreme cases (e.g., depending on the
number of variables and equations as well as
numerical parameter values);
The Modelica Association

collecting models with a special focus on
systems with variable structure;
 preparation of regression tests;
 and, last but not least, pedagogical aspects:
for use in lectures and tutorials.
Therefore, the construction or selection of benchmark models has to fulfill many criteria. The
ARGESIM comparisons ([2], [3]), published in the
journal Simulation News Europe (SNE) and via
http://www.argesim.org/ , have a similar goal. They
are considered here from a common point of view.
Further suggestions are expected from benchmarks
in other disciplines ([7], [8]) or with a general methodological background ([9]).

Types of simulation problems

The benchmark models are selected with respect to
the following tasks:
 simple tests of keywords and other language
constructs (especially for compiler tests and
version checking in the new Mosilab simulator),
 simple but non-trivial electric circuits (from
RLC circuits up to transformers and rectifiers),
 testing typical numerical simulation problems (e.g. stiff differential equations, discontinuities, simulation of ideal oscillators)
 more complicated transistor models which
lead in many cases to numerical simulation
problems in simulators which are not specialized for electronic applications,
 test of advantageous description means (e.g.
object oriented approaches)

605

Modelica 2008, March 3rd  4th , 2008

O. Enge-Rosenblatt, C. Clau, P. Schwarz, F. Breitenecker, C. Nytsch-Geusen









erroneous models (e.g. parallel ideal voltage
sources) to check the simulators behavior in
error cases
inclusion of some classical, mostly nonelectrical ARGESIM comparisons in new or
updated form (until now: C1, C3, C5, C7; in
preparation: C11, C12),
testing the capability of simulating systems
with variable structures (also called structural variability or model structure dynamics, see [3], [4], [5], [6]): rectifiers with
ideal diodes, voltage duplexers with two
ideal diodes, constrained pendulum C7,
string pendulum,
modeling with embedded statecharts (as a
potential extension of the Modelica language), especially for the Mosilab capabilities of handling variable structures.

1

Introduction

5

2
2.1
2.2
2.3
2.4
2.5
2.6
2.7
2.8
2.9
2.10

Small examples, taken from Modelica
Damped RLC oscillator (rlc_osci)
Transformer (trafo)
Ideal diode (ideal_diode)
MOS inverter (mos_inv)
MOS oscillator (mos_osci)
Switched capacitor integrator (sc_integrator)
Test of integrators error (integr_error)
Voltage duplexer (Vduplexer)
Graetz rectifier with resistive load (ideal_graetz)
Graetz rectifier with RC load (ideal_graetz2)

6
6
8
12
15
18
23
27
30
34
38

3
3.1
3.2
3.3
3.4

ARGESIM examples
Comparison 1 (comparison_1)
Comparison 3 (comparison_3)
Comparison 5 (comparison_5)
Comparison 7 (comparison_7)

43
43
48
55
61

4
4.1
4.2
4.2.1
4.2.2
4.2.3
4.2.4
4.3
4.3.1
4.3.2
4.3.3
4.4
4.4.1
4.4.2
4.5
4.6
4.6.1
4.6.2
4.6.3
4.6.4
4.6.5
4.7
4.7.1
4.7.2

Examples with structural variability
Ideal diode using events (ideal_diode_event):
Ideal diode using statecharts
1st realisation (ideal_diodeSC)
2nd realisation (ideal_diodeSCcon)
3rd realisation (ideal_diodeSCdyn)
4th realisation (ideal_diodeSCvN)
Voltage duplexer using statecharts
1st realisation (VduplexerSC)
2nd realisation (VduplexerSCcon)
3rd realisation (VduplexerSCdyn)
Comparison 7 using statecharts
1st realisation (comparison_7SC)
2nd realisation (comparison_7SCdyn)
String pendulum with free motion (fadenpendel)
String pendulum with free motion using statecharts
Realisation fadenpendelSC
Realisation fadenpendelSCaF
Realisation fadenpendelSC1
Realisation fadenpendelSC3a
Realisation fadenpendelSCdyn
Switched capacitor integrator in QV formulation
Realisation without statecharts (sc_integrator_QV)
Realisation with statecharts (sc_integrator_QVSC)

63
63
64
64
67
69
71
75
75
78
81
84
84
86
88
96
96
102
103
103
106
112
112
116

Table 1: Benchmark library

The Modelica Association

ARGESIM continues the comparisons by benchmarks with extended information and prepares special benchmarks with emphasis on various modeling
approaches. In 2008, benchmarks for hybrid modeling and simulation will be published, addressing different modeling techniques for four or five systems
(constrained pendulum, rotating pendulum, heat diffusion with different regimes, rotor dynamics).
The content of the actually implemented benchmark
library is summarized in Table 1. It consists of three
main sections. In the first section, some electrical
examples are collected. The second section deals
with a selection of the ARGESIM benchmarks,
which are mainly published in the journal Simulation
News Europe (SNE). The third section collects examples which are characterized by a variation of the
model structure. Such systems lead to different sets
of differential-algebraic equations and the need of
exchanges between them from time to time during
the simulation process ([1], [4], [5], [10]).

3

Documentation

Each test example is documented in the same manner:
 short description of the problem and the reason for selecting this model,
 graphical description (schematic/sketch),
 definition of relevant physical quantities and
dimensions,
 interface description (e.g., type of signals
and quantities),
 textual input description in the Modelica
language,
 applied simulator control parameters,
 graphical simulation results and some additional textual information,
 discussion of results (e.g., accuracy, runtime behavior) and detected problems.
If the models should be used for regression tests,
further regimentations are necessary.

4

Examples

In this section, some interesting benchmark tasks are
collected and discussed shortly. All examples are
characterized by variable structure because serious
numerical problems consist yet in very small systems.

606

Modelica 2008, March 3rd  4th , 2008

Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks

4.1

Electric example

The electric example shall illustrate the application
of different models of a diode component. For this
purpose, the diode is used within two different wellknown set-ups: a one-way rectifier with an ohmic
load (shown in Fig. 1) and a Graetz rectifier with an
ohmic-capacitive load (depicted in Fig. 2).
R=1
R

Di

Second, an ideal diode model was implemented:
 The voltage in flow direction is zero (conducting state).
 The current in the blocking direction is zero
(cut-off state).
Conditional equations are used for voltage and current always forcing at least one of them to zero. The
source code is shown in Table 3. This implementation requires an event handling by the simulator.
model IdealDiodeEvent
extends OnePort;
Boolean blocking(start=true);
equation
blocking = if pre(blocking)
then v<0 else i<0;
if blocking then
i = 0;
else
v = 0;
end if;
end IdealDiodeEvent;

V=220

M1

M2

Figure 1: One-way rectifier with ohmic load
Rinnen
R=1

Di1

Table 3: Source code of diode using conditional equation

Di3

C1

C=1

R1

R=10

With all simulators under test, very similar simulation results were received for the one way rectifier.
Exemplarily, Fig. 3 shows simulation results for
some voltages calculated by Mosilab using the PWL
diode model. The results of the other simulators are
the same. This statement also holds for the ideal diode model no matter which simulator is tested. Of
course, the current of the blocking diode is now exactly equal to zero or, vice versa, the voltage of the
conducting diode now vanishes completely.

V
Di2

M1

Di4

M2

Figure 2: Graetz rectifier with ohmic-capacitive load

First, the piecewise-linear (PWL) diode model of the
Modelica Standard Library is used. The relevant
source code is shown in Table 2. This model implements the behavior of an idealized switching diode
consisting of a piecewise-linear voltage-current characteristic. A so-called auxiliary variable is used
which implements a parametric representation of the
length of both straight lines [11], [12], [14].

250
V.v

200

R.p.v

150
100
50
0
0

10

20

30

40

50

60

70

80

90

100

-50
-100

model IdealDiode
extends OnePort;
parameter Real Ron= 1.E-5,
parameter Real Goff= 1.E-5;
Boolean off(start=true);
Real s;
equation
off = s < 0;
v = s*(if off then 1 else Ron);
i = s*(if off then Goff else 1);
end IdealDiode;

Table 2: Source code of diode using auxiliary variable

The Modelica Association

-150
-200
-250

Figure 3: Simulation result from Mosilab for a one-way rectifier

In contrast, the electric circuit of the Graetz rectifier
can only be simulated using the PWL diode model
(Table 2). The property of such a circuit, that two
diodes of the four must unconditionally be closed (or
607

Modelica 2008, March 3rd  4th , 2008

O. Enge-Rosenblatt, C. Clau, P. Schwarz, F. Breitenecker, C. Nytsch-Geusen

opened) at the same time, is the reason for this fact.
This conclusion is valid for Dymola as well as for
Mosilab. To handle a circuit with a Graetz rectifier
using ideal diodes, it is necessary to qualify a simulator with the feature of finding a valid new model
structure from the complete set of structures at each
switching point in time.
Some simulation results for the Graetz rectifier using
the PWL diode model are shown in Fig. 4 and Fig. 5.
Fig. 4 depicts some voltages while the corresponding
currents are shown in Fig. 5.
V .v

R1.v

200

[V]

100

0

-100

-200
0

50

100

Figure 4: Voltages of the Graetz rectifier circuit

Rinnen.i

R1.i

C1.i

60

40

(1)

In Equ. (1), the parameters c1 and c3 are fixed while
c2 and c4 have different values depending on the
actual state of the system. State 1 is valid as long as
y1 < 5.8 . Reaching this value, the system state is
changed to state 2 which, then, is valid until y1 goes
below 2.5 . All parameters and initial conditions
were chosen in a very sophisticated manner. This
way, the numerical accuracy of the simulators under
test can be investigated by looking at the switching
points in time, especially at the last one (denoted
with t5) which appears generally at about 5 Seconds.
The Dymola result computed by the DASSL solver
using the highest possible numerical accuracy (tolerance is set to 1E-12) shall be taken as reference for
other simulators. The last switching point in time
appears at t5=4.999999646. Other solvers, like
Runge-Kutta methods, are less suitable for such kind
of a simulation task.
With Mosilab, the switching point in time is found
very well if using the IDA solver which is very similar to the DASSL method. With an absolute tolerance of 1E-14 and a relative tolerance of 1E-10,
the switching point in time can be determined to
t5=4.999999645. Surely, this is a very good result. But using lower tolerances or using one of the
other numerical solvers of the Mosilab simulator
leads to more inexact results.
Exemplarily, Fig. 6 shows the time behavior of y1
using Dymola with the DASSL method as mentioned
above.

20

[A]

= c1 ( y2 + c2  y1 ),
= c3 (c4  y2 ).

y&1
y& 2

0

y1
6

-20
5

-40
4

-60
0

50

100

3

Figure 5: Currents of the Graetz rectifier circuit

2

1

4.2

Two-state model
0

The two-state model considered here is the
ARGESIM comparison C5 which is of high interest
regarding to the numerical behavior of each simulator. The problem consists of the two simple differential equations:

The Modelica Association

0.0

2.5

Figure 6: Time behavior of state variable

608

5.0

y1

Modelica 2008, March 3rd  4th , 2008

Comparisons of Different Modelica-Based Simulators Using Benchmark Tasks

4.3

String pendulum

A string pendulum is shown in Fig. 7. A point mass
is able to perform circular or free (downfall) movements  so-called phases (see Fig. 7A). The circular
movement is characterized by a stretched (but nonwidening) thread, i.e. the mass has the maximal possible distance to the fixing point. In contrast, the
mass has a smaller distance and the thread is folded
during the free movement. This is an extension of the
well-known mathematical pendulum with small
elongations and without the downfall phase.

b) free motion
(downfall)

thread

Pendulum

y

a) circular motion



The simplest description of the circular motion uses
polar coordinates; the downfall motion may be described with Cartesian coordinates. There are two
differential-algebraic equation systems with two and
three variables, respectively, describing both phases
(see Fig. 7B). In phase 1 (circular movement), the
stretching force F in the thread is greater zero. In
phase 2 (free movement), the distance r between
point mass and fixing point is less than the length L
of the thread. The indicator functions ( F < 0 and
r  L ) are used to detect the points in time of a necessary switching between the phases.
A large initial impulse results in a sequence of circular and free movements. This is illustrated in Fig. 7C.
The point mass performs two circles followed by
some swinging movements. The time behavior of the
mass position and the corresponding force F are
shown in Fig. 8 and Fig. 9, respectively.

x

r

x

y

1.5

1.0

0.5

transformation:

F < 0?

 , &  x, x&, y, y&

variables: , F

circular motion

0.0

free motion,
downfall

-0.5

m&x& = kx&,
m&y& = mg  ky&

J&& = mgL sin   &
F = mg cos + mL& 2
( r = konst.)

-1.0

-1.5

r 2 = x2 + y2

0.0

variables: x, y, r
transformation:

y

5.0

Figure 8: Pendulums mass position (x and y)

r  L?

x, x&, y, y&   , &

2.5

F

y

60

1.0

1. cycle

0.8

50

0.6
0.4

40

r

0.2

2. cycle

0.0

30

3., 4.  swing
-0.2

L

-0.4

20

initial
impulse

-0.6

Phase changes

10

-0.8
-1.0
-1.2

-0.8

-0.4

0.0

0.4

0.8

1.2

x

0

x

-10

Fig. 7: String pendulum
A) Geometrical configuration
B) Mathematical problem formulation of both phases
C) Simulation results

The Modelica Association

0.0

2.5

5.0

Figure 9: Force F in the thread

This description is closely related to a statechart description, which can be formulated with the State
Graph Library and simulated using Dymola or with

609

Modelica 2008, March 3rd  4th , 2008

O. Enge-Rosenblatt, C. Clau, P. Schwarz, F. Breitenecker, C. Nytsch-Geusen

an extended Modelica description for the Mosilab
simulator.
The model implementation depends strongly on the
applied simulator. In Dymola, it is necessary to use
the same number of equations in both phases. Therefore, some dummy equations have to be introduced.
In simulators like AnyLogic or Mosilab, different
numbers of equations are allowed in various model
states.

5

This collection of benchmark problems is under development in connection with the Mosilab development [1] and has its roots in a Fraunhofer-internal
research project GENSIM. Some parts of these examples will be published in connection with new
Modelica-oriented projects. Problems of more general interest will be prepared for the widelydistributed ARGESIM comparisons.
The collection of benchmarks presented here has
proved as a powerful tool for testing the numerical
behavior and the modeling limits of different simulators. In this paper, only some examples of general
interest are described.
The collection is under continuous development. The
pool of tasks as well as the tested simulators and the
different modeling languages have to be extended.
It is intended to include parts of the benchmark examples into the regression test library ModelicaTest,
which is used by the Modelica Design Group for developing the Modelica Standard Library.

References

[2]

[3]

[7]

[8]

[9]

[10]

[11]

[12]

Nytsch-Geusen C et al. Mosilab: Development of a Modelica based generic simulation
tool supporting model structural dynamics.
4th Int. Modelica Conf., Hamburg, Germany,
March 2005.
Breitenecker F et al. Education in modeling
and simulation using ARGESIM comparisons/benchmarks with physical modeling.
MATHMOD (5th IMACS Symposium on
Mathematical Modelling), Vienna, Austria,
February 2006.
Pawlik S et al. A classification of modeling
and simulation approaches based on the ARGESIM benchmarks. EUROSIM, Ljubljana,
Slovenia, September 2007.

The Modelica Association

[5]

[6]

Summary and outlook

[1]

[4]

610

[13]

[14]

Schwarz P. Simulation of systems with dynamically varying model structure. MATHMOD (5th IMACS Symposium on Mathematical Modelling), Vienna, Austria, February 2006.
Breitenecker F et al. Structure of simulators
for hybrid systems  general development
and introduction of a concept of external and
internal state events. EUROSIM, Ljubljana,
Slovenia, September 2007.
Nytsch-Geusen C. The use of the UML
within the modelling process of Modelicamodels. Proc. 1st Int. Workshop EOOLT,
Berlin, Germany, August 2007.
Benchmarks for water supply modelling,
simulation and optimisation.
http://www.eng.dmu.ac.uk/~wss/
Iwnicki S (Ed.). The Manchester Benchmarks for Rail Vehicle Simulation (Supplement Vehicle System Dynamics (SVD)).
Swets & Zeitlinger, July 1999.
Gelfert A. Simulating many-body models in
physics: rigorous results, benchmarks, and
cross-model justification. LSE/CPNSS Conf.
on Models and Simulations, Paris, France,
June 2006.
Enge-Rosenblatt O et al. Numerical Simulation of Continuous Systems with Structural
Dynamics. EUROSIM, Ljubljana, Slovenia,
September 2007.
Mattsson SE, Otter M, Elmqvist H. Modelica
Hybrid Modeling and Efficient Simulation.
38th IEEE Conference on Decision and Control, CDC99, Phoenix, Arizona, USA, December 1999.
Otter M, Elmqvist H, Mattsson SE. Objektorientierte Modellierung physikalischer Systeme, Teil 8. at  Automatisierungstechnik
47(1999)9, A29-A32.
Fritzson P. Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1.
Wiley, New York, 2004.
Clau C, Haase J, Kurth G, Schwarz P. Extended admittance description of nonlinear npoles. Archiv fr Elektronik und bertragungstechnik / Int. J. Electronics and Communications, Vol. 40, pp. 91-97, 1995.

Modelica 2008, March 3rd  4th , 2008

Modelica Wind Turbine Models with Structural Changes Related to Different Operating Modes

Modelica Wind Turbine Models with Structural Changes
Related to Different Operating Modes
Olaf Enge-Rosenblatt, Peter Schneider
Fraunhofer Institute Integrated Circuits, Branch Lab Design Automation,
Zeunerstrae 38, 01069 Dresden, Germany
olaf.enge@eas.iis.fraunhofer.de

Abstract

Investigation of wind turbines using numerical simulation becomes more and more important. Therefore,
design, construction and scheme of operation of the
turbine under investigation must be taken into account.
The level of detail which is necessary for a special
model depends on the questions which are to be answered by the simulation results. On the one hand, we
have to distinguish between models of single turbines
and whole wind parks. In the paper, model types suitable for both situations will be presented. On the other
hand, behavioural models describing only the flow of
electrical energy stand in opposition to models which
use voltage and current as time-depending electrical
quantities. Again, both types of models are introduced
here.

Investigation of large technical systems by simulation
of long time periods requires effective methods. One
possibility to handle such problems is the implementation of simulation models which use suitably simplified
descriptions of the real behaviour of technical systems.
In some cases, however, operating modes with highly
dynamic processes have to be investigated. These processes may occur suddenly within long time periods of
behaviour with none or very low dynamics, which can
be considered as static behaviour. In such cases, it
would be advantageous to be able to switch from the
simplified model mentioned above to a more complex
model describing the real behaviour in more detail.
In the paper, four different Modelica models for wind
turbines are presented. On the one hand, two static
models  the simple static model and the static mechatronic model  are shown representing two
different instances of a simplified behaviour. On the
other hand, two dynamic models  the mechanical
model and the dynamic mechatronic model  are
presented which describe the dynamic behaviour of a
wind turbine in more detail. Furthermore, a method
will shortly be proposed to exchange one model with
another one at certain points in time (see also [5]). Such
structural changes allow the application of that particular model of behaviour which suits the current situation
best. Using this method, the simulation of a complex
mechatronic system like a wind turbine can very effectively be carried out. Additionally, some simulation
results will be given to show the advantage of the method proposed.

1

Every type of a wind turbine model presented in this
paper is suitable for a well determined level of detail.
Every model uses a particular set of physical quantities
to describe the corresponding physical behaviour. All
models are equipped with interfaces that allow a simple
exchange of one model with another one at arbitrary
points in time. This property makes it possible to investigate a complex mechatronic system like a wind
turbine as exact as necessary depending on the current
situation of operation simply by using the actually best
suiting model of behaviour.
In the following section, the general logical scheme of
operation of the construction type of wind turbine considered in this paper is outlined. The four models are
presented in section 3. Some simulation results are given in section 4.

2

Introduction

There is a great variety of types of existing wind turbines (see e.g. [6], [7], [8], [14]). All of them have
advantages and disadvantages. However, the most
widely used type of a wind turbine is equipped with a
so-called pitch control and an asynchronous generator
([6], [9]). With such a turbine, the energy harvested
from the wind can be influenced by controlling the
pitch angle which is the angle of the rotor blade across

The proportion of renewable energy in industrial countries is growing with increasing speed. The usage of
wind turbines plays an important role among these
forms of power generation. A wind turbine is a complex mechatronic system consisting of mechanical
parts, electrical components, and a very complex control strategy.

The Modelica Association

Scheme of operation

611

Modelica 2008, March 3rd  4th , 2008

O. Enge-Rosenblatt, P. Schneider
speed
of
wind

pitch
angle

control
strategy

rotor
speed

gear box
and
generator

electric
power
fed
into grid

Figure 1: Wind turbines logical scheme of operation

cP

bine model presented here. Hence, investigations of
changing wind directions, their measurement, as well
as the dynamic behaviour of a turbine when rotating
across its vertical axis (i.e. when turning into the
wind) are not included in the models considered in
this paper.




Figure 2: Array of curves of power coefficient
its longitudinal axis. The simplified logical scheme of
operation of such a wind turbine is shown in Fig. 1.
The controller always tries to harvest as much as possible energy from the actual wind. To this end, the
controller uses the actual speed of wind and the actual
speed of rotor as input signals to calculate the pitch angle. This angle then again mainly determines the
angular momentum acting on the rotor. Hence, the rotor
speed and, therefore, the speed of the electric generator,
is influenced by the controller. Going into more detail,
the controller endeavours to put the point of operation
into a maximum of the power coefficients array of
curves, which are exemplarily depicted in Fig. 2. In
this figure, c P is the power coefficient,  stands for
the speed ratio between blades tip and wind
(  = R  v W , R  radius of rotor, v W  speed of
wind), and  denotes the pitch angle. In Fig. 2, five
curves of the whole array for fixed values of  are
shown (solid lines). The dotted line depicts an approximation of the connecting curve of the maximum points
of all c P -curves using the pitch angle  as a parameter.
Using such an array of curves, the controller chooses a
pitch angle which determines the rotor speed in such a
way that as much as possible energy can be harvested
from the actual wind. A realistic array of c P -curves 
implemented in the models of the next section  was
taken from [15].

3

The range of applicability of every model depends on
its level of detail. The simplest one is called simple
static model. It is suitable for energy flow considerations of whole wind parks. The mechanical model
allows simple dynamic investigations of the mechanical part of a single turbine. With both models, no
interaction between the turbine and the energy grid can
be considered. Compared with this, the static mechatronic model and the dynamic mechatronic
model are physical models with a more sophisticated
design. They use characteristic quantities of both mechanical and electric domain. Because of the usage of
electric quantities like current and voltage of the generator, many interations between turbine and energy grid
can be taken into account. Hence, these models are well
suitable for investigations of the mutual influence of
different turbines within a wind park.

3.1

Simple static model

The simple static model is the simplest possible model describing the physical behaviour of a wind turbine.
The only input is the actual speed of wind. The output
quantity is the electric power which can be harvested
from the actual wind under the assumption of an optimal operation of the turbines controller.
The relation between speed of wind and electric power
is shown in Fig. 3. It consists of two main areas: the
partial load range and the full load range (see e.g. [16]).
Within the partial load range, the speed of wind is slower than a value v Wnom which is called the nominal
speed of wind. Here, the electric power is a cubic function of the speed of wind. The full load area is the range

Wind turbine models

In this section, four different models of a wind turbine
characterized by a pitch angle and an asynchronous induction generator are presented. All these models use
the speed of wind as an input variable. Number and
physical quantity of the output variables depend on the
particular model. The direction of the wind (and the
variation of the direction) is not considered in any tur-

The Modelica Association

Pe
vWnom vW
Figure 3: Characteristic curve of the simple static
model

612

Modelica 2008, March 3rd  4th , 2008

Modelica Wind Turbine Models with Structural Changes Related to Different Operating Modes

N
vW

control
strategy



pitch
angle

calc. of
torque

T

gear
box



Klosss
approx.
of AIM

TL



Pe

Figure 4: Logical scheme of the mechanical model
Depending on the actual speed ratio  between the
blades tip and wind, the nominal pitch angle is choosen so that the power coefficient becomes a maximum
value (i.e. the point of operation is located on the dotted
line in Fig. 2). After a change of wind speed, the pitch
angle has to be readjusted. This has to be done in consideration of the limited angular velocity and
acceleration of the rotor blades. The profile of angular
velocity assumed here is a so-called trapezoid profile

(see Fig. 5, where the angular velocity  is plotted
against time t ). It consists of an acceleration region, a
range with constant speed and a deceleration region.
Using this profile, the pitch angle is changed if necessary. This way, the so-called pitch dynamics is included
in the mechanical model. Then, the actual pitch value
influences the driving torque via the array of curves of
the so-called torque coefficient. A sketch of this array
is shown in Fig. 6. In this figure, c T denotes the torque
coefficient, where  is again the speed ratio and  is
the pitch angle. The realistic array of c T -curves implemented within the mechanical model is taken from
[15]. The same array is also applied within both mechatronic models (see sections 3.3 and 3.4). Using the
actual value of c T at a time, the driving torque T is calculated according to

of wind speeds which are higher than the nominal value. Here, the electric power does not depend on the
actual speed of wind. Instead, it is assumed to be constant. Finally, the electric power is set to zero for both
very small values and very high values of v W . Within
these ranges, the system is not in operation because of
inefficiency and safety, respectively.
The simple static model describes a simple relation
between speed of wind and electric power without any
dynamics. No more characteristic quantities of a turbine are used. Therefore, the model can only be used if
all components of the turbine work correctly. Of
course, behavioural simulations with this model are really very fast. Hence, the model is suitable for
considerations of energy flows with single turbines as
well as with whole wind parks (consisting e.g. of 100
or more installations). The determination of bottle
necks within the energy grid while assuming typical
wind profiles for the park location may be of special interest in this context.

3.2

Mechanical model

The mechanical model implements the main properties of the turbines mechanical subsystem. Like with
the simple static model, the actual speed of wind is
used as the only input and the electric power is the output. In the model, some dynamics of mechanical
components are included.

 3 2
T = c T --- R v W
2

(1)

(   air density). After computation of driving torque,
the rotor acceleration is determined using the following
torque balance

The appropriate logical scheme is shown in Fig. 4. The
pitch angle is governed by the controller according to
the maximum power coefficient principle (see Fig. 2).


J = T  T L  

&

(2)

cT





t
Figure 5: Profile of pitch angle velocity

The Modelica Association

Figure 6: Array of curves of torque coefficient

613

Modelica 2008, March 3rd  4th , 2008

O. Enge-Rosenblatt, P. Schneider

N
vW

control
strategy

pitch
angle



calc. of
torque

T

gear
box

I


AIM

grid

V
TL



Figure 7: Logical scheme of the static mechatronic model
( J  rotors moment of inertia related to gear box ratio,
T L  load torque,   damping coefficient). For this
purpose, the generators load torque is calculated by
Klosss approximation for an asynchronous induction
machine (see e.g. [13])
TB
T L = ------------------------------ ,
s  sB + sB  s

The appropriate logical scheme is shown in Fig. 7.
Most of the mechanical subsystem is realized in the
very same way like in the mechanical model. This
concerns the pitch angle adjusting with its dynamics,
the calculation of driving torque, and the determination
of rotors acceleration via torque balance. Only Kloss
approximation of an asynchronous induction machine
is substituted by an equivalent circuit.
The electrical subsystem of the static mechatronic
model realizes only its steady state behaviour. Considering only steady states, the phasor description of
sinusoidal quantities leads to an adequate mathematical
model for the electrical subsystem (see e.g. [2], [12]).
An appropriate equivalent circuit for the asynchronous
induction generator (see Fig. 8) is used. Please note
that all underlined symbols in this figure denote
phasors ( V is a voltage phasor, I is a phasor of an
electric current  both are also used in Fig. 7) whereas
R , L ,  , and s denote ohmic resistor, inductance, angular frequency, and slip, respectively.

(3)

where s = (  N   )   N denotes the slip ( T B 
breakdown torque, s B  breakdown slip,  N  grids
angular frequency). Finally, the electric power P e fed
into the grid (the models output) is assumed to be
equal to the mechanical power (a given efficiency factor may be taken into account).
The mechanical model describes the electrical power
fed into the grid as a function of the speed of wind. This
description includes the main dynamics of the wind turbines mechanical subsystem and takes into account the
correct calculation of the driving torque using the
pitch-depending torque coefficient. Therefore, many of
the mechanical characteristic quantities are provided
for a dynamic simulation by the model. The model is
suitable for investigations of the dynamic behaviour of
the mechanical part of a single wind turbine if the dynamics of the electrical part is either negligable or not
of interest. An example for such investigations is e.g.
the problem of finding the optimal time interval for
measuring the speed of wind and  corresponding to
this question  the optimal strategy for controlling the
pitch angle.

3.3

The electrical subsystem is implemented using a special Modelica library for phasor domain-based
systems. This library was already presented at the last
Modelica conference (see [3]). Hence, details to the
phasor description and the special library shall not be
given here. In [3], we also pointed out that  with such
a model  a so-called quasi-stationary mode can be described under some weak assumptions. With a wind
turbine, such an operating mode is characterized by
slow dynamics of the mechanical subsystem and a sequence of steady states of the electrical subsystem. See
[3] for more details.

Static mechatronic model

The static mechatronic model extends the mechanical model mentioned before by an electrical
subsystem. Like with both models before, the actual
speed of wind is used as an input. But additionally, the
voltage of the energy grid is used as input, too. The output is the electrical current fed into the grid. Therefore,
the mechatronic models (the static one here and the dynamic one in the next section) implement a fully bidirectional connection between the turbines electrical
subsystem and the energy grid.

The Modelica Association

Is

VN

Rs

jLs

jLr

jLm

Im

I r

Rr s

Figure 8: Equivalent circuit of an asynchronous
induction machine using phasor description

614

Modelica 2008, March 3rd  4th , 2008

Modelica Wind Turbine Models with Structural Changes Related to Different Operating Modes

N
vW

control
strategy

pitch
angle



calc. of
torque

T

gear
box

i(t )


AIM

v(t )

grid

TL



Figure 9: Logical scheme of the dynamic mechatronic model
The dynamic mechatronic model realizes a fully dynamic model of the mechatronic system of a wind
turbine. Both subsystems (mechanical and electrical)
are described by differential-algebraic equations.
Merely, the power electronics with its switching effects
is neglected. Hence, this model is well suitable for investigations of the behaviour of a single wind turbine
taking into account many dynamic effects from mechanical and electrical domain. Especially, the
interaction between a wind turbine and the energy grid
can be considered in a detailled way with this model.
Enormous simulation times because of the high dynamics of many electrical quantities are a disadvantage
of this model.

The static mechatronic model realizes a complete
mechatronic system of a wind turbine consisting of a
controlling part, a mechanical part, and an electrical
part. Due to the application of phasor domain-based
electrical quantities, the high dynamics of the electrical
subsystems (usually the 50 Hz or 60 Hz sinusoidal oscillations) do not carry any weight concerning dynamic
simulations of the whole system. Hence, this model is
well suitable for investigations of the behaviour of
many turbines of a wind park, especially for considerations of mutual interactions between the turbines and
the grid or between different turbines connected with
the same part of the grid.

3.4

Dynamic mechatronic model

3.5

The dynamic mechatronic model is the most complex one described within this paper. Like with the
static mechatronic model, the actual speed of wind
and the voltage of the grid are used as inputs while the
output is the electric current fed into the grid. Hence,
the model implements a fully bi-directional connection
between turbine and grid.

Investigations of interesting questions concerning wind
turbines often require dynamic simulations over very
long time periods. To carry out such analysis in a conveniently effective manner, special simulation methods
are necessary. The main influence to the dynamic behaviour of a turbine is exerted by the wind. On the one
hand, there are long time periods with only few variations of its speed. Within these periods, a simulation
model consuming as less as possible calculation time is
of interest. On the other hand, there are short time intervals, where the speed of wind is changing very fast.
In such critical cases, the compliance of given conditions of operation is very important. Hence, a dynamic
simulation with a sufficient level of detail is of essential
importance.

The appropriate logical scheme is shown in Fig. 9. The
mechanical submodel is completely equal to that of the
static mechatronic model. The important difference to
this model mentioned above is the implementation of
the fully dynamic behaviour of an asynchronous-type
generator. Please note that time-depending electrical
quantities ( v ( t ) , i ( t ) ) are used in Fig. 9 instead of
phasors. In the usual case of a three phase grid, such a
model of a generator consists of six time-depending
electrical currents (three stator currents and three rotor
currents) which require, of course, six differential
equations to calculate them. One extra (algebraic)
equation is necessary to determine the load torque produced electrically (see e.g. [4]). Because of the
generator equations and the sinusoidal electrical quantities appearing there, high dynamics is involved in the
turbines model. Hence, a dynamic simulation using
such kind of model needs small solver steps. This fact
leads to time-consuming simulation experiments.

The Modelica Association

Model exchange

To handle the problem of changing demands to the level of detail of a model, the exchange of one submodel
with another one at proper points in time is proposed.
The points in time of a necessary change from the simple model to the detailled one can e.g. be found by
monitoring the acceleration of the wind (i.e. the variation of the speed of wind). If the accerelation value
exceeds a well defined border then the model change is
necessary. Switching on and off of main consuming devices may also be of interest. Here, the points in time
are predetermined. The switching back from the de-

615

Modelica 2008, March 3rd  4th , 2008

O. Enge-Rosenblatt, P. Schneider

more producers / consumers

wind park

energy grid
other producing devices
(e.g. photo-voltaic)

consumers

consuming devices
(industrial plant,
public building, )

Figure 10: Energy grid with wind park and consumers

4

tailled model to the simple one may be carried out if the
dynamics of the complete system is faded away.

Considering the four models of wind turbines presented in section 3, the mechatronic models are the most
interesting ones. Therefore in this section, some simulation results are shown which were reached using
these two models.

Both switching operations  from low level to high level of detail and vice versa  have to be performed taking
into account the possibly changing number of differential and algebraic equations. That means that three
steps are to be done:
 The dynamic simulation may be terminated at a
certain point in time.
 The actual state of the old model has to be transformed into the new model.
 Consistent initial values for the complete set of
equations of the new model have to be found.
For more information concerning this way of realisation, please refer to [5].

3.6

Please imagine a little wind park connected to some
consumers. A similar (but simplified) scenario is
shown in Fig. 10. Dynamic simulations of such a complex system using the dynamic mechatronic model
would require a huge simulation effort. An investigation of the systems behaviour for, say, one year would
hardly be possible. The only way to earn some results
within a reasonable time effort is to operate with changing submodels. To this end, the static mechatronic
model and the dynamic mechatronic model are alternately applied. Depending on the actual situation,
either the static model or the dynamic model is used to
describe the complete system.

Model implementation

The models presented here have been implemented using the Modelica Standard Library, extended by some
physical relations and algorithms in order to provide an
arbitrary wind profile, to model the whole turbines
control strategy, to handle the pitch angle adjustment,
as well as to carry out some approximations concerning
the coefficients arrays of curves (power coefficient,
torque coefficient) included in the models. Additionally, a Modelica library for phasor domain-based
description (see [3]) is used in case of the static mechatronic model.

4.1

Functionality test

First, a functionality test for the two mechatronic models is presented. This this end, a rapid change of speed
of wind  a zooming ramp which is nearly a step  is
assumed as input signal at time t = 1s (see Fig. 11).
Such a sudden step is admittedly very unlikely for a real wind turbine. But the functionality test was
intentionally performed under extreme conditions.

Unfortunately, a real switching between different levels of detail  i.e. an exchange of model parts in such a
way that the equations of the inactive part at a time
are excluded from the equation set of the numeric solver  is not supported by most Modelica simulators until
now. For this reason, parts of the following results are
achived by a kind of step-wise simulation.

The Modelica Association

Simulation results

The step responses of the two wind turbine models are
shown in the following figures (Fig. 12 ... Fig. 15). In
all these figures, the prefix smm (corresponding to a
solid line) means that the result originate from the
static mechatronic model while the string dmm
(corresponding to a dashed line) indicates the dynam-

616

Modelica 2008, March 3rd  4th , 2008

Modelica Wind Turbine Models with Structural Changes Related to Different Operating Modes

Figure 11: Sharp change of wind speed

Figure 14: Generators angular velocity

ic mechatronic model. In Fig. 12, the time progress of
the pitch angles is depicted. Both angles are very fast
justified by the controller from 0 to 20. The small difference of the ramps increase is caused by the fact that
the controller uses both the speed of wind and the rotor
speed as input signals. The rotor speed is shown in
Fig. 13 for both models. Here, the different behaviour
of both models is illustrated. The static model calculates significantly higher values than the dynamic
model. This is valid in the time interval of the changing
pitch angle as well as in the time of constant rotor
speed. The same behaviour is demonstrated in Fig. 14.

This figure contains the curves of the angular velocity
of the generator which is connected to the rotor via an
ideal gear with a speed ratio of 1:180. Fig. 13 and
Fig. 14 show after a very close look that the dynamic
model needs less more time to react to the sharp change
of wind speed. That means on the other hand that the
static model does not yield correct results in such cases.
Finally, the same effect is shown in Fig. 15 which depicts the corresponding time history of the electric
power produced by the turbine and fed into the grid.
Though in this diagram, the difference between both results is not such significant like with the turbines rotor
speed of with the generators angular velocity. However, the dynamic model needs less more time to reach the
area of constant electric power.

Figure 12: Pitch angle
Figure 15: Electric power

4.2

In this section, results of a long-term simulation are
given. Using such investigations, on the one hand the
suitability of different models and on the other hand the
rate of effectiveness of model exchange can be determined. As already pointed out in section 3.6, a stepwise simulation method is necessarily applied here
because of the inability of most Modelica simulators to
handle models with exchanging parts correctly. In this
context, step-wise simulation method means that the

Figure 13: Turbines rotor speed

The Modelica Association

Long-term simulation

617

Modelica 2008, March 3rd  4th , 2008

O. Enge-Rosenblatt, P. Schneider
mechatronic model, it takes much more time to finish.
On the same PC, a time effort of 43.5 s was needed.

three step mentioned in section 3.5 were carried out not
driven by the simulator but forced by the user. In other
words, different tasks had to be performed where the
model exchanges were done by transforming the actual
state into the new model and starting a further simulation task. Possibly, new developments (see e.g. [1], [5],
[10], [11]) will improve the situation in the near future.

A compromising solution is shown in Fig. 17. The five
regions mentioned above are investigated using the
static mechatronic model because the wind shows
only low dynamics there. The corresponding time history of the turbines electric power is indicated by solid
lines. However if monitoring high wind dynamics, the
dynamic mechatronic model is used. The corresponding power curves are indicated by dashed lines.
The dynamic model is used during the four short time
intervals between the five steadied regions. This way, a
model exchange is needed at eight points in time. These
are marked in Fig. 17 by changing line types.

The simulation period shall have a length of 1200 s.
The used wind profile along the complete time interval
is a realistic profile near to wind data meassured in reality. The shape of the wind profile is depicted in
Fig. 16. It has three regions with relatively low wind
speeds between 5 m/s and 10 m/s (time intervals: 030 s, 60-80 s, 100-120 s). In contrast, there are two regions with high or middle speeds of wind of about
20 m/s and 15 m/s, respectively (time intervals: 3355 s, 80-100 s).

5

A wind turbine is a complex mechatronic system consisting of mechanical parts, electrical components, and
a very complex control strategy. The article deals with
a widely used type of wind turbines which is equipped
with a so-called pitch control and an asynchronous generator. Four different models for describing the static
and/or dynamic behaviour of such a wind turbine are
presented. Every model implements a well determined
level of detail and uses a particular set of physical
quantities to describe the corresponding physical behaviour. All models are equipped with interfaces that
allow model exchanges. This property makes it possible to investigate a complex mechatronic system like a
wind turbine as exact as necessary depending on the
current situation of operation simply by using the actually best suiting model of behaviour.

First, the complete task was computed using the static
mechatronic model. On a nowadays standard PC (Intel T2400 dual-core CPU with 1.8 GHz each), the
simulation took only 1.8 s. But the results can only be
understood as a sequence of steady states (see [3]). In
highly dynamic situations, the numeric error of such a
calculation method may not be neglected. But if performing the complete task using the dynamic

In the paper, two static models are shown representing
two different instances of a simplified behaviour (a
simple characteristic curve and a static model using
mechanical and electrical components). Furthermore,
two dynamic models are presented which describe the
dynamic behaviour of a wind turbine in more detail (respecting only the dynamics of the mechanical
subsystem or taking into account the dynamics of mechanical and electrical components). In addition, a
method of model exchange at certain points in time is
proposed. Such structural changes allow the application of that particular model of behaviour which suits
the current situation best. Using this method, the simulation of a complex mechatronic system like a wind
turbine could very effectively be carried out.

Figure 16: Realistic shape of wind speed

Additionally, some simulation results using the two
mechatronic models are given. Both a functionality test
performed under extreme conditions as well as an investigation using a realistic wind profile are included.

Figure 17: Electric power with switching models

The Modelica Association

Summary

618

Modelica 2008, March 3rd  4th , 2008

Modelica Wind Turbine Models with Structural Changes Related to Different Operating Modes
[14] Zhang T. Energieertrag und dynamische BelasReferences
tungen an einer Windkraftanlage mit stufen[1]
Breitenecker F et al. Structure of simulators for
losem leistungsverzweigten Getriebe bei
hybrid systems  general development and
aktiver Dmpfung. Dissertation, TU Chemnitz,
introduction of a concept of external and interGUC-Verlag, Chemnitz, 2004.
th
nal state events. 6 EUROSIM Congress on
[15] Zhao X. Simulation des dynamischen VerModelling and Simulation  EUROSIM 2007,
haltens einer Windenergieanlage als mechatroLjubljana, Slovenia, September 9-13, 2007,
nisches System. Dissertation, TU Chemnitz,
Proceedings.
Shaker, Aachen, 2004.
[2]
Desoer CA, Kuh ES. Basic Circuit Theory.
[16] http://www.windpower.org/en/tour.htm.
McGraw-Hill, 1966.
Guided Tour on wind energy. Danish Wind
[3]
Enge O, Clau C, Schneider P, Schwarz P, VetIndustry Association, seen on October 25,
ter M, Schwunk S. Quasi-stationary AC Analy2007.
sis Using Phasor Description With Modelica.
th
5 International Modelica Conference  Modelica 2006, Vienna, Austria, September 4-5,
2006, Proceedings, pp. 579-588.
[4]
Enge O, Kielau G, Maier P. Modelling and
Simulation of Discrete Electromechanical Systems. 3rd Conference on Mechatronics and
Robotics, Paderborn, Germany, October 4-6,
1995, In Lckel, J. (Ed.): Mechatronics and
Robotics - From Design Methods to Industrial
Applications, Teubner, Stuttgart, 1995, pp. 302318.
[5]
Enge-Rosenblatt O, Bastian J, Clau C,
Schwarz P. Numerical Simulation of Continuous Systems with Structural Dynamics. 6th
EUROSIM Congress on Modelling and Simulation  EUROSIM 2007, Ljubljana, Slovenia,
September 9-13, 2007, Proceedings.
[6]
Garsch R, Twele J. Wind Power Plants  Fundamentals, Design, Construction and Operation. James and James, 2002.
[7]
Gasch R (Ed.). Windkraftanlagen  Grundlagen und Entwurf. B.G. Teubner, 1996.
[8]
Hau E. Windkraftanlagen  Grundlagen, Technik, Einsatz, Wirtschaftlichkeit. Springer, 1996.
[9]
Heier S. Grid Integration of Wind Energy Conversion Systems. John Wiley & Sons, 1998.
[10] Nytsch-Geusen C et al. Mosilab: Development
of a Modelica based generic simulation tool
supporting model structural dynamics. 4th
International Modelica Conference  Modelica
2005, Hamburg, Germany, March 7-8, 2005,
Proceedings, pp. 527-535.
[11] Schwarz P. Simulation of systems with dynamically varying model structure. 5th IMACS
Symposium on Mathematical Modelling 
MATHMOD 2006, Vienna, Austria, February
8-10, 2006.
[12] Steinmetz CP. Theory and Calculations of
Alternating Current Phenomena. 1e, W.J. Johnson Comp., 1897, or 4e, McGraw, 1908.
[13] Woodson HH, Melcher JR. Electromechanical
Dynamics  Part I: Discrete Systems. John
Wiley & Sons, 1968.

The Modelica Association

619

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

620

Modelica 2008, March 3rd  4th , 2008

ExcelInterface - A Tool for Interfacing Dymola through Excel

ExcelInterface  A Tool for Interfacing Dymola through Excel
Kristian Tuszynski,
Modelon AB, Ideon Science Park, SE-22370 Lund, Sweden

kristian.tuszynski@modelon.se

Abstract
This paper presents a tool created in Excel which enables interfacing with Dymola. The tool was created
to simplify batch simulations and allow easy post
processing of a large number of simulations. The interface handles both steady state sweeps of a model
as well as continuing from a previous simulation.
Support for calibration using linear regression is also
implemented which allows calibration of simpler
models.
Keywords: Excel; Simulation; DDE; Scripting; Dymola; Batch simulation; Steady State; Interface

1

Introduction

When simulating a large number of cases, either to
validate a model against measurement data or when
acquiring experimental results, there is strong need
to be able to organize and get a good overview of
both the experiment setup and the result of the simulations. The ExcelInterface greatly improves and
simplifies both the post processing and setup involved when running a batch of simulations with
changing boundary conditions between the cases.
The tool allows the user to define a number of cases
to run and then get the result from the simulations
presented in Excel for easy comparison. This gives a
good overview of what has been set in the model,
without actually changing the model code allowing
the model stored in Dymola to be generic and instead
all different simulation cases are defined in the Excel
sheet.
Doing the same thing using Dymola directly would
force the user to make model changes for each parameter set, create multiple models where each uses
a different parameter set or make a custom made
script file where the simulation cases are defined. All
these options are quite time consuming and do not
provide a good overview.
The Modelica Association

Having the result in Excel also enables the use of the
tools included in the program. Excel and its tools
have the advantage that the knowledge and use of
them are wide spread which means that it is not necessary for a person with Modelica or Dymola knowledge to analyze and make further post processing of
the result. This simplifies the result exchange when
working with someone without any prior Modelica
knowledge.

2

Overview

The tool is built using VBA (Visual Basic for Applications) which comes with Excel. The communication between Excel and Dymola is performed both
using files and a DDE connection established between Dymola and Excel.
When simulating, the interface works by creating a
Dymola script based on chosen settings in the ExcelInterface. This script is executed in Dymola, using
DDE commands sent from Excel. For each simulation, specified output values are saved in temporary
files which are read by Excel after all simulations
have completed. In Excel the result is presented at
position and with appearance defined by the user
through the interface. The communication is illustrated in Figure 1.

Figure 1 Communication between Excel and Dymola

621

Modelica 2008, March 3rd  4th , 2008

K. Tuszynski

3

Setup

The ExcelInterface contains a setup sheet, seen in
Figure 2, where all cases to be simulated are specified. A case is defined by a unique name used in the
interface, a path to a model file and the Modelica
path to the model to be simulated within the file.
Each case can be enabled and disabled deciding if
they are run or not when starting the simulations.

variables contained in the model. A DDE connection
is used between Excel and Dymola to execute the
commands necessary to perform these operations
which include:
 translation and simulation of the model
 parameter and variable names extraction
from the generated result file
 saving extracted parameter and variable
names in a user specified file
This procedure only has to be performed once for
every model as any following need to add parameters/variables the saved file is used.

Figure 2 Setup sheet of the ExcelInterface

For each case a new excel sheet is created where the
user has to specify a number of parameters including
work directory, integrator, tolerance, number of simulations cases and simulation time as seen in Figure
3.

Figure 4 Tree view menu with parameters and variables

Input and output variables are then selected from the
generated tree view menu, seen in Figure 4, and finally values are set in the generated input table such
as the one shown in Figure 5.

Figure 5 Set boundary conditions

4

There are two ways to run multiple simulations using
the ExcelInterface:

Figure 3 Sheet specific for a case

The input and output variables to/from the model are
selected from menus in Excel. The first time a model
is to be simulated through the ExcelInterface, the
model has to be analyzed to find all parameters and
The Modelica Association

Running Simulations

622




Steady State Simulations
Continue Simulation
o Continue from First
o

Continue from Previous

Modelica 2008, March 3rd  4th , 2008

ExcelInterface - A Tool for Interfacing Dymola through Excel

4.1

Steady State Simulations

This option simulates the specified cases one after
another and the results at the specified end time are
returned. In case of a model that initializes in steady
state, the simulation time should be set to zero for
faster execution, for all other cases the user has to
determine a simulation time that is long enough for
the simulation to reach steady state.
Structural parameters are parameters which force a
re-compilation of the model as they change the generated code structure. A good example of structural
parameters is discretization parameters. If all selected input parameters are non-structural the model is
only translated and compiled once, enabling fast
simulations. As it may not always be trivial to know
which parameters in a model that are structural, the
ExcelInterface automatically detects if a structural
parameter was selected as an input parameter. If one
or more structural parameters are detected the model
has to be retranslated between each run case.

By connecting ramp blocks to the boundary conditions of the simulated model where the start values
of the output signals equal the end value from the
previous simulation it is possible to start each new
simulation from steady state and then change the
boundary conditions by setting desired height of the
ramp blocks.
Continue from First simulates the model for a specified time and then the remaining simulations continue from this point. This makes it possible to define a
number of transients using, for instance, ramp blocks
and sweep any number of steady state points.
Figure 7 shows the outlet evaporator temperature in
an AC-cycle simulation where the model was first
simulated until it was in steady state. Once this point
was reached (after 200 seconds) five simulations
were executed from the end of the first simulation
where the inlet air temperature was changed between
the simulations.

Figure 6 Input and output in Excel

Figure 6 shows an example on how the output in Excel can look like after a successful simulation. In the
example four different cases were run and two parameters (init.mdot_init and init.p_in_init) were
changed between the simulations.
4.2

Continue Simulation

Besides running each simulation as a separate case,
the ExcelInterface offers two other ways for series of
steady state calculations. The most common reasons
for using these options are that the model can not
successfully initialize at every steady state point
and/or that the initialization phase of the model is
very time consuming making it practical to continue
from a initialized model that has reached steady
state.

The Modelica Association

Figure 7 Example result when using Continue from
First

The second option Continue from Previous also
simulates the model for a specified time and then
each specified case continues from the previous simulation.
A Continue from Previous run is illustrated in Figure 8 where the outlet evaporator temperature of an
AC-cycle is shown. The initial simulation is continued after 200 seconds. After this time 5 simulations
are run where each one is 100 seconds long.

623

Modelica 2008, March 3rd  4th , 2008

K. Tuszynski

ulation and there are no guarantees it will work the
second time around either.
Using the ExcelInterface the risk is minimized when
simulating the charge optimization using the continue feature of Dymola. The experiment is setup by
adding a controlled flow source, to the cycle, which
fills the accumulator with refrigerant at specified
time as shown in .

Figure 8 Example result when using Continue from
Previous

For both these options it is possible to start the simulations from a saved result file. Using this option the
initial simulation, which takes the model to steady
state, is skipped. Instead all initial values are taken
from the result file.
4.3

Plotting and Dynamic Result

For all simulations performed using the interface it is
optional to include plots of chosen variables in Excel. Enabling this option is useful to get a quick visual comparison of the different simulation results and
when it is necessary to verify that the model really
reached steady state after an initial transient.
The plots are created by extracting wanted trajectories from the result files and saving them in sheets
within the work book making the trajectories easily
accessible.

5

Usage Example  Charge Optimization

To find the optimal charge of an AC-Cycle the cycle
is first almost completely drained and then filled in
multiple steps until the accumulator of the cycle is
over filled. At each step important values such as the
power, pressures, subcooling and superheat temperatures are measured.
Simulating this procedure in one continuous simulation might prove difficult as it is often necessary to
simulate between 8 and 15 points altogether and
there is a risk that the simulation will fail during the
transition between, at least, two of the points. If this
happens it is quite time consuming to re-run the sim-

The Modelica Association

Figure 9 Cycle with controllable flow source

In the ExcelInterface the start time of the filling,
height and offset of the set-point ramp block is selected as input parameters and the experiment is run
using Continue from First. Finally, the cycle model
is parameterized to begin the continue simulations
having a charge of 150 kg/m3.

Figure 10 Setup in the ExcelInterface

Assuming that the initial simulation, which controls
the charge down to 150 kg/m3 passes the whole experiment will not fail if a single simulation fails. Instead of risking having to redo the whole experiment
the worst case scenario is now that some of the simulations have to be redone because they crashed.

624

Modelica 2008, March 3rd  4th , 2008

ExcelInterface - A Tool for Interfacing Dymola through Excel

Figure 11 Plot of specific charge. 5 points were simulated from 200-400 kg/m3

6

Summary

The ExcelInterface has proven to be an efficient tool
to use when doing batch simulations over a large
number of steady state points.
The interface gives the user a good overview of the
cases to simulate and simplifies the post processing
of the result as well as speeding up the setup of the
experiments. This in combination with the fact that
Excel is a well known program which many people
have experience working with gives the interface
great flexibility and a broad user base.

References
[1]
[2]

Excel VBA Language Reference, www.microsoft.com
Dymola User Manual

The Modelica Association

625

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

626

Modelica 2008, March 3rd  4th , 2008

Modeling of Cold Plates for Power Electronic Cooling

Modeling of Cold Plates for Power Electronic Cooling
Karin Dietl Jens Vasel Gerhard Schmitz Wilson Casas Christian Mehrkens
Hamburg University of Technology
Institute of Thermo-Fluid Dynamics, Applied Thermodynamics
21071 Hamburg, Germany

Abstract
This paper deals with the cooling of high power
electronic devices. Usually those devices dissipate 5
- 10% of their electrical power, therefore (convective)
cooling is needed. Power electronics can be cooled
directly by air or a non-conductive fluid via (forced)
convection. However discharging the heat of the
power electronics via convective heat transfer with
air leads often to a large cooling elements due to the
poor heat transfer coefficient of air. Also in most
applications the direct contact between the electronic
and the cooling fluid is undesirable.
For these applications the use of cold plates can be
an option. The fluid flows through a plate (see. fig.1)
which is directly connected to the electronic. This

This paper presents a model library developed in
order to model power electronics cooling. The library
provides on the one hand heat loss models for basic
power electronics equipment itself, like IGBTs, and
on the other hand thermodynamic models for different
cold plates. Lumped models of the cold plates can be
used in large system simulations whereas cold plate
models using a distributed approach are foreseen for
more detailed analysis.
To be able to calculate the temperature distribution
in the cold plate, the solid and fluid parts of the cold
plate have to be discretised in all directions (see fig.2).

Figure 1: Cold plate
type of cooling is far more effective than air cooling,
since the cold plate can be designed in order to cool
also high power density electronics without resulting
in a disproportional increase of the space envelope.
The fluid temperature can be increased with respect to
the air temperature, without decreasing reliability and
durability of the power electronics components.
Using cold plates open up possibilities of decentralised cooling which can improve the efficiency of
the cooling system.
 email:

karin.dietl@tu-harburg.de, Tel:+49 4042878 3765
vasel@tu-harburg.de, Tel:+49 4042878 3765
 email: schmitz@tu-harburg.de, Tel:+49 4042878 3144
 www.tt.tu-harburg.de
 email:

The Modelica Association

Figure 2: Cold plate model
The library is based on Modelica.Fluid, however for
the modeling of the single phase cooling medium, the
compressibility of the liquid is considered in order to
avoid large non-linear system of equations.
An important aspect of the library is the coupling of
the power electronic models to the cold plate model.
Hereby an efficient algorithm is needed which enables
the user to connect an unlimited number of power
electronic components of any size to arbitrary places
on the cold plate.

627

Modelica 2008, March 3rd  4th , 2008

K. Dietl, J. Vasel, G. Schmitz, W. Casas, C. Mehrkens

Additional to the simulations a test rig is built,
where the cold plates are tested. Whereas the models
can be used for both, single phase and two phase
cooling, on the test rig only single phase cooling is
investigated. Since the fluid channels often have a
complicated finned structure, where the geometric parameters are usually not accessible, the measurements
are needed to validate the cold plate models. Hereby
a large emphasis is placed on validating the pressure
drop and heat transfer correlations, as well as the time
constants.
Keywords: Modelica; Simulation; Cold plate; Cooling; Power Electronics

The Modelica Association

628

Modelica 2008, March 3rd  4th , 2008

Heavy Vehicle Modeling with VehicleDynamics Library

Heavy Vehicles Modeling with the Vehicle Dynamics Library
Niklas Philipson
Magnus Gfvert

Johan Andreasson
Andrew Woodruff

Modelon AB
Ideon Sience Park, SE-22370 Lund, Sweden

Abstract
This paper presents and describes recent extensions
to the Vehicle Dynamics Library (VDL) for heavy
and commercial road-vehicle modeling and simulation (VDL/Trucks). Until now, the VDL was targeted
mainly at passenger cars applications (VDL/Cars).
Users in this domain have been particularly enthusiastic about the openness, flexibility, and extensibility
compared to many competing solutions. These advantages which are inherent to Modelica technology are
even more important for heavy vehicles applications,
where a much larger set of vehicle configurations and
variations must be supported. It has therefore been natural to extend the scope of the library also into this
field with the VDL/Trucks options presented in this
Figure 1: Truck-fulltrailer in a double lane-change
paper. New components and templates have been introduced to reflect many standard chassis layouts. A
number of new experiment templates are also supplied
to make standard analysis tasks easy to perform.
senger cars have many common inputs such as a huKeywords: heavy vehicles; trucks; vehicle dynamics; man driver model with similar driver-vehicle interVehicle Dynamics Library
face, road and environment properties, etc, and outputs
of interest such as tire forces at the contact patches,
chassis and suspension motion. Joints, links, springs,
1 Introduction
dampers, drivers, roads, and tires all produce similar types of constraints on the model. A large set of
The Vehicle Dynamics Library (VDL) [1, 2] was orig- model components are therefore common for cars and
inally designed for studies on vehicle handling for pas- truck modeling. There are, however, some major difsenger cars (VDL/Cars). It was early clear that an ferences between heavy commercial vehicles and pasextension into the heavy vehicles domain would be senger cars when it comes to chassis layout. The numnatural. The inherent flexibility and extensibility of ber of axles, tires and trailers are some of the many
the Modelica-based solutions offers great benefits in parameters that are combined to form a heavy vehithis domain where a vast set of vehicle configurations cle configuration, while cars have a more static setup.
and variants must be handled, such as combinations This requires an even more flexible interface and temof trucks, tractors, full trailers, semi-trailers, tankers, plate design for heavy vehicles than for cars.
with various axle and powertrain configurations, and
also a wide range of payload conditions. This paper The heavy vehicles option has been developed from
introduces the VDL/Trucks option of VDL aimed at the same library base as the car option. This means
modeling and simulation of heavy vehicles.
that the new heavy vehicle models can benefit from an
Vehicle dynamics analysis of heavy vehicles and pas- already well tested and mature overall design.
The Modelica Association

629

Modelica 2008, March 3rd  4th , 2008

N. Philipson, J. Andreasson, M. Gafvert, A. Woodruff

2

Heavy vehicle components

As mentioned above, there are many low level
components that are shared between VDL/Cars and
VDL/Trucks, but there are of course many examples
of new components and components that are used differently in the context of heavy vehicles [3]. Essentially, this is due to the difference in weight and dimensions. The higher over-all weight requires different solutions and very large load variations means that
good performance have to be achieved for a wide variety of load cases. The higher center-of-gravity makes
rollover rather than road adhesion the handling limit in
many situations. This section highlights some of the
extensions made to VDL for heavy vehicle simulation
to address these differences. Figure 2 shows a screen
shot of parts of the library, indicating some important
new additions.

Suspension The suspension designs in heavy trucks
are usually axle-based for the steerable and nonsteerable wheels. Leaf springs are commonly used
for both axle guidance and load support and are implemented as described in [4]. To meet the requirement of high load variations the leaf springs are often
mounted in such a way that the effective length of them
decreases when they are subjected to load. There are
also leaf spring versions that are equipped with helper
springs that becomes active when the vehicle is loaded.
Air springs are often used in heavy vehicle suspensions in conjunction with trailing arms to easily adjust for different load cases, see Figure 3. Air springs
can be used to change the ride height of the vehicle by
increasing the air mass inside the spring, which also
results in a stiffer spring that can carry more load.

Figure 3: Typical heavy vehicle rear axles.

Frame The frame elasticity influences the load distribution between the axles, and therefore the available
grip from the tires. The elastic frame included in VDL
trucks has a torsional degree of freedom. It is easy to
add or change the degrees of freedom in the frame by
extending the interface so the common template connectors are used.
Payloads The payloads can be static (e.g. a crane),
dynamic (e.g. a tank for liquid load) or have varying masses or mass distributions (e.g. cargo containers). These different cases are supported with userfriendly configuration setup. The existing liquid payload model considers the dimensions of the tank and a
rotational damped degree of freedom for slosh.

Figure 2: Screen shot of parts of VDL as it appears
in Dymola. Some main extensions to VDL for heavy
Cabin The truck cabin is usually suspended for
vehicles are indicated.
driver comfort since the chassis suspension must be
The Modelica Association

630

Modelica 2008, March 3rd  4th , 2008

Heavy Vehicle Modeling with VehicleDynamics Library

templates are based on the same usage principles as the
car templates, where templates for aggregate models
are built by connecting replaceable components that
can be parameterized depending on application. An
example of a tractor template is given in Figure 5.

Figure 4: Sine-excitation of a tractor-trailer combination with the liquid load in the tank modelled with with
a one degree of freedom to capture dynamic load distributions.
stiff to accommodate the high loads. The cabin
suspension is a linkage mechanism equipped with
springs, dampers and antiroll bars. The suspension
also causes a relative motion between the steering
wheel and the steering gear since the steering wheel
moves with the suspended cabin. This is incorporated
in the vehicle templates and ensures that it is easy to
change the different subsystems such as the cabin suspension or the steerable axle linkage in an flexible way.
Couplings Heavy vehicle combinations often have
tractor (driven) and trailer vehicle units. The attachment to guide and constrain the trailer can vary, but has
a significant effect on the handling and vehicle behavior. One of the most common couplings is a fifth wheel
for the tractor/semi-trailer combination. Full trailers
and dollies usually have a draw bar and hook to attach
to the tractor, driven truck, or preceding trailer (in the
case of road trains). The coupling must have a mass on
both sides of the joint or be locked to avoid a singular
setup when no unit is attached on one side. This is
conveniently handled without much user intervention
by the available components and templates.

3

Heavy vehicle templates

The variation and configuration space of heavy vehicle combinations are much larger then for normal passenger cars. Also, the components can be of varying fidelity depending on the design and purpose of
the model. A new set of templates for heavy vehicle
components has therefore been developed to sustain
the user-friendliness offered in VDL/Cars. These new
The Modelica Association

Figure 5: Tractor template with two rear axles.
The heavy vehicle interfaces for basic components are
largely the same as those for cars. Some changes include extra connections to incorporate the frame and
suspended cabin. The axle-based suspension models
typically have connectors for the axle and chassis, instead of using separate connectors for the left and right
suspension linkage models. The templates still have
all connections and parameters predefined and propagated between models so they only require the replaceable components to be redeclared from the graphical
Dymola user interface.
The main chassis components include a number of suspension models that contain one or more axles, frame,
coupling, wheels, and a body or payload. Trailers can
also include components for a dolly.
The suspension templates are based on axle constraints. The axle can be a steerable or non-steerable
version. The axle connects through the linkage to the
chassis. The linkage has external or internal force elements such as coil/air springs or leaf springs, respectively, to support the chassis. An anti-roll bar is attached to the axle and chassis. The suspension components vary from the most basic bounce and roll degrees
of freedom to detailed elasto-kinematic setups.

4

Experiments

Simulation experiments for passenger cars and heavy
vehicles have many similarities and correspondingly
share setup of e.g., drivers, roads and grounds, and environments. Just as for cars, both the open and closed
loop driver models are available. The double lane-

631

Modelica 2008, March 3rd  4th , 2008

N. Philipson, J. Andreasson, M. Gafvert, A. Woodruff

change road maneuver as seen in Figure 1 is useful for
emergency handling evaluation since it excites the roll
motion which may cause roll-over [5]. The experiment
is set up using a driver model that follows the road path
defined by RoadBuilder [2]. The sine steering excitation experiment shown in Figure 4 is instead realized
using an open loop steering robot while a drive robot
is keeping the speed constant.
For out-of-plane frequency response, the shaker table
can be used [2]. It is implemented as a ground model
containing patches with time dependent altitudes, defined by inputs. Since a heavy vehicle can have more
than two axles, the shaker table has a configurable
number of patches to suite any number of axles and
wheel locations. Correspondingly, several suspension
rigs can be used together for detailed analysis of bogie
axles, see Figure 6.

monly used in e.g. Australia. These vehicle combinations allow for one driver to freight a larger amount
of cargo compared to a tractor pulling a single trailer.
Unlike rail-carried trains that are self steered by the
rail-wheel interaction, road trains are more sensible to
disturbances and may even exhibit instability if care
is not taken. Additionally, road trains are heavy and
thereby hard to stop which requires them to be able to
steer to avoid accidents. This puts high demands on
the design of trucks and trailers so that they safely can
be combined into road trains under a variety of load
conditions. In VDL, these configurations can be defined and tested conveniently. Figure 7 shows a set-up
with tree trailers pulled by a tractor.

Figure 6: Twin axle with load distribution linkage in a Figure 7: Road train with three trailers, diagram view
suspension rig.
(top) and animation screen shot (bottom).

5

Customization

5.2

Moving tire test rig

Tire test rigs are can be subdivided into two main categories depending on if the tested wheel or the ground
surface is moving. For the latter case, the ground is
typically implemented as drum or a belt. The drawback with these two concepts are on one hand that the
belt only makes it possible to use elastic surface material such as steel and on the other hand that a drum
has to have a curvature which impacts the tire-surface
contact. To avoid this and to enable testing on real road
surfaces such as gravel, asphalt, and ice under differ5.1 Road Train
ent conditions with respect to moisture, temperature,
Equipages with combinations of a truck or tractor with and so on, the tested wheel can be mounted on a movtwo or more trailers forms a road train of the type com- ing rig, typically attached to a heavy truck. However,
Just as for passenger cars and light vehicles,
VDL/Trucks is extended with a set of examples for
heavy vehicles. This includes both truck with full
trailer and tractor with semitrailer as seen in Figures 1
and 4, respectively. Thanks to the flexibility inherent
in the library, it is straightforward to re-configure these
and even build completely different equipages, as illustrated by the examples in this section.

The Modelica Association

632

Modelica 2008, March 3rd  4th , 2008

Heavy Vehicle Modeling with VehicleDynamics Library

a moving rig is harder to control, especially since the
forces generated from the tested wheel will affect the
course of the truck. To investigate both the static and
dynamic effects of the total system of truck, rig, and
tire on resulting measurements, a moving tire test rig
was implemented by mounting a test rig with wheel
onto a truck model as illustrated in Figure 8. The results were then compared to standard test rig simulations and real mobile-rig mesurement results and provided insight into the interpretation of sensor signals.

Figure 9: Experiment with in- and outputs for
Simulink. Inputs: Steering wheel angle, engine
torque, gear, wheel brake clamp forces. Outputs: Vehicle states, tire forces and wheel spin velocities.

Figure 8: Mobile tire test rig mounted on a truck.

6

Simulink

Just as for passenger cars, heavy vehicles modeled
with VDL can be imported into the Simulink [7] environment. Figure 9 shows an experiment layout in
Dymola [6] used for the yaw control application in
Simulink shown in Figure 10. In applications like this
VDL/Trucks can provide models that are of great use
in the design and validation of various chassis control
functions.

Figure 10: Yaw control application for the tractorsemitrailer combination shown in Figure 9.

8

Summary

This paper shows how the Vehicle Dynamics Library
is extended with the VDL/Trucks option for heavy
and commercial road-vehicle modeling and simulation. An overview of the recent additions is given and
7 Future
it is shown with several examples how the openness,
Currently the VDL/Trucks option is focused on the flexibility, and extensibility from VDL/Cars is mainchassis and covers well the most commonly used vehi- tained and extended.
cle types. VDL/Cars have more complete support for
full vehicle modeling with templates for powertrains,
drivelines, brakes, engines, etc. Future development
will move in the direction of complete vehicle model- References
ing also for heavy vehicles. Until then, many components are still available to build those subsystems from [1] Modelon AB, Lund, Sweden. The VehicleDybase classes, but without extensive templates.
namics library, Users Guide, Version 1.2, 2007.
The Modelica Association

633

Modelica 2008, March 3rd  4th , 2008

N. Philipson, J. Andreasson, M. Gafvert, A. Woodruff

[2] J. Andreasson and M. Gvert, The VehicleDynamics Library - Overview and Applications.
In: Proceedings of the 5th Modelica Conference, Vienna, Austria, Modelica Association, 4-5
September 2006.
[3] N. Philipson, Extension of a tool for vehicle dynamics studies to handle heavy vehicle configurations. Master Thesis Report, KTH-AVE, 2007.
[4] N. Philipson, Leaf spring modeling. In: Proceedings of the 5th Modelica Conference, Vienna,
Austria, Modelica Association, 4-5 September
2006.
[5] E. Dahlberg and A. Stensson, The Dynamic
Rollover Threshold of Commercial Vehicles - a
Sensitivity Study. International Journal of Vehicle Design, Vol. 40, No. 1-3, pp. 228-250, 2006.
[6] Dymola - Dynamic Modelica Laboratory,
http://www.dynasim.se
[7] The MathWorks:
Matlab
http://www.mathworks.com

The Modelica Association

and

Simulink

634

Modelica 2008, March 3rd  4th , 2008

Session 6a
Language, Tools and Algorithms

The Modelica Association

635

Modelica 2008, March 3-4, 2008

The Modelica Association

636

Modelica 2008, March 3rd  4th , 2008

Compiling and Using Pattern Matching in Modelica

The Modelica Association

637

Modelica 2008, March 3rd  4th , 2008

K. Stavaker, A. Pop, P. Fritzson

The Modelica Association

638

Modelica 2008, March 3rd  4th , 2008

Compiling and Using Pattern Matching in Modelica

The Modelica Association

639

Modelica 2008, March 3rd  4th , 2008

K. Stavaker, A. Pop, P. Fritzson

The Modelica Association

640

Modelica 2008, March 3rd  4th , 2008

Compiling and Using Pattern Matching in Modelica

The Modelica Association

641

Modelica 2008, March 3rd  4th , 2008

K. Stavaker, A. Pop, P. Fritzson

The Modelica Association

642

Modelica 2008, March 3rd  4th , 2008

Compiling and Using Pattern Matching in Modelica

The Modelica Association

643

Modelica 2008, March 3rd  4th , 2008

K. Stavaker, A. Pop, P. Fritzson

The Modelica Association

644

Modelica 2008, March 3rd  4th , 2008

Compiling and Using Pattern Matching in Modelica

The Modelica Association

645

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

646

Modelica 2008, March 3rd  4th , 2008

Patterns and Anti-Patterns in Modelica

Patterns and Anti-Patterns in Modelica
Dr. Michael M Tiller
Emmeskay, Inc.
Plymouth, MI, USA
mtiller@emmeskay.com

Abstract
In 1977, Christopher Alexander, Sara Ishikawa
and Murray Silverstein published the book A Pattern Language: Towns, Buildings, Construction [1].
Although the topic of the book was architecture, it
inspired Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides in their approach to pattern
based software development. This ultimately led to
the publication, in 1994, of the book Design Patterns: Elements of Reusable Object-Oriented Software [2] (also known as the Gang of Four or
GoF book) which launched a major movement in
the software development community toward pattern
based software design. The idea behind the pattern
movement is to formally identify sound design solutions to common problems.
Since the publication of Design Patterns there
have been numerous books published on the topic of
software patterns. Several of these books dealt with
the sub-topic of anti-patterns [3,4]. In contrast to a
normal pattern, anti-patterns are an attempt to identify common bad practices and ways they can be
refactored using sound design patterns.
The emphasis of the pattern community is, understandably, on object-oriented languages with procedural semantics. This paper will build on previous
work [5] identifying patterns in Modelica. These
design patterns include how medium properties can
be handled in a flexible way, how to deal with systems with varying causality and differential index,
idealized plant control and, finally, coordination between models. In addition, this paper includes some
extensive discussion of anti-patterns to avoid redundant code, awkward data management and inflexible
models.
This paper continues the discussion on patterns
within the Modelica community with the hope that
this will encourage others to contribute patterns of
their own. One obvious benefit of such efforts will
be additional resources for Modelica developers to
make the process of developing models in Modelica
easier. In addition, we expect that many of the patThe Modelica Association

terns discussed will also generate proposals for improving the Modelica language through new features
and semantics.
Keywords: patterns, anti-patterns

1

Background

When Alexander et. al., published their work,
each pattern included four principle aspects, the pattern name, the context in which the pattern applied,
the problem the pattern attempted to address and the
proposed solution. This paper will focus primarily
on the problem and solution.
In September of 2006, Mark Dominus wrote an
essay in his blog [6] in which he concluded with the
following statement:
Patterns are signs of weakness in programming
languages. When we identify and document one,
that should not be the end of the story. Rather,
we should have the long-term goal of trying to
understand how to improve the language so that
the pattern becomes invisible or unnecessary.
This statement triggered quite a bit of controversy
and many people argued with this assertion, not the
least of which was Ralph Johnson [7], co-author of
the original Design Patterns book who argued that
patterns are simply manifestations of high level concepts beyond the scope of language semantics.
In this paper the assumption will be that the truth
lies somewhere in between. Some patterns are simply manifestations of design decisions made in the
development of a given language. Other patterns
appear to address missing expressiveness in the underlying language. In some cases, patterns are simply introduced to encourage consistency and readability above and beyond what is really the purview
of language designers. Along with the patterns
themselves some discussion will be included indicat-

647

Modelica 2008, March 3rd  4th , 2008

M. Tiller

ing to what degree each pattern (or anti-pattern, as
the case may be) could be mitigated by changes in
the language or standard library.

2
2.1

Design Patterns
Architecture Pattern

2.1.1 Problem
While building models to support a variety of
systems and/or subsystems a large collection of
models with many structural similarities have been
developed. Adding additional models involves constructing models either by copy and pasting large
chunks from previous models or dragging and dropping the complete model from scratch.
There are two distinct issues being discussed.
The first is the amount of work required to create a
new model. The second is about redundancy between models. This pattern focuses on the former
and the latter is discussed as part of the DRY antipattern in Section 3.1.

2.1.2 Solution
When significant structural similarities exist between system or subsystem models then these models can be formulated in terms of architectures. In
doing so, each model becomes simply a variation of
the architecture with the various interfaces replaced
by implementations that are appropriate for that specific model.
For example, building vehicle models by simply
dragging all the usual constituents (e.g. engine,
transmission, chassis, etc) into a diagram can be
quite time consuming and tedious whereas building
them as variations from a standard vehicle architecture (e.g. [8]) can greatly reduce the overhead of creating and managing such models.
2.2

Singleton Pattern

2.2.2 Solution
In languages like Java and C++, the use of the
static qualifier on members provides a language
supported mechanism for ensuring uniqueness within
a given program. The closest equivalent in Modelica
would be a variable declared as constant. However, the values of constants cannot be changed so
while semantically similar, this is not adequate to
achieve the singleton pattern. Instead, the use of
inner and outer qualifiers is a more common
choice. By referring to an inner instance it is possible for all outer references to act simply as pointers to a single object. The use of inner and
outer has an additional advantage (or disadvantage, depending on how strict you need to be) which
is that they can be nested inside each other.
Two immediate examples of the singleton pattern can be found in the Modelica Standard Library.
The first is in the Multibody library. The design of
the library is such that it requires that there is exactly
one instance of the so-called world object in the
system to provide a reference coordinate system.
Another example, which exploits the ability to nest
one subsystem (requiring its own internally unique
singleton) inside another subsystem, can be seen in
the StateGraph library [9].
An example where the use of inner and
outer is not currently sufficient is in dealing with
many to many interactions. For example, consider
a model of the solar system. Each planet exerts a
gravitational force on all the others. While it is possible to implement each gravitational force as an individual component that connects between every
combination of planet instances in a system, it is
more convenient and scalable to have some kind of
(singleton) intermediary component that is somehow
aware of all planet instances and can, within the context of that single model, handle all interactions.
Similar many to many requirements can be found
in systems where collisions are possible between
multiple bodies.

2.2.1 Problem

2.3

When building libraries of models it is sometimes necessary to design the library in such a way
that there is a single instance somewhere that includes a definitive reference for some information.
The basic idea is that within some scope there is exactly one such instance. The challenge is not simply
how to access that singleton object but how to design the library so that this is handled well for users.

The medium model pattern is more generally
called the abstract factory or kit pattern. However in Modelica the most common use is to represent medium properties. For this reason the name
medium model is used since it is more familiar to
the target audience of this paper having appeared in
previous work [10, 11].

The Modelica Association

648

Medium Model Pattern

Modelica 2008, March 3rd  4th , 2008

Patterns and Anti-Patterns in Modelica

2.3.1 Problem
In a nutshell, the medium model pattern shows
up in models that include multiple configurable types
that must be, in some way, consistent with each
other. As already mentioned, this is something that
occurs often when characterizing the medium of a
given fluid system. The configurable types typically
include (but are not limited to) connector definitions
and some kind of property evaluation model. The
essential point is that many assumptions about a fluid
bind the definition of the connectors and the property
evaluation together (e.g. the number of species). For
example, it would not make sense to combine the
connector a multi-species gas with the properties of
oil.

2.3.2 Solution
As mentioned previously, this approach is called
the abstract factory pattern in other languages and
it is usually achieved through abstract methods that
return instances abstract types. The consistency is
assured by the implementation of the abstract factory. Because Modelica lacks methods or even any
appreciably dynamic object creation, the same effect
is achieved in Modelica using replaceable packages.
By using replaceable packages, it is possible for
models to reference constants and types defined in
the constraining package defined or implied in the
replaceable definition. A given implementation
(e.g. a specific medium) can then redefine these
types and constants in a consistent way (e.g. so they
all represent the same medium). The following sample code demonstrates the use of this pattern. First,
an abstract model of the medium must be defined:
partial model AbstractMedium
constant Integer n # of Species;
connector Fluid
Pressure p;
flow MassFlowRate m_dot;
MassFraction Xi[n-1];
flow MassFlowRate mXi_dot[n-1];
end Fluid;
partial block Properties
input Pressure p;
input MassFraction Xi[n-1];
output SpecificEnergy u;
output SpecificEnthalpy h;
end Properties;
end AbstractMedium;

The Modelica Association

Based on this abstract medium model, component
models can then be written that rely on information
from the medium model but without knowledge of
what specific medium model is being used:
model Component
replaceable package MediumModel =
AbstractMedium;
MediumModel.Fluid c;
MediumModel.Properties props(
p=c.p,X=c.X);
equation
// equations in this component
// can reference the pressure
// at the connector, c.p, or
// properties of the fluid,
// e.g. props.h
end Component;

Finally, an implementation of the medium model can
be created by extending from the abstract medium
model:
package RealMedium
extends AbstractMedium(nspecies=2);
redeclare model extends Properties
equation
// This model may include things
// like property calculations or
// an equation of state.
end Properties;
end RealMedium;

One usability issue with this pattern is that when
it is used in conjunction with the transport of physical information or behavior it is somewhat counter
intuitive since the redefinitions of the medium model
are propagated from top down when users think, at
least conceptually, that the information should be
propagated through connections. For example, the
Component model in the previous sample code
would need to be instantiated with a modification
specifying the medium model, e.g.
Component comp(
redeclare package MediumModel =
RealMedium);

whereas most users would expect that somehow
the type of medium was dictated by what the instace
was connected to. While this is not an issue with the
649

Modelica 2008, March 3rd  4th , 2008

M. Tiller

pattern in general, it is an important consideration for
language designers and tool vendors.
2.4

Adapter Pattern

2.4.1 Problem
When working with architectures, it is necessary
for the subsystem models to be developed so that
they satisfy the interface prescribed by the architecture. However, there are many cases where the subsystem model might be developed independently
from an architecture and as a result it does not conform to any specific interface. This situation may
come about because the subsystem models were developed before the architecture or perhaps they were
developed in an architecturally neutral way to avoid
dependence on a particular architecture or to support
multiple architectures.

model Vehicle1
extends VehicleInterfaceA(
vehicle_speed=);
end Vehicle1;
model Vehicle2
extends VehicleInterfaceA(
vehicle_speed=);
end Vehicle2;

Now consider an alternative vehicle model interface
and system architecture definition:
partial model VehicleInterfaceB
RealOutput v_vehicle;
end VehicleInterfaceB;

2.4.2 Solution
In these circumstances, it may be necessary to
develop adaptor components. Such components provide a mapping from the interface that the subsystem
currently has to the interface that is to be supported.
There are two variations of this pattern. In the first
case, the subsystem is developed independently from
any particular interface. In this case, the development of an adapter for the subsystem is a one time
only process since other subsystems are unlikely to
share the exact same interface (and if they do, they
should probably be refactored as described in Section 3.1).
The other case is where the subsystem has been
developed according to a specific interface (one that
presumably other subsystems satisfy). In this case, a
general adaptor could be constructed that maps one
interface onto another. Such an adaptor could then
be used as an adaptor for multiple subsystems. This
kind of adaptor pattern can also be used to implement compatibility between comparable interfaces
across different architectures.
The following code fragment shows an example
of how the adaptor pattern is implemented. First, let
us consider the one potential (and greatly simplified)
interface for a vehicle model:
partial model VehicleInterfaceA
RealOutput vehicle_speed;
end VehicleInterfaceA;

An adaptor between the different interfaces could be
developed as follows:
model VehicleAdaptor_A2B
extends VehicleInterfaceB;
replaceable VehicleInterfaceA vehicle;
equation
connect(vehicle.vehicle_speed,
v_vehicle);
end VehicleAdaptor_A2B;

Using this adaptor it is possible to build a system that
utilizes ArchitectureB but uses an implementation of VehicleInterfaceA as follows:
model System
extends ArchitectureB(
redeclare VehicleAdaptor_A2B(
redeclare Vehicle1 vehicle));
end System;

2.5

Several vehicle models might be developed using
this interface, e.g.

The Modelica Association

partial model ArchitectureB
replaceable VehicleInterfaceB vehicle;

end ArchitectureB;

Parametric Behavior Pattern

2.5.1 Problem
In acausal modeling most components tend to
describe the flow of some conserved quantity explic-

650

Modelica 2008, March 3rd  4th , 2008

Patterns and Anti-Patterns in Modelica

itly in terms of the across variables (e.g. i=v*R).
Other components describe the flow of conserved
quantities implicitly in terms of constraints (e.g. an
ideal voltage). However, it is often quite useful to be
able to describe components that describe the flow of
conserved quantities in terms of both implicit and
explicit relations depending on the state of the component. The simplest example of such a component
is an electrical diode which either allows no current
(explicit case) or no voltage drop (implicit case).
Another slightly more complicated case would be a
clutch which computes transmitted torque explicitly
in terms of dynamic friction when disengaged or
slipping but computes torque implicitly in terms of a
kinematic relation when locked.

2.5.2 Solution
One easy way to describe such behavior is to
compromise on the ideal nature of the behavior. For
example, where an ideal diode might describe the
implicit and explicit behavior using the equations
v=0 and i=0, respectively, a compromise model sacrifices the idealization might use the equations
v=G*i and i=v*R, where G is chosen to be very
small (to approximate the v=0 case) and R is chosen
to be very large (to approximate the i=0 case). The
result of this compromise is that the behavior is now
completely explicit in nature. However, another
consequence of this easy solution is that the system of equations is very likely to be poorly conditioned which means the system will be stiff and slow
to simulate.
A better solution (from the modelers perspective at least) is to capture the ideal behavior somehow. Not only is this possible but it can be a very
elegant and useful way to approach such problems.
The basic premise (which is presented in greater detail in [12]) is to introduce a third variable and describe the behavior of the original variables in terms
of the third parametric variable. This approach is
frequently used in geometric applications where it is
not possible to use a particular coordinate axis as an
independent variable to describe a line or surface.
The same issue is present, for example, in a diode
where it is not possible to write current explicitly in
terms of voltage nor is it possible to write voltage
explicitly in terms of current. However, it is possible
to write both in terms of a third parametric variable,
e.g.
off = s<0;
v = if off then s*unitV else 0;
i = if off then 0 else s*unitC;

The Modelica Association

where unitV and unitC are defined as follows:
import Modelica.SIunits.Voltage;
import Modelica.SIunits.Current;
constant Voltage unitV=1;
constant Current unitC=1;

Analysis of this parametric approach shows that
describing this kind of behavior is not simply an issue with the expressiveness of the underlying modeling language but with the solution method. While
some basic solution techniques exist to deal with
component models that are either implicit or explicit,
the ability of a component to function in both ways
creates additional complications for the underlying
solver.
One such complication is that switching between
two different sets of equations during a simulation
always brings with it the risk that the differential index of the system might change. As such, the posed
problem could be a variable index system. In fact, a
clutch model normally leads to a variable index system when modeled using the parametric behavior
pattern. However, by understanding this in advance
it is possible to differentiate the equations such that
the index is no longer variable. For this reason, it
would be very useful if investigation into this issue
showed that a general algorithm could be developed
along similar lines. Such an algorithm would most
likely benefit from language features that directly
supported this pattern.
2.6

Perfect Control Pattern

2.6.1 Problem
Physical models typically include sensors and
actuators and these are in turn normally connected to
some kind of control system. One of the burdens
that model developers face is to provide some kind
of actuator control strategy in addition to the base
physical models. In many cases, the model developer is not particularly interested in the dynamics of
the controller but they need some function in the
model to determine how the actuator will behave and
so therefore implementation of controls is unavoidable. Such implementations often take time both to
construct and calibrate and many times they do not
add any significant value to the model.

2.6.2 Solution
It is important to point out that this pattern is
very specific to cases where the model developer
simply wants a very good controller but they dont
651

Modelica 2008, March 3rd  4th , 2008

M. Tiller

need to be very concerned about how such a control
strategy would actually be deployed or implemented
in hardware. In these specific circumstances, it is
often possible to rely on a perfect control strategy
to control the device. For example, consider a simple SISO plant model defined as follows:
model PlantModel
input Real u;
output Real y;
protected
Real dy = der(y);
equation
2*der(dy) + dy + 4*y = u;
end PlantModel;

Closed Loop Response

2

0

0

1

2

"Perfect" Command

15

3

4

5

4

5

Closed Loop Command

10
5
0
-5
0

1

2

3

Figure 1: Example of "Perfect" Control Pattern

model ClosedLoop
PlantModel plant;
protected
Real ybar = max(0,time-2);
equation
plant.u = 10*(ybar-plant.y);
end ClosedLoop;

3

model PerfectControl
PlantModel plant;
protected
Real ybar = max(0,time-2);
equation
ybar = plant.y;
end PerfectControl;

The simulation results from both types of control
can be seen in Figure 1. The basic idea of this pattern is rather than including an explicit equation for
the command to the system an equation prescribing
the output is used. This equation for the output acts
as an implicit equation for the input. It should be
pointed out that this type of approach is limited to
cases where the plant model is sufficiently invertible.
Despite this limitation, this is a useful pattern that
can be used in conjunction with some surprisingly
complex systems. For example, this approach is the
same approach that is employed to create backward drive cycle models (models where the vehicle
speed is prescribed and the system resolves the
torque required to meet the speed profile). In addition, this same pattern can be used in conjunction
with actuators like clutches and valves.

The Modelica Association

"Perfect" Response

4

Anti-Patterns

Patterns are primarily useful for intermediate to
advanced users who, having written some substantial
amounts of code, are able to recognize the emergence of patterns and are interested in understanding
how patterns can help them be more productive (as
well as improve consistency and readability among
project members).
However, Modelica is still a relatively new technology with many new users. As a result, antipatterns are probably at least as important as patterns. The reason is that anti-patterns can help novices to recognize weaknesses in code they have written. As such, anti-patterns are almost immediately
applicable. This section introduces several antipatterns and discusses refactoring approaches associated with each pattern.
This is not to say that anti-patterns only apply to
novice users. Because Modelica improves developer
productivity, it is very easy to write a large volume
of code only to realize in hindsight that some antipatterns have developed. As a result, the material in
this section is applicable to a wide range of users.
As such, the material in the anti-patterns section
should be of particular interest to tool vendors since
refactoring typically requires tool support.
3.1

DRY Anti-Pattern

3.1.1 Problem
By far, the most common anti-pattern is the use
of copying and pasting model code between models. While this happens for a wide variety of reasons
most of them are ultimately because users are not
aware of the various mechanisms within Modelica

652

Modelica 2008, March 3rd  4th , 2008

Patterns and Anti-Patterns in Modelica

for code reuse. In software development there is
something known as the DRY principle where
DRY is an acronym for Dont Repeat Yourself.
The DRY anti-pattern is one where the DRY principle has not been followed.
The reason that the DRY principle is so important (and which has led to the motto that redundancy is the root of all evil) is that redundancy creates many problems. Not only does it lead to inefficiency when building models it also means significantly more work when maintaining those same
models.

3.1.2 Solution
While this is a very common anti-pattern, the
good news is that Modelica contains a rich supply of
language features to help combat it. The first language feature all users should become familiar with
is inheritance (specifically, the extends keyword).
Once developers understand inheritance they should
investigate the architecture pattern (described previously in this paper) which hinges on the replaceable and redeclare keywords.
One issue that prevents addressing this antipattern is tool support for refactoring. This manifests itself in several ways. First, it should be possible for users to change the names of components
and/or classes and be assured that all references that
use those names are also adjusted (ideally even if
they are not even currently loaded). Furthermore,
refactoring of existing code often involves the exercises of identifying commonality between existing
models, composing base classes that contain this
common code and then extending the original models from the base classes. Without tool support, such
refactoring can be very time consuming.
3.2

Kitchen Sink Anti-Pattern

3.2.1 Problem
Another common anti-pattern is the kitchen
sink anti-pattern. There are two variations of this
pattern. For component models, the anti-pattern
manifests itself as component models with too many
equations by lumping several distinct types of behavior together into a single component. For subsystem
models, the anti-pattern manifests itself in diagrams
with an unnecessarily large number of components.

3.2.2 Solution
In both of these cases, a divide and conquer
approach is required. For the component variation,
this means building component models that heed
The Modelica Association

Occams Razor, entia non sunt multiplicanda
praeter necessitatem. In practical terms, this means
building component models that attempt as much as
possible to describe individual effects (e.g. inertia,
compliance, dissipation, etc).
In the case of subsystem models, refactoring is
typically a matter of nesting some tightly coupled
subset of components into a subsystem of their own.
Again, tool support is an issue here. Simulink has a
very convenient feature to take a group of selected
components and lump them into a subsystem model.
Modelica tool vendors would do well to recognize
the value of such functionality (and users would do
well to remind them).
3.3

Literal Data Overload Anti-Pattern

3.3.1 Problem
Modelica supports a wide range of ways to deal
with data handling. In theory, users can bring data in
from an external database, they could read it from
external files, etc. However, the simplest way to
import data into Modelica models is to enter it literally (e.g. parameter Real table[:,2] =
[0, 1; 1, 2; 2, 3; ]). While there is
nothing wrong with this per se, it leads very quickly
to the literal data overload anti-pattern. The pattern
is characterized by the tendency of models to rely on
literal data. While this is acceptable for simple component models, this creates two problems with more
complex models. The first complication is that entering tables of data is often quite inconvenient. The
second complication is that often times any given
parameter cannot be changed independently. For
example data associated with a given electric motor
might bring together the rotor inertia, internal resistance, bearing friction, etc into a set of parameters.
If a different motor is to be used, it is not simply a
matter of changing a single parameter value but the
entire set must be exchanged for another consistent
set representing a different motor.

3.3.2 Solution
Both issues of entering literal data and parameter
set consistency can be handled by creating records to
represent such parameter sets and including the literal data only in the context of the record definitions.
In addition, it is advisable to make use of the
choices annotation so tools understand how the
data will be used. The result of such refactoring is
that users will only see opaque references to complex
and/or voluminous data sets rather than vast expressions containing literal data. It is also a advisable to
provide useful descriptions of the data sets so tools

653

Modelica 2008, March 3rd  4th , 2008

M. Tiller

can provide users with clear descriptions of available
choices.
3.4

Parameter Data Overload Anti-Pattern

3.4.1 Problem
The previous anti-pattern addresses some of the
issues associated with models that require large
amounts of data. While the aggregation prescribed
for refactoring reduces the number of individual parameters a complex system with many components
can still contain large numbers of parameter sets (and
even the aggregations themselves may have an unwieldy number of parameters). The result is parameter dialogs that contain large numbers of parameter
values and/or choices. In these cases, further consolidation doesnt make sense (since we do not want
to aggregate data together that is actually independent or unrelated) as a way to address the overload.

3.4.2 Solution
In cases where aggregation is not an appropriate
remedy the standard annotations for grouping parameters by tab and group can be utilized. Rather
than aggregate the data, the result of using the tab
and group directives is to organize the data into a
tree (i.e. the data is presented in a hierarchy where
the first layer is determined by the tab and the next
layers is determined by group). In particular, common parameters should be organized such that they
appear in the default tab and less common parameters are assigned to later tabs. Tab labels are also an
important consideration since users should be able to
determine quickly, based on the name, whether they
need to look in a particular tab.

4

Language Implications

Many of the normal patterns found in [2] do
not appear in this paper. This is primarily because
Modelica does not include concepts like pointers and
methods which are fundamental to many of the patterns. Furthermore, it has been observed that many
of the traditional patterns in software development
essentially boil down to adding an additional level of
indirection to an abstraction. Since there are very
few ways to express this indirection in Modelica, the
number of patterns is fairly limited.
One of the lingering questions from this discussion is to what extent these patterns (or lack of patterns) represent deficiencies in the language. For the
patterns and anti-patterns that are related to redundant code (i.e. Sections 2.1, 3.1 and 3.2) the lanThe Modelica Association

guage is well equipped to address these issues although there are certainly ways that tools can assist
model developers in more effectively utilizing those
language features.
Although the Singleton pattern is being used in
several libraries it is this authors opinion that the
semantics of the language do not mesh as well with
the pattern and modeler needs. The use of inner and
outer in this way has implications for robust model
checking and the dependency on inner elements is
not easily recognized or represented. In addition, the
many to many issue mentioned in Section 2.2.2
requires improved expressiveness in the language.
In the case of the medium model pattern, the inability to express type constraints through physical
connections is a serious limitation in the language
and one that is recognized in the design group.
Hopefully this deficiency will be addressed soon.
Section 2.5.2 discusses how behavior can be described parametrically. However, there are many
different ways to phrase this kind of behavior and
they cannot necessarily be easily recognized by
tools. Having language elements for describing parametric relationships could not only bring consistency how such behavior is described but it could
also allow tools to automatically deal with variable
index issues that currently burden developers (equation differentiation, continuity concerns, finite state
machines, etc).

5

Conclusion

The goal of this paper is to identify common patterns and anti-patterns to help users identify easy
solutions for common problems as well as to prompt
discussions within the Modelica design group on
ways the language can be enhanced to either institutionalize some of the best practices in these patterns
or add language features to eliminate the need for
these patterns.

References

654

1. Alexander, C., Ishikawa, S., and Silverstein,
M., A Pattern Language: Towns, Buildings,
Construction, Oxford University Press,
ISBN 0-19-501919-9, 1977.
2. Gamma, E., Helm, R., Johnson, R. and Vlissides, J., Design Patterns: Elements of Reusable Object-Oriented Software, AddisonWesley, ISBN 0-201-63361-2, 1994.

Modelica 2008, March 3rd  4th , 2008

Patterns and Anti-Patterns in Modelica

3. Brown, J. W., Malveau, R. C. and Mowbray,
T. J., AntiPatterns: Refactoring Software,
Architectures, and Projects in Crisis, John
Wiley and Sons, ISBN 0-471-19713-0, 1998.
4. Laplante, P. A., Neill, C. J., Antipatterns:
Identification, Refactoring, and Management, CRC Press, ISBN 0-8493-2994-9,
2006
5. Clauss, C., Leitner, T., Schneider, A. and
Schwarz, P., Object-oriented Modelling of
Physical Systems with Modelica using Design Patterns, Fraunhofer Institute, 2000
6. Dominus, M., Design Patterns of 1972,
http://blog.plover.com/prog/designpatterns.html
7. Johnson, R., Design patterns and language
design,
http://www.cincomsmalltalk.com/userblogs/r
alph/blogView?entry=3335803396
8. Tiller, M., Bowles, P. and Dempsey, M.,
Development of a Vehicle Modeling Architecture in Modelica, 3rd International Modelica Conference, 2003.
9. Otter, M., Arzen, K.-E., Dressler I.,
StateGraph-A Modelica Library for Hierarchical State Machines, 4th International
Modelica Conference, 2005.
10. Newman, C. E., Batteh, J. J., Tiller, M.,
Spark-Ignited Engine Cycle Simulation in
Modelica, 2nd International Modelica Conference,
2002.
http://www.modelica.org/events/Conference
2002/papers/p17_Newman.pdf
11. Elmqvist H., Tummescheit, H., Otter, M.,
Object-Oriented Modeling of Thermo-Fluid
Systems, 3rd International Modelica Conference, 2003.
12. Tiller, M. M., Introduction to Physical
Modeling with Modelica, Kluwer Academic Publishers, ISBN 0-7923-7367-7,
2001.

The Modelica Association

655

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

656

Modelica 2008, March 3rd  4th , 2008

Comment- and Indentation Preserving Refactoring and Unparsing for Modelica

Comment- and Indentation Preserving Refactoring
and Unparsing for Modelica
Peter Fritzson, Adrian Pop, Kristoffer Norling, Mikael Blom
PELAB  Programming Environment Lab, Dept. Computer Science
Linkping University, SE-581 83 Linkping, Sweden
{petfr, adrpo, x06krino, x06mikbl}@ida.liu.se

Abstract
In this paper we present a strategy for comment- and
indentation preserving refactoring and unparsing for
Modelica. The approach is general, but is currently being implemented for Modelica in the OpenModelica
environment. We believe this to be one of the first unparsing approaches that can preserve all user-defined
indentation and comment information, as well as fulfilling the principle of minimal replacement at refactorings.
Keywords: Refactoring, comments, unparsing,, Modelica.

1

Introduction

Integrated programming environments, e.g. InterLisp
[11] and Eclipse [12] provide various degrees of support for program transformations intended to improve
the structure of programs  so-called refactorings [5]
(see also Section 10).
Such operations typically operate on abstract syntax
tree (AST) representations of the program. Therefore
the program needs to be converted to tree form by parsing before refactoring, and be converted back into text
by the process of unparsing, also called pretty printing
This is supported by a number of environments (Section 10).
However, a well-known problem is that of preserving comments and user-defined indentation while performing refactorings. Essentially all current environments either loose the comments (except for special
comments that are part of the language syntax and AST
representation), or move them to some other place.
User-defined indentation is typically lost and replaced
by machine-generated standard indentations. This is
accepted by some developers, but judged as unacceptable by others. However, if the objective only is to improve indentation, then a semi-automatic indenter can
be used instead (Section 8.3).

The Modelica Association

Currently Modelica-based tools are handling only declaration comments that are part of the model and are
discarding or moving all the other comments, i.e. the
ones between /* */ and after //. Such behavior is
highly undesirable from a user perspective and heavily
affects the ease-of-use of code-versioning tools.
A goal for the work presented here is to support
Modelica code refactoring with minimal disruption of
user-defined comments and indentation. In this paper
we present such an approach for unparsing in conjunction with refactorings.

2

Comments and Indentation

Regard the following contrived Modelica example. It
has one declaration comment which is part of the language syntax, and two textual comments Itemcomm
and MyComm which would be eliminated by a conventional parser. It is also nicely hand formatted so that the
start positions of each component name in the text are
vertically aligned.
record MODIFICATION

"Declaration comment"

Boolean
finalItem; //Itemcomm
Each /* MyComm */ eachRef;
ComponentRef
componentReg;
end MODIFICATION;

Assume that this is parsed and unparsed by a conventional (comment-preserving) unparser, putting two
blanks between the type and the component name of
each component. The manual indentation would be
lost, and the textual comments would be moved to
some standard positions (or be lost):

657

record MODIFICATION "Declaration comment"
Boolean finalItem; //Itemcomm
Each eachRef; /* MyComm */
ComponentRef componentReg;
end MODIFICATION;

Modelica 2008, March 3rd  4th , 2008

P. Fritzson, A. Pop, K. Norling, M. Blom

3

Refactorings

4

Below we make some general observations and give
examples of refactorings.

3.1

The Principle of Minimal Replacement

For a refactoring to have minimal disruption on the
existing code, it is desired that it supports the principle
of minimal replacement:

How should information about comments and user defined indentation be represented in the internal (AST)
program representation? There are basically two possibilities for a chunk of code, e.g. a model:
 Tree. The AST representation is the main storage
(the TRUTH). Comments and indentation as extra
nodes/attributes in the AST.
 Text. The text representation, including indentation
and comments, is the main storage (the TRUTH).

 When replacing a subtree, the minimal subtree that
contains the change should be replaced.
This also has the consequence of minimal loss or
change of comments. For example, if a name (an identifier) is changed, only the identifier node in the tree
should be replaced, not the surrounding subtree.

3.2

The tree approach may seem natural, since the refactorings and the compiler operate on the tree representation. However, it has some disadvantages:
 Since white space and comments can appear essentially anywhere, between nodes, associated with
nodes, the AST will become cluttered and increase
the required memory usage and complexity of the
tree, perhaps by a factor 2-3.
 The large number of extra nodes in the AST may
complicate code accessing and traversing the tree.

Some Examples of Refactorings

Here we mention a few common refactorings. There are
also numerous, more advanced and specialized refactorings.
 Component name change. Change name of a component name in a record. For example:

Regarding the text representation we make the following observations:

record MODIFICATION "Declaration comment"
Boolean
finalItem; //Itemcomm
Each /* MyComm */ eachRef;
ComponentRef
componentReg;
end MODIFICATION;

 The text representation exists from the start, since
this is the storage form used in the file system. Environments like Eclipse use text buffers for direct
interaction with the programmer.
 The text representation includes all indentation and
comment information, and is compact.
 The structure of the program in the text representation is not apparent, and cannot be easily manipulated.

The name of the component reference name is currently componentReg, which is an error. It should
be componentRef. We would like to change the
name both in the declaration and all its uses, thus
avoiding updating all named references by hand,
which would be quite tedious.
 Function name change. Change the name of a function, both the declaration and all call sites.
 Add record component. Add a new component declaration to record. In MetaModelica, that would also
mean putting an underscore '_' at the correct position in all patterns for that record type with positional matching.

Why not combine the advantages of each representation, and try to avoid the disadvantages?

 Add function formal parameter. Add an input or
output formal parameter to a function. The question
is, how much is possible to do automatically? Adding arguments to recursive calls to the function itself
is no great problem, but calls from other functions
can be more problematic since meaningful input
data needs to be provided. This can be handled easily in those cases a default value can be passed to
the function's new formal parameter.

The Modelica Association

Representing Comments and UserDefined Indentation

658

 Use the text representation as the basic storage format including indentation and comment information. The text might be conceptually divided into
chunks, where for example each class definition
gives rise to a text chunk.
 Use the tree representation for compilation and
refactoring. Create it when needed and keep it during the current session. Create it piece-wise, e.g. for
one class at a time.
 Create a mapping from the tree representation to the
text representation; each node in the tree has a corresponding position and size in the text representation. Create this mapping when needed, for appropriate pieces (e.g. class definitions) of the total
model.

Modelica 2008, March 3rd  4th , 2008

Comment- and Indentation Preserving Refactoring and Unparsing for Modelica

5

 If there exist already indented text associated with a
node, use this text to produce the unparsing text.
 If there is no existing text, this must be a new tree
node produced by the refactoring tool. Call the tree
unparser to convert this subtree into text that is inserted into the final unparsing result.

Implementation

The following strategy is used for the implementation

5.1

Base Program representation

The text representation is the TRUTH, the source, and
the AST representation is a secondary representation
derived from the source, used during compilation and
refactoring.
The class information attribute of a class definition
in the AST should be extended, e.g. with the byte start
position (directly addressing within a file), or by a text
chunk corresponding to the text of a class declaration.
A package which contains classes would instead refer
to the definitions of those classes.
Text positions and text sizes of each AST node
should be indirectly associated with each AST node.

5.2

6

The following steps are to performed in this order during the actual refactoring:
 Traverse the AST and perform insertion/deletion/
replacement of subtrees.
 For each insertion/deletion/replacement operation,
put each such an operation descriptor in a list, together with the text position and size of the text of
the subtree to be replaced/deleted etc.
 After traversal, sort these operations according to
text position, and perform the operations in the text
in backwards order (take those at the highest text
position first).

The Parser

The following special considerations need to be addressed by the parser:
 In order not to clutter the produced AST tree, the
parser produces two trees: a standard AST tree, and
a positioning tree (produced in parallel) with the
same number of nodes, containing text positions and
sizes of each subtree.
 The parser should return the start text position and
text size of each built AST tree. Moreover, if there
are any comments within the AST tree text range, a
list of the start positions and sizes of these comments should be associated with the parallel tree
node.
 The pure AST tree should be clean and not cluttered
with position and comment information.
 As mentioned, a text position tree with the same
number of nodes and children as the AST is created
in parallel to the AST. The positioning tree is only
produced when needed for refactorings or text positioning, and thrown away when not needed.

7

01 within ParentPackage;
02 package pack
03 function addOne "function that adds 1"
04
input Real x = 1.0; // line comment
05
output Real y;
/* multiple
06
line
07
comment */
08 algorithm
09
y := x + 1.0;
10 end addOne;
11
12 class myClass
13
Real y;
14 equation
15
y = addOne(5); // Call to addOne
16 end myClass;
17 end pack;

The Scanner

The text position and size of each token is returned together with the token itself.

5.4

The New Unparser

The new unparser will use a combined strategy as follows, combining existing text with new text generated
by the tree unparser:

The Modelica Association

Example of Function Name Refactoring

The example below is used to illustrate the refactorings
and the used combined tree and text chunk representation.
All loaded models (including the Modelica package) reside in an un-named top-level scope that we can
call Top. A model may be a top-level model, but more
typically a package which in turn may consist of subpackages:

For example, a child nr 3 of a node at level 2, will find
its text positions in the parallel tree in the node at level
2 and child nr 3.

5.3

Refactoring Process

Line numbers are given to help the reader follow the
example. The position tree constructed by the parser is
given in the appendix as it is quite large. A portion of
the abstract syntax tree is also shown in order to understand the example.

659

Modelica 2008, March 3rd  4th , 2008

P. Fritzson, A. Pop, K. Norling, M. Blom

A function name refactoring will be applied to the example which will change the name of the function
"addOne" to "add1", The refactoring can be performed in the OpenModelica environment by loading
the example and calling the interactive API function:
loadFileForRefactoring("Example.mo");
refactorFunctionName(pack.addOne, "add1");

The compiler will execute the first command by calling
the new parser that also builds the position tree together
with the AST:
(ast,posTree) = Parse.refactorParse(file);

The result of the load command is two trees. The second (posTree) is the position tree presented (partly) in
the appendix. The first (ast) is the abstract syntax tree
of the loaded file which is presented also in the appendix entirely. Here is just a overview picture of the AST:

[5] / CLASSDEF [2]
IDENT("addOne") [1].

7.2

/

CLASS

[1]

/

Lookup Any Uses of pack.addOne

Lookup of the uses are performed by walking the AST,
keeping track of the scope, while keeping track of a
numbered path. To reach the function call of addOne,
the path: 1, 6, 1, 1, 1, 5, 2, 1, 1 is applied. The path
goes via the following AST nodes:
PROGRAM [1] / CLASS [6] / PARTS [1] /
PUBLIC [2] / ELEMENTITEM [1] / ELEMENT
[5] / CLASSDEF [2] / CLASS [6] / PARTS[1]
/ EQUATIONS [1] / EQUATIONITEM [1] /
EQ_EQUALS [2] / CALL[1] / CREF_IDENT [1]
/ IDENT("addOne") [1].

7.3

Apply the Refactoring to the Actual Text

Now that the paths needed for the minimal refactoring
were discovered in the AST, apply these paths to the
position tree and fetch the positions of the elements at
the end of the paths:
 Function name: IDENT, Start:047, End:053
 Function use: IDENT, Start:313, End:319
The text operations are applied bottom-up because otherwise the character positions of the elements below an
applied operation would change. Ordering of text operations is needed to have them applied in a bottom-up
fashion:




Figure 1. AST of the Example.mo file.

The figure shows that the program has one package
with two public elements which are class definitions.
Actually only two refactoring operations are needed
to implement any refactoring: add and delete or add and
replace.
When refactorFunctionName is called the compiler will perform these operations:

7.1

Lookup pack.addOne

Lookup of a class definition is performed by walking
the AST while keeping track of a numbered path in the
tree. To reach the addOne identifier, the path: 1, 6, 1, 1,
1, 5, 2, 1, 1 is applied. The path goes via the following
AST nodes in order to reach the desired class name:
PROGRAM [1] / CLASS [6] / PARTS [1] /
PUBLIC [1] / ELEMENTITEM [1] / ELEMENT

The Modelica Association

ReplaceText(file, 319, 313, "add1");
ReplaceText(file, 53, 47, "add1");
Close(file);
(ast, posTree) = // re-parse the file
Parse.refactorParse(file);

After the file is closed either a reparsing is performed
to load the new AST (as exemplified here) or the refactoring operations are perfomed on the tree already in
the memory. Of course the best alternative would be to
perform the refactoring during lookup as we have implemented it in the OpenModelica compiler.
As one can notice the comments stay in place so
there is minimal disruption to the text representation.
This is very valuable from a user point of view but also
for code-versioning tools.

7.4

Calculation of the Additional Overhead

There is not too much overhead for the refactoring both
with respect to memory usage and time spent walking
the tree. In the following table we discuss such overhead and give specific numbers for needed memory
size and time complexity of the refactoring procedure.

660

Modelica 2008, March 3rd  4th , 2008

Comment- and Indentation Preserving Refactoring and Unparsing for Modelica

8.3

Memory overhead

Time overhead

Space is required for storing the position tree. The
size of this space is two
integers (of 4 bytes) for
each AST node. Also the
list of operations to be
applied to the text needs
memory for storing the
paths and the operations
themselves, but this memory is negligible compared to the AST and position tree and can also be
freed.

Walking two trees while
performing the refactoring
has a time impact of
NumberOfNodesWalked x
O(1) to walk a node:
O(NrOfNodesWalked).
Walking the position tree
while and applying the
text operations to the file
is negligible compared to
the refactoring operation.

Example: there are about
50 nodes in the example,
which means an additional memory of ~
50NrNodes x 2Positions x
4Bytes = 400Bytes are
needed for the position
tree. Or course, the position tree could be built on
demand and the freed
when memory is needed.

8

Example: it took about
0.2 seconds to perform the
function name refactoring
for the example file using
the OpenModelica system. Refactoring old
graphical annotations of
the Modelica Standard
Library version 1.6 to the
new style graphical annotations took about 9.6 seconds, which is very good
for such a demanding
refactoring.

Unparsers/Prettyprinters
Indenters

versus

As mentioned previously, an unparser converts an AST
program representation into (nicely indented) text. A
reformatting indentation tool uses another approach, it
operates directly on the text representation to produce a
more nicely indented text.

8.1

Pretty printers/Unparser Generators

An unparser generator produces an unparser from a
specification, a grammar-like description of unparsing
related aspects of the language. A number of systems
mentioned in Section 8 support unparsing or generation
of unparsers from such specifications.

8.2

OpenModelica Tree Unparser

The current OpenModelica version 1.4 unparser is hand
implemented in MetaModelica, recursively traversing
the AST while generating the Modelica text representation. It can be invoked by the OpenModelica list
command. Comments are currently lost (except for declaration comments).

The Modelica Association

Reformatting Indentation in the OpenModelica Eclipse Plugin

A text reformatting indentation tool operates directly
on the text representation, and analyzes the text by a
combination of scanning and piecemeal heuristic partial
parsing to recognize certain combinations of tokens. It
inserts or removes white space in order to produce a
nice indentation, or improve an existing one. Such
mechanisms are typically invoked by the user on a few
lines at a time, and are not completely automatic, the
user is often required to perform the final adjustments.
An advantage with this approach is that comments are
not lost.
This kind of indentation tool is for example available for a number of languages in their respective
Emacs modes, or as part of Eclipse plugins, e.g. for
C++, Java, and more recently for Modelica in the
OpenModelica MDT Eclipse plugin.
MDT includes support for automatic indentation, as
described here and in [13]. When typing the Return
(Enter) key, the next line is indented correctly. The user
can also correct indentation of the current line or a
range selection using CTRL+I or Correct Indentation
action on the toolbar or in the Edit menu.
Indentation can be applied to incomplete code as a
heuristic Modelica scanner is used and the indentation
is based only on the tokens generated by this scanner.
The indenter indents one line at a time. For example,
consider that line four (4) in Figure 2 should be indented. The indenter asks the heuristic scanner to give
tokens from the starting token in backwards direction to
the start of the file until a scope introducer is recognized, which for this particular file is model MoonAndEarth. The reference position of the start of the scope
introducer is computed and line four (4) is indented
from this reference position one indent unit. The indentation result is presented in Figure 2.
Indenting Modelica code is far from trivial when incomplete (possibly incorrect) code should be indented
correctly. Most of the difficulty comes from Modelica
scopes which are hard to recognize using just a scanner
and some logic behind it. In languages like C/C++ and
Java finding enclosing scopes is very easy as one character tokens are used for the scope opening and closing:
"{" and "}". In Modelica you need at least two tokens
and much more case analysis to find where a scope
starts and ends. Complications also arise when mixing
if-statements with if-expressions (which was further
complicated by the introduction of conditional declarations in the Modelica language). In this particular case
we implemented a parser emulator that recognizes these
constructs based on scanner tokens delivered backwards.

661

Modelica 2008, March 3rd  4th , 2008

P. Fritzson, A. Pop, K. Norling, M. Blom

lined where the error occurs as shown in Figure 3. Of
course if the user selects an entire file and calls the
automatic indentation routine, the indentation will work
correctly if there are no large large grammatical errors
in the file.

Figure 2. Example of code after automatic indentation.

The indenter works well in almost all cases, but
there are cases in which is impossible to find the correct indentation. For example when the indentation of a
line consisting of "end Name;" is requested and the
scope introducer for Name is not found (that is identifier Name followed backwards by class, model,
package, block, record, connector etc.) then
the indenter fails and returns the indentation of the previous line.

9

Further Discussion

In this section we address some questions from the reviewers:
Question: A question I have always had is whether
there are any "mistakes" in the grammar that should be
corrected with respect to these issues. Similarly, how
is this handled with the Java tools in Eclipse?
Answer: The answer to this question highly depends on
the syntactic mistake the user made. For example if an
"end if;" is missing at the end of an equation section, but is followed by "end Model;", then such a
mistake can be automatically corrected using a heuristic
parser. However, if an opening scope is missing, i.e.,
model Model (or alternatively an ending scope) there
is no way to know where it should be introduced. There
are a lot of places that can be proposed:
 Just after the enclosing scope starts (after i.e.,
package MyPack introduction) if there exists such
scope or the start of the file if no such scope exists.
 Just after the every existing ending scope of a model
found by going backwards from the end Model;
Right now the Eclipse environment will call the
OpenModelica compiler to parse the file each time the
file is saved. The parsing errors are reported in the
Eclipse environment as a list of errors, but also under-

The Modelica Association

Figure 3. Syntax checking.

Question: Dymolas pretty printing algorithm does not
appear to be deterministic (it sometimes changes files
for no reason just because they have been re-saved).
Please discuss this deterministic issue and also what
implications the algorithms will have for version control tools (i.e. avoiding complex or unnecessary
changes since this will complicate "merge" operations).
Answer: As exemplified in Sections 3.1 and 7 the disruption to the actual text is minimal so the codeversioning tools would have no problem with merging
operations. This was one of our goals when designing
and implementing the refactoring tools presented in the
paper. The algorithms in this paper also apply to Modelica models constructed programmatically because
these can also be viewed as refactorings. In general the
construction of models programmatically is performed
by a visual component diagram editor. The editor will
give commands: addModel(), addComponent(),
addConnection(), etc., to the internal handler of
the textual model (that works on the AST and the positionTree) which in the case of a file with code formatting will minimally disrupt the existing code and add
all the new code correctly indented at the end or in
other appropriate places.

10 Related Work
The term refactoring and its use in a general and systematic sense was introduced by Martin Fowler et al
[5], also based on earlier work, even though similar

662

Modelica 2008, March 3rd  4th , 2008

Comment- and Indentation Preserving Refactoring and Unparsing for Modelica

code transformation operations were previously available, e.g. in the InterLisp environment [11].
Early work in interactive integrated programming
environments including unparsing/pretty printing supporting a specific language was done in the InterLisp
system for the Lisp language [11], common principles
and experience of early interactive Lisp environments
are described in [16], a generic editor/unparser/parser
generator used for Pascal (and later Ada) in the DICE
system [9], [10], the integrated Mjlner environment
with mullti-language editing and unparsing support
[17]. None of these approaches preserve comments
when unparsing, except the InterLisp environment
where the comments were already part of the AST
which was just pretty printed with a more readable indentation. However, also in the InterLisp case, all hand
indentation and white space added by the user is lost,
and text style comments (not part of the AST) are also
lost.
Many parser generation systems, e.g. ANTLR [14],
Eli [6], CoCo [15], also support unparsing from the
generated AST, but do not support preservation of
comments and hand-made indentation.

11 Conclusions
We have given a preliminary description of refactorings
together with an approach for comment- and indentation preserving unparsing. This is currently ongoing
work. Part of the unparser and the refactorings are implemented. A full prototype implementation is expected
to be completed early spring 2008.

12 Acknowledgements
This work has been supported by the Swedish Foundation for Strategic Research (SSF) in the RISE and
VISIMOD projects, by Vinnova in the Safe and Secure
Modeling and Simulation project, and by the Swedish
Research Council (VR).

References
[1] Peter Fritzson, Peter Aronsson, Hkan Lundvall,
Kaj Nystrm, Adrian Pop, Levon Saldamli, and
David Broman. The OpenModelica Modeling,
Simulation, and Software Development Environment. Simulation News Europe, 44/45, Dec
2005. http://ww.ida.liu.se/projects/OpenModelica
[2] Peter Fritzson. Principles of Object-Oriented
Modeling and Simulation with Modelica 2.1, 940
pp., Wiley-IEEE Press, 2004.

The Modelica Association

663

[3] Peter Fritzson, Adrian Pop, and Peter Aronsson.
Towards Comprehensive Meta-Modeling and
Meta-Programming Capabilities in Modelica. In
Proc. of the 4th International Modelica Conference, Hamburg, Germany, March 7-8, 2005.
[4] The Modelica Association. The Modelica Language Specification Version 3.0, September
2007. http://www.modelica.org.
[5] Martin Fowler, Kent Beck, John Brant, William
Opdyke, and Don Roberts. Refactoring: Improving the Design of Existing Code. Addison
Wesley, June 1999.
[6] Uwe Kastens, William M. Waite, and Anthony
M. Sloane,. Generating Software from Specifications. ISBN 0763741248. Jones and Bartlett Publishers. 2007.
[7] William W Pugh; Steven J Sinofsky. A new language-independent prettyprinting algorithm.
Ithaca, NY : Dept. of Computer Science, Cornell
University, 1987.
[8] Martin Mikelsons. Prettyprinting in an interactive
programming environment. In Proc. of ACM
SIGPLAN SIGOA symposium on Text manipulation. Portland, Oregon, 1981.
[9] Peter Fritzson. Towards a Distributed Programming Environment based on Incremental Compilation. 161 pages. PhD thesis no 109, Linkping
University, April 13 1984.
[10] Peter Fritzson. Symbolic Debugging through Incremental Compilation in an Integrated Environment, Journal of Systems and Software, 3, pp.
285294, 1983.
[11] Teitelman, Warren. INTERLISP Reference Manual. Xerox Palo Alto Research Center, Palo Alto,
CA, 1974.
[12] Eclipse website. http://www.eclipse.org. Referenced Nov 2007.
[13] Adrian Pop, Peter Fritzson, Andreas Remar, Elmir Jagudin, and David Akhvlediani. OpenModelica Development Environment with Eclipse Integration for Browsing, Modeling, and Debugging. In Proceedings of the 5th International
Modelica Conference (Modelica'2006), Vienna,
Austria, Sept. 4-5, 2006.
[14] http://www.antlr.org. ANTLR. Accessed Nov
2007.
[15] Hanspeter Mssenbck, Markus Lberbauer, and
Albrecht W. The Compiler Generator Coco/R.
http://www.ssw.uni-linz.ac.at/coco/.
Accessed
Nov 2007.

Modelica 2008, March 3rd  4th , 2008

P. Fritzson, A. Pop, K. Norling, M. Blom

[16] Erik Sandewall. Programming in an Interactive
Environment: The LISP Experience, Computing Surveys, 10:1, Mar. 1978.

[17] J. Lindskov, M. Knudsen, O. Lfgren, Ole Lehrmann-Madsen, and Boris Magnusson (Eds.). Object-Oriented Environments - The Mjlner Approach. Prentice Hall, 1993.

Appendix
Here we give (parts of) the generated position tree (posAST) for the code in the example section. The start and
end are given in character offsets. The nodes that have -1 as start/end position do not actually exist in the text, but
they appear in here to have 1-to-1 mapping to the AST definitions.
(Program, (Start: 1, End: 366, {
(list<Class>, (Start: 23, End: 366, {
(Class, (Start: 23, End: 366, { (Ident, (Start: 31, End: 35)
(Boolean Partial, (Start: -1, End: -1) (Boolean Final, (Start: -1, End: -1)
(Boolen Ecapsulated, (Start: -1, End: -1) (Restriction, (Start: 23, End: 30)
(ClassDef, (Start: 35, End: 356, {
(list<ClassPart>, (Start: 38, End: 356, {
(ClassPart, (Start: 38, End: 356, {
(list<ElementItem>, (Start: 38, End: 356, {
(ElementItem, (Start: 38, End: 264, {
(Element, (Start: 38, End: 264, {
(Boolean final, (Start: -1, End: -1)
(Option<RedeclareKeywords>, (Start: -1, End: -1)
(InnerOuter, (Start: -1, End: -1)
(Ident, (Start: -1, End: -1)
(ElementSpecEL5, (Start: 38, End: 264, {
(Boolean replaceable, (Start: -1, End: -1)
(Class, (Start: 53, End: 264, {
(Ident, (Start: 47, End: 53)
(Boolean Partial, (Start: -1, End: -1)
(Boolean Final, (Start: -1, End: -1)
(Boolen Ecapsulated, (Start: -1, End: -1)
(Restriction, (Start: 38, End: 46)
(ClassDef, (Start: 53, End: 264, {
(list<ClassPart>, (Start: 53, End: 264, {
(ClassPart, (Start: 80, End: 250, {
(list<ElementItem>, (Start: 80, End: 221, {
(ElementItem, (Start: 80, End: 100, {
(Element, (Start: 80, End: 100, {
(Boolean final, (Start: -1, End: -1)
(Option<RedeclareKeywords>,(Start: -1, End: -1)
(InnerOuter, (Start: -1, End: -1)
(Ident, (Start: 91, End: 92)
(ElementSpecEL3, (Start: 91, End: 100, {
(ElementAttributes, (Start: 80, End: 85, {
(Boolean flow, (Start: -1, End: -1)
(Variability, (Start: -1, End: -1)
(Direction, (Start: 80, End: 85)
(ArrayDim, (Start: -1, End: -1)
})
(TypeSpec, (Start: 86, End: 90, {
(Path, (Start: 86, End: 90, {
(Ident, (Start: 86, End: 90)
})
(Option<ArrayDim>, (Start: -1, End: -1)
})
... // truncated text due to its large size
}) (Option<String>, (Start: -1, End: -1)
}) (Info, (Start: -1, End: -1)
})
})
(Within, (Start: 1, End: 7,
(Path, (Start: 8, End: 22, {(Ident, (Start: 8, End: 22)})
)

The Modelica Association

664

Modelica 2008, March 3rd  4th , 2008

Comment- and Indentation Preserving Refactoring and Unparsing for Modelica

Here is another version of the example with character positions for end and start of a Modelica construct:
[001]within[007] [008]ParentPackage;[022]
[023]package[030] [031]pack[035]
[036] [038]function[046] [047]addOne[053] [054]"function that adds 1"[076]
[077]
[080]input[085] [086]Real[090] [091]x[092] [093]=[094] [095]1.0;[099]
[100]// line comment[115]
[116]
[119]output[125] [126]Real[130] [131]y;[133]
[139]/* multiple
line
comment */[221]
[222] [224]algorithm[233]
[234]
[237]y[238] [239]:=[241] [242]x[243] [244]+[245] [246]1.0;[250]
[251] [253]end[256] [257]addOne;[264]
[265]
[266] [268]class[273] [274]myClass[281]
[282]
[286]Real[290] [291]y;[293]
[294] [296]equation[304]
[305]
[309]y[310] [311]=[312] [313]addOne[319](5);[323] [324]// Call to addOne[341]
[342] [344]end[347] [348]myClass;[356]
[357]end[360] [361]pack;[366]

Parts of the abstract syntax tree (AST) of the Example.mo in the example section is presented below. The AST
has exactly the same structure as the position tree.
adrpo@KAFKA /c/home/adrpo/doc/projects/modelica2008/
$ omc +d=dump Example.mo
Absyn.PROGRAM([
Absyn.CLASS(Absyn.IDENT("pack"),
false, false, false, Absyn.R_PACKAGE,
Absyn.PARTS(
[Absyn.PUBLIC(
[Absyn.ELEMENTITEM(
Absyn.ELEMENT(false, _, Absyn.UNSPECIFIED , "function",
Absyn.CLASSDEF(false,
Absyn.CLASS(Absyn.IDENT("addOne"),
false, false, false, Absyn.R_FUNCTION,
Absyn.PARTS(
[Absyn.PUBLIC(
[Absyn.ELEMENTITEM(
Absyn.ELEMENT(false, _, Absyn.UNSPECIFIED, "comp",
Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.INPUT,[]),
Absyn.PATH(Absyn.IDENT("Real")),
[Absyn.COMPONENTITEM(
Absyn.COMPONENT(Absyn.IDENT("x"),[],
SOME(Absyn.CLASSMOD([], SOME(Absyn.REAL(1.0))))), NONE)]),
Absyn.INFO("Example.mo", false, 4, 4, 4, 22)), NONE)),
Absyn.ELEMENTITEM(
Absyn.ELEMENT(false, _, Absyn.UNSPECIFIED , "component",
Absyn.COMPONENTS(Absyn.ATTR(false, Absyn.VAR, Absyn.OUTPUT, []),
Absyn.PATH(Absyn.IDENT("Real")),
[Absyn.COMPONENTITEM(Absyn.COMPONENT("y",[],
NONE), NONE)]),
Absyn.INFO("Example.mo", false, 5, 4, 5, 17)), NONE))]),
Absyn.ALGORITHMS(
ALGORITHMITEM(
ALG_ASSIGN(
Absyn.CREF(Absyn.CREF_IDENT("y", [])),
Absyn.BINARY(
Absyn.CREF(Absyn.CREF_IDENT("x", [])),
Absyn.ADD,
Absyn.REAL(1.0)))))],
SOME("function that adds 1")),
Absyn.INFO("Example.mo", false, 3, 3, 10, 13))
... // truncated text due to its large size
], // end of Absyn.CLASS list
Absyn.WITHIN(Absyn.IDENT("ParentPackage")
) // end Absyn.PROGRAM

The Modelica Association

665

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

666

Modelica 2008, March 3rd  4th , 2008

Session 6b
Language, Tools and Algorithms

The Modelica Association

667

Modelica 2008, March 3-4, 2008

The Modelica Association

668

Modelica 2008, March 3rd  4th , 2008

Sensitivity Analysis of Modelica Applications via Automatic Differentiation

Sensitivity Analysis of Modelica Applications
via Automatic Differentiation
1

Elsheikh, Atya1 Noack, Stephan2 Wiechert, Wolfgang1
Siegen University, Department of Simulation, {elsheikh,wiechert}@simtec.mb.uni-siegen.de
2 Research Center Jlich GmbH, Institute of Biotechnology 2, s.noack@fz-juelich.de

Abstract

more, the results are not affected by any truncation
errors, resulting from numerical differentiation using
Modeling and simulation of physical systems is, in divided difference methods.
general, a complex iterative process. Asserted models
are necessarily based on simplifications, and in many This work is concerned with AD of Modelica modcases are subject to improvement and optimization. In els. Modelica is essentially targeted towards modeling
this context, a wide range of applications of sensitivity complex systems that can be described by differential
analysis can assist the modeling process, from param- algebraic equation (DAE) systems:
eter fitting and optimization through model validation
F(t, x, x, p) = 0, x(0) = x0 (p)
(1)
to statistical analysis and experimental design. These
common methods, among others, drew increasing
n
m
2n+m+1  Rn . Assuming
attention to a research area of scientific computing, i.e. where x  R , p  R , F : R
m
Automatic Differentiation (AD) of program code. The that  F/ x is non-singular for all p  R , and that
main objective of this work is to compute derivatives  x/ p is smooth enough, sensitivity analysis requires
of variables in Modelica models using AD concepts the sensitivities  x/ p of solution variables with reto assist sensitivity analysis applications. It is shown spect to perturbations in the parameters. These can be
how Open Modelica Compiler (OMC) and other calculated by solving the original DAE system (1) and
tools simplify the implementation of ADModelica, m sensitivity systems:
a prototype of an AD-based tool for Modelica. As
 F  x
F x
F
 x   p +  x   p +  p = 0,
a proof of concept, an application in the field of
(2)
x

 p (0) =  p (x0 (p))
biochemical networks is presented.
obtained by explicit differentiation of (1) with respect
Keywords: Sensitivity Analysis, Automatic Difto p [14]. Additionally, the sensitivities  xi / x j
ferentiation, Open Modelica, Biochemical Networks
of certain variables xi with respect to other specific
variables x j might be needed.

1

Introduction

AD is a methodology that refers to algorithmic
techniques for semantic augmentation of numerical
programs with additional code for derivative computations [6]. For many reasons, AD is a better
choice over other ways for computing derivatives
such as symbolic differentiation and finite difference
methods. In contrast to symbolic differentiation tools,
an AD tool does not generate the derivative formula
explicitly, but it computes the numerical values of
efficient derivative formulas expressed as a program.
Nevertheless, the derivative values using AD are as
accurate as the values of those generated by symbolic
algebra packages up to machine precision. Further-

The Modelica Association

This paper presents first experiences with a prototype
of a tool, ADModelica, that augments Modelica models with Modelica code for computing certain sensitivities, with minimal user efforts. Aiming at the fullsupport of Modelica language constructs, we implemented a first version, which supports most basic constructs of Modelica. The rest of the paper is structured
as follows. Section 2 introduces basic terminologies
and algorithmic aspects of AD. The Generalization of
the introduced concepts into the Modelica framework
is clarified in Sect. 3. Section 4 presents the ADModelica tool and briefly discusses some design and implementation issues. In Sect. 5, applications in the field
of Biochemical Engineering using a special library is

669

Modelica 2008, March 3rd  4th , 2008

A. Elsheikh, S. Noack, W. Wiechert

presented. Finally, conclusions are presented and fu- a(x) and b(x) be intermediate values that depend on
an independent variable x, and let c := f (a, b). Then
ture work is discussed in Sect. 6.
by using the chain rule, x c the derivative of the dependent variable c with respect to x is computed as:

2

Introduction to Automatic Differentiation

Many techniques such as numerical differentiation
or computer algebra methods are used to compute
derivatives. However, AD has proved to be superior
over other ways for obtaining derivatives in terms of
computational efficiency, numerical precision and discretization parameters. ADIC [2] and ADIFOR [1] are
examples of a wide range of AD tools for differentiating C and Fortran programs respectively. In this section, some basic terminologies of AD are introduced.

f
f
 x a +
 x b
(3)
a
b
The chain rule is associative. If y := f (g(x)),  y/ x
can be computed by forwardly accumulating the
derivatives (i.e.  f / g and  g/ x) in the computational path from the independent variable(s) (eg. x)
to the dependent variable(s) (eg. y). By exploiting the
associativity of the chain-rule, the augmented program
is generated to evaluate f (x) and the partial derivatives
of f simultaneously.
x c :=

2.3 Why AD for Modelica?
2.1

Basic Concepts

2.2

Algorithmic Aspects of AD

AD is naturally implemented by Modelica compilers
to provide partial derivatives of functions for solving
Formally, given a program P that computes a function:
the DAE index problem [12]. A DAE system of high
n
m
index is transformed into a solvable ODE system by
f :xR yR
differentiating some equations selected by Pantelidess

with n inputs and m outputs, a new code P is sought algorithm [13]. Here, AD is chosen for the fundamento compute the Jacobian f  =  y/ x. The following tally different task of calculating sensitivities of solution variables, motivated by the following reasons:
terms are commonly used in the context of AD:
 DAE systems are represented in Modelica by us Independent variables are program input variing components and connectors; internal formuables with respect to which derivatives are
las in components and models may be implesought.
mented with loops and many branches. Therefore, it makes sense to utilize existing tools and
 Dependent variables are output variables whose
concepts of handling DAE systems, used by modderivatives are desired.
elica compilers, for generating derivative formu A derivative object represents some derivative inlas.
formation, such as a vector of partial derivatives
 For a Modelica model that computes a DAE Sys( z/ x1 , ...,  z/ xn )T of a variable z with respect
tem (1), a lot of common sub-expressions in
to a vector x = (x1 , x2 , ..., xn )T .
F,  F/ x and  F/ p arise. In many cases,
these common sub-expressions need not to be re Any program variable with which a derivative obevaluated if these partial derivatives are computed
ject is associated is called an active variable.
using AD.
 Compiler techniques used for reducing the dimension of a generated DAE system, can be
adopted by AD for reducing the number of equations needed to be differentiated , instead of blind
differentiation of all equations, as the DAE system (2) suggests [4].

The key concept behind AD is that every computation, no matter how complex it is, is executed on a
computer as a sequence of a limited set of elementary operations, such as addition and multiplication,
and intrinsic functions, such as sine and cosine. The
derivative of each of these elementary operations can
be computed by applying the chain rule to combine 3 Differentiating DAE Systems
the local partial derivatives of each executed operator.
An AD tool operates by systematic application of the Assignments (eg. x := f (y, z)) are the main elemenchain rule on the numerical code. For example, let tary units of procedural languages, whereas declara-

The Modelica Association

670

Modelica 2008, March 3rd  4th , 2008

Sensitivity Analysis of Modelica Applications via Automatic Differentiation

tive equations (eg. f (x(t), y(t), z(t)) = 0) constitute the
main building units of Modelica. While an assignment
is a relation between inputs (a collection of values)
and one output, an equation is a relation between several variables, that needs to be fulfilled concurrently.
This conceptual difference has vital consequences on
the way derivatives can be generated for DAE systems, namely, AD techniques for classical languages,
such as C/FORTRAN, are not necessarily applicable
for equation-based languages.

3.1

Example

Consider the DAE System
A = v, A(0) = A0
B = v, B(0) = B0
Ik
A
 B+I
v = vmax  A+k
k

3.2 Utilizing Common Sub-expressions
Given that the values of A(t) and B(t) are known for
a time point t, v(t) and v p (t) can be computed from
the DAE systems (4) and (5). The third equation
v p =  f / p in the DAE system (5) consists of three
equations of similar algebraic structure. Excessive reevaluation of common sub-expressions arising in v and
v p can be avoided by dividing the equation v = f in the
DAE system (5) into a set of binary assignments using
the Abstract Syntax Tree (AST) of v as shown in Fig.
1. The gradient of v(t) is computed by forward accumulation of the gradients of the intermediate variables
obtained by differentiating each assignment instead of
direct differentiation of the algebraic formula. An implementation for the DAE systems (4) and (5) looks as
follows:

(4)

A = v

 t  p A =  p v
B = v

 t  pB =  pv

describing the dynamics of a chemical reaction, in
which a chemical substance with concentration A =
A(t) is converted to another chemical substance with
concentration B = B(t). v = v(A, B,t) stands for reaction rate and vmax , k and Ik stand for enzymatic parameters. The first two ordinary differential equations
represent balance equations, whereas the third equation describes the reaction rate using the well-known
Michaelis-Menten Kinetics [7]. The sensitivities of
x = (A, B, v)T w.r.t. parameters p = (vmax , k, Ik )T can
be computed as in (2) by adding the following equations:
Ap = v p , A p (0) = 0
Bp = v p , B p (0) = 0
(5)

v p =  p f (A, B, vmax , k, Ik )
to (4), where
f (A, B, vmax , k, Ik ) = vmax 
vp =  pv = (

A
Ik

A + k B + Ik

v v v T
, ,
)
 vmax  k  Ik

u1 := vmax  A;
 p u1 :=  p vmax  A + vmax   p A;
u2 := A + k;
 p u2 :=  p A +  p k;
u3 := u1  u2 ;
 p u3 :=  p u1  u2 + u1   p u2 ;
u4 := B + Ik ;
 p u4 :=  p B +  p Ik ;
u5 := Ik /u4 ;
 p u5 := ( p Ik  u4  Ik   p u4 )/u24 ;
v := u3  u5 ;
 p v :=  p u3  u5 + u3   p u5 ;

(9)

In this way, common sub-expressions are evaluated
only once, and hence less arithmetic operations are
needed. The assignments can be implemented in Mod(6) elica with the help of the algorithm construct.

(7)

3.3 Limitations

While optimizing common sub-expressions works
and A p , B p are similar to v p . Given that Jp = I3 (Iden- well for AD of classical procedural languages, this
may not be the case with equation-based languages.
tity matrix of size 3), i.e.:
For example, in the DAE system (4), v(0) can be
computed by considering the available values of A(0)
 p vmax := (1, 0, 0)T ;
T
 p k := (0, 1, 0) ;
(8) and B(0). Then, v(0) is used to compute subsequent
values of A and B, and hence forth. That is, at each
 p Ik := (0, 0, 1)T ;
iteration, A(t) and B(t) are used to compute v(t).
(5) can be easily implemented in Modelica with the In other words, the values v(t) depends on A(t) and
help of arrays. Notice that := stands for assignments. B(t). By this way, computing v(t) from A(t) and B(t)

The Modelica Association

671

Modelica 2008, March 3rd  4th , 2008

A. Elsheikh, S. Noack, W. Wiechert

4.1 Possible Approaches
There are three levels, on which AD of (implicit) DAE
systems can operate:
1. Library level: All library units (i.e. components
and connectors) are differentiated independently
to generate another library that additionally computes parameter sensitivities of variables. Each
component is augmented with code for derivatives.

Figure 1: Abstract Syntax Tree (AST) of v = f

2. Flat Model Level: The source code is given as
(or transformed into) pure equations, represented
by elementary Modelicas constructs, rather than
physical formulation with components and connectors. Sensitivity Equations are added in a new
Modelica model.

in (9) does not change the dependency of variables.
However, in general, an equation can be divided into a
3. Generated C-code level: The generated C-code
set of binary operations if the output variable depends
is differentiated.
on the variables arising in the left hand side of all
In [4], the above approaches are discussed in more deintermediate assignments.
tails. The adopted approach is based on differentiation on the flat model level. The current supported inAdditionally, the dimension of the rewritten DAE sysput models, are namely those, which flattened models
tem increases according to the way the Modelica comhave pure mathematical formulation. Particularly, inpiler handles local variables. If intermediate results of
put models with components, connectors and arrays
local variables are always stored, this exhausts extra
with equations expressed as for-loops are supported.
storage and computation time. Note that, the number
However, some control constructs in Modelica, such
of local variables can be reduced by reusing local varias if, while and others, are not yet supported. As a reables. For example, there is no need to introduce new
mark, AD of such classical languages constructs is a
local variables u4 and u5 if u1 and u2 are used instead.
well-know problem and has been successfully handled
Moreover, excessive use of the algorithm section may
[6].
disable some optimization methods for reducing the
dimension of a DAE system and hence worsen the per4.2 Overview of ADModelica
formance. Finally, side effects implied by the enforced
order of sub-expressions evaluation result in slightly Figure 2 shows the corresponding Modelica impledifferent results for state variables.
mentation of the DAE system (9). The user specifies
the independent variables. If not specified, all parameters are considered as independent variables. To every
variable v of type Real an array representing the gradient of that variable g_v is associated. The arrays size
4 Automatic Differentiation of
represents the number of independent variables. Each
entry of the array represents the derivative of v with reModelica Code
spect to an independent variable. To each active variable, a gradient is associated. ADModelica follows a
ADModelica is a prototype of a source-to-source AD conservative strategy that considers all variables and
tool that strives to support Modelica programs. The parameters active. In that case, non-interesting paramsource-to-source approach employs a combination of eters have the zero gradients.
classical- and equation-based compiler techniques to
transform a program source code into a new source
4.3 Design and Implementation
code that computes the derivatives. This section gives
a quick overview of the implementation of ADModel- Implementing an AD tool from scratch, supporting
ica.
a wide set of Modelica grammar, would be an ex-

The Modelica Association

672

Modelica 2008, March 3rd  4th , 2008

Sensitivity Analysis of Modelica Applications via Automatic Differentiation

Figure 3: The Architecture of ADModelica
differentiate all equations laying in all Strongly
Connected Components (SCCs) of the computational path from the independent variable(s) to
the dependent variable(s).
Figure 2: Implementation of the DAE system (4) and
its Sensitivity Equations (5)
pensive and error-prone process. Therefore, existing
tools and software are utilized by ADModelica, particularly OMC [5]. OMC allows communication with
other tools through the CORBA interface. Figure 3
shows the main steps performed to generate a Modelica model that computes additional required derivatives. These steps are summarized as follows:
 Flattening: A high-level model is transformed to
a model with pure mathematical equations, using
the Open Modelica Compiler (OMC). ADModelica makes use of the CORBA interface, offered
by OMC.
 Transforming to intermediate format: The
ModelicaXML parser [15] parses an input model
to an easy-to-handle format, in which the AST
representation of the equations are implicitly inherited. The ASTs are extracted into intermediate
format in Java classes.
 Analyzing: The dimension of the generated DAE
system is reduced by removing alias equations
(s.a. x = y and x + y = 0 ) [9]. The computational
path between variables is computed [3, 8].

 Unparsing: The differentiated model is generated with additional code for derivatives.
 Visualizing ASTs: Producing graphs of the
ASTs was proven to be useful during the course
of development, for finding potential semantical
mistakes.

5 Application
Modeling the dynamics of metabolic reaction networks has a wide spectrum of applications. Special
attention has been paid to modeling biochemical
systems with Modelica [11]. In general, the parameters expressing the characteristics of enzymatic
reactions (eg. reaction rate, enzyme activation/inhibition constants, etc.) are one of the largest source
of uncertainty in modeling metabolic networks, and
are not necessarily known. Their values might be
estimated by fitting them to measured data, resulted
from stimulus-response experiments [16]. Estimating
the correct values of parameters can reveal hidden
information about the system. However, even in that
case, the asserted model alone does not explain the
underlying behavior.

Understanding the functions of enzymatic reactions
 Differentiating: The ASTs of the derivatives are within a metabolic network can be achieved by
computed. A conservative strategy is to differ- measuring changes to directed perturbations of certain
entiate all equations. However, it is enough to parameters (eg. quantity of a certain enzyme). While

The Modelica Association

673

Modelica 2008, March 3rd  4th , 2008

A. Elsheikh, S. Noack, W. Wiechert

independent variables, 49 of which are parameters
corresponding to enzymatic characteristics and 15
concentrations variables.
The dimension of the
generated DAE is 12,270. It takes about 35 seconds
to get the network and corresponding sensitivities
simulated.
Investigations on the dynamics of metabolic network
models mostly follow a system perturbation starting
from a stationary state. In this example, the network
is stimulated by a pulse of the input metabolite PEP.
Results show that responses of following metabolite
pools are very fast (e.g. PYR) or delayed (e.g. ACCOA). Especially in the case of the output metabolite LYS the concentration change is rather low in the
given time frame. The results are used to identify some
model parameters, which show a higher sensitivity in
the instationary case directly after system perturbation,
as well as others, which generally do not have any significant influence on the corresponding flux.

6 Summary and Future Work
Figure 4: A dynamic Metabolic Network

this can be experimentally difficult or impractical,
it is easier to quantify the effect of these changes
using a validated model [17]. This can be achieved
by computing the sensitivities of reaction rates and
concentration to parameters  r/ p and  c/ p, and
the sensitivities of reaction rates to concentration of
metabolites  r/ c. Using these sensitivities, the well
known quantities of Metabolic Control Theory, i.e.
the concentration and flux control coefficients CM and
CF , can be calculated [10, 7].

This work shows that AD is a natural choice for computing sensitivities of solution variables for Modelica
models. ADModelica is a prototype of a source-tosource AD tool for the Modelica language. It follows
the flat model approach, as it is easy to implement because it does not consist of high-level language constructs. ADModelica utilizes OMC by using CORBA
communication. Potential improvements of ADModelica can be achieved by making more use of OMC.
OMC access a lot of facilities that can be utilized by
ADModelica. Examples involve, but are not limited
to:
 Symbolic manipulation of algebraic equations

In Figure 4, a dynamic metabolic network model
including reactions of the tricarbon acid cycle is
shown. The network has been implemented using a
specialized library for biochemical networks, making
use of many object-oriented features of the Modelica
language. Various classes (e.g. Enzyme, Metabolites,
Reactions) are the main common objects. Objects
are connected via interfaces for potential variables
(e.g. concentration c) and flux variables (e.g. reaction
rate r). The dimension of the corresponding DAE
system of the flattened model is 690. The number of
non-trivial equations is 182. It takes few milli-seconds
to simulate the network using Dymola (Dynasim AB,
Sweden). The model was differentiated w.r.t. 64

The Modelica Association

 An intermediate format for computational graphs
for DAE systems
 Utilizing the Dependency Flow Graph (DFG) of
variables for decomposing a large resorted DAE
system in Block Lower Triangular (BLT) format
into smaller DAE systems
These facilities are used for optimizing common subexpressions, reducing the number of equations needed
to be differentiated and computing sensitivities of
variables w.r.t. other (non input) variables. Although,
these are partially implemented by ADModelica, it is
certainly better to rely on the reliable well-maintained

674

Modelica 2008, March 3rd  4th , 2008

Sensitivity Analysis of Modelica Applications via Automatic Differentiation

[11] E. L. Nilsson and P. Fritzson. A Metabolic Specialization of a General Purpose Modelica Library for Biological and Biochemical Systems.
acknowledgment. This research is funded by German
In Modelica2005, the 4th International Modelica
Ministry of Education and Research (BMBF) within
Conference, pages 8593, Hamburg, Germany,
the Sysmap project.
March 2005.
and continuously growing OMC.

References

[12] H. Olsson, H. Tummescheit, and H. Elmqvist.
Using Automatic Differentiation for Partial
[1] C. H. Bischof, P. Khademi, A. Mauer, and
Derivatives of Functions in Modelica. In ModA. Carle. Adifor 2.0: Automatic Differentiation
elica2005, the 4th International Modelica Conof Fortran 77 Programs. IEEE Computational
ference, pages 105112, Hamburg, Germany,
Science & Engineering, 3(3):1832, Fall 1996.
March 2005.

[2] C. H. Bischof, L. Roh, and A. Mauer. ADIC [13] C. C. Pantelides. The Consistent Initializa An Extensible Automatic Differentiation Tool
tion of Differential-Algebraic Systems. SIAM
for ANSI-C. Software: Practice and Experience,
Journal on Scientific and Statistical Computing,
27(12):14271456, 1997.
9(2):213231, Mar. 1988.
[3] F. E. Cellier. Continuous System Modeling. [14] L. Petzold, S. T. Li, Y. Cao, and R. Serban. SenSpringer Verlag, 1991.
sitivity Analysis of Differential-Algebraic Equations and Partial Differential Equations. Com[4] A. Elsheikh and W. Wiechert. Automatic Sensiputers & Chemical Engineering, 30:15531559,
tivity Analysis of DAE-Systems Generated from
2006.
Equation-Based Modeling Languages. submitted to 5th International Conference on Automatic
[15] A. Pop and P. Fritzson. Modelicaxml: A ModDifferentiation, Bonn, Germany, 11-15 August
elica XML Representation with Applications. In
2008.
Proceedings of The 3rd International Modelica
Conference, pages 419429, Linkping, Swe[5] P. Fritzson, P. Aronsson, P. Bunus, V. Engelson,
den, November 2003.
L. Saldami, H. Johansson, and A. Karstrm. The
Open Source Modelica Project. In Proceedings
[16] S. Wahl, M. Haunschild, M. Oldiges, and
of The 2nd International Modelica Conference,
W. Wiechert. Unravelling the Regulatory Strucpages 297306, Munich, Germany, March 2002.
ture of Biochemical Networks Using Stimulus
Response Experiments and Large-scale Model
[6] A. Griewank. Evaluating Derivatives: PrinciSelection. In IEEE Proceedings Systems Biology,
ples and Techniques of Algorithmic Differentivolume 153, pages 275285. IEEE Computer Soation. Number 19 in Frontiers in Appl. Math.
ciety, 2006.
SIAM, Philadelphia, PA, 2000.
[7] R. Heinrich and S. Schuster, editors. The Regu- [17] W. Wiechert. Validation of Metabolic Models:
Concepts, Tools, and Problems. In B. Khololation of Cellular Systems. Springer, 1996.
denko and H. Westerhoff, editors, Metabolic En[8] A. Leitold and K. M. Hangos. Structural Solvgineering in the Post Genomic Era, chapter 11.
ability Analysis of Dynamic Process Models.
Horizon Bioscience, 2004.
Computers & Chemical Engineering, 25:1633
1646, 2001.
[9] C. Maffezzoni, R. Girelli, and P. Lluka.
Generating Efficient Computational Procedures
from Declarative Models. Simul. Pr. Theory,
4(5):303317, 1996.
[10] K. Mauch, S. Arnold, and M. Reuss. Dynamic Sensitivity Analysis for Metabolic Systems. Chem. Eng. Sci., 52:25892598, 1997.

The Modelica Association

675

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

676

Modelica 2008, March 3rd  4th , 2008

Synchronous and Asynchronous Events in Modelica: Proposal for an Improved Hybrid Model

SynchronousandasynchronouseventsinModelica:proposalforanim
provedhybridmodel
RamineNikoukhah1
SbastienFuric2
1INRIARocquencourtBP105,78153LeChesnayCedex,France
2
LMSImagine,7placedesMinimes,42300Roanne,France
ramine.nikoukhah@inria.frfuric@amesim.com

Abstract
TheeventsynchronisminModelicahasbeenasubject
ofcontradictoryinterpretations.Aninterpretationin
spired  by  Scicos  formalism [2]  has  been  shown  to
providedesirableproperties.Inthisinterpretation,all
independent  events  are  assumed  asynchronous;  that
includes  events generated by the sample keywords.
Butinanalogywiththewaymultiratesystemsare
modeledinSimulink,itisdesirablealsotoconsider
sample generatedeventsassynchronous.Inthispa
per,weproposeaspecialtreatmentforthekeyword
sampletoovercomethisdilemma.
Keywords:Modelica,Scicos,synchronism,realtime
codegeneration

Asynchronousmeansthatevenifthetwoeventsoccur
(intheory)atexactlythesametime,oneisconsidered
tooccurjustbeforeorafter.Inthesynchronouscon
text,theformalismconsidersalsothecaseofthetwo
eventshappeningsimultaneouslyandtreatsitdiffer
ently.Howeverinpractice,sinceeventssuchasx<2
aredetectedbythezerocrossingmechanismofthe
numericalsolver,thereisverylittlechancethattwo
eventsbedetectedsimultaneouslyeveniftheoretically
theyaresimultaneous.Sointhesynchronouscontext,
thenondeterminismisevenworse:notonlythereare
threepossibleoutcomesinthepresenceoftwozero
crossingeventsbuttheuserisleadtobelievethatit
can  count  on simultaneous  detection  when  in  most
casestheresultiscompletelyunpredictable.

The sample generatedevents,eventhoughnotpro
duced  by  the  zerocrossing  mechanism  during  the
simulation,  should  naturally  be  considered  as  inde
1. Introduction
pendentandthusasynchronousaswell.Butthisgoes
against  the  usual  practices  in  Modelica  where  syn
In[1],itisarguedthatallModelicaeventsshouldbe
chronismisoftenimplicitlyassumed.Inthispaperwe
consideredasynchronousunlesstheyarederivedex
proposeaveryspecialinterpretationofthe sample
plicitlyfromasingleevent.ThisisincontrasttoDy
keyword  which  not  only leads  to  models in accord
molas  implementation  where  all  events  are  con
with  our  asynchronous  framework  but  assures  syn
sidered  potentially  synchronous,  by  default.  In  Dy
mola,simultaneityisinterpretedassynchronism.In chronismamongsamplegeneratedevents.
[1]itisshownthattheasynchronouspointofviewnot
onlyleadstothegenerationofmoreefficientcodebut
itcanalsoallowforseparatecompilationofisolated 2. Asynchronousframework
modules.
In  the  asynchronous  interpretation  of  the  Modelica
Itmaybearguedthatwiththeasynchronouspointof
specification,twoeventsareconsideredsynchronous
view,  nondeterministic behavior  becomes  an  issue.
only  if  they  can  be  traced  back  to  a  single  event
Buttheproblemofnondeterminismhereisnotworse
source.Forexampleinthefollowingmodel:
than  in  the  fully  synchronous  context  because  the
whensample(0,1)then
reasonfornondeterminisminhybridsystemsisthe
finiteprecisionofthenumericalsolver.Indeed,itis
d=pre(d)+1;
notmorenondeterministictoassumethattwoevents:
endwhen;
time>3andx<2,wherexisacontinuoustimevari
whend>3then
able, are asynchronous than assuming that they are
a=pre(a)+1;
potentiallysynchronous.
The Modelica Association

677

Modelica 2008, March 3rd  4th , 2008

R. Nikoukhah, S. Furic

endwhen;

equation

the  event  d  >  3  is  synchronous  with  the  event
sample(0,1).Theformeristhesourceofthelatter.
Butin

whentime>=kthen
k=pre(k)+1;
endwhen;

der(x)=x;

b=false;

whensample(0,1)then

whenchange(k)andf(true)then

d=pre(d)+1;

...g(true)...

endwhen;

endwhen;

whenx>3then

...

a=pre(a)+1;

endM;

endwhen;
the  two  events  are  not  synchronous.  There  is  no
unique  source  of  activation  at  the  origin  of  these
events.Sotheseeventsareconsideredasynchronous
evenifthetwoeventsareactivatedsimultaneously;
evenifwecanprovemathematicallythattheyalways
occursimultaneously.
Thebasicassumptionisthateventsdetectedbythe
zerocrossingmechanismofthenumericalsolver(or
anequivalentmechanismusedtoimprove perform
ance)arealwaysasynchronous.Soeveniftheyarede
tectedsimultaneouslybythesolver,bydefaultthey
aretreatedsequentiallyinanarbitraryorder.

Thismeansthatweareleadtoassumethatdifferent
sample statementsgenerateasynchronousevents(we
alsoloseperiodicityinformationcontainedinthear
gumentsofthesample).Forexample,inthemodel:
whensample(0,1)then
b=a;
endwhen;
whensample(0,1)then
a=b+1;
endwhen;

thevariablesaandbareevaluatedinanarbitraryor
derandnoalgebraicloopisdetected..
Dymolaontheotherhandassumesthatalleventsare
3. Specialcaseofsampleconstruct
synchronous.  In  particular  it  assumes  that  all  the
equationsinboth when clausesinthisexamplemay
Undertheasynchronousassumption,andbytreating havetobesatisfiedsimultaneously.ThatiswhyDy
the sample keywordasamacro,thefollowingpro molafindsanalgebraicloopinthisexample.
gram:
Thisseemsreasonable;howeverDymolaalsofindsan
modelM
algebraicloopin:
Booleanb;
whensample(0,1)then
...

b=a;

equation

endwhen;

b=sample(0,1);

whensample(0.5,1)then

whenf(b)then

a=b+1;

...g(b)...

endwhen;

endwhen;

whenclearlynoalgebraicloopexistsinthismodel.

...
endM;
canbeexpandedasfollows:
modelM
discretetimeIntegerk(start=0);
Booleanb;
...
The Modelica Association

4. Periodicityinformation
Theperiodicityinformationmaynotbeveryuseful
for  simulation  but  it  is  precious  for  realtime  code
generation.  It  is  a  lot  easier  to  generate  embedded
codeforadiscretetimesystemwhenthesystemis
periodic and all the timing  information is available
678

Modelica 2008, March 3rd  4th , 2008

Synchronous and Asynchronous Events in Modelica: Proposal for an Improved Hybrid Model

duringthecodegenerationprocess.Considerforex
amplethefollowingsystem,whichrepresentsacon
tinuoustimeplantwithadiscretetimefailuredetector
andareconfigurablecontroller.Differentcomponents
ofthedetector/controllermechanismrunatdifferent
frequencies;wesaythenthatthesystemismultirate.

10 Hz sampling

2 Hz

Observer output

FFT computation

Sliding window

Fault Dection

sample sources  (this  is  done  in  particular,  by  de
velopersoftheModelicaStandardLibraries)andrep
resent  each  clock  by  an  independent sample state
ment.
Butintheasynchronouspointofviewadoptedbyus,
followingthereplacementofthesamplemacroswith
thecorrespondingModelicacodeaspresentedprevi
ously,theclocksbecomeasynchronous.Inthisframe
work,itisnecessarytouseasingleclockandderive
theotherclocksbysubsampling;otherwisethebeha
viorofthesystemwillnotcorrespondtothedesired
behavior.

5. Synchronoussample

350 msec
Controllers
Only oneactive

Considernowtheproblemofhardrealtimecodegen
erationforthismechanism,whichcontainsthreebasic
frequencieswithperiods0.1,0.5and0.35.Theevents
correspondingtothesethreeclocksaresynchronized
atdifferenttimeinstants.Ingeneraltherecouldbe7
different situationsfor which staticcodegeneration
mustbeperformedbutinthisparticularcaseonly5
situationscomeup.Theimportantinformationtonote
hereisthatthesystemwillfunctioninafullyperiodic
wayandthetimingofallthesituationscanbecom
putedinadvancethankstoinformationontheperiods
(andoffsetsifany)oftheclocks.Itturnsoutthatin
thiscase,theoverallperiodis3.5;thetimingsofdif
ferenteventsituationsareillustratedbelow:

Wehaveseenthatononehanditisdesirabletocon
siderallindependenteventstobeasynchronousand
ontheotherhand,itisconvenienttoforce,depending
ontheirarguments,samplegeneratedeventsassyn
chronous.
Thetypeofsynchronismconsideredherehasnothing
todowiththewayDymolaenforcessynchronismbut
itisratherclosetoSimulinkswayofhandlingmulti
ratesystemsandScicosSampleClkblocks.Theidea
is  to  synthesize  a  basic  clock  at  a  precompilation
phasesothatallthesynchronousclocksdefinedby
sample statementscanbeobtainedbysubsampling
thebasicclock.Thecomputationoftheparametersof
thisbasicclockisstraightforward,see[3]fordetails.
Hereisasimpleexample:
whensample(0,2)then
<expr1>;
endwhen;
whensample(0,3)then
<expr2>;
endwhen;

Period = 3.5

Theperiodsinvolvedinthiscaseare2and3;theperi
odofthebasicclockisobtainedbycomputingthe
greatestcommondivisorof2and3,whichis1.The
overallperiodinthiscaseis6,soonewaythepre
compilercouldmodifythecodeisasfollows:
whensample(0,1)then
k=mod(pre(k)+1,6);
ifk==0then
TomodelsuchasysteminModelica,itiscommon
practice  to  assume  synchronism  of  independent
The Modelica Association

679

<expr1>;
<expr2>;
elseifk==2ork==4then
Modelica 2008, March 3rd  4th , 2008

R. Nikoukhah, S. Furic

<expr1>;

wehaveonlydrawntwooftheactivationlinksoutof
possible7(actually5inthisparticularcase).

elseifk==3then
<expr2>;
endif;
endwhen;

Thiswayofsubsamplingclockshavealreadybeen
introducedintheModelicaspecification(seeforex
amplethefastsample,slowsampleexampleonpage
81of[6]).
Goingbacktoourcodenow,weseethatitcontainsa
single sample keywordsoitisasynchronouscode
(assumingnowhenconstructsarepresentintherest
ofthemodel).Thesampleconstructcannowbeex
pandedaspreviouslydescribed.Thisconstructionin
Scicosisreferredtoasaperiodicconstruction.For
examplegoingbacktothedetector/controllermodel
from  the  previous  section,  the  period  of  the  basic Periodicsolutionsarealsodesirableforrealtimecode
clockwouldbe0.05(thegreatestcommondivisorof generationbecausetheembeddedcodecanbedriven
0.1,  0.5  and  0.35)  and the  periodic  solution  would byahardwarefixedfrequencyclock.
looklikethefollowing.Notethatthemodulocounter
countsfrom0to69becausetheperiodis3.5andthe
basicclocksperiodis0.05.
6. Implicationsoftheproposal

An  alternative  procedure  consists  of  constructing  a
vector  of  time  instants  where  events  occur  over  a
single  period  (in  this  case  [0,2,3,4])  and  generate
eventsusingindependenteventsourcescorresponding
totimeinstanceswhich,modulo6,aremappedtothe
elementsofthisvector.
Thisconstructioncanbemoreefficientforsimulation
buttheperiodicsolutionhastheadvantageofyielding
a  synchronous  code.  For  the  detector/controller  ex
ample,thenonperiodic(asynchronous)construction
lookslikethefollowing.Tokeepthediagramsimple
The Modelica Association

Byadmittingthattheasynchronousassumptiononin
dependenteventgeneratorsisthecorrectinterpreta
tion,ifthespecialtreatmentproposedforthesample
keywordisnotused,mostdiscretetimemodelsinuse
wont  operate  properly.  The  reason  is  that,  despite
somerecommendationsinthelanguagespecification,
synchronism  of  independent sample sources  is  as
sumed  by  library  developers  (in  particular,  by  de
velopers  of  the  Modelica  Standard  Libraries).  This
practice,mostlydrivenbyanalogywithotherprac
ticesfrequentlyencounteredinSimulinkbasedmod
eling,  conflicts  with  the  asynchronous  assumption
madeinourhybridmodel.
Toimposesynchronismamongvariousdiscretetime
models,insteadofrelyingontheusageofidentical
sample keywords,synchronizationsignalsshouldbe
used.Thisissuehasbeendiscussedin[5]whereactiv
ationsignalshavebeenintroduced.
Eventhoughtheuseofactivationsignalsisapower
fulmodelingmechanismthatshouldbeconsideredin
futureModelica,forthespecialcaseofperiodicevent
clocks,thetreatmentofthe sample keywordaspro
posedinthispaperavoidstheneedforthereusage.In
deed,byassumingthistreatment,backwardcompatib
ility for  discretetime  models would be  guaranteed.
Theprecompilationphasemakesthenecessarymodi

680

Modelica 2008, March 3rd  4th , 2008

Synchronous and Asynchronous Events in Modelica: Proposal for an Improved Hybrid Model

fications that assure the synchronizationof isolated [2]
modelsthatarerelatedtoeachothersimplybecause
they include  identical sample keywords.  The  back
ward  compatibility  is  also  assured  in  the  case  of [3]
multirate  systems  (when  non  identical sample
keywordsarepresentinthemodel)..

7. Conclusion

[4]

Wehaveproposedtointerpretthesamplekeywordin
Modelicainaspecialmannerinsuchawayastoas
suresynchronismbetweenthesekeywordsyetstaying [5]
withintheasynchronousframeworkproposedin[1].
Theimplementationconsistsofisolatingthe sample
keywordsintheflatModelicamodel.Ifonlyonesuch
keywordispresent,thenitistransformedasexplained [6]
inthepaper.Ifmorethanonesampleispresentinthe
model,  the  necessary  clock  computations  are  per
formedandallthesampleconstructsarereplacedby
conditionalstatementsdrivenbyasingle sample,as
illustratedonanexampleinthepaper.Thissampleis
thentransformedasinthepreviouscase.
Beside  backward compatibility (no Modelica model
needstobealtered),allowingtheusageofindepend
entsamplekeywordstomodelsynchronousmultirate
systems  provides  valuable  information  for  realtime
codegeneration.Howeversomeissuesremaintobe
solvedwiththisapproach,especiallythewaysample
constructsaretranslatedatthetypelevel(theyprob
ablycannotbeabstractedawayduringtypecomputa
tionsincethepublicinformationtheycarrymayinter
ferewithcompatibilitychecksofmodels).
UsingModelicaforrealtimeembeddedcodegenera
tionhasgreatpotentials.Unlikemostcodegeneration
environments,  in  Modelica  the  execution  semantics
canbebrokenupintoveryfinegrainsandmanipu
latedsymbolically.Inmostcasesthismeansthatreal
timecodecanbeobtainedwithouthavingtousepree
mption.Thisissuewillbeexaminedinafuturepaper.

Campbell,  S.  L.,  Chancelier,  J.  Ph.,  and
Nikoukhah,  R.,  Modeling  and  Simulation  in
Scilab/Scicos,Springer,2005.
Caspi,P.,Curic, A.,Maignan, A.,Sofronis,C.
and  Tripakis,  S., "Translating  DiscreteTime
Simulink  to  Lustre,  in Embedded  Software,
LectureNotes inComputer Science, Springer,
2003.
Otter,  M.,  Elmqvist,  H.  and  Mattsson,  S.  E.,
Hybrid  Modeling  in  Modelica  based  on  the
SynchronousDataFlowPrinciple,CACSD99,
Aug;1999,Hawaii.
Nikoukhah,R.,ExtensionstoModelicaforef
ficient  code  generation  and  separate  compila
tion,inProc.EOOLTWorkshopatECOOP07,
Berlin,2007.
Modelica  Association,  Modelica   A Unified
ObjectOrientedLanguageforPhysicalSystems
Modeling.  Language  Specification,  version
3.0,2007,availablefromwww.modelica.org.

References
[1]

Nikoukhah,R.,"HybriddynamicsinModelica:
Shouldalleventsbeconsideredsynchronous",
inProc.EOOLTWorkshopatECOOP'07,Ber
lin,2007.

The Modelica Association

681

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

682

Modelica 2008, March 3rd  4th , 2008

Support for Dymola in the Modeling and Simulation of Physical Systems with Distributed Parameters

Support for Dymola in the Modeling and Simulation
of Physical Systems with Distributed Parameters

Farid Dshabarow
ABB Turbo Systems AG
Switzerland
Farid.Dshabarow@CH.ABB.Com

Franois E. Cellier, Dirk Zimmer
ETH Zrich
Switzerland
{FCellier,DZimmer}@Inf.ETHZ.CH

Abstract
This paper introduces a new Modelica library for
modeling and simulation of systems with distributed
parameters in one space dimension. The resulting
partial differential equations of either the parabolic
or hyperbolic types are being converted to sets of
ordinary differential equations using either the
method of lines or the finite volume approach. Some
simple examples serve to document the utilization of
the new library.
Keywords: Distributed Parameter Systems, Numerical PDEs, Method of Lines, Finite Volume
Method

1

Introduction

1.1

History of General-purpose PDE Solvers

Lumped parameter systems have been successfully
modeled and simulated using general-purpose simulation software for several decades. With the advent
of Modelica, it has become unnecessary to model
and simulate any physical systems with lumped parameters using either general programming languages, like C++, or special-purpose simulation languages, like Adams or Spice. Modelica is capable of
converting any lumped parameter model of a physical system to executable code that is as efficient in
its execution as the best manually coded spaghetti
programs of the past. Modelica can also successfully
compete with special-purpose simulation codes, like
Spice or Adams, in the simulation of electronic circuits [5] and multi-body systems [15].
The modeling and simulation of distributed parameter systems using general-purpose simulation
software has not been as successful. In the 70s and
early 80s, a number of general-purpose simulation
codes, like FORSIM VI [4], were developed for the
purpose of modeling and simulating at least some

The Modelica Association

classes of systems with distributed parameters.
FORSIM VI, for example, was designed for simulating parabolic PDEs in one or two space dimensions.
Hyperbolic PDEs could be simulated as well, but the
resulting simulation code was not as efficient. Elliptic PDEs could sometimes be converted to equivalent
parabolic problems using invariant embedding.
Around the same time frame, another program,
ELLPACK [11], was developed that was designed
for solving elliptic PDEs in two or three space dimensions. The ELLPACK project was very ambitious, and the code grew rapidly to a size that made
the code difficult to use and maintain. In order to
make ELLPACK easier to use, the designers of the
code developed a preprocessor for translating an abstract model description down to a set of Fortran
subroutine calls. Yet, as new algorithms were added
constantly to the software, maintenance of the preprocessor became soon too difficult. Hence a compiler-compiler was developed that could be used to
generate a new version of the preprocessor from an
abstract description thereof. Yet in spite of all of
those efforts, the resulting simulation programs were
highly inefficient at run time.
Whereas one of the primary mantras of modeling
and simulation environments is to be able to protect
the user from having to fully understand the numerical properties of the underlying solver algorithms,
this demand could never be fully satisfied when dealing with PDEs. The run-time efficiency of the resulting simulation code depends too heavily on the chosen discretization method, and no logic was found
that could relieve the user from having to make hard
choices manually.
Sometimes codes like ELLPACK have been
used to quickly try out different combinations of algorithms and compare them with each other. In this
way, the user could more quickly determine, which
combination of algorithms might work best. However, once this decision has been reached, the final
code nevertheless had to be hand-coded, because the

683

Modelica 2008, March 3rd  4th , 2008

F. Dshabarow, F. Cellier, D. Zimmer

real problems were not limited to the PDE solvers
themselves, but more often than not were related to
how the code dealt with complex geometries, i.e.,
how physical boundary conditions were converted to
boundary conditions that the PDE solver could make
use of [14].
For all of these reasons, the use of generalpurpose simulation software for the simulation of
distributed parameter systems became unfashionable
again. The researchers dealing with these types of
systems simply gave up, and most of todays simulation codes are specially designed codes for very
small classes of problems only.
1.2

A Renaissance for General PDE Solvers

One technique that has proven to be more robust
than other approaches is the finite element method
[9]. The success of this technique is based on its
ability for dealing effectively with complex geometries. Originally developed for simulating elliptic 2D
and 3D problems, finite element methods have
quickly also been adapted to the discretization of
parabolic and hyperbolic PDEs [12].
FEMLAB is a general-purpose numerical PDE
solver based on the finite element method. FEMLAB was developed in recent years for the simulation of multi-physics applications. The code is capable of simulating models involving multiple PDEs
[13].
FEMLAB started out as a MATLAB toolbox.
Yet, its developers learnt quickly the same truth that
the ELLPACK developers had learnt before them: a
general-purpose PDE solver becomes soon unmanageable without a preprocessor capable of interpreting an abstract model definition. They also learnt
that they needed to offer CAD support for entering
the device geometry.
FEMLAB was more successful than ELLPACK,
in part, because the computers have meanwhile become faster, and in part, because they were less ambitious in the sense that they didnt insist on incorporating each and every algorithm that has ever been
developed for the numerical solution of PDEs.
FEMLAB has recently changed its name to
COMSOL. This software represents currently the
gold standard of general-purpose numerical PDE
solvers for multi-physics applications.
1.3

A Role for Modelica?

Modelica has become the de facto standard for modeling and simulation of physical systems with

The Modelica Association

lumped parameters. Does it have a role to play in
numerical PDEs also?
Modelica, or rather its implementations, such as
Dymola, offer not much that is unique or special
w.r.t. their simulation engine. The only feature
worth mentioning in this respect is a fairly robust
root solver (discontinuity handler). The true power
of Modelica lies in its ability to deal with differential
and algebraic equations (DAEs) in a very flexible
and truly object-oriented manner.
Todays numerical PDE solvers, including
COMSOL, offer numerically advanced algorithms,
but are very primitive w.r.t. their user interface. The
complexity and elaboration of the user interface is at
approximately the same level that the Continuous
System Simulation Languages (CSSLs) were prior to
the advent of the CSSL standard [2].
Would a language like Modelica have made a
big impact in the 1960s, had it been available? The
answer to this question is no. The computers of
those times were far too small and too slow to adequately host a language like Modelica. The researchers of those days dealt with much simpler
models, models that could be handled by the tools
available to them, not because they lacked a better
understanding of physics, but simply, because their
computers couldnt handle more complex models.
Are distributed parameter problems structurally
simpler than lumped parameter problems? The answer to that question is also no. Physics in general
deals with 3D fields, and lumped parameter models
are simply abstractions of distributed parameter
problems.
If we wish to bend a pipe, we first heat up the
area where the pipe is to be bent. If we were to
simulate the physics of bending a pipe, we would
have to solve a 3D distributed parameter problem
with one PDE describing the heat diffusion problem
and another PDE describing the mechanical stresses
and strains within the material. These PDEs would
furthermore have to be solved in a geometry that
changes over time as a function of the numerical solution of the two PDEs.
Researchers arent currently simulating such
processes, they arent dealing with partial differential
and algebraic equations (PDAEs) yet, because the
computers of today are too small and too slow to
adequately handle such problems.
Yet, it is not too early to ponder about the language constructs and numerical algorithms that will
be needed in support of such endeavors, once the
computers shall have advanced to a level, where they
can deal with such models effectively and efficiently.

684

Modelica 2008, March 3rd  4th , 2008

Support for Dymola in the Modeling and Simulation of Physical Systems with Distributed Parameters

2

PDELib for 1D Numerical PDEs

3

Since the Standard Modelica Library doesnt offer
any support yet for modeling distributed parameter
systems, we decided to take a first, and very modest,
step towards the much larger and more grandiose
aim outlined in the introduction.
To this end, we revisited some of the programs
of the past, in particular FORSIM VI, and decided to
re-implement some of the algorithms and capabilities
offered by FORSIM VI in a Modelica experimental
library. The results of that effort are being presented
in this paper.
In order to keep things simple, we decided to
limit the tool to the numerical solution of parabolic
and/or hyperbolic PDEs in a single space dimension,
the class of 1D numerical PDEs.
Since 1D PDEs are solved on a straight line between point A and point B, the geometry plays no
role yet in these problems. The spatial discretization
is straightforward; finite elements arent needed or
even useful yet for the spatial discretization; and the
resulting simulation code can still be simulated fairly
efficiently and rapidly using almost any half-way
suitable numerical algorithm.
The aim of the project was to create an experimental tool that can be used to study some properties
of numerical PDEs that havent received much coverage yet in the open literature.
One of the numerical problems to be studied is
the propagation of discontinuities through a 1D hyperbolic PDE. Such discontinuities cause a new
class of numerical problems. Once the discontinuity
has reached the boundary condition of the PDE, it
can no longer be isolated in time. At any moment in
time, the discontinuity exists somewhere within the
spatial domain covered by the PDE. Thus, traditional event handling cannot be used to deal with this
type of discontinuities.
A structural problem to be studied concerns the
numerical solution of 1D PDAEs. Can Modelica
help in translating a 1D PDAE into a simulation code
that can be simulated effectively and efficiently?
Two algorithms were implemented in the first
official release of PDELib: the method of lines [6],
and a dialect of the finite volumes approach [10].

The Modelica Association

Method of Lines

Given the 1D diffusion equation:

The method of lines discretizes the spatial derivatives, while keeping the temporal derivatives continuous. In a first approximation, we may write:

Plugging Eq.(2) into Eq.(1), we find:

In this way, we have converted a PDE into a stiff set
of ODEs that can now be simulated using any offthe-shelf stiff ODE solver, such as DASSL.
The method of lines is fairly easy to implement.
The chosen approximation is third order accurate. If
the user wishes to use a more accurate approximation
formula, this can be done easily.
Care must be taken in a correct implementation
of the boundary conditions. As the discretization
approaches the boundary, biased discretization formulae in place of central formulae must be used in
order not to make use of grid points outside the
simulated domain.
The approach works fairly well, especially in the
case of parabolic PDEs such as the diffusion equation. The spatial discretization of a parabolic PDE
by means of the method of lines leads invariably to a
stiff set of ODEs, but modern numerical ODE
solvers are good at dealing with those.
This is the approach that FORSIM VI took. In
order to relieve the user of having to remember different discretization formulae, FORSIM VI offered a
set of Fortran subroutines for computing spatial derivatives both in the bulk and in the vicinity of the
domain boundaries.
PDELib also hides the details of the discretization formulae from the user, but does so using a
Graphical User Interface (GUI) as shown in Fig.1.

685

Modelica 2008, March 3rd  4th , 2008

F. Dshabarow, F. Cellier, D. Zimmer

Since Dymola hasnt been designed for simulating
PDEs, there is currently no support for 3D graphics
in Dymola. The graph shows the temperature, u, at
different space locations as a function of time.
The analytical results were superposed with the
simulation results. In the simulation, the space was
discretized into 40 segments of equal size. With 40
segments, the simulation results are still noticeably
different from the analytical results.

Figure 1: Model of 1D diffusion equation in PDELib

PDELib offers a method-of-lines (MOL) integrator block. This is a vector integrator block that integrates the vector of temporal derivatives, dui /dt
(marked as R on the integrator block), into the vector of states, u (marked as Var), while considering
the vector of initial conditions (IC) as well as the left
and right boundary conditions (BCL and BCR).
The blue box computes the spatial derivatives.
In its parameter window, the user can select the approximation order to be used. Biased formulae of
suitable approximation accuracy automatically replace the central formulae in the vicinity of the two
domain boundaries.
The WorldModel box is used to provide general
information, such as the grid width of the spatial discretization.
Since the diffusion equation with the chosen initial and boundary conditions has an analytical solution, that solution is also computed in the block DAN
for comparison.
Simulation results are shown in Fig.2.

The MOL approach is less well suited for dealing with hyperbolic PDEs, because their discretization leads to marginally stable ODE systems, rather
than stiff ODE systems. Unfortunately, the numerical ODE solvers provided with Dymola and most
other ODE simulators are not geared to accurately
integrate marginally stable systems of ODEs.
The numerical condition of the model can sometimes be improved by using upwind discretization
schemes [3]. In these schemes, the spatial derivatives are on purpose computed using biased formulae
also in the bulk. FORSIM VI and PDELib offer optional upwind discretization schemes.

4

Finite Volume Method

Another discretization technique that has been successfully applied to numerically simulating hyperbolic PDEs is the Finite Volume Method (FVM).
Just like the MOL technique, also the FVM approach
comes in many different variants. Hence it may be
useful to provide a toolkit that enables a user to
compose a FVM from a set of component models.
In one space dimension, the FVM consists in
subdividing the spatial domain into intervals, also
called cells or finite volumes. The integral of the
unknown function, u, is approximated over each of
these cells at each time step. Let us denote the ith
cell by:

The average value of the function u over this cell
is then:

Figure 2: Diffusion equation simulation results

The Modelica Association

How can we estimate the value of Ui? Considering the mass conservation law, we note that the average within the cell can only change due to fluxes at
the boundaries, assuming that neither source nor sink

686

Modelica 2008, March 3rd  4th , 2008

Support for Dymola in the Modeling and Simulation of Physical Systems with Distributed Parameters

is present in the cell. Mass conservation can be expressed mathematically in the following form:

5

Examples

In the following section of the paper, some of the
models currently available as examples in PDELib
are shown.
where f denotes the flux function. The change of
total mass inside the cell equals the flux entering the
cell minus the flux leaving it.
Let us integrate Eq.(6) over time from t to t+t
and divide the equation by t and x. We obtain:

5.1

Linear Advection Equation

The advection equation is one of the simplest PDEs
to be found. Given a constant speed, c, the linear
advection equation can be written as:

This problem was encoded using the MOL approach
with the initial condition:

Plugging Eq.(5) into Eq.(7), we obtain:

and with the boundary condition:

applied at the left boundary of the domain.
MOL model is shown in Fig.3.

where:

The

is the average flux over one time step.
We can reinterpret Eq.(8) as a discrete approximation of a differential equation:

Using this simple trick, we have reduced also the
FVM to a Continuous-Time/Discrete-Space (CTDS)
method.
How do we approximate the average flux? Different approximations have been proposed. A simple
approximation is the upwind flux:

Figure 3: MOL model of linear advection equation

Some simulation results are shown in Fig.4.
i.e., the average flux across a border between cells
during one integration step is proportional to the average value of u in the upwind cell.

Figure 4: MOL simulation of linear advection equation

The Modelica Association

687

Modelica 2008, March 3rd  4th , 2008

F. Dshabarow, F. Cellier, D. Zimmer

The same problem was also solved using the FVM
technique with upwind flux computation. The model
is shown in Fig.5.

The MOL implementation of Burgers equation
is shown in Fig.7.

Figure 7: MOL model of Burgers equation
Figure 5: FVM model of linear advection equation

Some simulation results are shown in Fig.8.
This model generates the simulation results shown in
Fig.6:

Figure 8: MOL simulation of Burgers equation
Figure 6: FVM simulation of linear advection equation

The index of the FVM solution is off by two segments due to the ghost cells used in this approach for
computing the solution in the vicinity of the domain
boundary [8].
5.2

Burgers Equation

The inviscid Burgers equation is the non-linear PDE

The results look excellent, but they are deceiving. The simulation here used 20 segments. Using
10 segments, the numerical results start deviating
from the analytical results after only 0.2 seconds of
simulated time. With 20 segments, the simulation
results are more accurate, but the numerical simulation turns unstable after roughly 0.6 seconds. The
more segments are being used, the faster the simulation becomes numerically unstable.
An FVM implementation of Burgers equation is
shown in Fig.9.

If we choose as initial condition:

and as boundary conditions:

the problem has the analytical solution:
Figure 9: FVM model of Burgers equation

The Modelica Association

688

Modelica 2008, March 3rd  4th , 2008

Support for Dymola in the Modeling and Simulation of Physical Systems with Distributed Parameters

In this example, the FVM implementation uses a
Lax-Friedrichs flux together with Local Double
Logarithmic Reconstruction (LDLR) [1,7,10].
Some simulation results are shown in Fig.10.

us. Otherwise, we shall never be able to solve
PDAEs.
We had made the same mistake initially in the
design of MultiBondLib [15], our multi-bond graph
library. Initially, we formulated holonomic constraints between bodies using blocks from the Blocks
library. If we use an adder:

Figure 11: Adder of the Blocks library
Figure 10: FVM simulation of Burgers equation

The FVM simulation remains numerically stable
independent of the number of cells in use. Unfortunately, the results obtained are less accurate than using the MOL approach. The indices are again off by
two because of the ghost cells.

6

Conclusions

What have we accomplished? We have been able to
create an experimental library that enables experienced analysts to quickly try out different combinations of algorithms that can be used for the simulation of 1D parabolic and hyperbolic PDEs. Yet, we
have failed in our aim to protect the user from having
to understand the numerical properties of PDE
solvers.
We chose a mathematical rather than a physical
interface to our library, because it makes the tool
more flexible and more general in its applicability.
However, it was precisely that decision that made us
fail in our endeavor of delivering a tool to the end
user that can be applied blindly and reliably. This
simply cannot be done at a mathematical level.
Yet, this is not a major problem. Modelica, due
to its object-oriented philosophy, is good at information hiding. In the future, we shall be able to place a
physical layer on top of the mathematical layer that
offers solutions to particular subsets of PDEs, just as
COMSOL does. Each physical module then decomposes its models internally into a combination of
modules programmed at the mathematical layer.
We chose a blocks philosophy for our library.
Each mathematical model is composed as a block
diagram. In the long run, this decision will prove to
have been a mistake. We shall need to learn to trust
Modelica to make the right causality decisions for

The Modelica Association

from the Blocks library, we force Modelica to compute y = u1  u2, but maybe the correct causality
ought to be u2 = u1  y. By using blocks from the
Blocks library, we are tying Modelicas hands unnecessarily, which may lead to situations, where
Modelica can no longer find a solution to the problem.
Yet for the time being, the decision to program
PDELib using blocks rather than models helped us
restrict the sources of errors. During the initial phase
of the research, the phase of determining the most
suitable numerical algorithms, the use of blocks may
be a good thing.
Finally, Dymola doesnt offer any support yet
for 3D graphics. Although it is possible to export
simulation results to MATLAB and produce 3D
graphics using that software, this is a hassle. Dynasim should develop a 3D graphics package that can
be used to plot vectors of variables against time. The
package should furthermore be tied to the 3D View
Control window to give the users an opportunity to
look at their 3D graphs from different angles.

References

689

[1]

Artebrant, H., Schroll, J., Limiter-free Third Order Logarithmic Reconstruction. SIAM Journal
on Scientific Computation 28 (2006) 359-381

[2]

Augustin, D.C, Fineberg, M.S., Johnson, B.B.,
Linebarger, R.N., Sansom, F.J., Strauss, J.C.: The
SCi Continuous System Simulation Lanugage
(CSSL). Simulation 9 (1967) 281-303

[3]

Carver, M.B., Hinds, H.W.: The Method of Lines
and the Advective Equation. Simulation 31
(1978) 59-69

[4]

Carver, M.B., Stewart, D.G., Blair, J.M., Selander, W.N.: The FORSIM VI Simulation Pack-

Modelica 2008, March 3rd  4th , 2008

F. Dshabarow, F. Cellier, D. Zimmer

age for the Automated Solution of Arbitrarily Defined Partial and/or Ordinary Differential Equation Systems. Atomic Energy of Canada, Ltd.,
Chalk River, Ontario, 1978
[5]

Cellier, F.E., Clau, C., Urqua, A.: Electronic
Circuit Modeling and Simulation in Modelica. In:
Proceedings of the Sixth Eurosim Congress on
Modelling and Simulation, Ljubljana, Slovenia
(2007) Vol. 2, 1-10

[6]

Cellier, F.E., Kofman E.: Continuous System
Simulation. Springer-Verlag, New York, 2006

[7]

Daz Lpez, J.: Shock Wave Modeling for Modelica.Fluid Library Using Oscillation-free Logarithmic Reconstruction. In: Proceedings of the
5th International Modelica Conference, Vienna,
Austria (2006) Vol.2 641-649

[8]

Dshabarow, F.: Support for Dymola in the Modeling and Simulation of Physical Systems with
Distributed Parameters. MS Thesis, ETH Zurich, Switzerland, 2007

[9]

Hughes, T.J.R.: The Finite Element Method: Linear Static and Dynamic Finite Element Analysis.
Dover Publications, 2000

[10] LeVeque, R.J.: Finite Volume Methods for Hyperbolic Problems, Cambridge University Press,
2002
[11] Rice, J.R., Boisvert, R.F.: Solving Elliptic Problems Using ELLPACK. Springer-Verlag, New
York, 1984
[12] Thome, V.: Galerkin Finite Element Methods
for Parabolic Problems, 2nd Edition. SpringerVerlag, Berlin, 1997
[13] van Schijndel, A.W.M.: Modeling and Solving
Building Physics Problems with FemLab. Building and Environment 38 (2003) 319-327
[14] Wu, Q.M., Cellier, F.E.: Simulation of Bipolar
High-voltage Devices in the Neighborhood of
Breakdown. Mathematics and Computers in
Simulation 28 (1986) 271-284

Farid Dshabarow received his MS
degree in computer science from the
Swiss Federal Institute of Technology (ETH) Zurich in 2007. He is
now working at ABB Turbo Systems, where he deals with gas dynamics simulations in turbochargers
and software for calculating and visualizing turbocharger characteristics.
Franois E. Cellier received his BS
degree in electrical engineering in
1972, his MS degree in automatic control in 1973, and his PhD degree in
technical sciences in 1979, all from the
Swiss Federal Institute of Technology (ETH) Zurich.
Dr. Cellier worked at the University of Arizona as
professor of Electrical and Computer Engineering
from 1984 until 2005. He recently returned to his
home country of Switzerland. Dr. Cellier's main scientific interests concern modeling and simulation
methodologies, and the design of advanced software
systems for simulation, computer aided modeling,
and computer-aided design. Dr. Cellier has authored
or co-authored more than 200 technical publications,
and he has edited several books. He published a textbook on Continuous System Modeling in 1991 and a
second textbook on Continuous System Simulation
in 2006, both with Springer-Verlag, New York.
Dirk Zimmer received his MS degree
in computer science from the Swiss
Federal Institute of Technology
(ETH) Zurich in 2006. He gained
additional experience in Modelica and
in the field of modeling mechanical
systems during an internship at the
German Aerospace Center (DLR) in 2005. Dirk
Zimmer is currently pursuing a PhD degree with a
dissertation related to computer simulation and modeling under the guidance of Profs. Franois E. Cellier
and Walter Gander. His research interests focus on
the simulation and modeling of physical systems
with dynamically changing structure.

[15] Zimmer, D., Cellier, F.E.: The Modelica Multibond Graph Library. In: Proceedings of the 5th
International Modelica Conference, Vienna,
Austria (2006) Vol. 2, 559-568

The Modelica Association

690

Modelica 2008, March 3rd  4th , 2008

Session 6c
Thermodynamic Systems & Applications

The Modelica Association

691

Modelica 2008, March 3-4, 2008

The Modelica Association

692

Modelica 2008, March 3rd  4th , 2008

Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic Transfer System

Simulation of Peak Stresses and Bowing Phenomena
during the Cool Down of a Cryogenic Transfer System
Hubertus Tummescheit, Kristian Tuszynski , Philipp Arnold
Modelon AB, Ideon Science Park, SE-22370 Lund, Sweden
Linde Kryotechik AG, CH-8422 Pfungen, Switzerland
Hubertus.Tummescheit@modelon.se, Kristian.Tuszynski@modelon.se

Abstract
An extension for cryogenic systems to the AirConditioning Library by Modelon was used to analyze the
cool down of a cryogenic transfer system where
Linde Kryotechnologie in Pfungen, Switzerland was
the main contractor. Simulation was used early in the
design process to make sure that the system was well
designed for a number of cool-down scenarios. Early
detection of problematic parts of the system for some
cool-down sequences lead to changes in the piping
design. Simulation was also used to assess the maximum thermal stresses during cool down and determine suitable mass flow rates. Proper cool-down sequences were established iteratively with the help of
a combined simulation of the cryogenic two-phase
flow, the heat conduction in solid structures and the
resulting thermal stresses. The two main problems to
avoid during cool down are (1) excessive thermal
stresses in thick-walled components, and (2) bowing
of pipes with liquid cryogen in the lower part of a
long, horizontal pipe with gaseous cryogen above.
Two similar systems where considered, one for liquid hydrogen, the other for liquid oxygen. Dymola
and Modelica were choosen for the project due to the
good multi-domain and multi-physics capabilities,
and the availability of model libraries that covered a
large part of the problem.
Keywords: Cryogenics, two-phase flow, transient
thermal stress simulation

1

Introduction

The Indian Space Research Organization, ISRO, is
building and commissioning a new cryogenic engine
test rig in their Liquid Propulsion Test Centre in Mahendragiri, Tamil Nadu. The system under investigation is the cryogenic transfer system for the cryogenic fluids hydrogen and oxygen, used to transfer
cryogen from tankers into the run-tanks and from
both tankers and run tanks to the test objects. The
The Modelica Association

system is designed for a wide range of pressures and
flow rates which leads to a rather complex overall
structure of pipes, valves and measurement equipment. Simulations of the system cool down was used
early in the design process to validate the design 
here the main issue is to avoid bowing of dead-end
pipes  and to find improvement potential from an
operational point of view. Simulation was also used
later on to establish suitable cool-down flow rates
and valve sequences that fulfill the two main requirements: use as little cryogen as possible for cool down
while not exceeding the maximum allowed thermal
stresses.
Obtaining the desired mass flow rates in a transient
two-phase flow system throughout the system is very
difficult because of the enormous change in densities
between gaseous and liquid cryogen: the density ratio can be up to 1:1000. During the filling of the system with liquid, deviations between local mass flow
rates and controlled rates at a valve with one-phase
inlet conditions can be large. In the situations when
the control valve is inside the two-phase region, actual mass flow rates can not be controlled at all.

2

Modeling of thermal stress in
cylindrical bodies

The model for thermal stress is based on a radial discretization of cylindrical geometries both for pipes
and valves. For the bowing phenomenon, also a tangential discretization and, if necessary an axial one
are added. The energy balance of a cylindrical slice
of the pipe is based on the Fourier equation with a
central difference approximation of the temperature
gradient and takes the temperature dependence of the
heat capacity and thermal conductivity into account.
Stresses are computed separately for the stress introduced through temperature gradients and the mechanical stress due to the pressure inside the pipe.
The stress vectors are summed to compute a total
equivalent stress. The equivalent stress reaches its

693

Modelica 2008, March 3rd  4th , 2008

H. Tummescheit, K. Tuszynski, P. Arnold

maximum value either on the inside of the cylinder
or on the outside of the cylinder. The ratio of the
maximum equivalent stress and the yield stress is the
stress ratio.
The Fourier equation is given by [7],
(1)

i  T i
 Cpi

Cpi
T
 i t
t i
= AiT i1BiT iC iT i1

where E is the Young modulus,  the linear expansion coefficient and  the Poisson ratio.
By only calculating the thermal stress at the inner
and outer points of the wall (the maximum stress of a
pipe is always at one of these points) the equations
can be simplified as:

E 11
[ TmT  r i  ]
11 
E N r N r
o
 =
[ TmT r o ]
1 N r 
E 
i
 z= 1 1 [ TmT  r i ]
11 
E N r N r
o
z=
[ TmT r o ]
1 N r 
i
o
 r =0,
 r =0
 i=

Where i = 2, 3.. Nr-1 and Nr is the discretization
number of the material in radial direction. The two
remaining elements are given by the boundary conditions.
The calculation of the Fourier coefficients, A, B and
C for a radial discretization is shown in equation (2).

Ai =

r i r i1
r i  r ir i 1 r i 1r i 1 

Where Tm is the mean temperature of the material
and 1 and Nr refer to the innermost and outermost radial discretizations respectively.

Bi =

r i 1 r i
(2)
r i  r i1r i r i 1r i 1

The effective stress according to Von-Mises theory
results in (from [7]):

 eff =  2 2z  2r   r  z  r z 

C i= Ai Bi
The axial heat conduction in the material is assumed
to be negligible.
To obtain the thermal stress distribution, three stress
components in tangential (), radial (r) and axial (z)
directions are calculated. The general stress equations are given by

[

2

r r
2

r or

2
i
2
i

ro

r

r T r  r dr r T r  r dr T  r r 2
i

i

E
r =

1 r 2
r
r 2r 2i r
T
r

r
dr

T r  r dr


r
r 2or 2i r

[

z =

(5)
The stress-ratio is defined as the ratio of effective
stress to yield stress of the material:

 ratio =

 eff
Y

(6)

The two different problems analyzed later in the paper need different discretizations.

E

2
1r

 =

(4)

o
i

[

i

r
E
2
 2 2 r T r  r dr T r 
1 r or i
o
i

]

1. The thermal stress analysis from cool-down
requires a two-dimensional model with radial and axial discretizations to capture the local thermal stresses along the pipe.

]
]

2. The bowing problem requires axial and tangential discretizations to capture the different deformations on the top and bottom of a
pipe where the bottom is filled with boiling
liquid and the top is filled with saturated gas.
Both cases were captured with a single model with
all 3 discretizations, where the ones that were not
needed were set to one element.

(3)

The Modelica Association

694

Modelica 2008, March 3rd  4th , 2008

Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic Transfer System

3

Flow modeling

For the two-phase flow in the pipes, a standard finite
volume method assuming homogeneous equilibrium
flow was used as described in [2] and [3]. Due to the
partially violent transients, a dynamic momentum
balance has been used for some of the simulations.
Heat transfer needs to take into account the subcooled boiling regime, which is important towards
the end of the cool down and is present during a
large fraction of the overall cooldown time. Pressure
drop models are from the standard literature like [4].
Properties for oxygen were implemented according
to [1], hydrogen properties according to [8], and the
results were compared to RefProp by NIST which
contains the same property models.

limit. The lower limit is defined by the non-stratified flow condition. A stable phase separation with
liquid flow on the bottom of the pipe and gaseous
flow above it results in differences in the heat transfer rate of about one order of magnitude. They may
lead to faster cooldown on the bottom of the pipe,
which may lead to bowing. The limit for stratified
flow conditions for cryogens has been investigated in
[9].
It could be argued that a homogeneous equilibrium
model does not capture the physics of the cool down
flow sufficiently accurate. For the main focus of the
study, the thermal stress in the thick-walled components, it is not necessary to predict the flow and the
flow-regime exactly (appart from avoiding stratified
flow conditions), and therefore we do not believe
that a non-homogeneous flow would improve the
quality of the results in a way that would justify the
much higher model complexity.

4

Low temperature properties

Both the thermal conductivity and the heat capacity
of metal pipes go to 0 at 0 degrees Kelvin. This has a

Figure 2: Thermal conductivity for steel 316L
as a function of temperature.
number of surprising effects when the temperatures

Figure 1: Flow rate which predicts non-strati- are approaching the lower limits (ca. 20 K for liquid
fied flow conditions for pipeline fluid qualities hydrogen and ca. 80 K for liquid oxygen): the cold
below95% (liquid and gas phase assumed saturated parts of metal pipes and valves almost insulate the
at boiling point), from [9].

The main trade-off that has to be taken into account
is between minimal cryogen consumption for cooldown and a minimal cool down time. The mass flow
is restricted by an upper limit, usually determined by
the maximum allowable thermal stress, and a lower
The Modelica Association

remaining warmer parts from the cryogen, effectively slowing down the last part of the cool down.
Fortunately detailed data for metals used in cryogenic transfer systems is publicly available from
NIST (National Institute for Standards and Technology) via their web-based database, see [8].

695

Modelica 2008, March 3rd  4th , 2008

H. Tummescheit, K. Tuszynski, P. Arnold

3. stream of the valve but a short distance into the pipe,
at a location where the combination of high heat
transfer coefficient and large T results in the combination with the highest heat flow. The longitudinal
discretization is 20 segments, the radial discretization 10 segments for pipes.
Different phases of cool down can be clearly distinguished from the temperature trajectories. The difference between hydrogen and oxygen cool down is
also striking, but becomes understandable once the
influences of the different thermophysical properties
of the fluids and the metals are taken into consideration. Some of the results are not entirely intuitive,
e.g. that the first part of the pipe has initially lower
Figure 3: Specific heat capacity for steel 316L temperature than the downstream parts, but is the last
part to be cooled down entirely.
as a function of temperature.

5

Thermal stress results

For the evaluation of thermal stresses, a 10 m long
pipe with ca 150 mm diameter (DN 150) and ca 8
mm wall thickness, material stainless steel 316 for
oxygen and 304 for hydrogen, directly downstream
of an open-close valve that opens completely in 2
seconds is investigated. The results for pipes give a
good understanding for the situation of the complete
system as they demonstrate well the differences
caused by the different cryogen properties The upstream properties are:
1. Liquid oxygen of 0.5 MPa at 91 K.
2. Liquid hydrogen of 0.5 MPa at 21 K.
In both cases, the highest stress is not directly down

Figure 4: Temperature over time with different
phases for a 10m high-pressure pipe during
cool down with an oxygen mass flow of 1.7 kg/s
at control valve.

The Modelica Association

Figure 5: Temperature over time with different
phases for a 10m low-pressure pipe during cool
down with a hydrogen mass flow of 0.25 kg/s at
control valve.
This is explainable from the change of the heat transfer coefficients over time/temperature: obviously the
first part of the pipe is cooled down faster at the beginning, but the combination of a cold wall (metal
conductivity decreases with temperature) and a low
heat transfer coefficient (the beginning of the pipe is
exposed to single phase liquid flow at very low
Reynolds numbers). This fact, combined with further
results omitted here, leads to the result that the cool
down time is independent of the pipe length for pipe
lengths less than 50 m. The differences between oxygen and hydrogen cool down become clear when
looking in more detail at the required energy for the
metal cool down and the available specific enthalpy
differences for cooling in different phases, tabulated
in Table 1. It is obvious that a much larger part of the
cooldown is between gas phase and metal for hydrogen, both due to the larger energy content and the
larger temperature difference. The gas phase cool
down has a lower heat transfer coefficient which

696

Modelica 2008, March 3rd  4th , 2008

Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic Transfer System

leads to lower stress peaks in the material. Secondly,
the rapid cool-down with two-phase flow mostly
happens after efficient pre-cooling with cold gas.
Overall and against first intuition, cooling down with
oxygen poses higher risks in spite of the lower temperature difference. Note also the temperature
bounce-back of the metal layer in contact with the
hydrogen after the hydrogen in the pipe changes
from two-phase to liquid. This effect is caused by the
drastic drop in heat transfer coefficent in the presence of much warmer outer layers in the pipe metal.
Material / Energy content for complete
phase
cooldown (from 318 K to 80 K for
O2, 20K for H2)
Steel 304

101.5 kJ/kg

Steel 316

94.6 kJ/kg

Total h H2

4158 kJ/kg

Total h O2

391.2 kJ/kg

h H2 evap

373 kJ/kg

h H2 gas

3785 kJ/kg

h O2 evap

191.2 kJ/kg

h O2 gas

200 kJ/kg

Table 1: Integrated energy content comparison
The largest source of uncertainty in the evaluation of
the stress ratio is the occurrence of the boiling crisis in two-phase heat transfer at very high heat flow
rates. Under such conditions, a thin layer of gas at
the metal wall separates the boiling liquid from the
metal by an insulating layer, thus drastically reducing the heat flow and the resulting thermal stresses.
Correlations for the occurrence of the boiling crisis
for cryogenic fluids are not very reliable, data only
exists for non-cryogenic fluids. In addition, the boiling crisis condition for cryogenic cooling occurs at
(almost) constant temperature of the hot side, which
is different form the usual experiments with rapid
heating and rising temperature on the hot side.

The Modelica Association

Figure 6: Stress ration along oxygen pipe directly after valve without any pre-cooling.
While this means that the exact heat transfer in
the vicinity of the boiling crisis is difficult, the
existing correlations can nonetheless be used to
estimate the highest reasonable heat transfer coefficient and thus the worst case scenario for the
thermal stresses in the metal wall. The results in
Figure 6 for a high pressure pipe show that the
combination of worst case assumptions (first
segments of pipe that is subject to two-phase
heat transfer from the start and high coefficinent
of heat transfer) lead to stress ratios close to the
permissible limit. The stress ratio plot in Figure
6 also shows that locations further downstream
are subject to lower stress due to pre-cooling
with cold gas. The stress peaks widen and the
level decreases as the two-phase zone widens
further downstream. A sensitivity study was
conducted with repect to the most important parameters for the stress calculation, among others,
the heat transfer coefficient, and the result was
that the maximum heat transfer coefficient had a
negligible effect on the stress ratio. For valves,
due to the much thicker metal walls, the stress
ratio exceeds 1.0 locally and for brief times.
Cryogenic valves survive these conditions, but
the high thermal stress leads to local deformations and cold hardening, but is far from values that would cause complete material failure.
While it is not possible to avoid these conditions
everywhere in the system, the operation of the
plant can be adapted to minimize the number of
times and locations that are subject to the extreme conditions. It was, however, possible to
avoid the severe thermal stress conditions for
valves in the high pressure part of the system.

697

Modelica 2008, March 3rd  4th , 2008

H. Tummescheit, K. Tuszynski, P. Arnold

6

Pipe Bowing

Lliq L Dbottom
L Dtop L Dbottom
Lliq L Dbottom
k gasT wall T gas A HT1

L Dtop L Dbottom
Q=k liqT wall T liq A HT

The calculation of the pipe bending due to the temperature difference at the top and bottom of the pipe,
when filling with cold liquid, is done with the following assumptions:


Pipes are considered straight,



The pipes are fixed at the lower end points
with a gliding support at one end to compensate for longitudinal length change,



Both radial and circumferential heat transfer
is taken into consideration in the wall, axial
heat transfer is neglected due to axial symmetry.

The liquid cross section area in the pipe is calculated
according to (1):

Aliq =acos 1

Lliq 2
r  Lliq r pipe 
r pipe pipe

 2r pipeLliq L 2liq

(1)

The liquid volume is computed from the mass flow
into the horizontal pipe, assumed to end at a closed
valve. The mass flow into the pipe is taken from a
prior cooldown simulation, at the position of the horizontally connected pipe.

4

where AHT is the heat transfer area, LDbottom is the
length from the bottom of the pipe to the lower
boundary of a discretization, LDtop is the length from
the bottom of the pipe to the top boundary of a discretization, kliq is the heat transfer coefficient when in
contact with liquid and kgas is the heat transfer coefficient when in contact with the gas. Note that the
weighted heat transfer area is a linearization of the
inner pipe area fraction around the middle of a circumferential section and should thus only be used for
relatively high discretization (16 were considered
sufficient).
When calculating the pipe bending only the length
change at the top (element 4 and 5 in Figure 5) and
bottom (1 and 8 in Figure 5) of the pipe is taken into
consideration. The length change is calculated
through:

 L=L T wall 

(4)

where  is the linear expansion coefficient of the
material.

5

3

6

2

7
1

d
z

8

Figure 5: Circumferential discretization of the wall
(defined by user)
Simulations use two heat transfer coefficients, one
for the part of the wall that is in contact with liquid
and the other for the part that is in contact with the
gas. The gas temperature has very little influence on
the overall result because of the low heat transfer coefficient between gas and pipe wall. Due to the boiling liquid underneath it will within short time after
liquid cryogen is at the bottom reach the saturation
temperature.
To calculate the heat transfer to the wall the actual
liquid level is used to find the length of a discretization that is covered by liquid (if any) and the heat
transfer is proportional to this value:

The Modelica Association

698

Lift

L

h

r

Figure 4: Pipe bending

Lift =r h

r=

(5)

L/2
sin

and

sin =

z
d

(6)

Modelica 2008, March 3rd  4th , 2008

Simulation of Peak Stresses and Bowing Phenomena during the Cool Down of a Cryogenic Transfer System

h=

L/2
tan 

log when the requested accuracy was not
achieved.
3. Improved numerical debugging facilities.
Dymola's current debugging facilities for numerical problems in large models are insufficient.

(7)

(5), (6) and (7) yields,

L d
1
Lift =  

2 z tan 

(8)

If the lift would reach high values of several centimeters, the influence of the lift on the local level
and heat transfer would have to be taken into account, but such values are outside of the permissible
range anyways.
The worst case encountered in the final modified
version of the plant diagram was for a dead end of
slighly less than 4 m length and a filling time form
empty to full of about 11 minutes. The worst lift was
2.8 cm, a tolerable amount, and the worst case stress
ratio using an equivalent stress from the full three-dimensional stress tensor was around 0.45. The length
of the pipe has the worst effect on bowing as it effects both the geometry and the exposure time, and
dead end pipes longer than 4 m would quickly cause
inacceptable bowing.

7

Computational effort

For cooldown scenarios of the larger plant segments,
the computational effort was very high: for the most
complex segments of the plant cooldown, CPU-times
of 3-4 days were necessary for each simulation case,
and most of the work is spent during the first few
seconds of simulation time. Dymola's version of the
dassl solver only managed to survive the initial time
without error when the option equidistant output
grid was switched off. This in turn lead to result
files of around 1GB that could not be handled by
Dymola and made postprocessing very tedious.
Overall, for system simulations of the level of complexity encountered during the cool down simulations, We see the following tool requirements for
large scale system simulations with short periods of
very sharp gradients:
1. A fine grained control over how many variables are stored and how often they are
stored that does not influence the step-size
control algorithm. Dymola's Dassl is a bad
example of a solver that takes the storage interval into account in a way that lets simulations fail for a small step size to storage interval ratio.
2. Means to influence step size control during
extreme gradients under short time, or set a
minimum step size and get warnings in the
The Modelica Association

8

Conclusions

Modelica is not primarily known for its strength for
modeling partial differential equations, but due to its
suitability for system level simulations, there are situations in which Modelica and Dymola are an excellent tool even for models that require a full 3-dimensional PDE discretization, under the contraint that
this only works for simple geometries. In particular
the heat conduction equation with its simple structure can be combined with 1-dimensional two phase
flow for thermal stress calculations. The key advantage is that it is possible to capture the most critical
thermal stress situation within a complex plant without the need to resort to co-simulation, or difficult to
assess assumptions.
This simulation study regarding cool down of a cryogenic transfer system was able to achieve a number
of goals, in part because simulation was used already
early in the design process:
1. It was possible to establish design guidelines
regarding dead pipe ends at closed branches
of the network to avoid pipe bowing. The
guidelines were incorporated in later revisions of the design.
2. Flow rates were optimized with respect to
the contradictory goals of minimum cryogen
consumption and avoidance of stratified
flow conditions.
3. Simulation results allowed to devise cool
down sequences that substantially decreased
the thermal stress for all parts in the plant
except the parts closest to the tanker used for
filling.
There are situations in which there is no possibility
to validate simulations against measurements. In
spite of that shortcoming, simulation gives important
insight into system behaviour and even allows to improve both system design and system operation.
Even quantitative analysis is possible to a certain degree when important parameters are well understood
and a careful sensitivity analysis is conducted with
respect to such parameters.
Cryogenic plant simulations, even under the violent
transients that occur during cool down of transfer

699

Modelica 2008, March 3rd  4th , 2008

H. Tummescheit, K. Tuszynski, P. Arnold

lines, can be modeled easily with the cryogenic option of the AirConditioning Library.

References
[1] Span, R., Multiparameter Equations of
State. An Accurate Source of Thermodynamic
Property Data, Springer, Berlin, 2000.
[2] Tummescheit, H.: Design and Implementation of Object-Oriented Model Libraries using
Modelica, Dissertation, TFRT-1063-SE, Department of Automatic Control, Lund Inst. of Technology, Lund, Schweden, 2002.
[3] Tummescheit, H., Eborn, J. und Prl, K.:
AirConditioning  a Modelica Library for Dynamic Simulation of AC Systems, in Proceedings
of the 4th International Modelica Conference,
Hamburg, pp. 185  192, 2005.
[4] VDI-Gesellschaft Verfahrenstechnik und
Chemiewesen (Editor), VDI-Wrmeatlas, 9th Edition, Springer, Berlin, 2002
[5] Versteeg, H. K. and Malalasekera, W., An Introduction to Computational Fluid Dynamics  The
Finite Volume Method, Prentice Hall, 1995.
[6] Lemmon, E., The RefProp User manual, version
7.1, Personal communication See also information
on version 7.0 at http://www.nist.gov/srd/nist23.htm
(accessed 2005-11-15).

[7] Fauple J.H., Fisher F.E., Engineering Design-A Synthesis of Stress Analysis and Material
Engineering, Wiley, New York, 1981.
[8] http://Cryogenics.nist.gov. Accessed October
2005.
[8] Younglove, B.A., Thermophysical Properties
of Fluids. I. Argon, Ethylene, Parahydrogen, Nitrogen, Nitrogen Trifluoride, and Oxygen, J.
Phys. Chem. Ref. Data, Vol. 11, Suppl. 1, pp.
1-11, 1982.
[9] D.H. Liebenberg, J.K. Novak, F.J. Edeskuty: Cooldown of Cryogenic Transfer Systems,
AIAA Paper No. 67-475.

The Modelica Association

700

Modelica 2008, March 3rd  4th , 2008

Enhancement of a Modelica Model of a Desiccant Wheel

Enhancement of a Modelica Model of a Desiccant Wheel
Andreas Joos Gerhard Schmitz Wilson Casas
Hamburg University of Technology
Institute of Thermo-Fluid Dynamics, Applied Thermodynamics
21071 Hamburg, Germany

Abstract
This paper presents a M ODELICA model for a desiccant wheel. Desiccant wheels are used in new concepts for air conditioning systems, which can save primary energy in contrast to conventional systems. This
model is based on a model, which was presented at
the M ODELICA Conference 2005 [2], however in this
study the model is improved with a new modeling approach to represent the wheels rotation. This struc- Figure 1: Example of an air-conditioning using a destural change made the model faster and able to pro- iccant wheel
duce continuous output in contrast to the one of Casas
et al., [1, 2]. This was an essential step to enhance
long term simulations of desiccant systems and control strategies. These simulations are necessary to optimize such systems and to evaluate their primary energy consumption.
Keywords: Modelica; Simulation; Desiccant Wheel;
Air Conditioning; Sorption

1

Introduction

In desiccant air conditioning systems, moist air is dehumidified by means of a desiccant wheel, see figure 1.
Water vapor is absorbed by desiccant material as humid air passes through the wheel. Using this technology, considerable energy savings can be obtained
compared to conventional air conditioning systems. In
[1] a model library has been developed to evaluate the
performance of the desiccant assisted air conditioning process, so that different configurations and system concepts can be easily realized. Because it is necessary to simulate a period of a year to evaluate an
air-conditioning concept, fast, dynamic models with a
good accuracy are required. All these requirements argue for M ODELICA as modeling language. The main
and most complex component of this library is the
 email:

andreas.joos@tu-harburg.de, Tel:+49 40 42878 3079
schmitz@tu-harburg.de, Tel:+49 40 42878 3144
 www.tt.tu-harburg.de
 email:

The Modelica Association

Figure 2: Schema of the old modeling approach [2]
model of the desiccant wheel.
Early approaches for numerical models can be found
in [3, 7, 8]. These model formulations have the disadvantage in that they can not handle desiccant materials with discontinuities in their sorption isotherm (e.g.
lithium chloride, LiCl). In [2] a M ODELICA model is
introduced to overcome those limitations, see figure 2
for an overview.
This model is discretized in such a way, that a system of ordinary differential and algebraic equations is
generated, which can be easily re-configured for different set-ups. Also new relations for further sorption

701

Modelica 2008, March 3rd  4th , 2008

A. Joos, G. Schmitz, W. Casas

isotherms can be provided without much effort. But
due to the modeling approach of the rotation movement of the desiccant wheel through the two airflows, Air flow I
every half revolution time a state event in the numerical solver is caused. Thereby the maximal step size
of the solver is restricted. This approach is also only
valid, if the change of the boundary conditions of the
desiccant wheel is insignificant in half a revolution cycle. Considering the field of application, this is a rather
academic aspect. Although the user should be aware
of this fact. Another disadvantage is that the model
produces discrete output variables from a continuous
process. To overcome these handicaps a new model
approach of the coated wheels movement through the
airflow was developed, implemented and tested. This
approach was developed during the work on [4].

2

Wheel Part I

Air flow II
Wheel Part II
Airflow I connected to
Wheel Part I and
Airflow II connected to
Wheel Part II

t = ti

Computing (t) =

t = ti + 12 T

Figure 3: Function principle of the model from Casas
et al.

 to the time t is introduced, which leads to equation (1b).

1
Air,out =


1. The states are not a function of the wheels radius:
with
 , x 6= f(R) .
2. The variation of boundary conditions
during half

 BC 
a rotation is negligible:  t  T  0.
2

t=

( ,t,BC(t) ) d 

(1a)

0


 T
=
and dt = d 

2

2
Air,out =
T

2

The Modelica Association

Z

leads to

3. The angular velocity of the wheel  is constant

during half a period: t  T  0.

Equation (1a) gives the average outlet temperature of
one airstream. To calculate the integral, the tangential
outlet temperature distribution must be known. This
leads to a tangential discretization of the wheel and
a modeling of the the motion of the discrete pieces
through one airflow into the other. To display this
movement the variable transformation from the angle

 dt
tti

ti

OUT = (ti + 1 T ) ,
2
Airflow I connected to
Wheel Part II and
Airflow II connected to
Wheel Part I

M ODELICA Model of Casas et al.

The model of Casas et al. is described in detail in [2].
This section will only give a short overview of the
model and highlight the structural criteria that were
changed in this work. As shown in figure 2 the implementation in M ODELICA is based on control volumes for air (AirCV) and for the desiccant material
(wall_A/B), which can exchange heat and moisture.
M ODELICA can only handle ordinary differential
equations with respect to time. Therefore the basic
idea of the first approach was a variable transformation to express the position of the rotating wheel with
respect to the airflows in terms of time instead of angular position. Among the assumptions made in [2],
three are elementary in this approach:

Rt

t0Z+ T2

(t,BC(t) ) dt

(1b)

t0

The advantage of this formulation is, that the wheel
has only to be split in two halves; one for each air flow.
At the end of half a rotation period, the boundary conditions of the two pieces are switched; the wheel has
performed half a revolution. Figure 3 illustrate this behavior.

702

Modelica 2008, March 3rd  4th , 2008

Enhancement of a Modelica Model of a Desiccant Wheel

Another more process engineering oriented point of
view is that the continuous process of the turning
wheel is represented by batch processes, which each
last half a revolution period.
Among the application restrictions mentioned, this
model has two other drawbacks. First it produces discrete output variables from continuous input values in
contrast to the physical process. And second, as will
be pointed out in section 4.2 the models computing
time is quite large, because it causes every T2 a state
event.

ential velocity (2a), the conservation of mass (2b) and
the radial passage area (2c). The area is obtained by
dividing the longitudinal half section R  L by the axial
discretization n.

3

and

Structure of the new M ODELICA
Model

Based on the restriction of applicability and the large
computing times mentioned in section 2, a new modeling structure has been developed. The basic idea in
this approach is not to perform the variable transformation, but to use equation (1a). To reach this aim, another way to describe the motion of the wheel through
the air flows had to be introduced.
The construct of the air and desiccant material control volumes is no longer virtually moved through the
air flow by switching the air connectors every half
rotation period. Instead the control volume are locally fixed and a desiccant fluid was introduced, which
flows through the desiccant CVs in cross flow to air
flow direction.
Therefore the existing control volumes for air and the
desiccant material were used to build a wheel model
with a discretization in axial and tangential direction.
This modeling approach is sketched in figure 4(a). The
black lines on the wheel should hint to the discretization. In contrast to figure 3 the air connectors of the Air
CV are attached to the in- and outlet connectors of the
wheel model. Also the desiccant material models are
connected in series to model the rotation by keeping
the desiccant fluid in a continuously circulating flow.
Figure 4(b) illustrates how the air and the desiccant
CVs interact by exchanging heat and moisture for
modeling the (de-)humidifying the air by the sorbens.
These flows are sketched by the double headed arrows
between the two CVs. Air flows along the cylinder
axis while the solid passes its CVs in tangential direction. These two streams are indicated in figure 4(b) by
the arrows near the two CVs.
For these purposes a desiccant fluid flow had to be introduced in the desiccant CV and set in relation to the
revolution speed. This mass flow is computed by equation (2d), which results of the wheels mean circumferThe Modelica Association

vDF =

R

2

(2a)

with
m = A    v

A=

(2b)

LR
n

(2c)

L  R2    DF
2n

(2d)

leads to
mDF,i =

The density DF represents the mass of the carrier material for the sorbent divided by the volume of the
wheel, thus including its porosity. This definition was
chosen, because the phase equilibrium calculation uses
the loading of the carrier material with the sorbens and
the loading of the sorbens with water.
As mentioned before, the new wheel model was constructed by control volumes for air and desiccant material. Casas et al. used for their model Air CVs with an
axial discretization n in flow direction. To include as
much of the existing code as possible m of the air CVs
are put side by side to get a control volume, which is
discretized in two dimensions. Each stream tube in
this construct can not directly interact with its neighbors. Listing 1 gives some code snippets to illustrate
the implementation in M ODELICA.
There are m instances of the model AirCV, which
are n times discretized Air CV. Each AirCV has an
HeatConnector and HumidityConnector in
order to couple it with the Desiccant CV. These connectors are united in the two models Heat1Dto2D
and Humidity1Dto2D. The function of these two
models is to provide a n  m matrix of heat and humidity flows respectively, so that an Air2D model can easily be connected to a two dimensional desiccant material model to form half a desiccant wheel. Figure 5
shows the two Air CVs connected to two Desiccant
CVs, which form a closed loop with a circular flow of
the desiccant fluid.
The Desiccant CV is constructed using an analog
method. Its model name in the library is SMCV_2D.

703

Modelica 2008, March 3rd  4th , 2008

A. Joos, G. Schmitz, W. Casas

.
.
.
);
MeanValues Mean(m=m);
Heat1Dto2D HeatMatrix(n=n,m=m);
Humidity1Dto2D HumidityMatrix(n=n,m=m
);
AirSplit Split(m=m);
equation
for j in 1:m loop
connect(Split.Outlet[j], Air[j]
.Inlet);
connect(Air[j].Outlet, Mittel.Inlet
[j]);
connect(Air[j].HeatConnector,
HeatMatrix.Heat1D[j]);
connect(Air[j].HumidityConnector,
HumidityMatrix.Hum1D[j]);
end for;
.
.
.

Air flow I
Des. flow
Air flow II
(a) Complete Wheel

Air CV
Air flow
Moisture Flow

Heat Flow
Desiccant CV

end Air2D;

Desiccant flow
(b) Detail scheme of one element from the
wheel in fig. 4(a)

Air CV

Figure 4: Scheme of the new modeling approach

Desiccant CV

It has n stream tubes, which are discretized m times.
The mass flow of the virtual fluid is computed in both
SMCV_2D models by equation (2d). The connectors
Desiccant CV
between the Desiccant CV only contain the temperature and the water loading of the desiccant fluid. The
Air CV
reason for this is to avoid initialization problems with
a circular incompressible flow. The disadvantage of
this approach is, that the wheels rotation direction is
fixed. But this restriction is also true for the real desicFigure 5: Dymola representation of the new modeling
cant wheel, which was used for the experimental part.
approach
Another simplification of this model is that the entrainment of air from one air flow to the other is not modeled. So the simulation of fast rotating wheels will lead
to errors. But in their application the wheels circum- 4 Comparison of the two Models
ferential speed is small in comparison to the velocity
of the air flows.
4.1 Results
Listing 1: Excerpt from the Air CV 2D Matrix model
model Air2D
parameter Integer n = 1 "Axial
Discretization";
parameter Integer m = 1 "Tangential
Discretization";
.
.
.
AirCV[m] Air(
each n=n,

The Modelica Association

The model of Casas et al. contains sorption isotherms
in the medium model for LiCl, which where validated
with measured values. The steady state results of the
whole wheel were checked against the manufacturers
data and the transient simulations against the model of
Rau et al. [5]. These isotherms were also implemented
in the desiccant material CV of the new model. To
validate the implementation the test model shown in
figure 6 was used. This model consists of a desiccant
material CV which is connected to an Air CV. The des-

704

Modelica 2008, March 3rd  4th , 2008

Enhancement of a Modelica Model of a Desiccant Wheel

Des. CV

Air CV

1.2

80
This Work

Casas et al.

standardized temperature  / water content X

water content x in kg/kg

temperature  in C

Figure 6: Test model for the comparison with the Figure 8: Test model for comparisons of the whole
isotherm data of Rau et al.
wheel model, here with the model form this work
Rau et al.

60
40
20
0

50

100

150

200
250
time in s

300

350

400

0.02
This Work

Casas et al.

Rau et al.

0.015
0.01
0.005
0
0

50

100

150

200
250
time in s

300

350

1.15
1.1
1.05
1
0.95
0.9
0.85
0

400

water content air flow I
water content air flow II
temperature air flow I
temperature air flow II

5

10
15
20
tangetial Discretization m

25

30

Figure 7: Comparison of a single element of the model Figure 9: Influence of the tangential discretization to
from Casas et al. and the new one
the accuracy
iccant fluid flow is set to zero in this model, so that the
results can be compared to the single blow simulations
done by Rau et al. [5] and Casas et al. [1, 2]. Figure 7
shows the results of the three models. It is obvious
that the sorption isotherms implementation in the new
model is equivalent to the model of Casas et al.. In this
aspect it is adequate, because the mathematical implementation of those isotherms was already adapted to
the use in M ODELICA.
For all results, which are discussed below, models
were used, which contain an instance of a whole desiccant wheel model and sources and sinks for the air
flows. One of those test configurations is presented in
figure 8, in this case with the new model.
The accuracy of the new model depends on the tangential discretization m. The behavior of the desiccant material CV approaches that of the real wheel as
the computational grid is refined, viz. the more disThe Modelica Association

crete control volumes are instantiated in flow direction of the desiccant fluid. Figure 9 shows standardized outlet temperatures  and water contents X of the
two air flow through the desiccant wheel model. They
are plotted against the tangential discretization m. The
reference value is the corresponding simulation result
from a calculation with m = 50. The values were computed from the steady state results from a step response
after 5000 s. It can be seen, that at m = 8 the relative error is smaller 2%. Later the consequences on
the CPU time will be discussed, but it can be seem
from table 1, that depending on the required accuracy
m should be chosen as 5 or 8.
Figure 10 shows a detail view on the step response of
an outlet temperature of three test models, one with
the desiccant wheel form Casas et al. and two with
wheel models from this work with different numbers
of tangential CVs. The complete simulation time was

705

Modelica 2008, March 3rd  4th , 2008

A. Joos, G. Schmitz, W. Casas

49.5

60

Casas et al.
this work m = 5
this work m = 8
this work m = 10

50
CPU time in s



temperature  in C

49

70
Casas et al.
this work m = 8
this work m = 50

48.5

48

40
30
20

47.5

10
47
50

60

70

80

90

100

0
0

time in s

50

100

150

200
250
time in s

300

350

400

Figure 10: Comparison of complete the model from
Figure 11: Impact of tangential discretization m on
Casas et al. and the new one
computing time, compared with the model from [2]
5000 s. The new model produces continuous output
variables in respect to the solver step-size in contrast to
the discrete output of the old one. The model with the
tangential discretization of m = 8 has a slightly larger
deviation from the one with m = 50 than the model of
Casas et al.. But as will be shown in the next section,
it has a remarkable advantage concerning computing
times. And compared with measurement errors, the
accuracy is sufficient.

4.2

Computing Time

The computing times discussed in this section correspond to calculations on one core of an Genuine Intel(R) CPU T2300 @ 1.66 GHz on a laptop with 1 GB
RAM.
Figure 11 shows a comparison in computing time between the previous approach and the new model. The
old model has no tangential discretization, but has
to modify the connect statement between the air
flows an the wheels control volumes every half period.
Whereas the new one needs to be divided in at least
five to eight parts (m in fig. 11) per control volume to
produce good output values. This leads to the behavior
presented in the plot. The old model produces at every
half revolution time an event while switching the sides,
which wastes computing time while reinitialization of
the equation system. This leads to the nearly linear
characteristic consisting of numerous small steps. The
new model contains a multiple ( m times) of equations compared the the old one, so the computing time
for one step is much higher, but due to the model structure time steps larger than half the revolution time are
possible. In highly dynamic regions, like the beginning of the plot in figure 11, the computational effort
The Modelica Association

is high, but due to the large time steps in regions with
small gradients, the overall computing time is lower
for the new model with a tangential discretization of
m = 5,8 and 10 for simulation times larger than 300
seconds in this example.
This behavior is expected to lead to a large decrease in
computing time, especially at long time simulations of
air-conditioning systems.
Table 1 gives an overview of the equations, which are
created by the different test models, so the number of
equations is a little larger than in the stand alone wheel
model. The table also shows the computational time of
the test model for a simulation time of 5000 s. Due to
the above mentioned effect of the state events during
the simulations of Casas et al.s model, the new model
with m = 5 is nearly 20 times faster even though it
consists of about 10 times the number of equations. In
this case with the old wheels test model 4166 state
events occurred during simulation time.

5 Summary and Outlook
Because of the enhancement of the desiccant wheel
model from Casas et al. a M ODELICA model could
be created, which combines good accuracy with acceptable computing times. It was successfully used in
further work of Applied Thermodynamics, like [4, 6],
as the heart of a library for desiccant systems. Several simulation of complete climate periods were performed as well as studies concerning different control strategies of those systems. For the analysis of
control strategies the models were exported to Matlab/Simulink to find and optimize control parameters.

706

Modelica 2008, March 3rd  4th , 2008

Enhancement of a Modelica Model of a Desiccant Wheel

References

Table 1: Number of equations and CPU time of the
test model against the tangential discretization m
[1] Casas, Wilson: Untersuchung und Optimierung
m No. of equations CPU timea in s
sorptionsgesttzter Klimatisierungsprozesse. PhD
thesis, TU Hamburg-Harburg, 2005.
1
1681
1
2
3043
4
[2] Casas, Wilson, Katrin Proelss, and Gerhard
5
7129
20
Schmitz: Modeling of desiccant assisted air con8
11215
48
ditioning systems. In Proceedings of the 4th Inter10
13939
78
national Modelica Conference, volume 2, pages
15
20749
186
487496. Modelica Association, 2005.
20
27559
289
30
41179
810
[3] Casas, Wilson and Gerhard Schmitz: Nume50
68419
2154
rische Untersuchungen an einer sorptionsgesttzen Klimaanlage. In VDI Fortschrittliche
Casas et al.
1184
827
Energiewandlung- und Anwendung, volume 1594
a For a simulation time of 5000 s in Dymola using Dassl
of VDI-Berichte, 2001.
Especially for this part it was very helpful, that the new
model no longer produces discrete output. It was also
possible to adapt the model parameters in such a way
that data from existing air conditioning systems could
be recomputed.

Nomenclature
Latin Symbols
A
L
m
m
n
R
t
T
v
x
X

Area
Length
Tangential discretization
Mass flow
Axial discretization
Radius
Time
Period
Velocity
Water content
Standardized water content

Greek Symbols







Temperature
Standardized temperature
Density
Angle
Angular Velocity

[4] Joos, Andreas: Untersuchung und Optimierung eines solargesttzten Heiz- und Klimatisierungssystems fr ein Einfamilienhaus. Masters thesis, TU
Hamburg-Harburg, Institut fr Thermofluiddynamik, 2006.
[5] Rau, J. J., S. A. Klein, and J. W. Mitchell: Characteristics of lithium chloride in rotary heat and
mass exchangers. Int. Journal of Heat and Mass
Transfer, 34(11):27032713, 1991.
[6] Schmitz, Gerhard, Wilson Casas, and Andreas
Joos: Entwicklung eines thermisch betriebenen
Klimatisierungssystems fr Ein- und Zweifamilienhuser, December 2006. Institute of ThermoFluid Dynamics, Hamburg University of Technology.
[7] Simonson, C.J. and Robert W. Besant: Heat and
Moisture Transfer in Desiccant Coated Rotary
Energy Exchangers: Part I. Numerical Model.
HVAC&R Research, 3(4):325340, 1997.
[8] Zheng, W. and W.M. Worek: Numerical simulation of combined heat and mass transfer processes
in a rotary dehumifier. Numerical Heat Transfer,
23:211232, 1993.

Abbreviations and Subscripts
BC
CV
DF
i

Boundary condition
Control Volume
Index for desiccant fluid
Index for i-th element

The Modelica Association

707

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

708

Modelica 2008, March 3rd  4th , 2008

Real-Time HWIL Simulation of Liquid Food Process Lines

Real-Time HWIL Simulation of Liquid Food Process Lines
Magnus Gfverta
Tomas Skoglundb
Hubertus Tummescheita
Johan Windahla
c
Hans Wikander
Philip Reuterswrda
a

Modelon AB
Ideon Science Park, SE-223 70 Lund, Sweden
magnus.gafvert@modelon.se
b

Tetra Pak Processing Systems
Ruben Rausings gata, SE-221 86 Lund, Sweden
tomas.skoglund@tetrapak.com
c

Avensia Innovation AB
Gasverksgatan 1, SE-222 29 Lund, Sweden

Abstract
This paper describes a newly developed Modelica
and Dymola based solution for hardware-in-the-loop
(HWIL) simulation in the food processing industry.
The solution has been evaluated for potential larger
scale deployment into the operational processes of
Tetra Pak Processing Systems. The solution consists
of a real-time enabled model library for liquid food
processing, which is compiled into a process
simulator using Dymola, and custom developed
software for communication between the process
simulator and a production PLC control system using
industry standard OPC protocols.

addressed particular characteristics of liquid food
process lines. For example dynamic propagation of
fluid properties was considered due to the need of
simulating start-up and shut-down with fluid
changes, which are occurring frequently in the
addressed applications.
Within the operations of Tetra Pak Processing
Systems, the FoodProcessing library was used to
simulate many processes with their control system as
a tool for development or improvement. Simulation
was also used as a means for trouble shooting.

Keywords: physical modeling and simulation;
hardware-in-the-loop; liquid food processing;
process simulation; real-time simulation

1

Introduction

Dynamic simulation of liquid food process lines, e.g.
pasteurization lines in dairies, see Figure 1, has
already been practiced in a systematic way by means
of the FoodProcessing library (FP), see Figure 2.
This Modelica [1] and Dymola [2] based dynamic
model library developed for in-house use has
previously been reported in [3] (Skoglund, 2003), [4]
(Skoglund and Dejmek, 2006) and [5] (Skoglund,
2007). Besides the fundamental laws of
conservation, e.g. mass and energy, the model library

The Modelica Association

Figure 1. A
pasteurization.

typical

dairy

process-line

for

In the regular delivery process of Tetra Paks order
handling, food processing units are functionally
tested by running them with water before they are
shipped to the customers. This is carried out to
secure high quality of the equipment. The test cannot

709

Modelica 2008, March 3rd  4th , 2008

M. Gafvert, T. Skoglund, H. Tummescheit, J. Windahl, H. Wikander, P. Reutersward

be carried out before the machine is manufactured,
which leads to the need of extra time before delivery.
The test itself also requires costly test places with
water, steam, electricity, compressed air and drain
available. Also, water has different properties
compared to the liquid food that will eventually be
processed by the unit which means that the test result
may deviate from real plant performance.
To enable shorter delivery time at a lower cost,
alternatives to this functional test were investigated.
One of the alternatives is to run real-time hardwarein-the-loop (HWIL) simulation where the real PLC
(Programmable Logic Controller) control system is
connected and run with the process model. Since the
process model enables simulation with not just
water, but real fluid models the HWIL simulation
may also, in some cases, be more realistic.
Furthermore, often the normal water test does not
include special equipment (centrifugal separators or
equipment upstream/downstream) due to practical
problems. For simulation, this limitation does
seldom exist. In simulation it is also possible to
monitor virtually any dynamic variable in the system
without the need for sensors, which may be of great
help to quickly understand and resolve issues.
Furthermore HWIL simulation enables other possibilities, e.g. as a test, validation, and verification tool
in PLC software development, and operator training
[6] (De Prada et al., 2003) and [7] (Bckman and
Edwall, 2005).
This article describes:
 How the model library was adapted for realtime simulation
 How a communication program was
developed as a link between the PLC and the
simulator.
The work was carried out as a project with Tetra Pak
Processing Systems and Modelon.

2

The FoodProcessing library

Since the start of the development of the
FoodProcessing (FP) library [3] (Skoglund, 2003)
much more work was spent to address characteristics
of liquid food process lines. Thus Skoglund et al.
(2006) [8] described a way to handle fluid transitions
in heat exchangers that leads to thermal transients. A
model for axial-dispersed plug flow (ADPF) was
also described [9] (Skoglund and Dejmek, 2007) and
extended to model first-order reaction kinetics [10]
(Skoglund and Dejmek, 2007). Figure 2 shows the
FoodProcessing library in the Modelica tool Dymola.

The Modelica Association

The library has since been used to configure many
process lines and to investigate various performance
issues, e.g. product losses. Thus the development of
a mixing zone was simulated for product filling and
emptying in a commercial UHT line for milk
sterilization [11] (Skoglund & Dejmek, 2007). The
result was compared with measured data.

Figure 2. The FoodProcessing library
The library was also used for trouble shooting and
testing new design ideas, both concerning process
design and control algorithm.

3

Real-Time Aspects

The original FoodProcessing library was designed
for high-fidelity desktop simulation with variablestep high-order solvers and many models were not
suited for real-time simulation. It was decided to
translate and adapt the library into a real-time FoodProcessing library (FPRT). The models in FPRT are
made to simulate robustly with fixed-step solvers
with a computational load that avoids computation
over-runs when executed in real time on standard
PC:s.
One major difficulty is the nonlinear equation systems that appear from the pressure dynamics for pipe
networks with incompressible fluids. A related difficulty is the effective structural change that valve
closing and opening implies on the equation systems.
The overall system contains stiff modes and requires
implicit methods for numerically stable integration.
The inline integration feature of Dymola is used to

710

Modelica 2008, March 3rd  4th , 2008

Real-Time HWIL Simulation of Liquid Food Process Lines

take advantage of the symbolic reduction and transformation. To reduce the sizes of the resulting equation systems an explicit integration routine was introduced by inlining Modelica code in some components in the library. (The mixed implicit/explicit inline
integration in Dymola does not handle the present
type of models.)
Several numerical tweaks were introduced to increase robustness [12]. Several models have also
been simplified and discretization grids have been
made smaller. The number of dynamic states has
been reduced.

4

HWIL Setup

HWIL simulation is often performed on dedicated
computers with real-time operating systems and extensive I/O possibilities. In the present application
the solution should be able to run on a standard PC
with Microsoft Windows operating system with Ethernet or automation-bus communication with the
PLC hardware. This means that hard real-time cannot be ensured. The sampling rate of feedback control-loops in the food processing applications are in
the range of 100 ms or longer, and sufficient performance can be met with soft real-time.

and a software to route signals between the PLC and
the simulator. See Figure 3.

4.1

PLC System

PLC systems are digital computers for automation
with extensive support for I/O arrangements and bus
communication. The PLC computers host control
programs for sequence control and sampled data
feedback control typically expressed with IEC
61131-3 languages such as ladder diagrams or function block diagrams.
Tetra Pak work with several suppliers of PLC systems, such as Rockwell Automation, see Figure 4,
and Siemens, and the HWIL solution must support
them all. Most major systems support the DDE (Dynamic Data Exchange) and OPC (OLE for process
control) technologies for interoperability [13,14].

SimLink

OPC

DDE

clients

DDE

SAPI

Rcv Snd

Rcv Snd



Rcv Snd

Rcv Snd

Figure 4. Allen Bradley PLC Controller from Rockwell Automation.

alt.
OPC

DDE

PLC OPC/DDE Server

DDE

SAPI

dymosim
Executable

dsmodel
DLL

alt.

PLC
H/W

compilation

PLC
S/W

Dymola

Figure 3. Overview of HWIL setup with SimLink
signal routing application, PLC communication
server, PLC hardware or emulated controller, and
dymosim executable or dsmodel DLL process
simulator.
The HWIL setup consists of a PLC system with control algorithms and programs, the process simulator,

The Modelica Association

DDE is an old technology for communication
between multiple applications under Microsoft Windows. OPC is a standard protocol for open connectivity in industrial automation. DDE suffers from
scalability and performance issues, and is more or
less being superseded by newer technology. Therefore, the communication between the simulator and
the PLC was decided to build mainly on OPC with
DDE as fallback.
OPC is originally designed for communication with
HMI (Human-Machine Interface) units, operator
panels, and enterprise systems with moderate to low
requirements on data bandwidth. The standard has
then evolved to cover a wider class of communication tasks in industrial automation. OPC supports
synchronous and asynchronous communication and
is highly flexible and scalable. OPC is not primarily
intended for feedback control or communication with
high-bandwidth hard real-time requirements. With a
soft real-time performance of about 400 items at a
rate of about 20-30 ms, or 2000 items at about 100

711

Modelica 2008, March 3rd  4th , 2008

M. Gafvert, T. Skoglund, H. Tummescheit, J. Windahl, H. Wikander, P. Reutersward

ms it is still deemed sufficient for the present HWIL
application.
In HWIL simulation the I/O signals in the PLC are
re-routed from the physical I/O card to memory addresses associated with OPC items. This means that
the PLC programs must be extended with a simulation mode to support simulated I/O.
Some vendors, such as Rockwell Automation, also
offer emulators for their PLC computers. This makes
it possible to also work with SWIL (software-in-theloop) with the same setup.
4.2

Process Simulator

Dymola supports, via the dymosim executable,
stand-alone real-time simulation with DDE communication. All variables in the model are then available as DDE items for subscription. The performance and scalability issues with DDE mean that alternative solutions have also been investigated.
One attractive solution is to use a model DLL (Dynamically Linked Library) similar to that used in the
DymolaBlock that enables Dymola models to be
used in MATLAB/Simulink. This means that an external integration routine is used and the model derivatives and outputs are returned by direct function
calls. An SAPI (Simulation Application Programming Interface) for calling the simulation model as a
function was therefore developed together with build
scripts to produce the model DLL. For real-time simulation the integration routine is a fixed-step explicit
Euler with event management. The direct function
calls means that virtually all communication overhead is eliminated.
4.3

SimLink is a Windows application and builds on the
Microsoft .NET Framework and is based on OPC
Core Components and OPC .NET API 2.0. SimLink
is configured by specifying a set of clients, defining
their signals, and then connect the signals by introducing links, see Figures 5 and 6. The configuration of
clients, signals and links can be saved to a configuration file, that later can be loaded into the application.
This makes it easy to maintain different configuration setups. The configuration file contains all information of the setup, and is stored in a human
readable XML format.

Figure 5. The Links view displays details on signal
links and offers a convenient user interface for connecting clients.

Signal Routing with SimLink

The number of signals in a HWIL setup may be in
the range of a few ten for small process modules, to
several hundred for large processes. The signals represent all sensor and actuator values that logically
connects the process with the PLC, but may also include values from virtual sensors that are not
available on the real process. The signals may also
represent alarms and warnings from the model components, for example to alert the user of operating
points outside the range of validity.
A core component in the HWIL setup is the organization and synchronization of the signal routing. The
SimLink software described in the following was developed for this purpose.
SimLink can be viewed as a coupling panel where
input and output signals from different clients are
connected or linked via a graphical user interface.
The Modelica Association

Figure 6. The Clients view gives an overview of configured clients and signals. Signals can be monitored
and manipulated in run mode.
When the setup is finished, the next step is to connect to the clients. The application then makes sure
that it has valid connections to all clients and that

712

Modelica 2008, March 3rd  4th , 2008

Real-Time HWIL Simulation of Liquid Food Process Lines

they are ready to send and receive signals. After connecting, the application is ready to go into run mode,
and this is done by clicking the play-button. In run
mode, SimLink is listening to all signals sent to the
clients from external applications and internally
routes them through the links to clients connected to
the receiving applications. Run mode is ended by
clicking the stop-button.
SimLink currently supports the client types listed in
Table 1. Figures 7  9 shows the properties dialogs
for the DDE, OPC, and SAPI client types.
Table 1. SimLink client types.
Client type Description
DDE
OPC
SAPI DLL

Internal
Trigger

Connects to programs that support
Windows DDE.
Connects to programs with an OPC
server
The simulation model resides in a
DLL that is loaded into the client.
The client contains the simulation algorithms and communicates with the
model through a direct function API
(SAPI).
Signal sink for testing purposes.
Signal source that generates output
signals at a specific rate.

Figure 8. Properties for OPC
client.

Figure 9. Properties for SAPI
client.
The SimLink OPC client is to date verified to support PLC systems from Rockwell Automation and
Siemens.

5

Figure 7. Properties for DDE client.

Process Examples

The process line that was chosen for the evaluation
of the real-time HWIL simulation was a custom
designed commercial processing module for dairy
pasteurization1, see also Figure 1. Figure 10 shows
the top-level model diagram (flow chart) as
configured by using the library FPRT.
The process consists of a balance tank, a plate heat
exchanger for pre-heating and pasteurization, a deaerator, a homogenizer, holding cell, steam-powered
hot-water unit, and pumps, valves, and sensors being
monitored and controlled by the PLC system. The
process supports a number of operating modes, e.g.,
start-up, production, cleaning, and hibernation,
which have different flow configurations.
1

Tetra Therm Lacta, designed and manufactured by Tetra
Pak Processing Systems.

The Modelica Association

713

Modelica 2008, March 3rd  4th , 2008

M. Gafvert, T. Skoglund, H. Tummescheit, J. Windahl, H. Wikander, P. Reutersward

sw itch1

V152_PC
k=6...
Scalin...
8e5
0
V104
AO_PC1...6...3...
NC=...
valve_...
L=...
V114
f...
Tp... D=D
Pi...
V114
V1...
V1
4
0

Act 10=...

V1
0
2

ip =D
P
.
D
f.. .
L=0.

V99 NC=tr...
L=15 m
fal...
D=D
V99
Pipe12

V120A

PD =D
e
ip
.
fa . m
L=3
BTD
cm
LE65

a
P
k
P 8
T
6
Homo...

L=8.1...
fal...
D=D
Pipe5

in
a
g

TE71_...
TT71 PT83_...
C
L=0.6...
fa...
D=D
Pipe3

k=1..

Tpi...

LKH-...
M2

L=4.57...
false
D=D
Pipe17
TT... TE43_MV
C
L=6.57...
false
D=D
Pipe4
TI06
C
AlroxOption
L=2....
f...
W
D=D FLOW_...
Pip...

T 5
F
m..

p .
T

NC...
SC2
AO_M2_...
M2_M9_...Hz W V112_... V...

P 8
T
3
a
P
k

PT87_MV

V103 LE65_MV
d=0..

C =
N
.
L=0..
f..
V1
3
0
D
ip =D
P
.
Bus_I...

I_II_III_IV_V

L=1 m
fa .
D
P=0...
e
P 8
T
7 ip
a
P
k

AO_LIC65
val... L=0...
f...
D=D
V2... Pip...

DO

TT...
TE64_MV
L=... C
D...
Pi...

Top...
0.2 ...

P 2
O

L=3..
f..
D =D
p .
ip
P
. T

V102

PT86_MV

e
ip
P
D =D8
f..
L=6..

P 1
O

Drain1

V1
2
0

L=1.7...
fa...
D=D
Pipe1

d=0..

L=0.
f.. .
D =D
ip
P
.

V115

Supply

L=4.6..
fa .
eD =D
ip
P
2

V1
5
1

i .
p
T

AO

V122

ip
P
.
D =D
f.. .
L=6.
ip =D
P
.
D
f.. .
L=0.

L=0..
Df..=D
P
ip
.

V120B

L=1
4 m
n.. n=1
D =0.0..
C 1
H
5 s

L=10 m
fa...
D=D
Pipe...

Tpi... L=9.7... L=213 m
fal... n=1 n...
Pipe19
D=D
D=D
Pipe20
D=0.0...
fal...
SPHC285s L=9.5...
V122

L=1.7
0 .
e
ls
fa
eD =D
ip
P
8
1

AO_TIC52
const

C =t..
N

bus

V1..
S..
lv .
a

RT

RT

FT05_MV

I
A

I
D

Figure 12. PLC operator panel showing the performance of a PID controller regulating a simulated process.

Figure 10. Flow diagram of the process line used to
evaluate real-time HWIL simulation. The model is A HWIL simulation setup was prepared for the
built in a hierarchy. The figure shows the top level process module described in Section 5 with its
view.
production PLC system from Rockwell Automation
(hardware and software). A number of evaluations
Figures 11 and 12 show the PLC operator panel that were arranged where the HWIL testing procedure
is used to control and monitor the process.
was compared with the traditional water testing
described in Section 1. The tests were built on cases
from water testing of actual units delivered to
customers and now in production. The models and
PLC programs were rigged with a set of faults from a
database and testing personnel then performed an
HWIL testing to see if these faults would be
identified. The protocols from this HWIL testing
reported all or most problems also found in water
testing, and then some additional that was not found
in water testing. The results so far indicate that
HWIL simulation may indeed replace water testing
and also result in better test coverage.
One comment from the de-briefing of the test
personnel was that the simulated process was lacking
the noises, sounds, vibrations, and other sensory
Figure 11. An overview picture of the PLC operator information that is used by humans to monitor the
panel.
process and detect deviations. Still, the overall
impression was that the simulator had advantages
over water testing. The SimLink software was
extended with alarm/alert functionality to support
6 Results
emulated sensory information from the simulation
model. A component can, for example, trigger a
The described HWIL solution is being evaluated
boolean signal to indicate that the fluid media is
both from a business perspective and a technical
boiling. On the real process this might have been
perspective. Technically, the presented solution
detected by noise. In SimLink this triggers an alarm
seems to fulfil all given requirements. There have
that alerts the user of the abnormal situation.
been a number of minor issues that have been
resolved, but the core solution design and The HWIL setup was also in parallel used for testing,
architecture has shown to be sound, scalable, and validation, and verification in development of new
PLC control software. The HWIL setup has proven
extensible.

The Modelica Association

714

Modelica 2008, March 3rd  4th , 2008

Real-Time HWIL Simulation of Liquid Food Process Lines

to be very useful to find and identify issues and bugs
at an early stage.
There have been some problems with robustness of
the simulation at complex mode switches. Possibly,
this will lead to some re-design of the fundamental
models of the fluid dynamics. For example, the
current models are designed for uni-directional flow,
even though back-flow may occur in transients and
mode switches.

7

Conclusions

Experiences from the presented solution indicate that
the Modelica based HWIL technology may contribute significantly and in a wide range of operations in
a business organization like Tetra Pak Processing
Systems. Parts of a larger evaluation effort have been
performed and indicate that expensive and time-consuming water testing may be replaced by simulation.
Application of the HWIL solution for software debugging has also been done successfully.
Large parts of the FP library have been adapted for
real-time simulation with the evaluated process module. Remaining parts will be adapted as HWIL simulation is introduced for other process modules.
The SimLink program was designed and developed
for general HWIL simulation with PLC systems in
the process industry. It has been continuously improved during the work described in this paper and
has now become a stable and feature complete core
component in the HWIL simulation environment.

References
[1] Modelica Association,
http://www.modelica.org
[2] Dynasim AB, http://www.dynasim.se
[3] Skoglund, T. Simulation of Liquid Food
Processes in Modelica. Proceedings of the 3rd
International Modelica Conference 2003, 5158. Linkping, Sweden, November 3-4, 2003,
Organized by the Modelica Association and
Linkping University, Sweden. Available at
http://www.modelica.org.
[4] Skoglund, T. and Dejmek P. A model library
for dynamic simulation of liquid food process
lines. Proceedings of FOODSIM 2006, 5-12,
Naples, Italy, June 15-17, 2006, Organized by
EUROSIS.
[5] Skoglund, T. Dynamic Modelling and
Simulation of Liquid Food Process Lines.
The Modelica Association

715

Lund, Sweden: Doctoral thesis, Department of
Food Technology, Engineering and Nutrition,
Faculty of Engineering, LTH, Lund
University, 2007.
[6] De Prada, C., Merino, A., Pelayo, F., Acebes,
F., Alves, R. A simulator of Sugar Factories
for Operator Training, AfoT 2003, II
International Workshop on Information
Technologies and Computing Techniques for
the Agro-Food Sector, Barcelona, Spain,
November 27-28, 2003, Monograph CIMNE
No-86.
[7] Bckman, J., Edvall, M. Using Modelica and
Control Systems for Real-time Simulations in
the Pulp. Proceedings of the 4th International
Modelica Conference, March 7-8, 2005, pp.
579-583, Hamburg University of Technology
(TUHH), Germany. Organized by the
Modelica Association and TUHH. Available
at www.modelica.org
[8] Skoglund, T., rzn, K-E. and Dejmek, P.
Dynamic object-oriented heat-exchanger
models for simulation of fluid property
transitions. International Journal of Heat and
Mass Transfer, 2006, 49, pp. 2291-2303.
[9] Skoglund, T. and Dejmek, P. A dynamic
object-oriented model for efficient simulation
of fluid dispersion in turbulent flow with
varying
fluid
properties.
Chemical
Engineering Science, 2007, 62, pp. 2168-2178
[10] Skoglund, T. and Dejmek, P. A dynamic
object-oriented model for efficient simulation
of microbial reduction in dispersed turbulent
flow. Journal of Food Engineering, 2008, 86,
pp. 358369.
[11] Skoglund, T. and Dejmek, P. Fuzzy
traceability  A process simulation derived
extension of the traceability concept in
continuous food processing. Trans IChemE
Part C, Food and Bio products Processing,
2007, 85 (C4) pp. 354-359.
[12] Tummescheit, H. Design and Implementation
of Object-Oriented Model Libraries using
Modelica, Doctoral thesis, Lund University,
2002.
[13] Iwanitz, F., Lange, J., OPC Fundamentals,
Implementation, and Application, 3rd Ed.,
Hthig Verlag Heidelberg, 2006.
[14] The OPC Foundation.
http://www.opcfoundation.org

Modelica 2008, March 3rd  4th , 2008

The Modelica Association

716

Modelica 2008, March 3rd  4th , 2008

Session 6d
Mechanical Systems & Applications

The Modelica Association

717

Modelica 2008, March 3-4, 2008

The Modelica Association

718

Modelica 2008, March 3rd  4th , 2008

Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation

Automatic Model Conversion to Modelica
for Dymola-based Mechatronic Simulation
Tams Juhsz, M. Sc. and Ulrich Schmucker, Dr. Sc. techn.
Fraunhofer Institute for Factory Operation and Automation, Magdeburg, Germany
Tamas.Juhasz@iff.fraunhofer.de and Ulrich.Schmucker@iff.fraunhofer.de

Virtual product development allows us to recognize
and evaluate the characteristics of a new product on
the basis of simulation at an early stage without having to build a physical model. Currently the most,
widely spread commercial CAE systems do not offer
direct support to external dynamic simulation applications. Conversely, dynamic simulation of a detailed model is required to maintain good correlation
between the behaviour of the real product and its
virtual counterpart. In this paper it will be presented,
that using a partially automated workflow a convenient Modelica model translation can be achieved
from the output of a mechanical CAD system, allowing the final model to be extended independently
with new elements from other simulation domains,
considering Dymola-based multi-domain simulation.
A .NET-based integrated tool for mechatronic model
editing and online / offline visualization support using advanced 3D (and stereo) techniques will also be
emphasized in this article.

some internal model parameters must be fine-tuned,
according to model assessment or verification processes. This implies that an automated model conversion is highly demanded in order to accomplish a
good workflow. The designing engineer can inspect
the behaviour of the given virtual product by utilizing a dynamic simulation of that. For a convenient
iterative workflow a solution have to be provided to
automate the conversion between the standard output
format of the source CAD system and the input format of the target simulator.
In this article it will be presented that using RobotMax, our .NET-based mechatronic model authoring
and visualization application mechanical CAD data
from the widely-spread Pro/Engineer CAD environment can be imported, new mechatronic components
can be added, thus multi-domain Modelica models
can be generated and the results of the Dymola-based
multi-domain simulation can be visualized in a convenient way, even in 3D stereo using various 3D
technologies, for example by exploiting autostereo
monitors, polarizer- or liquid crystal shutter glasses.

Keywords: Pro/Engineer, Mechatronics, Collision,
Modelica, Dymola Simulation, Stereo, 3D Visualization

2 Translation from CAD data to
Modelica models

Abstract

1

Introduction

Virtual engineering offers a completely new aspect
of product development, as thereby all sections of
the product life cycle can be independently analyzed
and in parallel continuously optimized in the virtual
world. Simulation makes the practical verification of
the desired behaviour possible in early development
stages.
It is very cumbersome to manually create a parametric simulation model representing a complex product
that has been designed in a CAD system. Additionally it is often the case that in machine production a
family of component parts with varying parameters
has to be designed repeatedly. Nevertheless the
product planning is usually an iterative practice:
The Modelica Association

We have interposed an own developed tool into the
design workflow to achieve automated conversion to
Modelica models from a Pro/E CAD model assembly (e.g. for mechanics: geometry, mass / inertia parameters, joints).
Similar work has been done in [1], but using the
AutoCAD Mechanical Desktop system, and a different, shallower structure of Modelica models. Our
approach allows a 3rd party to extend the mechanical
model with additional elements from other engineering domains in such a way that a designer can still
change / fine tune parameters in the CAD environment (and re-export the mechanical model), without
sacrificing the extra work that another expert might
have already done within the other model domains,
where there might be connections to the previous
mechanical model.

719

Modelica 2008, March 3rd  4th , 2008

T. Juhasz, U. Schmucker

2.1 Basic steps of the translation process

2.2 Building a draft hierarchy out of XML information

There is a large amount of commercial and noncommercial applications (e.g.: 3D_Evolution or
TransMagic) available on the market offering native conversion between common standard (STEP,
IGES) and other well-known (AutoCAD, CATIA,
Inventor, Pro/Engineer, SolidWorks, Unigraphics,
etc.) CAD data formats. Thus without subsequent
restrictions it is assumed our source data is available
in the format that our CAD system (Pro/Engineer) is
able to import.
The translation from a CAD source file to Modelica
description needs the following basic steps:
- Assuming the CAD model has already been imported into Pro/Engineer, you can export the hierarchy and geometry information of the actual
model to VRML files simply through a click over
the File menu Save as command. Note that in a
general case you get a main hierarchy file and the
geometries of the subsequent parts in separate
.WRL files. Geometry information is essential if
you want to model collision between the parts during the simulation (see section 3.1 for further information).
- SimMechanics is a single-domain extension of the
Simulink environment developed by MathWorks,
and can be used for modelling and simulation of
mechanical systems. Under Pro/Engineer environment the freely available Pro/E-to-SimMechanics
plug-in [2] lets you export the given CAD assembly
to a single (so called Physical Modeling XML)
descriptor file, which is invented to ease the generation of SimMechanics models out of Pro/E data
in an automated way. The result XML file contains
global hierarchy-, constraint- and physical parameter information (inertia-tensors, masses, etc.), but
no geometries at all.
- We developed an application (it is called RobotMax) the core logic of which processes the aforementioned XML descriptor file matching with
VRML hierarchy/geometry files, thus generating an
internal multibody model out of the CAD information. In RobotMax the internal (original) model can
be extended interactively with various electromechanical elements (e.g.: with parametrical motors
from a model library: see section 4.1) to form a
more complex mechatronic (multi-domain) model.
Finally, our tool is able to export its final mechatronic model to Modelica models using the built-in
conversion module, and on demand by the same
time it propagates the geometry to DXF format
mesh files, in order to use those as visualizing
shapes in Dymola environment.

The Modelica Association

A single Physical Modelling XML file enumerates
all parts (= XML bodies) in the original root CAD
assembly (= XML subsystem) from which it was
created. The special RootGround part represents a
fixed point in the environment. Each normal XML
rigid body entry contains information about the
physical parameters (mass, inertia, surface area, volume, etc.) of the given Pro/E part and has at least
two coordinate frames in World space: the one that
defines the location of the centre of gravity (CG) of
the rigid body, the other that shows the origin transformation of the bodys geometry (CS1). XML bodies can carry any number of additional frames (CS2,
CS3 ), which all have a unique integer ID: these
unique numbers are used by us to find the corresponding parts between joints.
As it was mentioned before, the XML file also contains information about joints, which represent the
constraints of the original CAD assembly. Each
XML joint (Ji) has two integer IDs that are uniquely
referencing two different frames (these are named
Base and Follower in a SimMechanics model).
The special weld joints are used to mount two rigid
parts together with no degrees of freedom left between those. There can also be a series of primitive
joints between two frames, representing various degrees of rotational / translational freedom between
those parts. In the hierarchy this always implies the
following sequence: Follower  J1   
JN  Base, where a  b shows that a is the
child of b in the hierarchy (i.e. it inherits all transformation from that). Using the XML Joints frame
references you could build a skeleton (a draft hierarchy) of XML bodies. Unfortunately this does not
imply automatically that the final hierarchical model
is also ready: the geometries of the possibly colliding
(but point-sized so far) bodies are still missing at this
point.
In CAD systems it is quite often the case that more
parts in an assembly share the same name (you can
imagine a template part that has been used many
times as a building element). On the contrary, in case
of the target language Modelica, the variable names
must be unique inside each model. Via translating
the mechanical CAD information, a single, pure mechanic Modelica model has to be generated first.
This initial model contains only the parametrical
bodies and the mechanical joints, which are connected by connect Modelica clauses. All exported
bodies and joints must have an individual, unique
instance name.

720

Modelica 2008, March 3rd  4th , 2008

Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation

As the auto-generation of VRML and XML files are
independently done, the partially auto-generated
names inside the result files (e.g.: Obj01, Obj02
vs. Obj, Obj-1) will neither be globally unique
nor match each other. In order to find the corresponding entities both in VRML and in XML domains, you have to follow a sophisticated procedure.
This is in the most cases inevitable, because there are
usually less XML bodies than actual VRML geometries. You must know which geometries form together a single rigid body, if you want to have a consistent collision handling during the simulation.
2.3 Matching hierarchies in XML and VRML
domains
All VRML geometry nodes have a homogenous
transformation matrix (which can arise derived from
their respective parents, recursively), from which
you can derive their global pose (position and orientation) in the 3D world. This derived 4x4 matrix is
also used to transform the local vertices of a given
VRML shape into the global (World) coordinate system during rendering, for example. Fortunately the
same pose information is also included in XML file
with CS1 frame of the XML bodies.
First you have to search for matching the position of
all CS1 frames (extracted from XML) with an origin
frame location from VRML geometries being just
imported. If there are more bodies having the same
CS1 frame position, you continue filtering the candidates by differences in CS1 frame orientation.
Assuming there are still more than one parts with the
same global pose in CS1 (which is blissfully a rare
case), you can compare the names of the XML bodies and VRML shapes (namely just their prefixes:
e.g.: Obj01 will match with Obj or Obj-1) to
find the highly demanded single positive match. It is
hardly imaginable that there are more parts in the
CAD assembly with exactly the same pose and
name. This should indicate that there is an error in
the source CAD plan.
It is often the case, that there are subsequent levels in
the VRML geometry hierarchy: in this case these
child shapes are to be merged into the same higher
level geometry.
After assigning the VRML geometry to the corresponding XML bodies, the final, pure mechanic multibody model can be finally generated. For this sake,
the necessary physical parameters (masses, locations
of CG frames, inertia tensors) have to be substituted
into the final Modelica actors parameters.

The Modelica Association

3 Expanding the standard Modelica
library
The Modelica Standard Library is a standardized and
free package that is developed together with the
Modelica language by the international Modelica
Association [8]. The Mechanics Multibody Library
(MML) is a package in the main library providing 3dimensional mechanical components to model mechanical systems in a convenient way.
The MML does not include support for rigid body
collision handling. Handling contacts between mechanical objects can be very important in many disciplines of mechatronic simulation (e.g.: robot manipulating tasks).
3.1 Collision Handling
We extended the MML library with support for collision handling using a spring and damper material
model, suggested by the article [3], but based on
more robust Bullet collision library in our recent implementation. We discussed the details of our implementation in [4]. In this section it will be presented what sort of new Modelica components have
been developed for this purpose.
The basic World model in MML represents a global
coordinate system fixed in 3D space origin. The behaviour of the basic World model has been extended
via inheritance: from the original base model a Collision Manager (CM) subclass has been inherited that
is responsible for collision handling in simulation of
multibody systems.
The standard Modelica implementation of rigid bodies (see BodyShape component in MML) needed also
to be extended to handle collision (via communication with the CM). Our Actor class encapsulates the
physical kinematic- (pose, velocity and acceleration),
dynamic- (mass, location of centre of gravity and
inertia tensor) and material- (stiffness and restitution)
parameters (also initial values of those) of a rigid
body. Note that actors dont have any geometry information.
The
Shape
class
extends
the
Modelica.Mechanics.MultiBody.Visualizers.Advanced.Sha
pe class, offering 3D visualization possibilities in
Modelica environment. Each Shape instance must
connect to a single actor with a respective 4x4 transform of local origin of the geometry. These objects
represent the geometry of the rigid body they connect to. The Collider class is the subclass of Shape,
which can serve the collision geometry of that part.
In order to ease the export to Modelica, these classi-

721

Modelica 2008, March 3rd  4th , 2008

T. Juhasz, U. Schmucker

fications of new shape classes make handling of geometry orbicular from both the aspect of Modelica
and RobotMax, our CAD translator application.
For online, real time visualization support (see section 5.3) each Shape instance has a 7 component
pose vector (3D position + a quaternion orientation)
simply assigned by their local origin frames pose.
There is a pre- allocated P pose matrix (dimensions:
7 by N) reserved for the N shape objects, stored in a
shared memory. The shared memory is implemented
in a C++ class, is compiled to a DLL and it offers C
interfaces to Modelica. The columns of P are updated every simulation step by the respective shapes
poses using the external C function invocation setPose( ) from the Shape instances Modelica source.
The singleton Collision Manager instance stores information about the positions, orientations, angularand linear velocities of all Colliders existing in the
global collision set. At the initial phase of the simulation each Collider instance reports the CM its geometry, which cannot change during the simulation.
The CM updates the external collision forces on each
colliding shape in each simulation step. These shape
instances propagate the external collision force
through their connectors to the respective actor instances.
Unfortunately the Modelica language specification
being used at the development time (it was version
2.2.1) did not allow having a collection containing
polymorphic references to the instances of a user
defined class (i.e. abstract models) themselves: our
Modelica arrays can contain only basic data types.
This introduces a little performance loss: the CM has
to store duplicated information in separate arrays
about the positions, orientations, angular- and linear
velocities of all shapes existing in the global collision set.
Some shapes can be individually excluded from collision handling via disabling their collision flags (for
example in draft motion tests). On the other hand,
sometimes it is desired (usually for simplified models) to allow also pairs of bodies to constantly interpenetrate each other during the simulation, without
any internal tension or force between them. For this
purpose the user of the extended library can assign a
matrix to the CM containing the IDs of unwanted
collider pairs.
There is a permanent bidirectional communication
between the colliders and the collision manager. The
external collision response forces and -torques that
are calculated and responded by the CM, act together
on the given actors automatically as it was told before. This is due to the behaviour of bidirectional
Modelica connect equations.
The Modelica Association

The Modelica standard has a well-designed interface
to external software modules [5] (e.g.: Fortan or
ANSI C: sometimes allowing more powerful algorithm implementation). Accordingly, we were not
confined to implement the whole collision manager
class in pure Modelica. For the algorithmic core
functionality of collision detection and -response
calculation the C interface could be used:
For each supported collider shape type a C++ class
had to be implemented, having parameters similar to
their Modelica counterparts. These classes are instantiated at the initial phase of simulation: as soon
as a Modelica Collider is initiated, the corresponding
C++ constructor is invoked from Modelica code,
through our C interface wrapper.
In each simulation step the C++ part of the CM updates the pose of all C++ shapes via their Modelica
counterparts pose, and invokes the main method to
query the actual collision forces and -torques for all
active geometry in the scene. In the background the
free Bullet library [7] is being used to query collision
information among our rigid bodies (these are being
treated as independent ones, no joint-constraints are
introduced here). The penetration checking functionality of Bullet is done the following way:
For each pair of shape types, a certain collision algorithm is assigned, by using an internal dispatcher.
The collision detection library part of Bullet can retrieve contact points between any triangular geometry types (for some concave-convex case the primitive geometry types  such as sphere or cylinder 
need to be tessellated to triangles). The used algorithms are a modified version of the GJK algorithm
[6] with the EPA - Expanding Polythope Algorithm
for convex-convex cases, and GIMPACT for the
cases involving concave geometry.
Our pair-wise collision response calculation method
(spring and damper technique: dependent on penetration velocity, relative motion of colliding parts, material stiffness- and restitution parameters) is discussed in [4]. A single invoke on the external C++
library can solve the collision response for the whole
system at once, thus the external forces on the Modelica colliders can be updated in each simulation step.
3.2 Abstract joint models allowing domain independency
Our purpose is to simulate articulated multibody
mechatronic systems having multiple rigid bodies
connected by joints. The original test CAD models,
which we seized to test our conversion process, have
either no motor information, or this information is

722

Modelica 2008, March 3rd  4th , 2008

Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation

not accessible from the outside (i.e. cannot be exported from) the CAD system. This implies that in
RobotMax all XML joints will be converted first to
abstract ones by default (prismatic, revolute and
spherical joints, or serial combination of those are
supported in the entire system). Note that spherical
joints (allowing 3 rotational degrees of freedom in
their coupling centre point) are always passive: they
cannot be actuated in the original manner.
We implemented abstract joint models in Modelica
for prismatic and revolute joints, which are exactly
the pure mechanical constraints, representing the
allowed single degree of translational or rotational
freedom between their 3D frame connectors. These
abstract joint models have a one dimensional Drive
flange, as you can see on Figure 1:

Figure 1: Abstract model of a revolute joint

If the Drive flange connector is not connected from
the outside in the container Modelica model, an abstract joint will be equivalent to an ideal, free joint.
On the contrary, connecting a motors drive part to
the drive flange of these joints makes actuated joints
in the final mechatronic model. For the details please
refer to section 4.2.
Using this abstraction we could decouple the pure
mechanical model from other electromechanical
components: these can be exported to a separate toplevel Modelica model.

Unfortunately, we cant seize so far any description
of the possibly occurring electromechanical components from the Pro/E CAD system, which we could
embed automatically into the final mechatronic
model at the end of the conversion process.
You can say that the requirement of having motors in
an articulated multibody system is more than desirable. Without such elements you could not simulate /
verify the active dynamic behaviour of a moving
virtual structure.
4.1 The Motor Library in RobotMax
We developed an XML-based extensible Object Library that can contain parametric components of any
modelling domain. The special modelling domain of
electromechanical components (motors) will be emphasized in this section. For example the Motor Database inside the Object Library contains motor
classes (e.g.: DC motors or induction machines) as
entries.
Every class in the library has an absolute path reference to the Modelica implementation of the model
represented by it. These classes enumerate their parameters, which all must have a unique name (referring to their respective variables in the Modelica
model). Each parameter must also have a type (Float,
Integer, String, etc.) and a Boolean flag indicating
whether its actual value is editable by the user. For
example changing the gear ratio parameter in a final
motor instance is still allowed. A general parameter
can also have a physical unit (like Ohm or kgm2:
one should use SI standard units, unless it is not
specified here differently), minimum / maximum
limits and a descriptive comment optionally.

4 Adding electromechanical components to the internal model in RobotMax
Our goal is to support the simulation of the dynamic
behaviour of the product being designed in the
source CAD system. Assuming you have a CAD
model of an industrial robot having a few joints that
should be actuated by motors, you could easily ask
what kind of motors should be applied in order to
achieve a pre-defined speed along the desired path of
the tool centre point, or to stay below the maximal
allowed positioning error.

The Modelica Association

Figure 2: An example entry in our motor library

Figure 2 shows a screenshot of our librarys browser
dialog displaying the parameters of our DC permanent magnet motor class. The user can also edit here
the highlighted gear ratio, before it will be inserted to
the internal model in RobotMax.

723

Modelica 2008, March 3rd  4th , 2008

T. Juhasz, U. Schmucker

The instances of a class are enumerated in the library
after each class declaration, defining the actual / initial values for each parameter in all occurring instances. The instances must have a global unique ID
(a primary key along that column), which is always
required in a relational database (e.g.: during searching).
4.2 Our actuated joint models in Modelica

5 Simulation and visualization
The workflow presented so far had been finally extended with a motion planning task, which can be
carried out right before the Modelica export step, in
order to define a continuous-time function in a convenient way for each joints path.
5.1 Defining motions and simulating the model

For the most mechatronic simulation purposes one
has to set continuous reference values of the active
joints in the system (defining position, velocity or
acceleration parameters of those) in order to make
the parts follow a pre-defined trajectory. A welldesigned controller should be introduced that minimizes the error between the actual and the reference
values of each joint in every single moment.
We implemented 1-1 parametrical, translation- and
rotation based drive model in Modelica (for prismatic- and revolute joints, respectively), which contain a separated control- and actuator part, and is decoupled from the given joints mechanical part.
Figure 3 shows our general model for an actuated
joint:

RobotMax  our .NET-based CAD translator / environment editor application  offers keyframe-based
motion planning and has built-in support for inverse
kinematics that was used in the following example to
model a palette manipulating motion with an industrial robot model. The user can also fine-tune the
motion by interactively adjusting the values of the
selected servos.
The following image sequence shows the three basic
steps of the CAD to SIM process (in Pro/E  RobotMax  Dymola order), presented so far:

Figure 3: The schema of our joint drive subsystem

The general jointDrive actuator model has a replaceable motor and gear component. If a component
is declared replaceable in Modelica it means that one
can transparently exchange the implementation of
this part with another model, unless the given external connector interfaces are kept intact.
As it was told before, the pure mechanical model
was exported to a separate Modelica text file. As
long as the names of the joint entries are not changing, we will find the way to connect the respective
Drive connectors in both models. Thus the user can
experiment with fine-tuning the motor parameters
and simulate the new model without the need to redo
the CAD / XML conversion process from the beginning again.
Figure 4: The Dymola simulation of an industrial
robot-arm designed in Pro/Engineer and converted
by RobotMax using the presented workflow

The Modelica Association

724

Modelica 2008, March 3rd  4th , 2008

Automatic Model Conversion to Modelica for Dymola-based Mechatronic Simulation

5.2 Creating test scenarios in RobotMax
The Scene Editor in RobotMax can be used to create
various static / dynamic scenarios, allowing testing
the interaction between the actual virtual product
(that is being designed in CAD) and its environment,
which is usually modelled separately or is sometimes
simply neglected. For example a bumpy road can be
added to the 3D world in case of testing a new car
suspension assembly. VRML geometry can be imported, or the user can create new static / dynamic
objects from primitives with the interactive tools in
RobotMax. The parameters (materials, dimensions,
positions, etc.) are interactively changeable (in case
better precision is needed, can be set also manually)
and the modifications can be undone, thus allowing
an iterative approach of testing with various scenarios. Multiple viewports and various alignment tools
are helping you to make the test setup as precise (and
as informative) as possible.
5.3 Problem of online visualization
The Dymola simulator [9] being used in our project
has a 3D viewer (animation) support for multibody
models containing 3D geometry, but has a limited
functionality and is not user friendly enough.
If you want to visualize the simulation results from a
3rd party application while Dymola is running in the
background, the poses of the various geometries
have to be gathered and transmitted to the viewer
application online. Although Dymola stores the output of a simulation in a file (in Matlab format), this
file is exclusively locked: thus no other application
can read from that file until the simulation finishes.
Another solution had to be found to access pose information during the simulation.

and built-in support for advanced 3D visualization
techniques  including real 3D methods such as autostereo (for monitors with lenticular lens layer), timeinterleaved (for liquid crystal shutter goggles), spectral-interleaved (for red-cyan anaglyph spectacles) or
dual output (for two projectors and polarizer glasses)
 representing the actual internal model in 3D. For a
broader overview of these techniques please refer to
the article [10].
If the user switches RobotMax to online visualization
mode, it polls the pose information for each shape
continuously and updates the viewports with the preset frequency only.
In order to be able to inspect the simulation results
multiple times, there is a support for offline visualization, of course. A simulation output file can be
parsed by an external application only after it has
been completely written and released by Dymola. In
offline visualization mode RobotMax invokes Dymola with the generated Modelica models (according
to the process described in Section 2) and waits for
the lock of the result file to be released.
The sequences of samples of each simulation signal
are stored in this file, including input / output variables, state variables and their derivatives. In RobotMax after parsing all the exported signals into
memory, the signals belonging to the world transformation matrices are used to setup a keyframe
animation, which can be sought and played back
from a desired position at the desired speed.

5.4 Visualization in RobotMax
Our idea to transfer data to a viewer was to query it
from the shared memory containing the P matrix of
actual shape-poses (see section 3.1). On a viewer
side there is usually no need to update the pose of the
objects after each solver step (e.g.: a step size of 1
ms would lead to 1000 frames/second required refresh rate). The problem can be turned around: you
can retrieve (poll) the actual pose of any shape from
the shared memory at a desired, smaller frequency
(e.g.: 50 Hz).
The RobotMax has all functionalities a modern 3D
viewer application requires, with multiple orthogonal
or perspective viewports, interactive camera setup
The Modelica Association

Figure 5: anaglyph mode 3D visualization, screenshot

On Figure 5 a screenshot can be seen that was taken
in RobotMax showing the red-cyan spectralseparated anaglyph stereo image of the previous industrial robot-arm example at initial pose at the very
beginning of the simulation.

725

Modelica 2008, March 3rd  4th , 2008

T. Juhasz, U. Schmucker

6 Conclusion and future work

References

A highly automated, convenient conversion workflow from Pro/Engineer CAD data to multi-domain
Modelica simulation models has been presented in
this paper. The relevant online / offline visualization
methods  with advanced 3D techniques within the
same integrated tool used for model translation 
were also discussed here. For a schematic overview
of the presented workflow see Figure 6.

VRML
geometry

Pro/Engineer
Assembly
Parts

L
XM

Pro/E-to-SM
PlugIn

CM

.mat
Dymola

tP

os

e

Shared
Memory
se
tP
os
e

Modelica
models

offline viz.

ge

online viz.

RobotMax

Figure 6: schematic process overview

In our future implementation we will use the
Pro/ToolKit API to directly access data of other,
newly added components in Pro/Engineer WildFire
3, such as springs, dampers and motors, and translate
these elements also into the final Modelica models.
Using this interface the functionality of the Pro/E-toSimMechanics plug-in can be completely replaced
later by our implementation.
There is a free Modelica library  called BondLib,
available at [11]  for bond-graph represented analog
electronic circuits, including a full implementation of
Spice models. The presented CAD conversion process can be generalized to introduce complex models
of electrics / electronics domain, to be converted to
Modelica. We will investigate the possibilities to
introduce OrCAD layout plans and P-Spice models
into our virtual mechatronic workflow.
In the next version of our RobotMax tool we will
implement a 2D Plot functionality to be able to inspect simulation signals as 2D curves in a given
viewport. Our collision response calculation in tangential space (which is currently very simplified) has
to be improved to achieve more realistic friction
forces and torques between contacting bodies.

The Modelica Association

726

[1]

Engelson, V.; Bunus, P.; Popescu, L.;
Fritzson, P.: Mechanical CAD with Multibody Dynamic Analysis Based on Modelica
Simulation; In Proceedings of the 44th Scandinavian Conference on Simulation and
Modeling (SIMS-2003), September 18-19,
2003, Vsters, Sweden
[2] MathWorks: SimMechanics Translators:
http://www.mathworks.com/products/simme
chanics/description5.html
[3] Otter, M.; Elmqvist, H.; Daz Lpez, J.:
Collision Handling for the Modelica MultiBody Library; In Proceedings of the 4th International Modelica Conference, March 7-8,
2005, Hamburg, pp. 45-53
[4] Juhasz, T.; Konyev, M.; Rusin, V.;
Schmucker, U.: Contact Processing in the
Simulation of CLAWAR; In Proceedings of
10th CLAWAR International Conference,
16-18 July 2007, Singapore, pp. 583-590.
[5] Fritzson, P.: Principles of Object-Oriented
Modeling and Simulation with Modelica
2.1, Wiley Press 2004, ISBN 0-471-471631,
pp. 311-322.
[6] Gilbert, E. G.; Johnson, D. W.; Keerthi, S.
S.: A Fast Procedure for Computing the
Distance between Complex Objects in ThreeDimensional Space; In IEEE Trans. Robotics and Automation 4 (Vol2), April 1988, pp.
193-203.
[7] Bullet 3D Collision Detection Library:
http://www.bulletphysics.com/Bullet
[8] Modelica Association 
http://www.modelica.org
[9] Dynasim AB: Dymola 6 
http://www.dynasim.com/index.htm
[10] Juhasz, T.; Vajta, L.: The Role of 3D Simulation in the Advanced Robotic Design, Test
and Control, International Journal of Advanced Robotic Systems  Cutting Edge Robotics 2005, ISBN 3-86611-038-3; pp. 47-61.
[11] Cellier, F.: BondLib  Modelica library:
http://www.modelica.org/libraries/BondLib

Modelica 2008, March 3rd  4th , 2008

Modelica Implementation of the Skateboard Dynamics

Modelica Implementation of the Skateboard Dynamics
Ivan I. Kosenko1 , Alexander S. Kuleshov2
Moscow State University of Tourism and Service, Department of Engineering Mechanics,
Glavnaya str., 99, Cherkizovo-1, Moscow reg., 141221, Russia
2 Lomonosov Moscow State University, Department of Mechanics and Mathematics,
Leninskie Gory, Main Building of MSU, Moscow, 119991, Russia
1

Abstract
In the present paper analysis and simulation are performed for a simplest model of a skateboard. We suppose that the rider control is absent during the motion.
Equations of motion of the model are presented and
their stability analysed in brief.
Modelica implementation of the skateboard dynamics
is described as well. Its main featured outlined, and
the verification procedures explained. It is pointed out
the skateboard can behave in dynamical sense likewise
the known example of the rattleback.
Keywords: skateboard; nonholonomic constraints;
normal form; contact models, dynamical verification

1

Introduction

Nowadays the skateboarding, the art of riding on a
skateboard, is one of the most popular sports. Nevertheless serious researches concerning dynamics and
stability of a skateboard are almost absent. At the
late 70th  early 80th of the last century Mont Hubbard [1, 2] proposed two mathematical models describing the motion of a skateboard with the rider. To
derive equations of motion of the models he used the
principal theorems of dynamics. In our paper we give
the further development of the models proposed by
Hubbard to have an additional possibility to verify the
engineering solutions for this type of a vehicle.
Simultaneously to give the further move in field of
the sportswear appliances development we created and
verified a dynamical model of the skateboard. The
model was developed on Modelica, and it is easy to
improve it in different directions to be able to investigate the regular riding technique or the interesting
tricks performed by the experts while the skateboarding shows.
The skateboard typically consists of a board, two
trucks and four wheels, see Figure 1. The modern
The Modelica Association

Figure 1: The Skateboard Side View
boards are usually from 78 to 83 cm long, 17 to 21 cm
wide and 1 to 2 cm thick. The most essential elements
of a skateboard are the trucks, connecting the axles to
the board. Angular motion of both the front and rear
axles is constrained to be about their respective nonhorizontal pivot axes, thus causing a steering angle of
the wheels whenever the axles are not parallel to the
plane of the board, see Figure 2. The vehicle is steered
by making use of this kinematic relationship between
steering angles and tilt of the board. In addition, there
is a torsional spring, which exerts a restoring torque
between the wheelset and the board proportional to the
tilt of the board with respect to the wheelset, Figure 3.
We denote the stiffness of this spring by k1 .

727

Figure 2: The Skateboard Top View

Modelica 2008, March 3rd  4th , 2008

I. I. Kosenko, A. S. Kuleshov

will be directed horizontally and perpendicularly to the
axles of wheels and there is a point P on the line FR
which has zero lateral velocity. Its forward velocity we
denote by u. It may be shown, that (see e. g. [1]  [6])
u=
FP =

u sin ( f + r )
a sin  f cos r
,  = 
.
sin ( f + r )
a cos  f cos r

(2)

Using results obtained in [5, 6] we conclude that the
steering angles  f and r are related to the tilt of the
board by the following equations

Figure 3: The Skateboard Front/Rear View

2

a cos  f cos r
,
sin ( f + r )

tan  f = tan  f sin ,

tan  f = tan  f sin ,

(3)

The Problem Formulation.
Equations of Motion.

where  f and r are the fixed angles which the front
and rear axes make with the horizontal, Figure 1. Using constraints (3) we can rewrite equations (1) as folWe assume that the rider, modeled as a rigid body, re- lows
mains perpendicular with respect to the board. There(tan  f  tan r )
X = u cos  +
u sin  sin ,
fore, when the board tilts through , the rider tilts
2
(4)
through the same angle relative to the vertical. Let us
(tan  f  tan r )
Y = u sin  
u sin  cos .
introduce an inertial coordinate system OXY Z in the
2
ground plane. Let FR = a is a distance between two Expressions (2) become
axle centers F and R of a skateboard. The position of
a tan  f
(tan  f +tan r )
a line FR with respect to the OXY Z-system is defined
FP =
,  = 
u sin .
tan  f +tan r
a
by X and Y coordinates of its center and by the angle
(5)
 between this line and the OX-axis, see Figure 4.
Suppose that the board of the skateboard is located on
the distance h above the line FR. The length of the
board is also equal to a. The board center of mass is
located in its center. As to the rider we suppose that
the rider center of mass is not located above the board
center of mass, but it is located over the central line
of the board on a distance d from the front truck. Let
l be the height of the rider center of mass above the
point P. Other parameters for the problem are: mb is
the mass of the board, mr is the mass of the rider; Ibx ,
Iby , Ibz are the principal central moments of inertia of
the board; Irx , Iry , Irz are the principal central moments
Figure 4: The Basic Coordinate Systems.
of inertia of the rider. We introduce also the following
The tilt of the board causes the rotation of front wheels parameters:
clockwise through  f and the rotation of rear wheels
Ix = Ibx + Irx , Iy = Iby + Iry , Iz = Ibz + Irz .
anticlockwise through r , Figures 2, 4. The wheels of
a skateboard are assumed to roll without lateral slid- It can be proved, see [5], that the variables u and 
ing. This condition is modeled by constraints, which satisfy the following differential equations

may be shown to be nonholonomic
A + (C  2D) sin2 + K sin4  u+
1
C  3D + 3K sin2  u sin  cos
Y cos ( f )X sin ( f )+ a  cos  f = 0,
 +
2 sin  sin  = 0,
2
B

cos



(1)

(6)
1
E  + D  K sin2  u2 sin  cos +
Y cos (+r )X sin (+r ) a  cos r = 0.
2
k   (m h + m l) g sin +
1

Under these conditions velocities of a points F and R
The Modelica Association

728

b

r

B (u sin  + u cos ) cos  = 0.

Modelica 2008, March 3rd  4th , 2008

Modelica Implementation of the Skateboard Dynamics

Here A, . . ., E, K are functions of the parameters, Assuming that condition (9) holds, let us consider the
behavior of the system near the equilibrium position.
namely
Solving equations (6) with respect to u and  and asA = mb + mr ,
suming that u,  and  are small, we can write equaE = Ix + mb h2 + mr l 2 ,
tions of perturbed motion taking into account the terms
mb h
which are quadratic in u,  and  as follows
B =
(tan  f  tan r ) +
2
mr l
B2 2
Bu
((a  d) tan  f  d tan r ) ,
u
=
 ,  + 2  = 
,
(10)
a
A
E
mb
2
C =
(tan  f  tan r ) +
where we introduce the following notation
4
Iz
(tan  f + tan r )2 +
k1  (mb h + mr l) g
a2
2 =
.
mr
2
E
((a

d)
tan


d
tan

)
,
f
r
a2
Note, that the linear terms in the second equation of
(tan  f + tan r )
D =
(mb h + mr l) ,
the system (10) have a form which corresponds to
a
2
a normal oscillations. For investigation of nonlin
(tan  f + tan r )
2
2
K =
I
+
m
h
+
m
l

I
.
y
r
z
b
ear system (10) we reduce it to a normal form [10].
a2
To obtain the normal form of the system (10) first of
Thus, equations (46) form the closed DAE system for all we make a change of variables and introduce two
the skateboard motion.
complex-conjugate variables z1 and z2 such that

3

=

Stability of the Skateboard
Straight-Line Motion

z1  z2
z1 + z2
,  =
, u = z3 .
2i
2

In variables zk , k = 1, 2, 3 the linear part of the system
(10) has a diagonal form and the derivation of its norEquations (6) have a particular solution
mal form reduces to separating of resonant terms from
the nonlinearities in the right-hand sides of the transu = u0 = const,  = 0,
(7) formed system (10). Finally, the normal form of the
system (10) may be written as follows
which corresponds to a uniform straight-line motion of
B
the skateboard. The stability conditions of this particz1 = iz1 
z1 z3 ,
ular solution have the following form [1]-[6]:
2E
B
z2 z3 ,
z2 = iz2 
2E
Bu0 > 0, Du20 + k1  (mb h + mr l) g > 0. (8)
2
B
z3 =
z1 z2 .
2A
From the first condition of (8) we can conclude that
the stability of motion (7) depends on its direction. If Introducing real polar coordinates according to the forone direction of motion is stable the opposite direc- mulae
z1 = 1 (cos  + i sin ) ,
tion is necessary unstable. Such a behavior is peculiar
z2 = 1 (cos   i sin ) ,
to many nonholonomic systems. First of all, we can
z3 =
2
mention here the classical problem the rattleback motion (aka wobblestone or celtic stone, see e. g. [7]-[9]). we obtain from the system (10) the normalized system
In this problem the stability of permanent rotations of of equations of perturbed motion which is then split
a rattleback also depends on the direction of rotation. into two independent subsystems:
Suppose that the coefficient B is positive, B > 0. Then
B
B2 2
for u0 > 0 the skateboard moves in stable direction,
 ,
(11)
1 =  1 2 , 2 =
and for u0 < 0 it moves in unstable direction. When
2E
2A 1
u0 = 0 the skateboard is in equilibrium position on the
 = .
(12)
plane. The necessary and sufficient condition for staTerms of order higher than the second in (11) and those
bility of this equilibrium have a form [1]-[6]:
higher than the first in k , k = 1, 2 in (12) have been
k1  (mb h + mr l) g > 0.
(9) omitted here.
The Modelica Association

729

Modelica 2008, March 3rd  4th , 2008

I. I. Kosenko, A. S. Kuleshov

In the -neighborhood of the equilibrium position the
right-hand sides of equations (11) and (12) differ from
the respective right-hand sides of the exact equations
of perturbed motion by quantities of order 3 and 2
respectively. The solutions of the exact equations are
approximated by the solutions of system (1112) with
an error of 2 for 1 , 2 and of order  for  over time
interval of order 1/. Restricting the calculations to
this accuracy, we will consider the approximate system
(1112) instead of the complete equations of perturbed
motion.
Equation (12) is immediately integrable, and we obtain
 = t + 0 .
System (11) describes the evolution of the amplitude
1 of the board oscillations and also the evolution of
the velocity 2 of a the skateboard straight-line motion. One can see that this system has the first integral
E21 +

A 2
 = An21 ,
2 2

(13)

n2 = 0. An arbitrary constant n1 can be both positive
and negative. The positive values of this constant correspond to the skateboard straight-line motions with
small velocity in stable direction and the negative
ones do in unstable direction. Indeed, if we linearize
equations (11) near the equilibrium position (17) we
get
B
1 =  n1 1 , 2 = 0.
2E
Thus, for n1 > 0 the equilibrium position (17) is stable
and for n1 < 0 it is unstable.
Evolution of the functions 1 and 2 gives the complete description of behavior of a skateboard with
small velocities. Let us suppose, that at initial instant the system is near the stable equilibrium position
(n1 > 0) and 2 (0)  0, i. e. n2  1. The case of
n1 > 0, n2 > 1 is similar to the case of n1 < 0, n2 < 1,
which will be investigated below. These initial conditions correspond to the situation correspond to the
skateboard to take the small velocity

1  n2
2 (0) = n1
where n1 is a constant, specified by initial conditions.
1 + n2
We will use this integral for solving of the system (11)
and for finding the variables 1 and 2 as functions of in the stable direction at initial instant. Then in the
time: 1 = 1 (t), 2 = 2 (t). Expressing 21 from the course of time the amplitude 1 of the board oscillaintegral (13) and substitute it to the second equation of tions decreases monotonically from its initial value
the system (11) we get
r
2n1
An2
1 (0) =

B
2 2
2
1 + n2
E
2 =
 n1  2 .
(14)
2E
to zero, while the velocity of a skateboard 2 increases
The general solution of equation (14) has the following
in absolute value. In the limit the skateboard moves
form:
in stable direction with a constant velocity n1 , see



Bn1
Figure 56.
n1 1  n2 exp  E t



2 (t) =
,
(15)
1
1 + n2 exp  Bn
E t
where n2 is a nonnegative arbitrary constant. Now, using the integral (13), we can find the explicit form of
the function 1 (t) in the following way


r
Bn1
t
exp

2E
An2
.

(16)
1 (t) = 2n1
E 1 + n exp  Bn1 t
2

E

Let us consider the properties of the solutions (15),
(16) of system (11) and their relations to the properties
of the skateboard motion. System (11) has an equilibrium position
1 = 0,

2 = n1 .

Figure 5: Evolution of the Amplitude 1 of the Board
(17) Oscillations in Time for the Case n1 > 0, n2  1.

These particular solutions can be obtained from gen- Suppose now that at initial instant the system is near
eral functions (1516) if we suppose in that functions the unstable equilibrium position n1 < 0. Suppose
The Modelica Association

730

Modelica 2008, March 3rd  4th , 2008

Modelica Implementation of the Skateboard Dynamics

Figure 6: Evolution of the "Velocity" 2 of the SkateFigure 7: Evolution of the Amplitude 1 of the Board
board in Time for the Case n1 > 0, n2  1.
Oscillations in Time for the Case n1 < 0, n2  1.
again, that at initial instant n2 < 1, i. e. 2 (0) < 0.
The case n1 < 0, n2 > 1 is similar to the case n1 > 0,
n2 < 1 which was considered above. These initial conditions correspond to the situation if at initial instant
the skateboard takes the small velocity
2 (0) = n1

1  n2
1 + n2

in unstable direction. In this case the limit of the
system motions is the same as for 2 (0)  0 but the
evolution of the motion is entirely different. For
0 < t < t =

E ln (n2 )
Bn1

Figure 8: Evolution of the "Velocity" 2 of the Skatethe absolute value of the oscillation amplitude 1 board in Time for the Case n1 < 0, n2  1.
increases monotonically and the skateboard moves in
unstable direction with decreasing velocity. At the in4 Implementation and Experimental
stant t = t the velocity vanishes and the oscillation
Validation
amplitude 1 reaches its maximum absolute value
r
A
Evidently an analytic modeling and a numeric simula1 (t ) = n1
.
tion may be useful to predict the dynamical properties
E
of the sports equipment, the skateboard in our case. To
When t > t the skateboard already moves in stable verify a possibility of the behavior described above,
direction with an increasing absolute value of its ve- i. e. an asymmetry property of stability depending on
locity and the oscillation amplitude decreases mono- the rider relocation on the board, an attempt was untonically. Thus when 2 (0) < 0 during the time of dertaken to create the model of this device, see Figevolution of the motion a change in the direction of ure 9.
motion of the skateboard occurs, see Figure 78. The To achieve the goal announced we used an approach
similar nonlinear effects, like the change of the mo- and components applied earlier to the one else sports
tion direction, were observed earlier in other problems appliance: the snakeboard [11]. However, we have a
of nonholonomic mechanics, for example in a clas- serious differences with the snakeboard model now.
sical problem of dynamics of the rattleback [7]-[9]). First, we used a spheroids of different shapes instead
Thus, we describe here the basic features of the sim- of ideal disks. That seems more natural and allows
plest skateboard model dynamics, proposed in [1, 2] to consider as a wheels more plausible models of the
and developed by us.
elastic bodies rolling in future. The main current difThe Modelica Association

731

Modelica 2008, March 3rd  4th , 2008

I. I. Kosenko, A. S. Kuleshov

wheelset is not vertical and allows the rider an effective possibility to maneuver along the road. Besides to
ensure the stable riding the manufacturers frequently
equip their skateboards by an elastic connections the
wheelset axle and the board. Such a construct includes
two springs of a high stiffness. An example of the
so-called "Seismic" truck invented by D. Gesmer and
M. Haug [13] see in Figure 11. The whole skateboard
visual model including the spring elements is shown
in Figure 12.

Figure 9: The Skateboard Model Animation
ference is that we applied the Hertz model and its
volumetric modification for the contact of the wheel
and the floor [12]. This made it possible to avoid entirely an application of the compliances artificially introduced to the snakeboard model in [11].
The wheelset model, see in Figure 10 its visual model,
thus equipped by the objects of a simple revolute
joint class FixedJoint instead of the joint model
SpringJoint with elastic compliance along its axis.
The joint connects the wheel with the shaft of the
wheelset axis.

Figure 11: The Truck with Springs

Figure 12: The Skateboard Visual Model
The visual model of the spring connection see in Figure 13. Here tne side A of a particular spring elements, Spring1 and Spring2, is connected with the
wheelset axle model, while the B-sides of these objects
merge to one point producing one total effort. Further
Figure 10: The Wheelset Visual Model
the model Spring is a usual spatial spring element resisting both the compression and the stretch. Its ModWe saw above that in difference with the snakeboard elica code has the following easy to read form:
an axis of the joint connection of the board and the
The Modelica Association

732

Modelica 2008, March 3rd  4th , 2008

Modelica Implementation of the Skateboard Dynamics

model Spring
extends Constraint;
//undeformed spring length
parameter SI.Length l;
//spring stiffness
parameter Real c;
//fixed point on Body A
parameter SI.Position[3] rA ;
//fixed point on Body B
parameter SI.Position[3] rB;
//fixed point on Body A in abs. syst.
SI.Position[3] RA;
//fixed point on Body B in abs. syst.
SI.Position[3] RB;
SI.Length[3] RAB;
SI.Length deltal;
equation
RA = InPortA.r + InPortA.T*rA;
RB = InPortB.r + InPortB.T*rB;
OutPortA.P = RA;
OutPortB.P = RB;
RAB = RB - RA;
deltal = sqrt((RAB l*RAB/sqrt(RAB*RAB))*
(RAB - l*RAB/sqrt(RAB*RAB)));
OutPortB.F = -c*deltal*RAB/
sqrt(RAB*RAB);
OutPortB.M = zeros(3);
end Spring;

to it rigidly, by the constraint of the class Rigid.
A various numeric experiments performed with the
skateboard model under consideration. In particular,
to verify the dynamic effect of the stability of motion asymmetry, being similar to the stability asymmetry of the rattleback rotation, the cylinder playing
a role of the rider motionlessly standing on the board
was shifted to the right away from the board masscenter. In this case according to results outlined above if
one pushes the whole skateboard to the right then the
skateboard will keep this motion all the time of simulation. Otherwise, if one directs an initial skateboard
velocity to the left then soon the skateboard would
stop its translatory motion and then will start it to the
right direction thus demonstrating instability of the left
translatory motions, see the board masscenter velocity
x-coordinate depending on the time in Figure 14 and
the corresponding 2D-plot of the board masscenter xcoordinate itself in Figure 15.

Figure 14: The Skateboard Velocity

Figure 13: The Spring Connection Visual Model
Let us continue a description of the skateboard visual
model in Figure 12. It is quite natural for the rider to
Figure 15: The Skateboard Position
be included into the vehicle dynamics. In our case the
rider reduced simply to the cylinder standing perpen- Remark that the skateboard model built up turned out
dicular to the board top surface and being connected to be quite effective dynamic toy allowing to simThe Modelica Association

733

Modelica 2008, March 3rd  4th , 2008

I. I. Kosenko, A. S. Kuleshov

ulate the skateboard roll overs, tumbling, jumps, and
bouncing over the road. It is clear to simulate a control of such motion the rider model has to be far more
complicated.

5

Conclusions

An analytic analysis and numeric experimentation performed on the skateboard dynamics allow us to have
simultaneously several conclusions:
 The analytic analysis results showing acceptable
consistence with the numeric simulations of the
models created using the physical oriented approach still remains an effective tool to investigate the skateboard dynamics.
 On the other hand the model itself can be verified reliably enough using the proper constructed
analytical tools.
 Modelica turned out to be useful instrument in
field of sporting and more wider in field of biomechanical applications.

[4] Kuleshov A. S., Mathematical Model of a Skateboard with One Degree of Freedom // Doklady
Physics, 2007, Vol. 52, No. 5, pp. 283286.
[5] Kremnev A. V., Kuleshov A. S., Nonlinear Dynamics and Stability of a Simplified Skateboard
Model, 2007.
http://akule.pisem.net/
Kuleshov2.pdf
[6] sterling A. E. MAS 3030. On the Skateboard,
Kinematics and Dynamics. School of Mathematical Sciences. University of Exeter. UK. 2004.
http://akule.pisem.net/
theSkateboard.pdf
[7] Lindberg R. E., Longman R. W. On the Dynamic
Behavior of the Wobblestone // Acta Mechanica,
1983, Vol. 49, pp. 8194.
[8] Bondi H. The Rigid Body Dynamics of Unidirectional Spin // Proceedings of the Royal Society of
London, Series A, 1986, Vol. 405, pp. 265274.
[9] Garcia A., Hubbard M. Spin Reversal of the Rattleback: Theory and Experiment // Proceedings
of the Royal Society of London, Series A, 1988,
Vol. 418, pp. 165197.

And finally the nearest plans for the future work are
about to investigate the complicated types of the skate- [10] Bruno A. D. Local Method in Nonlinear Difboard motion including in particular the jumps.
ferential Equation  SpringerVerlag: Berlin,
1989.

6

Acknowledgement

[11] Kosenko I. I., Loginova M. S., Obraztsov Ya. P.,
Stavrovskaya M.S. Multibody Systems DynamThe paper was prepared with partial support of Rusics: Modelica Implementation and Bond Graph
sian Foundation for Basic Research, projects 05-01Representation // Proceedings of the 5th Inter00308-a, 05-08-65470, 05-01-00454, 07-01-00290,
national Modelica Conference, arsenal research,
SS-6667.2006.1.
Vienna, Austria, September 45, 2006, pp. 213
223.

References

[12] Kosenko I. I., Alexandrov E. B. Implementation
of the Hertz Contact Model and Its Volumetric
[1] Hubbard M., Lateral Dynamics and Stability of
Modification on Modelica // Submitted to Modthe Skateboard // Journal of Applied Mechanics,
elica2008 Conference.
1979, Vol. 46, pp. 931936.
[13] Gesmer D., Haug M. Skateboard truck assembly.
1993.
[2] Hubbard M., Human Control of the Skateboard //
http://www.freepatentsonline.
Journal of Biomechanics, 1980, Vol. 13, pp. 745
com/5263725.pdf
754.
[3] Kuleshov A. S., Mathematical Model of the
Skateboard // Proceedings of XXIV Int. Symp.
on Biomechanics in Sports, Salzburg, Austria,
2006, Vol. 2, pp. 715719.

The Modelica Association

734

Modelica 2008, March 3rd  4th , 2008

Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in Modelica

Design and validation of an annotation-concept
for the representation of 3D-geometries in Modelica
Thomas Hoeft1
Christoph Nytsch-Geusen1, 2
Fraunhofer Institute for Computer Architecture and Software Technology
Kekulstrae 7, 12489 Berlin, Germany
2
University of Arts Berlin, Hardenbergstrae 33, 10623 Berlin, Germany
christoph.nytsch@first.fraunhofer.de

1

Abstract
Simulation models of complex technical systems
need beside the description of their physical behaviors also a representation of their 3-dimensional geometry and topology. Up to now, the Modelica language specification [1] includes only rules for 2Dprimitives in form of specialized annotations. Starting from this point, this paper illustrates the design
and validation of an advanced annotation-concept for
embedded 3D-geometries in physical models. The
basic idea consists in the combination of specialized
3D-annotions for classes and objects with a standardized description of 3D-geometries and topologies.
Therefore the X3D-standard [2] is used by the authors. Based on the founded similarities and parallelisms in the object-oriented concept of Modelica and
the node concept of X3D an annotation concept for
the embedding of the 3D-geometries was designed.
Further an extension for the Modelica-simulator
MOSILAB [3] in form of a 3D-editor plug-in was
developed for the generation of X3D/Modelicascenes and the validation of the new annotation concept. Finally the annotation-concept was evaluated in
a simulation use case, where the physical model of a
simplified Pool-Billiard game [4] was combined with
its 3D-geometry description.
Keywords: 3D-annotation concept; X3D; 3Drepresentation of physical models; 4D-animation

1

Introduction

Up to now the Modelica language specification does
not comprise means of expressions for code integrated description of 3D-geometries. The first fundamental analysis and conceptual work in this direction was done by [5]. Two alternative ways were
discussed by the author for the integration of 3D object information in Modelica:

The Modelica Association

1. Definition of a basic set of graphical classes,
which make a representation of primitive 3D objects (e.g. Triangle, Sphere) and position operations with this objects (e.g. Translation, Rotation) in user defined physical models possible.
2. Direct integration of the 3D object information
as graphical annotations into the physical
models self.
Further the embedding of external graphical formats
like STL, VRML or DXF in Modelica models as
annotations information was shortly discussed in this
paper.
The Modelica-simulator Dymola [6] supports with
an additional software component the visualization
of 3D-objects, mainly for the MultiBody-Library.
For this, external definitions of 3D-shapes via dxffiles are utilized.
In our approach for a model integrated representation
of 3D objects, we have introduced Extensible 3D
Graphics (X3D) - an open international standard for
3D on the Web and the official successor of VRML into the Modelica language as a new annotation-type.
We think this approach offers a number of important
advantages:
 X3D represents a sophisticated (and international
accepted) concept for complex and hierarchical
structured 3D-scenes, which fits well to the object-oriented Modelica language concept.
 The prototype-concept of X3D allows an efficient integration in the object-oriented concept
of Modelica.
 The annotation concept of Modelica supports the
X3D integration by adding the 3D-geometrical
information as X3D-strings on class level or object level. Modelica-tools, which dont understand those X3D-annotations, are not bothered.
 The use of X3D in Modelica classes enables a
simple export of the 3D representation of a
physical model as a X3D-scene.

735

Modelica 2008, March 3rd  4th , 2008

T. Hoeft, C. Nytsch-Geusen

2

Annotation concept for 3D-object
representation in Modelica

For the integration and validation of X3D in the
Modelica language we have done following three
steps:
1. Design of an annotation concept for the representation of 3D-geometries in Modelica
This comprises
 the definition of the language subset of X3D,
which is necessary for the representation of
3D-objects in Modelica,
 the definition of the annotation syntax for
X3D information,
 the Modelica class definition of a set of 3Dprimitives as a base for complex 3D-scenes,
 the rules to instantiate this 3D-classes in
physical models and
 a syntax for the coupling between the X3D
object attributes and the Modelica variables
for 3D-animated simulation experiments.
2. Development of a 3D-editor for the generation
and validation of Modelica models, which
contain 3D-objects, described in X3D
This comprises
 the definition of a set of 3D-base objects and
their attributes, which shall be supported by
the editor,
 the design and the implementation of the
construction interface for 3D-scenes and
 the integration of the 3D-editor in the MOSILAB-IDE [3] as a plug-in.
3. Evaluation of the annotation-concept with the
help of a use case
The analyzed system model and its graphical
representation
 have to have a nontrivial recursive hierarchical structured geometry and
 have to include static and animated subcomponents.
2.1

totype Ball is defined with the ProtoDeclare node.
The first subnode, named ProtoInterface, contains
the field declarations, for which values can be set
during the instantiation of the prototype:
<X3D profile="Immersive">
<Scene>
<ProtoDeclare name="Ball">
<ProtoInterface>
<field accessType="initializeOnly"
name="radius" type="SFFloat" value="1.0"/>
<field accessType="initializeOnly"
name="diffuseColor" type="SFColor"
value="0.8 0.8 0.8"/>
<field accessType="initializeOnly"
name="translation" type="SFVec3f"
value="0.0 0.0 0.0"/>
...
</ProtoInterface>

The second subnode, named ProtoBody, defines the
functionality of the prototype. The three-dimensional
geometry of the ball is described by the node for the
X3D-primitive Sphere and its optical appearance
(diffuseColor, transparency ) by the Materialnode. The ball position and orientation is defined by
the Transform-node with the fields translation and
rotation. Further, the code snippet shows some connections between a nodeField of a subnode within
the ProtoBody-node and a declared protoField of the
ProtoInterface-node. This concept makes the access
to these quantities possible during the instantiation of
the prototype:
<ProtoBody>
<Transform>
<IS>
<connect nodeField="translation"
protoField="translation"/>
...
</IS>
<Shape>
<Sphere>
<connect nodeField="radius"
protoField="radius"/>
</Sphere>
<Appearance>
<Material>
<connect nodeField="diffuseColor"
protoField="diffuseColor"/>
...
</Material>
</Appearance>
</Shape>
</Transform>
</ProtoBody>
</ProtoDeclare>

Graphical representation in X3D

The X3D specification uses a hierarchical node concept by the use of the XML-Syntax. A single node is
described by its node type and a number of fields
(node attributes). Each field has to be declared with
one of the 26 X3D data types. The following simple
X3D-scene, composed of a blue and a red ball, explains the main features of X3D for our use in the
context with Modelica. In a first step, a reusable proThe Modelica Association

In the second step, the both objects ballBlue and
ballRed with the prototype Ball are instantiated,
whereas the radius value is set on the typical size for
a billiard ball (2.65 cm) and the diffuseColor value is
set on the RGB-values for blue and red. The red ball
is displaced from the origin at 25 cm by setting the
value of the transform field:

736

Modelica 2008, March 3rd  4th , 2008

Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in Modelica

<ProtoInstance name="Ball">
<MetadataString name="ballBlue"/>
<fieldValue name="diffuseColor"
value="0.0 0.0 1.0"/>
<fieldValue name="radius" value="0.0265"/>
</ProtoInstance>

2.3

<ProtoInstance name="Ball">
<MetadataString name="ballRed"/>
<fieldValue name="diffuseColor"
value="1.0 0.0 0.0"/>
<fieldValue name="radius" value="0.0265"/>
<fieldValue name="translation"
value="0.25 0.0 0.0"/>
</ProtoInstance>
</Scene>
</X3D>

Figure 1 shows the visualization of this short X3Dscene. As the example illustrates, X3D has not a real
object-oriented concept, but the ProtoDeclare-node
with its ProtoInterface and ProtoBody subnodes has
strong parallelism to the object composition in Modelica.

Integration of X3D in Modelica

Annotations in Modelica can be used as containers
for additional information, which have no influence
on the modeled physical behavior of a model class.
Well known examples are the definitions of graphical 2D-objects for the model icons or the model
documentation in form of embedded html-Code.
In our concept we have defined a new type of annotations, which contains parts of X3D-scenes as
strings and give a Modelica-model a representation
of its 3D-geometry. These annotations are labeled by
a new element, named Object3D and can be used for
classes and objects:
Use in the class context:
model ClassName
annotation(Object3D(x3d="X3D-String))
...
end ClassName;

Use in the object context:
model ClassName
...
ClassType objectname
annotation(Object3D(x3d="X3D-String));
...
end ClassName;

Figure 1: Simple X3D-scene with two balls
2.2

Physical behavior in Modelica

The Modelica model of the ball describes its physical
behavior with simplified equations of motion of a
concentrated mass. Up to now, the model has not a
representation of its three-dimensional geometry:
import Modelica.SIunits;
...
model Ball
parameter SIunits.Mass m = 0.2;
parameter Real f_r = 0.05 friction coeffient;
SIunits.Length x, y;
SIunits.Velocity v_x, v_y;
equation
m * der(v_x) = - v_x * f_r; der(x) = v_x;
m * der(v_y) = - v_y * f_r; der(y) = v_y;
end Ball;

The Modelica Association

At first, based on this syntax, we have defined a set
of Modelica basic types for the 3D-modeling in the
package BasicBodies:
 Sphere3D,
 Cone3D,
 Box3D,
 Cylinder3D,
 Point3D,
 PolyLine3D.
As an example, the following code shows the implementation of the basic type Sphere 3D:
package BasicBodies
model Sphere3D annotation(Object3D(x3d = "
<ProtoDeclare name=\" Sphere3D\">
<ProtoInterface>
<field accessType=\" initializeOnly\"
name=\" radius\" type=\" SFFloat\"
value=\" 1.0\"/>
<field accessType=\" initializeOnly\"
name=\" transparency\" type=\" SFFloat\"
value=\" 0.0\"/>
<field accessType=\" initializeOnly\"
name=\" diffuseColor\" type=\" SFColor\"
value=\" 0.8 0.8 0.8\"/>
<field accessType=\" initializeOnly\"
name=\" translation\" type=\" SFVec3f\"
value=\" 0.0 0.0 0.0\"/>
<field accessType=\" initializeOnly\"
name=\" rotation\" type=\" SFRotation\"
value=\" 0.0 0.0 1.0 1.0\"/>
</ProtoInterface>

737

Modelica 2008, March 3rd  4th , 2008

T. Hoeft, C. Nytsch-Geusen

<ProtoBody>
<Transform>
<IS>
<connect nodeField=\" translation\"
protoField=\" translation\"/>
<connect nodeField=\" rotation\"
protoField=\" rotation\"/>
</IS>
<Shape>
<Sphere>
<connect nodeField=\" radius\"
protoField=\" radius\"/>
</Sphere>
<Appearance>
<Material>
<connect nodeField=\" diffuseColor\"
protoField=\" diffuseColor\"/>
<connect nodeField=\" transparency\"
protoField=\" transparency\"/>
</Material>
</Appearance>
</Shape>
</Transform>
</ProtoBody>
</ProtoDeclare>"));
end Sphere3D;
end BasicBodies;

...
import BasicBodies3D;
...
model Ball annotation(Object3D(x3d="
<ProtoInterface>
<field accessType=\" initializeOnly\"
name=\" radius\" type=\" SFFloat\"
value=\" 0.0265\"/>
...
<field accessType="initializeOnly"
name=\" translation\" type=\" SFVec3f\"
value=\" 0.0 0.0 0.0\"/>
</ProtoInterface>"),
coupling(translation={x,y,0.0});

The representation of the 3D-geometry of the class
Ball takes place by the instantiation of the basic 3Dtype Sphere3D as an object within the class:

The other basic 3D-types are described in a similar
manner. Starting from these basic types, the configuration of complex 3D-models in Modelica can take
place.
2.4

Coupling of the physical and geometrical
model description

The decisive connection between the variables of the
physical model and field-values of its X3Drepresentation is realized by the introduction of the
annotation-element coupling. The syntax is defined
as follows:
model ClassName
annotation(Object3D(x3d="X3D-String,
coupling(protoFieldName1={v1,v2,0.0},
protoFieldName2={v3}, ...)))
...
end ClassName;

At this, protoFieldName stands for the field in the
3D-representation, which shall be updated dynamically during the simulation (e.g. the object position
or its size or color) and v1, v2, v3 the corresponding
Modelica variables. Thus, a physical model can have
a number of coupled protoFields.
The next code piece shall illustrate this coupling
concept with the help of the ball example in paragraphs 2.2 and 2.3. For this purpose, the ProtoInterface definition of the X3D description is integrated
as an annotation on the class level, because this information concerns only the class interface. The ProtoDeclare node is omitted, because this information
is implicit contained in the Modelica class-name itself:
The Modelica Association

BasicBodies3D.Sphere3D ball
annotation(Object3D(x3d="
<ProtoBody>
<ProtoInstance
name=\" BasicBodies3D.Sphere3D\">
<MetadataString name=\" ball\"/>
<connect nodeField=\" radius\"
protoField=\" radius\"/>
...
<connect nodeField=\" translation\"
protoField=\" translation\"/>
</ProtoInstance>
</ProtoBody>")));
parameter SIunits.Mass m = 0.2;
parameter Real f_r = 0.05 friction coeffient;
SIunits.Length x, y;
SIunits.Velocity v_x, v_y;
equation
m * der(v_x) = - v_x * f_r; der(x) = v_x;
m * der(v_y) = - v_y * f_r; der(y) = v_y;
end Ball;

3

Use case Pool-Billard game for
validating the annotation concept

In the use case, which shall validate our annotation
concept for embedded 3D-geometry representations,
we have used a model of a simplified Pool-Billiard
game with three balls and one hole [4]. This simulation model suits well to the problem, because its geometry is hierarchical structured and includes static
(table) and dynamic sub-components (billiard balls).
3.1

Modeling process

In the first step, a leg model (class TableLeg) from
the billiard table shall be configured from the three
submodels bottom (type Cylinder3D), adapter (type
Cone3D) and shaft (type Cylinder3D):
import BasicBodies.*
...
model TableLeg annotation(Object3D(x3d="
<ProtoInterface>
<field accessType=\" initializeOnly\"
name=\" bottom.height\" type=\" SFFloat\"
value=\" 0.025\"/>

738

Modelica 2008, March 3rd  4th , 2008

Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in Modelica
model BillardTable annotation(Object3D(x3d="
<ProtoInterface>
<field accessType=\" initializeOnly\"
name=\" hole.height\" type=\" SFFloat\"
value=\" 0.081\"/>
<field accessType=\" initializeOnly\"
name=\" hole.radius\" type=\" SFFloat\"
value=\" 0.15\"/>
...
</ProtoInterface>"));
parameter SIunits.Length width,length;

<field accessType=\" initializeOnly\"
name=\" bottom.radius\" type=\" SFFloat\"
value=\" 0.125\"/>
...
<field accessType=\" initializeOnly\"
name=\" translation\" type=\" SFVec3f\"
value=\" 0.0 0.0 0.0\"/>
<field accessType=\" initializeOnly\"
name=\" rotation\" type=\" SFRotation\"
value=\" 0.0 0.0 1.0 0.0\"/>
</ProtoInterface>"));
Cylinder3D bottom annotation(Object3D(x3d="
<ProtoInstance name=\" Cylinder3D\">
<MetadataString name=\" bottom\"/>
<connect nodeField=\" radius\"
protoField=\" bottom.radius\"/>
<connect nodeField=\" height\"
protoField=\" bottom.height\"/>
...
<IS>
<fieldValue name=\" translation\"
value=\" 0.0 -0.4 0.0\"/>
</IS>
</ProtoInstance>"));

Box3D plate annotation(Object3D(x3d="
<ProtoInstance name=\" Box3D\">
<MetadataString name=\" plate\"/>
<fieldValue name=\" size\"
value=\" 2.54 0.08 1.27\"/>
<fieldValue name=\" diffuseColor\"
value=\" 0.0 1.0 0.0\"/>
<fieldValue name=\" translation\"
value=\" 0.0 0.0 0.0\"/>
</ProtoInstance>"));
Border
Border
Border
Border

Cone3D adapter annotation(Object3D(x3d="
<ProtoInstance name=\" Cone3D\">
...
</ProtoInstance>"));

borderUp annotation(Object3D());
borderDown annotation(Object3D());
borderLeft annotation(Object3D());
borderRight annotation(Object3D());

Cylinder3D hole annotation(Object3D(x3d="
<ProtoInstance name=\" Cylinder3D\">
...
<connect nodeField=\" height\"
protoField=\" hole.height\"/>
<connect nodeField=\" radius\"
protoField=\" hole.radius\"/>
<IS><fieldValue name=\" translation\"
value=\" 1.26 0.0 -0.635\"/></IS>
</ProtoInstance>"));

Cylinder3D shaft annotation(Object3D(x3d="
<ProtoInstance name=\" Cylinder3D\">
...
</ProtoInstance>"));
end TableLeg;

Figure 2 shows the visualization of the previous defined 3D-representation of the TableLeg model class.

TableLeg legDownLeft annotation(Object3D(x3d="
<ProtoInstance name=\" TableLeg\">
<MetadataString name=\" legDownLeft\"/>
<fieldValue name=\" translation\"
value=\" -1.06 -0.375 0.5\"/>
</ProtoInstance>"));
TableLeg legDownRight annotation(Object3D());
TableLeg legUpLeft annotation(Object3D());
TableLeg legUpRight annotation(Object3D());
end BillardTable;

Figure 2: 3D-representation of the TableLeg model
On the next hierarchy level the submodels for the
billiard table model are instantiated from two predefined model classes (TableLeg, Border) and from
two 3D basic types classes (Box3D, Cylinder3D).
The model class BillardTable includes the submodels for the plate, the borders, the legs and the hole.
Figure 3 shows the visualization of this table model.
The Modelica Association

Figure 3: 3D-representation of the BillardTable model

739

Modelica 2008, March 3rd  4th , 2008

T. Hoeft, C. Nytsch-Geusen

transition Playing->Playing
event disappear_bw action
disconnect(bw.p,p[1]); remove(bw);
bw:=new Ball(d=d_balls, width=t.width,
length = t.length,
x(start = 1.27/2.0),
y(start = 0.6));
connect(bw.p,p[1]);
end transition;

The class SystemModel integrates the static table
model and the three physical ball models. The physical model of the simplified Pool-Billiard game shall
be drafted only roughly in this paper. A detailed description is given in [4]. The implementation of this
example was realized with the language extension
for Modelica for model structural dynamics from the
GENSIM project [7, 8]. The different events of a
billiard game (reflections, collisions) and a varying
number of balls can be efficiently described with the
concept of object-oriented statecharts and object dynamics:
...
model SystemModel
annotation(Object3D(...));
parameter Integer n_balls = 3;
parameter Real v_x, v_y;
parameter Real d_balls = 0.0572;
parameter Real d_holes = 0.15;
Point p[n_balls];

transition Playing->Playing
event collision_bw_bb action
v_x := bw.v_x; v_y := bw.v_y;
bw.v_x := bb.v_x; bw.v_y := bb.v_y;
bb.v_x := v_x; bb.v_y := v_y;
end transition;
end SystemSC;
end SystemModel;

Figure 4 illustrates the complete system model with
the static and dynamic model parts.

dynamic Ball bw annotation(Object3D(x3d="
<ProtoInstance name=\" Ball\">
<MetadataString name=\" bw\"/>
<fieldValue name=\" diffuseColor\"
value=\" 1.0 1.0 1.0\"/>
<fieldValue name=\" translation\"
value=\" 0.8 0.066 -0.2\"/>
</ProtoInstance>"));
dynamic Ball bb annotation(Object3D(x3d="
<ProtoInstance name=\" Ball\">
<MetadataString name=\" bb\"/>
<fieldValue name=\" diffuseColor\"
value=\" 0.0 0.0 0.0\"/>
<fieldValue name=\" translation\"
value=\" 0.6 0.066 -0.2\"/>
</ProtoInstance>"));
dynamic Ball bc annotation(Object3D(x3d="
<ProtoInstance name=\" Ball\">
<MetadataString name=\" bc\"/>
<fieldValue name=\" diffuseColor\"
value=\" 0.0 0.0 1.0\"/>
<fieldValue name=\" translation\"
value=\" 0.4 0.066 -0.2\"/>
</ProtoInstance>"));

Figure 4: 3D-representation of the SystemModel
3.2

Simulation experiment

BillardTable t(width = 1.27, length = 2.54)
annotation(Object3D(x3d="
<ProtoInstance name=\" BillardTable\">
<MetadataString name=\" t\"/>
</ProtoInstance>"));
event Boolean disappear_bw(start = false);
event Boolean collision_bw_bb(start = false);
...
equation
disappear_bw =
if((p[1].x-0.0)^2+(p[1].y-0.0)^2)^0.5<d_holes
then true else false;
collision_bw_bb =
if((p[2].x-p[1].x)^2+(p[2].y-p[1].y)^2)^0.5
<d_balls then true else false;
...
statechart
state SystemSC extends State;
State startState(isInitial=true);
State Playing, GameOver;

The Modelica Association

Figure 5: Simulation experiment for the Pool-Billiard
game over 4 seconds.
Figure 5 shows the positions of the white and the
black ball during a simulation period of 4 seconds.

740

Modelica 2008, March 3rd  4th , 2008

Design and Validation of an Annotation-Concept for the Representation of 3D-Geometries in Modelica

After 0.2 seconds, the white ball collides with the
black ball. After 1.0 second, the black ball is reflected twice in a short time period on the top side on
the billiard-table and both balls collide again between its reflections. After 2.3 and 2.5 seconds the
balls reflect on the left border. At 2.95 seconds the
white ball drops into the hole. At the end, the white
ball is set again on its starting position.
Figure 6 to Figure 9 show the 4D-animation of the
same simulation experiment. Because the calculated
x- and y-coordinates of both ball models are connected with their 3D-representations by the annotation-element coupling (compare with paragraph 2.4),
a 4D-animation (3 space coordinates plus the time)
of the experiment can be automatically generated.

Figure 6: Simulation experiment at time=0 seconds

4

Development of a 3D-Model editor

For the validation of the previous described annotation concept for 3D-geometries in Modelica, a 3Dmodel editor is being developed by the authors. This
editor supports the definition of 3D-scenes and generates the Modelica-code with the embedded X3Ddescription. Because the editor is implemented as a
plug-in for the graphical user interface of the simulation tool MOSILAB [3], the 3D-modeling works
close together with the other modeling features of the
MOSILAB-IDE (compare with Figure 10).

Figure 10: 3D-model editor as plug-in for the simulation tool MOSILAB .

5

Conclusions

The new designed annotation-concept for the
representation of 3D-geometries in Modelica, based
on the X3D-standard, offers a number of advantages
and new perspectives:
 An integrated description of the equation based
physical behavior and a corresponding representation of the 3D geometry in a unitary Modelicamodel is an excellent precondition for an efficient communication between the physical and
the geometrical model aspects.
 The use of X3D and its ProtoDeclare-concept
fits well to the object-oriented concept of Modelica.
 3D-objects, based on Modelica standard types,
can be added directly to the physical models and
could be connected by the coupling-annotation
element.
 The modeling process of complex 3D-scenes can
take place recursively on a multitude of hierarchical layers, because each Modelica/X3D-class
can be reused on the next hierarchy-level (see

Figure 7: Simulation experiment at time=0.2 seconds

Figure 8: Simulation experiment at time=2.3 seconds

Figure 9:Simulation experiment at time=2.95 seconds
The Modelica Association

741

Modelica 2008, March 3rd  4th , 2008

T. Hoeft, C. Nytsch-Geusen





the modeling process of the billiard table in
chapter 3.1).
The use of the standard X3D-format for the
modeling of the 3D-geometries within the Modelica language enables the import and export of
3D-scenes from/to X3D.
Future works will focus on a closer integration
of the 3D-editor in the simulation tool MOSILAB.

References
[1]

[2]

[3]
[4]

[5]

[6]
[7]

[8]

Modelica Association Modelica - A Unified
Object-Oriented Language for Physical Systems Modeling. Language Specification,
Version 3.0, September 2007.
Brutzman D. and Daly L. X3D: Extensible
3D Graphics for Web Authors. The Morgan
Kaufmann Series in Interactive 3D Technology, 2007.
MOSILAB-Homepage:
http://www.mosilab.de
Nytsch-Geusen C. The use of the UML
within the modelling process of Modelicamodels. EOOLT2007, 1st International
Workshop on Equation-Based ObjectOriented Languages and Tools, Berlin 2007.
Engelson V. 3D Graphics and Modelica  an
integrated approach. Linkping Electronic
Articles in Computer and Information Science. Linkping universitet, 2000.
Dymola-Homepage: http://www.dynasim.se
Nytsch-Geusen C. et al. MOSILAB: Development of a Modelica based generic simulation tool supporting model structural dynamics. Proceedings of the 4th International
Modelica Conference, TU HamburgHarburg, Hamburg, 2005.
Nytsch-Geusen C. et al. Advanced modeling
and simulation techniques in MOSILAB: A
system development case study. Proceedings
of the 5th International Modelica Conference, Arsenal Research, Wien, 2006.

The Modelica Association

742

Modelica 2008, March 3rd  4th , 2008

